"""
nsmbw_homage.py
A small Pygame prototype inspired by classic side-scrolling platformers.
This is an original homage (no Nintendo assets).  Single-file runnable prototype.

Features:
- Smooth platformer physics (run, variable-height jump)
- Tile-based levels (simple ASCII map in code)
- Collectible coins, basic patrolling enemies, and a flag/goal
- Score and lives HUD
- Keyboard controls: A/D or Left/Right to move, Space to jump, R to restart, Esc to quit
- Save as "nsmbw_homage.py" and run: python nsmbw_homage.py
Requires: pygame (pip install pygame)

Author: Generated by ChatGPT (homage code)
"""

import os
import sys
import math
import random
import pygame

# ----- Config -----
SCREEN_WIDTH = 1024
SCREEN_HEIGHT = 576
FPS = 60

TILE_SIZE = 32
GRAVITY = 0.8
PLAYER_RUN_SPEED = 4.0
PLAYER_AIR_ACCEL = 0.25
PLAYER_JUMP_SPEED = -13.0
PLAYER_MAX_FALL = 18

# level: simple ASCII map (P = player start, # = solid block, c = coin, e = enemy, G = goal)
LEVEL_MAP = [
"                                                                                ",
"                                                                                ",
"                                                                                ",
"                                                                                ",
"                                                                                ",
"                    c                                                           ",
"               #######                e                                       ",
"                                                                                ",
"         P                                                                      ",
"    #######        ####       c            #######           c               G",
"                                                                                ",
"###############################     ############################ ##############",
"###############################     ############################ ##############"
]

# Colors (simple placeholders)
COLOR_BG = (120, 184, 255)
COLOR_BLOCK = (80, 48, 16)
COLOR_PLAYER = (200, 40, 40)
COLOR_COIN = (255, 200, 0)
COLOR_ENEMY = (40, 40, 200)
COLOR_TEXT = (30, 30, 30)
COLOR_GOAL = (50, 200, 80)

# --------------------

class Camera:
    def __init__(self, width, height):
        self.offset = pygame.Vector2(0,0)
        self.width = width
        self.height = height

    def apply(self, rect):
        return rect.move(-self.offset.x, -self.offset.y)

    def update(self, target_rect):
        # center the camera on player horizontally, clamp to level bounds
        self.offset.x = target_rect.centerx - SCREEN_WIDTH // 2
        self.offset.y = target_rect.centery - SCREEN_HEIGHT // 2
        # clamp
        max_x = self.width - SCREEN_WIDTH
        max_y = self.height - SCREEN_HEIGHT
        self.offset.x = max(0, min(self.offset.x, max_x if max_x>0 else 0))
        self.offset.y = max(0, min(self.offset.y, max_y if max_y>0 else 0))


class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface((TILE_SIZE-4, TILE_SIZE*1.6))
        self.image.fill(COLOR_PLAYER)
        self.rect = self.image.get_rect(topleft=(x,y))
        self.pos = pygame.Vector2(self.rect.topleft)
        self.vel = pygame.Vector2(0,0)
        self.on_ground = False
        self.facing = 1
        self.coins = 0
        self.lives = 3
        self.score = 0
        self.jump_hold = False
        self.jump_time = 0

    def update(self, tiles, dt, keys):
        # horizontal input
        move = 0
        if keys[pygame.K_a] or keys[pygame.K_LEFT]:
            move -= 1
        if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            move += 1

        if move != 0:
            self.facing = move

        # apply horizontal movement
        if self.on_ground:
            self.vel.x = move * PLAYER_RUN_SPEED
        else:
            # air control
            self.vel.x += move * PLAYER_AIR_ACCEL
            # clamp horizontal air speed
            self.vel.x = max(-PLAYER_RUN_SPEED, min(PLAYER_RUN_SPEED, self.vel.x))

        # gravity
        self.vel.y += GRAVITY
        self.vel.y = min(self.vel.y, PLAYER_MAX_FALL)

        # jumping (variable jump: hold Space to prolong a little)
        if (keys[pygame.K_SPACE] or keys[pygame.K_w] or keys[pygame.K_UP]):
            if self.on_ground and not self.jump_hold:
                self.vel.y = PLAYER_JUMP_SPEED
                self.on_ground = False
                self.jump_hold = True
                self.jump_time = 0
            elif self.jump_hold and self.jump_time < 12:
                # small sustained upward force while holding jump
                self.vel.y += -0.9
                self.jump_time += 1
        else:
            self.jump_hold = False
            self.jump_time = 0

        # move horizontally and handle collisions
        self.pos.x += self.vel.x
        self.rect.x = int(self.pos.x)
        self.collide(self.vel.x, 0, tiles)

        # move vertically and handle collisions
        self.pos.y += self.vel.y
        self.rect.y = int(self.pos.y)
        self.on_ground = False
        self.collide(0, self.vel.y, tiles)

    def collide(self, vx, vy, tiles):
        for tile in tiles:
            if self.rect.colliderect(tile):
                if vx > 0:
                    self.rect.right = tile.left
                    self.pos.x = self.rect.x
                    self.vel.x = 0
                if vx < 0:
                    self.rect.left = tile.right
                    self.pos.x = self.rect.x
                    self.vel.x = 0
                if vy > 0:
                    self.rect.bottom = tile.top
                    self.pos.y = self.rect.y
                    self.vel.y = 0
                    self.on_ground = True
                if vy < 0:
                    self.rect.top = tile.bottom
                    self.pos.y = self.rect.y
                    self.vel.y = 0

class Enemy(pygame.sprite.Sprite):
    def __init__(self, x, y, patrol_len=96):
        super().__init__()
        self.image = pygame.Surface((TILE_SIZE-6, TILE_SIZE-6))
        self.image.fill(COLOR_ENEMY)
        self.rect = self.image.get_rect(topleft=(x,y))
        self.start_x = x
        self.patrol_len = patrol_len
        self.speed = 1.2
        self.dir = 1
        self.alive = True

    def update(self, tiles):
        if not self.alive:
            return
        self.rect.x += self.speed * self.dir
        # change direction when reaching patrol bounds or hitting a tile
        if self.rect.x < self.start_x - self.patrol_len or self.rect.x > self.start_x + self.patrol_len:
            self.dir *= -1
        # basic tile collision to avoid walking into walls
        for t in tiles:
            if self.rect.colliderect(t):
                # step back and flip
                if self.dir > 0:
                    self.rect.right = t.left
                else:
                    self.rect.left = t.right
                self.dir *= -1

class Coin(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        s = TILE_SIZE//2
        self.image = pygame.Surface((s,s), pygame.SRCALPHA)
        pygame.draw.circle(self.image, COLOR_COIN, (s//2, s//2), s//2)
        self.rect = self.image.get_rect(center=(x + TILE_SIZE//2, y + TILE_SIZE//2))

class Goal(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        w = TILE_SIZE
        h = TILE_SIZE*2
        self.image = pygame.Surface((w,h))
        self.image.fill(COLOR_GOAL)
        self.rect = self.image.get_rect(bottomleft=(x, y + TILE_SIZE))

def parse_level(level_map):
    tiles = []
    coins = pygame.sprite.Group()
    enemies = pygame.sprite.Group()
    goal = None
    player_start = (0,0)
    width = max(len(row) for row in level_map) * TILE_SIZE
    height = len(level_map) * TILE_SIZE

    for row_idx, row in enumerate(level_map):
        for col_idx, ch in enumerate(row):
            x = col_idx * TILE_SIZE
            y = row_idx * TILE_SIZE
            if ch == '#':
                tiles.append(pygame.Rect(x,y,TILE_SIZE,TILE_SIZE))
            elif ch == 'P':
                player_start = (x, y - TILE_SIZE//2)
            elif ch == 'c':
                coins.add(Coin(x,y))
            elif ch == 'e':
                enemies.add(Enemy(x, y - TILE_SIZE//2))
            elif ch == 'G':
                goal = Goal(x, y - TILE_SIZE)

    return tiles, coins, enemies, goal, player_start, width, height

def draw_tiles(surface, tiles, camera):
    for t in tiles:
        r = camera.apply(t)
        pygame.draw.rect(surface, COLOR_BLOCK, r)

def play_beep(freq=440, duration_ms=80, volume=0.15):
    # simple pygame beep using sndarray if available; otherwise skip
    try:
        import numpy as np
        sample_rate = 44100
        n = int(sample_rate * duration_ms / 1000)
        t = (np.linspace(0, duration_ms/1000, n, False))
        wave = 0.5 * np.sign(np.sin(2 * math.pi * freq * t))
        audio = (wave * 32767 * volume).astype('int16')
        sound = pygame.sndarray.make_sound(np.column_stack([audio,audio]))
        sound.play()
    except Exception:
        return

def main():
    pygame.init()
    try:
        pygame.mixer.init()
    except Exception:
        pass
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("Homage Platformer Prototype")
    clock = pygame.time.Clock()

    tiles, coins, enemies, goal, player_start, level_w, level_h = parse_level(LEVEL_MAP)

    player = Player(*player_start)
    sprites = pygame.sprite.Group()
    sprites.add(player)
    sprites.add(enemies)
    sprites.add(coins)
    if goal:
        sprites.add(goal)

    camera = Camera(level_w, level_h)
    font = pygame.font.Font(None, 28)
    bigfont = pygame.font.Font(None, 48)

    running = True
    win = False
    paused = False

    while running:
        dt = clock.tick(FPS) / 1000.0
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False
                if event.key == pygame.K_r:
                    main()  # simple restart loop (relaunch main)
                    return

        keys = pygame.key.get_pressed()
        if keys[pygame.K_p]:
            paused = not paused

        if not paused and not win:
            player.update(tiles, dt, keys)
            # enemies
            for e in enemies:
                e.update(tiles)
                # collision with player: if player falls on enemy, stomp; else lose life
                if e.alive and player.rect.colliderect(e.rect):
                    if player.vel.y > 2 and player.rect.bottom - e.rect.top < 14:
                        # stomp
                        e.alive = False
                        enemies.remove(e)
                        player.vel.y = PLAYER_JUMP_SPEED/2
                        player.score += 100
                        play_beep(900, 60, 0.18)
                    else:
                        # take damage: simple respawn/reset
                        player.lives -= 1
                        play_beep(220, 200, 0.2)
                        if player.lives <= 0:
                            # game over: restart
                            main()
                            return
                        # respawn player at start
                        player.pos = pygame.Vector2(player_start)
                        player.rect.topleft = player_start
                        player.vel = pygame.Vector2(0,0)
            # coins collection
            collected = pygame.sprite.spritecollide(player, coins, dokill=True)
            if collected:
                player.coins += len(collected)
                player.score += 50 * len(collected)
                play_beep(1200, 70, 0.16)
            # goal check
            if goal and player.rect.colliderect(goal.rect):
                win = True
                play_beep(1400, 200, 0.22)

        # camera
        camera.update(player.rect)

        # draw
        screen.fill(COLOR_BG)
        draw_tiles(screen, tiles, camera)

        # draw coins
        for c in coins:
            screen.blit(c.image, camera.apply(c.rect))
        # draw enemies
        for e in enemies:
            if e.alive:
                screen.blit(e.image, camera.apply(e.rect))
        # draw goal
        if goal:
            screen.blit(goal.image, camera.apply(goal.rect))
        # draw player
        screen.blit(player.image, camera.apply(player.rect))

        # HUD
        hud = font.render(f"Score: {player.score}   Coins: {player.coins}   Lives: {player.lives}", True, COLOR_TEXT)
        screen.blit(hud, (10,10))

        if paused:
            pause_surf = bigfont.render("PAUSED", True, COLOR_TEXT)
            screen.blit(pause_surf, (SCREEN_WIDTH//2 - pause_surf.get_width()//2, SCREEN_HEIGHT//2 - 40))
        if win:
            win_surf = bigfont.render("LEVEL COMPLETE!", True, COLOR_TEXT)
            screen.blit(win_surf, (SCREEN_WIDTH//2 - win_surf.get_width()//2, SCREEN_HEIGHT//2 - 40))
            info = font.render("Press R to restart", True, COLOR_TEXT)
            screen.blit(info, (SCREEN_WIDTH//2 - info.get_width()//2, SCREEN_HEIGHT//2 + 20))

        pygame.display.flip()

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
