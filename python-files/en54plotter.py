# -*- coding: utf-8 -*-
"""en54plotter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jkn-PVC11BuuByikVQQNqiyUfSSNvJ8N
"""

# === EN54_24_Isobaren_GUI.py ===
# GUI-Version basierend auf Referenz 1.9_EN54-24_LautsprecherField_spacing
# Anforderungen: Python 3.10+, numpy, matplotlib, scipy

import os, glob, re, wave
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.lines import Line2D
from matplotlib.table import Table
import tkinter as tk
from tkinter import filedialog, messagebox
from scipy.io import wavfile
from scipy.interpolate import interp1d
import matplotlib.patheffects as pe

# ===== Anzeigeparameter =====
DB_MIN, DB_MAX = -24, 6
ANGLE_STEP = 10
FREQ_MIN, FREQ_MAX = 100, 10000
N_FREQ_POINTS = 400
OCT_BANDS = [500, 1000, 2000, 4000]
FS_DEFAULT = 96000
USE_ANGLE_SMOOTH = False
SMOOTH_WIN = 3

# === Hilfsfunktionen ===
def band_edges(fc): return fc/np.sqrt(2), fc*np.sqrt(2)
def monotone_envelope_from_center(profile_db, angles):
    env = profile_db.copy()
    idx0 = np.argmin(np.abs(angles))
    for i in range(idx0-1, -1, -1): env[i] = min(env[i], env[i+1])
    for i in range(idx0+1, len(angles)): env[i] = min(env[i], env[i-1])
    return env
def central_connected_zone(mask, angles):
    idx0 = np.argmin(np.abs(angles))
    if not mask[idx0]: return None, None
    iL = iR = idx0
    while iL > 0 and mask[iL-1]: iL -= 1
    while iR < len(mask)-1 and mask[iR+1]: iR += 1
    return iL, iR
def smooth_angle_profile(y, win=3):
    if win is None or win < 3 or win % 2 == 0: return y
    k = win; ker = np.ones(k)/k; pad = k//2
    ypad = np.r_[np.full(pad, y[0]), y, np.full(pad, y[-1])]
    return np.convolve(ypad, ker, mode="valid")

# === Reader ===
def parse_angle_from_filename(path):
    m = re.search(r"(\d{3})\.[A-Za-z0-9]+$", os.path.basename(path))
    return int(m.group(1)) if m else None

def read_etm_float64(path, offset=0x80):
    with open(path, "rb") as f: data = f.read()
    ir = np.frombuffer(data, dtype="<f8", offset=offset)
    nz = np.flatnonzero(np.abs(ir) > 1e-12)
    return ir[nz[0]:nz[-1]+1] if nz.size else ir

def fft_mag_db(ir, fs, nfft=2**15):
    F = np.fft.rfft(ir, n=nfft)
    freqs = np.fft.rfftfreq(nfft, 1/fs)
    return freqs, 20*np.log10(np.abs(F)+1e-20)

def read_wav_robust(path):
    try:
        fs, data = wavfile.read(path, mmap=False)
        if data.ndim > 1: data = data[:,0]
        if np.issubdtype(data.dtype, np.floating):
            ir = data.astype(np.float64)
        else:
            info = np.iinfo(data.dtype)
            ir = data.astype(np.float64)/max(abs(info.min), info.max)
        return int(fs), ir
    except Exception:
        with wave.open(path, 'rb') as wf:
            fs, nchan, sw, nf = wf.getframerate(), wf.getnchannels(), wf.getsampwidth(), wf.getnframes()
            frames = wf.readframes(nf)
        dtype = {1:np.int8,2:np.int16,4:np.int32}.get(sw,np.int16)
        ir = np.frombuffer(frames,dtype=dtype)/float(np.iinfo(dtype).max)
        if nchan>1: ir = ir.reshape(-1,nchan)[:,0]
        return fs, ir

def _parse_euro_float(s):
    s = s.strip().replace('\xa0','').replace('\u202f','')
    if ',' in s and '.' in s: s = s.replace('.','')
    return float(s.replace(',','.'))

def read_txt_rew(path):
    fs=None; freqs=[]; spl=[]
    with open(path,'r',encoding='utf-8',errors='ignore') as f: lines=f.readlines()
    for l in lines:
        if l.startswith('*'): continue
        if not l.strip(): continue
        parts=l.split('\t')
        if len(parts)<2: parts=re.split(r'\s+',l.strip())
        try:
            f_hz=_parse_euro_float(parts[0]); spl_db=_parse_euro_float(parts[1])
        except: continue
        freqs.append(f_hz); spl.append(spl_db)
    freqs=np.array(freqs); spl=np.array(spl)
    idx=np.argsort(freqs)
    freqs,spl=freqs[idx],spl[idx]
    uniq,inv=np.unique(freqs,return_inverse=True)
    return uniq, np.array([np.mean(spl[inv==i]) for i in range(len(uniq))]), 'REW', fs

def read_txt_vituix(path):
    freqs=[]; mags=[]
    with open(path,'r',encoding='utf-8',errors='ignore') as f: lines=[l.strip() for l in f if l.strip()]
    start_idx=0
    if any('hz' in l.lower() for l in lines[:5]):
        for i,l in enumerate(lines):
            if 'hz' in l.lower(): start_idx=i+1; break
    for l in lines[start_idx:]:
        parts = l.split(';') if ';' in l else (l.split('\t') if '\t' in l else re.split(r'\s+',l))
        if len(parts)<2: continue
        try:
            f_hz=float(parts[0].replace(',','.')); spl=float(parts[1].replace(',','.'))
        except: continue
        freqs.append(f_hz); mags.append(spl)
    freqs,mags=np.array(freqs),np.array(mags)
    idx=np.argsort(freqs)
    return freqs[idx],mags[idx],'VituixCAD',None

# === Hauptfunktion: Berechnen & Plotten ===
def plot_isobars(data_dir, lautsprecher, canvas_frame):
    files = sorted(sum([glob.glob(os.path.join(data_dir, f"*.{ext}")) for ext in ["etm","wav","txt"]], []))
    if not files:
        messagebox.showerror("Fehler", "Keine passenden Dateien im Ordner gefunden.")
        return None

    angles=[]; all_mag=[]; basis_name=None; basis_fs=None
    for path in files:
        ext=os.path.splitext(path)[1].lower()
        angle=parse_angle_from_filename(path)
        if angle is None: continue
        if ext==".etm":
            ir=read_etm_float64(path); freqs,mag=fft_mag_db(ir,FS_DEFAULT); basis,bfs="ETM",FS_DEFAULT
        elif ext==".wav":
            fs,ir=read_wav_robust(path); freqs,mag=fft_mag_db(ir,fs); basis,bfs="WAV",fs
        elif ext==".txt":
            with open(path,'r',encoding='utf-8',errors='ignore') as f:first=f.read(256)
            if '*' in first or 'SPL' in first:
                freqs,mag,basis,bfs=read_txt_rew(path)
            else:
                freqs,mag,basis,bfs=read_txt_vituix(path)
        else: continue
        if basis_name is None: basis_name, basis_fs = basis, bfs
        angles.append(angle); all_mag.append((freqs,mag))

    if not angles:
        messagebox.showwarning("Hinweis", "Keine Winkelinformationen erkannt.")
        return None

    angles=np.array(angles); idx=np.argsort(angles)
    angles=angles[idx]; all_mag=[all_mag[i] for i in idx]

    freqs_log=np.logspace(np.log10(FREQ_MIN),np.log10(FREQ_MAX),N_FREQ_POINTS)
    mag_matrix=np.zeros((len(angles),N_FREQ_POINTS))
    for i,(f,m) in enumerate(all_mag):
        mag_matrix[i,:]=interp1d(f,m,kind='linear',bounds_error=False,fill_value=np.nan)(freqs_log)

    if 0 in angles:
        ref=mag_matrix[np.where(angles==0)[0][0],:]; mag_matrix-=ref
        shift=len(angles)//2 - np.where(angles==0)[0][0]
        mag_matrix=np.roll(mag_matrix,shift,axis=0)
        angles_centered=np.linspace(-180,180,len(angles))
    else: angles_centered=angles

    # Berechnung -6 dB Winkel
    results=[]
    for fc in OCT_BANDS:
        f1,f2=band_edges(fc); mask=(freqs_log>=f1)&(freqs_log<=f2)
        P=np.nanmean(10**(mag_matrix[:,mask]/10),axis=1)
        L=10*np.log10(P+1e-20)
        if USE_ANGLE_SMOOTH: L=smooth_angle_profile(L,SMOOTH_WIN)
        L_env=monotone_envelope_from_center(L,angles_centered)
        ref_db=L_env[np.argmin(np.abs(angles_centered))]; thr=ref_db-6
        zone=L_env>=thr; iL,iR=central_connected_zone(zone,angles_centered)
        if iL is None: aL,aR=-180,180
        else:
            def edge(i1,i2,y1,y2):
                t=(thr-y1)/(y2-y1+1e-20); return i1+t*(i2-i1)
            aL=edge(angles_centered[iL-1],angles_centered[iL],L_env[iL-1],L_env[iL]) if iL>0 else angles_centered[iL]
            aR=edge(angles_centered[iR],angles_centered[iR+1],L_env[iR],L_env[iR+1]) if iR<len(angles_centered)-1 else angles_centered[iR]
        total=aR-aL; results.append((fc,f1,f2,total,total/2,aL,aR))

    # Plot
    fig,ax=plt.subplots(figsize=(10.5,12))
    levels=np.linspace(DB_MIN,DB_MAX,61)
    cf=ax.contourf(freqs_log,angles_centered,mag_matrix,levels=levels,cmap="jet",extend="both")
    cb=fig.colorbar(cf,ax=ax,label="Pegel relativ zu 0° [dB]")
    cb.set_ticks(np.arange(DB_MIN,DB_MAX+3,3)); cb.ax.tick_params(labelsize=9)
    ax.contour(freqs_log,angles_centered,mag_matrix,levels=[-6],colors="black",linewidths=1.2)
    ax.set_xscale("log"); ax.set_yticks(np.arange(-180,181,ANGLE_STEP))
    ax.set_xticks([100,200,500,1000,2000,5000,10000])
    ax.set_xticklabels(["100","200","500","1k","2k","5k","10k"])
    ax.set_xlabel("Frequenz [Hz]"); ax.set_ylabel("Winkel [°]")
    ax.set_title("EN 54-24 (-6dB / ISO-Oktavband) Isobarenplotter V1.0")

    # Lautsprecherfeld mit großem Abstand
    ax.text(0.5, 1.12, lautsprecher, transform=ax.transAxes,
            fontsize=13, fontweight="bold", ha="center", va="bottom",
            bbox=dict(facecolor="white", edgecolor="black", boxstyle="round,pad=0.4"))

    # Info links
    legend_y=-0.57
    ax.text(-0.25, legend_y+0.03, f"Datenbasis: {basis_name or 'n/a'}", transform=ax.transAxes,
            fontsize=9, va="bottom", ha="left", color="black")
    ax.text(-0.25, legend_y, f"Abtastrate: {int(basis_fs) if basis_fs else 'n/a'} Hz", transform=ax.transAxes,
            fontsize=9, va="bottom", ha="left", color="black")

    legend_elements=[Line2D([0],[0],color="black",lw=1.2,label="-6 dB Isobare"),
                     Line2D([0],[0],color="red",lw=1.5,label="-6 dB Oktavband",
                            path_effects=[pe.Stroke(linewidth=2.5),pe.Normal()])]
    ax.legend(handles=legend_elements,loc="lower right",bbox_to_anchor=(1.22,legend_y),frameon=True)
    plt.subplots_adjust(left=0.13,right=0.90,top=0.97,bottom=0.60)

    # Anzeige im GUI
    for widget in canvas_frame.winfo_children(): widget.destroy()
    canvas=FigureCanvasTkAgg(fig,master=canvas_frame)
    canvas.draw()
    canvas.get_tk_widget().pack(fill=tk.BOTH,expand=True)
    canvas_frame.canvas = canvas
    canvas_frame.current_fig = fig

# === GUI-Setup ===
root = tk.Tk()
root.title("EN 54-24 Isobarenplotter V1.0")
root.geometry("1200x900")

frame_controls = tk.Frame(root)
frame_controls.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)

tk.Label(frame_controls, text="Ordner:").grid(row=0, column=0, sticky="w")
entry_folder = tk.Entry(frame_controls, width=60)
entry_folder.grid(row=0, column=1, padx=5)
def browse_folder():
    path = filedialog.askdirectory(title="Messdaten-Ordner auswählen")
    if path: entry_folder.delete(0, tk.END); entry_folder.insert(0, path)
tk.Button(frame_controls, text="Durchsuchen", command=browse_folder).grid(row=0, column=2, padx=5)

tk.Label(frame_controls, text="Lautsprecher:").grid(row=1, column=0, sticky="w")
entry_name = tk.Entry(frame_controls, width=40)
entry_name.insert(0, "DUMMY")
entry_name.grid(row=1, column=1, padx=5, pady=5)

canvas_frame = tk.Frame(root, bg="white")
canvas_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

def run_plot():
    folder = entry_folder.get().strip()
    name = entry_name.get().strip()
    if not folder:
        messagebox.showwarning("Hinweis", "Bitte einen Ordner auswählen.")
        return
    try:
        plot_isobars(folder, name, canvas_frame)
    except Exception as e:
        messagebox.showerror("Fehler", str(e))

def save_png():
    if not hasattr(canvas_frame, "current_fig"):
        messagebox.showwarning("Hinweis", "Noch keine Grafik erzeugt.")
        return
    path = filedialog.asksaveasfilename(defaultextension=".png",
                                        filetypes=[("PNG-Datei", "*.png")],
                                        title="Grafik speichern unter")
    if path:
        canvas_frame.current_fig.savefig(path, dpi=300)
        messagebox.showinfo("Gespeichert", f"Grafik gespeichert als:\n{path}")

tk.Button(frame_controls, text="Plot erzeugen", command=run_plot, bg="#d0ffd0").grid(row=1, column=2, padx=5)
tk.Button(frame_controls, text="Als PNG speichern", command=save_png, bg="#c0d0ff").grid(row=1, column=3, padx=5)

root.mainloop()

"""# Neuer Abschnitt"""