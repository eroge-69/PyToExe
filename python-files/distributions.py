# -*- coding: utf-8 -*-
"""Distributions

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aXJQRcoruMAyZzHtqIfzGuYXHKp3pGrK
"""

import textwrap
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import io
import random
from scipy.stats import t
from scipy.stats import uniform
from scipy.stats import expon
from scipy.stats import weibull_min
from scipy.stats import bernoulli
from scipy.stats import binom
from scipy.stats import poisson
from scipy.stats import hypergeom

"""# **Continuous**

## **Normal Distribution**
"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Normaldata.csv']))
column_y = df.columns[1]

mean_dataset = df[column_y].mean()
sd_dataset = df[column_y].std()
data_dataset = np.random.normal(mean_dataset, sd_dataset, 100000)

long_text = "This is the normal distribution plotter. Data points are plotted and generally form a symmetrical bell curve shape, with the mean value in the middle and an equal distribution of data points on either side. It's parametrized by two parameters, the mean and standard deviation. The normal distribution of the dataset you input will be plotted along with a custom distribution by inputting desired values below."
information = textwrap.fill(long_text, width=100)
print(information)
print()

mean_custom = float(input("Enter the Mean: "))
sd_custom = float(input("Enter the Standard Deviation: "))
data_custom = np.random.normal(float(mean_custom), float(sd_custom), 100000)

sns.kdeplot(data_dataset, color='blue', label="Dataset plot with mean " + str(round(mean_dataset, 2)) + " and standard deviation " + str(round(sd_dataset, 2)))
sns.kdeplot(data_custom, color='red', label="Custom plot with mean " + str(mean_custom) + " and standard deviation " + str(sd_custom))

plt.ylabel("Probability Density")
plt.title("Normal Distribution Plot")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()

"""## **Student's T-Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['T-distributiondata.csv']))
x = np.linspace(-5, 5, 500)

dof_dataset = int(len(df)) - 1
data_dataset = t.pdf(x, dof_dataset)

var_dataset = 0
if dof_dataset > 2:
  var_dataset = round(dof_dataset / (dof_dataset - 2), 2)
else:
  var_dataset = "undefined"

long_text = "This is the student's t-distribution plotter. It works very similarly to the normal distribution, but is generally used for datasets with smaller sample sizes (< 30). For larger samples, it becomes identical to normal distributions. It's parametrized by the degrees of freedom, which depend on the number of samples. Also, it's always symmetric, so the mean will always be zero, and the variance will be undefined if the degree of freedom is less than or equal to two."
information = textwrap.fill(long_text, width=100)
print(information)
print()

dof_custom = int(input("Enter the degrees of freedom: "))
data_custom = t.pdf(x, dof_custom)

var_custom = 0
if dof_custom > 2:
  var_custom = round(dof_custom / (dof_custom - 2), 2)
else:
  var_custom = "undefined"

print()
print("Dataset plot degrees of freedom is " + str(dof_dataset))
print("Custom plot degrees of freedom is " + str(dof_custom))

plt.plot(x, data_dataset, color="blue", label="Dataset plot with variance " + str(var_dataset))
plt.plot(x, data_custom, color="red", label="Custom plot with variance " + str(var_custom))

plt.title("t-distribution")
plt.ylabel("Probability Density")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()

"""## **Uniform Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Uniformdata.csv']))

low_bound = df.iloc[:, 1].min()
up_bound = df.iloc[:, 1].max()

x_dataset = np.linspace(low_bound-0.1, up_bound+0.1, 100)
y_dataset = uniform.pdf(x_dataset, loc=low_bound, scale=up_bound-low_bound)

long_text = "This is the uniform distribution plotter. It's suitable for datasets where the probability for all outcomes is the same. So, all data points will be evenly distributed. It's parametrized by the lowest and highest values in the dataset. To view a custom uniform distribution alongside the uploaded dataset, enter the upper and lower bounds below."
information = textwrap.fill(long_text, width=100)
print(information)
print()

a = float(input("Enter the Lower Bound: "))
b = float(input("Enter the Upper Bound: "))
if a >= b:
  raise ValueError("Lower bound 'a' should be less than upper bound 'b'.")

x_custom = np.linspace(a-0.1, b+0.1, 100)
y_custom = uniform.pdf(x_custom, loc=a, scale=b-a)

mean_dataset = (low_bound+up_bound)/2
sd_dataset = round((up_bound-low_bound)/12**0.5, 2)

mean_custom = ((a+b)/2)
sd_custom = round((b-a)/12**0.5, 2)

plt.plot(x_dataset, y_dataset, color="blue", label="Dataset plot with mean " + str(mean_dataset) + " and standard deviation " + str(sd_dataset))
plt.plot(x_custom, y_custom, color="red", label="Custom plot with mean " + str(mean_custom) + " and standard deviation " + str(sd_custom))
plt.title('Probabilty Density Between Bounds')
plt.ylabel('Probability Density')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()

plt.show()

"""## **Chi-Square Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Chisquaredata.csv']))

first_column = df.columns[0]
df = df.drop(['total','Total'], axis=1, errors='ignore')
df = df.drop(first_column, axis=1)
df = df[:-1]

row_number = int(len(df))
column_number = int(len(df.columns))

dof_dataset = (row_number - 1) * (column_number - 1)
data_dataset = np.random.chisquare(dof_dataset, size=1000)

long_text = "This is the chi-square distribution plotter. The plotted data represent the distribution of the sum of squares of random variables. It is parametrized by degrees of freedom, which corresponds to the number of different variables being squared and summed. A plot will be created using the dataset you provided by removing appropriate rows and columns to calculate the degrees of freedom (assumes there is a row and column with totals). The value you input below will plot a custom chi-square distribution."
information = textwrap.fill(long_text, width=100)
print(information)
print()

dof_custom = int(input("Please enter the degree of freedom (must be an integer): "))
data_custom = np.random.chisquare(dof_custom, size=1000)

sns.kdeplot(data_dataset, color="blue", label="Dataset plot with mean " + str(dof_dataset) + " and variance " + str(2 * dof_dataset))
sns.kdeplot(data_custom, color="red", label="Custom plot with mean " + str(dof_custom) + " and variance " + str(2 * dof_custom))

print()
print("The dataset has a degree of freedom " + str(dof_dataset))
print("Your custom degree of freedom is " + str(dof_custom))

plt.title("Chi Square Distribution")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()

"""## **Exponential Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Exponentialdata.csv']))

column_data = df.columns[1]
mean_dataset = df[column_data].mean()
lam_dataset = 1/mean_dataset
var_dataset = 1/(lam_dataset)**2
data_dataset = expon.rvs(lam_dataset, size=1000)

long_text = "This is the exponential distribution plotter. It models the time between events occurring. These events are also independent from each other, so the time is not influenced by future events. It's parametrized by one variable, lambda, which is the average rate at which these events occur. The lambda will be calculated from the dataset you provided. To visualize a custom distribution, you can enter your preferred value."
information = textwrap.fill(long_text, width=100)
print(information)
print()

lam_custom = float(input("Enter the value of lambda: "))
mean_custom = 1/lam_custom
var_custom = 1/(lam_custom)**2
data_custom = expon.rvs(lam_custom, size=1000)

print()
print("The dataset has a lambda of " + str(round(lam_dataset, 2)))
print("Your custom lambda is " + str(lam_custom))

sns.kdeplot(data_dataset, color="blue", label="Dataset plot with mean " + str(round(mean_dataset, 2)) + " and variance " + str(round(var_dataset, 2)))
sns.kdeplot(data_custom, color="red", label="Custom plot with mean " + str(round(mean_custom, 2)) + " and variance " + str(round(var_custom, 2)))
plt.title("Exponential Distribution")
plt.ylabel("Probability")
plt.xticks()
plt.grid()
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""## **Weibull Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Weibulldata.csv']))

values = df.columns[1]
beta_dataset, loc, alpha_dataset = weibull_min.fit(df[values], floc=0)
data_dataset = [random.weibullvariate(alpha_dataset, beta_dataset) for x in range(10000)]
mean_dataset = round(weibull_min.mean(beta_dataset, alpha_dataset), 2)
sd_dataset = round(weibull_min.std(beta_dataset, alpha_dataset), 2)

long_text = "This is the Weibull distribution plotter. It models the estimated time until an event occurs. The distribution's versatility allows it to be applied to many time-to-event datasets. It's parametrized by two parameters: scale and shape. The scale parameter controls the spread of data, and the shape parameter controls the rate of change."
information = textwrap.fill(long_text, width=100)
print(information)
print()

alpha_custom = float(input("Enter the scale parameter: "))
beta_custom = float(input("Enter the shape parameter: "))
data_custom = [random.weibullvariate(alpha_custom, beta_custom) for x in range(10000)]
mean_custom = weibull_min.mean(beta_custom, alpha_custom)
sd_custom = weibull_min.std(beta_custom, alpha_custom)

sns.kdeplot(data_dataset, color='blue', label="Dataset plot with mean " + str(round(mean_dataset, 2)) + " and standard deviation " + str(round(sd_dataset, 2)))
sns.kdeplot(data_custom, color='red', label="Custom plot with mean " + str(round(mean_custom, 2)) + " and standard deviation " + str(round(sd_custom, 2)))

print()
print("The dataset has a scale parameter " + str(round(alpha_dataset, 2)) + " and a shape parameter " + str(round(beta_dataset, 2)))
print("Your custom plot has a scale parameter " + str(alpha_custom) + " and a shape parameter " + str(beta_custom))

plt.title('Weibull Distribution')
plt.ylabel('Probability Density')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()

"""## **Lognormal Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Lognormaldata.csv']))
values = df.columns[1]

mean_dataset = df[values].mean()
sd_dataset = df[values].std()
data_dataset = np.random.lognormal(mean_dataset, sd_dataset, size=100)

negative = (df[values] < 0).any()
if negative == True:
  raise ValueError("This distribution doesn't apply for datasets with negative values.")

long_text = "This is the lognormal distribution plotter. It plots the probability distribution of a random variable whose logarithm forms a normal distribution. As a result, this distribution is not suitable for datasets that contain any negative values. It's parametrized by two parameters, the mean and standard deviation."
information = textwrap.fill(long_text, width=100)
print(information)
print()

mean_custom = float(input("Enter the mean: "))
sd_custom = float(input("Enter the standard deviation: "))
data_custom = np.random.lognormal(mean_custom, sd_custom, size=100)

sns.kdeplot(data_dataset, color='blue', label="Dataset plot with mean " + str(round(mean_dataset, 2)) + " and standard deviation " + str(round(sd_dataset, 2)))
sns.kdeplot(data_custom, color='red', label="Custom plot with mean " + str(mean_custom) + " and standard deviation " + str(sd_custom))

plt.title("Lognormal Distribution")
plt.ylabel("Density")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""# **Discrete**

## **Bernoulli's Distribution**
"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Bernoullidata.csv']))
outcomes = [0, 1]

n = int(len(df))
successes = df['Outcome'].value_counts()[1] or df.columns[1].value_counts()
p_dataset = successes/n

probabilities_dataset = [bernoulli.pmf(0, p_dataset), bernoulli.pmf(1, p_dataset)]
sd_dataset = round((p_dataset*(1-p_dataset))**0.5, 2)

long_text = "This is the Bernoulli distribution plotter. It plots the probability outcome of a random variable in a single trial with two possibilities: success and failure. For the dataset plot, ensure your dataset has a column titled 'Outcome' and all successful entries are '1' and failures are '0'. Only then will this dataset distribution work. An example is shown below. This distribution is only parametrized by the probability of success, which you can enter for the custom plot."
information = textwrap.fill(long_text, width=100)
print(information)
data = {
    'Trial': [1, 2, 3, 4, 5],
    'Result': ['Success', 'Success', 'Failure', 'Success', 'Failure'],
    'Outcome': [1, 1, 0, 1, 0]
}
example_dataset = pd.DataFrame(data)
print()
print(example_dataset)
print()
print()

p_custom = float(input("Enter the probability of success: "))
if p_custom > 1 or p_custom < 0:
  raise ValueError("The probability must be between 0 and 1. Please try again.")

probabilities_custom = [bernoulli.pmf(0, p_custom), bernoulli.pmf(1, p_custom)]
sd_custom = round((p_custom*(1-p_custom))**0.5, 2)

label_locations = [0, 1]
label_names = ['Failure', 'Success']

fig, (ax1, ax2) = plt.subplots(2, 1)

ax1.bar(outcomes, probabilities_dataset, color=['red', 'green'])
ax1.set_xticks(label_locations, label_names)
ax1.set_ylabel("Probability")
ax1.set_title("Dataset Bernoulli's distribution with mean " + str(round(p_dataset, 2)) + " and standard deviation " + str(sd_dataset))
ax1.set_ylim(0,1)
ax1.grid(axis='y')

ax2.bar(outcomes, probabilities_custom, color=['red', 'green'])
ax2.set_xticks(label_locations, label_names)
ax2.set_ylabel("Probability")
ax2.set_title("Custom Bernoulli's distribution with mean " + str(p_custom) + " and standard deviation " + str(sd_custom))
ax2.set_ylim(0,1)
ax2.grid(axis='y')

plt.tight_layout()
plt.show()

"""## **Binomial Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Binomialdata.csv']))

n_dataset = int(len(df))
successes = df['Outcome'].value_counts()[1] or df.columns[1].value_counts()
p_dataset = successes/n_dataset
k_values_dataset = np.arange(0, n_dataset + 1)
probability_values_dataset = binom.pmf(k_values_dataset, n_dataset, p_dataset)

mean_dataset = round(n_dataset * p_dataset, 2)
sd_dataset = round(mean_dataset * (1 - p_dataset), 2)

long_text = "This is the binomial distribution plotter. It models the outcomes of several independent events that have two outcomes: success and failure. The probability of each result will be the same for all trials. For the dataset plot, ensure your dataset has a column titled 'Outcome' and all successful entries are '1' and failures are '0'. Only then will this dataset distribution work. An example is shown below. This distribution is parametrized by the number of trials and the probability of success, which you can enter for the custom plot."
information = textwrap.fill(long_text, width=100)
print(information)
print()
data = {
    'Trial': [1, 2, 3, 4, 5],
    'Result': ['Success', 'Success', 'Failure', 'Success', 'Failure'],
    'Outcome': [1, 1, 0, 1, 0]
}
example_dataset = pd.DataFrame(data)
print()
print(example_dataset)
print()
print()

n_custom = int(input("Enter the number of trials: "))
p_custom = float(input("Enter the probability of success: "))
if p_custom > 1 or p_custom < 0:
  raise ValueError("The probability must be between 0 and 1. Please try again.")

k_values_custom = np.arange(0, n_custom + 1)
probability_values_custom = binom.pmf(k_values_custom, n_custom, p_custom)

mean_custom = round(n_custom * p_custom, 2)
sd_custom = round(mean_custom * (1 - p_custom), 2)

sns.kdeplot(probability_values_dataset, color='blue', label="Dataset plot with mean " + str(mean_dataset) + " and standard deviation " + str(sd_dataset))
sns.kdeplot(probability_values_custom, color='red', label="Custom plot with mean " + str(mean_custom) + " and standard deviation " + str(sd_custom))

print()
print("The dataset plot has a probability of " + str(round(p_dataset, 2)) + " with " + str(n_dataset) + " trials")
print("The custom plot has a probability of " + str(round(p_custom, 2)) + " with " + str(n_custom) + " trials")

plt.title("Binomial Distribution")
plt.ylabel("Probability")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()

"""## **Poisson Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Poissondata.csv']))

values = df.columns[1]
lam_dataset = np.mean(df[values])
data_dataset = np.random.poisson(lam_dataset, size=1000)

long_text = "This is the Poisson distribution plotter. It models the expected number of events to occur within a given time frame. The events are independent from one another and happen at a constant rate. It's parametrized by lambda, which is the average rate of events occurring. Something unique about the Poisson distribution is that the mean and variance are also equal to the value of lambda."
information = textwrap.fill(long_text, width=100)
print(information)
print()

lam_custom = float(input("Enter the value of lambda: "))
data_custom = np.random.poisson(lam_custom, size=1000)

sns.histplot(data_dataset, color="blue", alpha=0.5, label="Dataset plot with mean and variance equal to " + str(lam_dataset))
sns.histplot(data_custom, color="red", alpha=0.5, label="Custom plot with mean and variance equal to " + str(lam_custom))

plt.title("Poisson Distribution")
plt.xlabel("Number of Events")
plt.ylabel("Probability")
plt.xticks()
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()

"""## **Geometrical Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Geometricaldata.csv']))

values = df.columns[1]
mean_dataset = df[values].mean()
p_dataset = 1/mean_dataset
var_dataset = (1 - p_dataset)/p_dataset**2

long_text = "This is the geometrical distribution plotter. It models the expected number of trials required for a successful outcome. It's parametrized only by the probability of success, which stays constant for all trials. The probability will be calculated from the dataset you input. The custom probability of success you input below will showcase the probability distribution alongside."
information = textwrap.fill(long_text, width=100)
print(information)
print()

p_custom = float(input("Enter the probability of success: "))
if p_custom > 1 or p_custom < 0:
  raise ValueError("The probability must be between 0 and 1. Please try again.")
mean_custom = 1/p_custom
var_custom = (1 - p_custom)/p_custom**2

data_dataset = np.random.geometric(p_dataset, size=1000)
data_custom = np.random.geometric(p_custom, size=1000)

print()
print("The dataset plot has a probability of " + str(round(p_dataset, 2)))
print("The custom plot has a probability of " + str(p_custom))

plt.hist(data_dataset, bins=np.arange(1, max(data_dataset)), color="blue", alpha=0.5, label="Dataset plot with mean " + str(round(mean_dataset, 2)) + " and variance " + str(round(var_dataset, 2)))
plt.hist(data_custom, bins=np.arange(1, max(data_custom)), color="red", alpha=0.5, label="Custom plot with mean " + str(round(mean_custom, 2)) + " and variance " + str(round(var_custom, 2)))

plt.xlabel("Number of Trials for First Success")
plt.ylabel("Probability Density")
plt.title("Geometric Distribution")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()

"""## **Hypergeometric Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Hypergeometricdata.csv']))
values = df.columns[1]

data_dataset = df[values]

long_text = "This is the hypergeometric distribution plotter. It models the probability of achieving a certain number of successes in a small sample without replacement. Due to this, the probability of success won't stay constant. It's parametrized by the population (total number of items), the successes (number of successful outcomes), and the sample (number of items drawn). You can plot a custom distribution by assigning values to these parameters. With the dataset you provide, an estimate plot can be made, but won't be accurate without specific values of the parameters."
information = textwrap.fill(long_text, width=100)
print(information)
print()

population_custom = int(input("Enter the population size: "))
success_custom = int(input("Enter the number of successes in the population: "))
sample_custom = int(input("Enter the sample size: "))

mean_custom = (sample_custom * success_custom) / population_custom
var_custom = ((sample_custom * success_custom)*(population_custom - success_custom)*(population_custom - sample_custom)) / (population_custom**2 * (population_custom - 1))

data_custom = np.arange(0, min(sample_custom, success_custom) + 1)
probability_custom = hypergeom.pmf(data_custom, population_custom, success_custom, sample_custom)

print()
print("The custom plot has a mean of " + str(round(mean_custom, 2)) + " and variance " + str(round(var_custom, 2)))

plt.hist(data_dataset, bins=range(data_dataset.min(), data_dataset.max() + 2), alpha=0.5, color="blue", density=True, label="Dataset plot")
plt.bar(data_custom, probability_custom, alpha=0.5, color="red", label="Custom plot")

plt.title("Hypergeometric Distribution")
plt.xlabel("Number of Successes in Sample")
plt.ylabel("Probability")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid()
plt.show()

"""## **Multinomial Distribution**"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv(io.BytesIO(uploaded['Multinomialdata.csv']))

n_dataset = int(len(df))
column1 = df.columns[0]
column2 = df.columns[1]
probabilities_dataset = list(df[column2])

long_text = "This is the multinomial distribution plotter. It calculates the probability distribution of independent events with numerous outcomes, each with a respective probability of occurring. Therefore, each outcome will have a different expected number of occurrences. It's parametrized by the number of outcomes and the probabilities of each outcome (all adding up to 1). After uploading your dataset, you can view the probability distribution of each outcome individually as well as a custom distribution with preferred values."
information = textwrap.fill(long_text, width=100)
print(information)
print()

outcome_dataset = int(input("Enter which outcome for the dataset plot do you want to see: "))
print()

print("Now for the custom plot")
n_custom = int(input("Enter the number of outcomes: "))
inputs = input("Enter probabilities of each outcome in order separated by commas (ensure in order of outcome): ")
probabilities_custom = inputs.split(',')
probabilities_custom = [float(p) for p in probabilities_custom]

outcome_custom = int(input("Enter which outcome for the custom plot do you want to see: "))
print()

data_dataset = np.random.multinomial(n_dataset, probabilities_dataset, size=1000)
data_custom = np.random.multinomial(n_custom, probabilities_custom, size=1000)

mean_dataset = n_dataset * probabilities_dataset[outcome_dataset - 1]
var_dataset = n_dataset * probabilities_dataset[outcome_dataset - 1] * (1 - probabilities_dataset[outcome_dataset - 1])
mean_custom = n_custom * probabilities_custom[outcome_custom - 1]
var_custom = n_custom * probabilities_custom[outcome_custom - 1] * (1 - probabilities_custom[outcome_custom - 1])

print("The dataset plot has a mean of " + str(round(mean_dataset, 2)) + " and variance " + str(round(var_dataset, 2)))
print("The custom plot has a mean of " + str(round(mean_custom, 2)) + " and variance " + str(round(var_custom, 2)))
print()

fig, axes = plt.subplots(1, 2)

sns.histplot(data_dataset[:, outcome_dataset - 1], bins=range(n_dataset + 2), alpha=0.5, color="blue", ax=axes[0])
axes[0].set_title("Dataset Plot (Outcome " + str(outcome_dataset) + ")")
axes[0].set_xlabel("Number of Occurrences of Outcome " + str(outcome_dataset))
axes[0].set_ylabel("Frequency")
axes[0].grid(axis="y")

sns.histplot(data_custom[:, outcome_custom - 1], bins=range(n_custom + 2), alpha=0.5, color="red", ax=axes[1])
axes[1].set_title("Custom Plot (Outcome " + str(outcome_custom) + ")")
axes[1].set_xlabel("Number of Occurrences of Outcome " + str(outcome_custom))
axes[1].set_ylabel("Frequency")
axes[1].grid(axis="y")

plt.tight_layout()
plt.show()