# -*- coding: utf-8 -*-
"""EGM5_CO2_Flux_분석기.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lfc8SOT6cDsNcf1lAFck1aFl7L5d-aoQ

# **EGM5 Soil CO₂ Flux 분석기**
한 번의 클릭으로 EGM5 데이터를 뽑아보자.

**호흡이 불안정한 초기 구간**을 제거하고, 전체 데이터를 이용해 회귀 분석 **(기울기가 안정되는 구간을 자동 탐색)**을 수행해요.

온도는 Tsoil 보정식을 사용해요: T_K = 273.15 + (평균 Tsoil - 4.4805) / 0.9761.

**ZIP 파일 형태로 (YYYYMMDD_processed.zip)**로 결과를 내보내며, ZIP 안에는 요약 엑셀 파일과 각 Plot의 PNG 그래프가 저장되죠
"""

# @title 함께 시작해볼까요?

!pip -q install pandas numpy openpyxl pillow matplotlib pytz

!pip -q install gradio pandas numpy openpyxl pillow matplotlib pytz

import os, json, zipfile, shutil, traceback
from pathlib import Path
from datetime import datetime, timezone
import numpy as np, pandas as pd, matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from openpyxl.drawing.image import Image as XLImage
from openpyxl.utils import get_column_letter
import pytz, gradio as gr

KST = pytz.timezone("Asia/Seoul")

DEFAULT_VOLUME_ML = 1413.7164
DEFAULT_AREA_CM2  = 78.0

def lin_regression(x, y):
    x = np.asarray(x, dtype=float); y = np.asarray(y, dtype=float)
    if len(x) < 2: return np.nan, np.nan, np.nan
    A = np.vstack([x, np.ones_like(x)]).T
    a, b = np.linalg.lstsq(A, y, rcond=None)[0]
    y_hat = a * x + b
    ss_res = np.sum((y - y_hat) ** 2)
    ss_tot = np.sum((y - np.mean(y)) ** 2)
    r2 = 1 - ss_res / ss_tot if ss_tot > 0 else np.nan
    return float(a), float(b), float(r2)

def detect_time_column(df):
    for c in df.columns:
        if str(df[c].iloc[0]).strip().lower() == "time":
            return c
    for c in df.columns:
        if str(c).strip().lower() in ("time","time(s)","time (s)","seconds","sec","s"):
            return c
    raise RuntimeError("시간 열을 찾지 못했습니다. 첫 행에 'Time' 셀을 두거나 시트를 확인하세요.")

def choose_initial_window(t, ppm, front_skip_s, window_s, min_pts, r2_thresholds):
    t = np.asarray(t, dtype=float); ppm = np.asarray(ppm, dtype=float)
    ok = np.isfinite(t) & np.isfinite(ppm)
    t, ppm = t[ok], ppm[ok]
    if len(t) < min_pts:
        return {"t_start": np.nan, "t_end": np.nan, "slope": np.nan, "r2": np.nan}
    order = np.argsort(t); t, ppm = t[order], ppm[order]
    t0 = t.min() + front_skip_s; t1 = t.max()
    best = {"t_start": np.nan, "t_end": np.nan, "slope": np.nan, "r2": -np.inf}
    for r2_target in list(r2_thresholds) + [0.0]:
        found=False
        for i in range(len(t)):
            if t[i] < t0 or t[i] >= t1: continue
            j=i
            while j < len(t) and (t[j]-t[i]) < window_s: j+=1
            if (j-i) < min_pts: continue
            a,b,r2 = lin_regression(t[i:j], ppm[i:j])
            if np.isfinite(a) and a>0 and np.isfinite(r2) and r2>=r2_target:
                best={"t_start":float(t[i]), "t_end":float(t[j-1]), "slope":a, "r2":r2}
                found=True; break
        if found: break
    return best

def compute_flux_with_TsoilK(slope_ppm_per_s, pressure_hPa, tsoil_mean_C, volume_ml, area_cm2):
    GAS_R=0.08206; CARBON=12.0
    T_K = 273.15 + (tsoil_mean_C - 4.4805) / 0.9761
    V_L = volume_ml/1000.0
    Vdot_CO2_L_s = slope_ppm_per_s * 1e-6 * V_L
    P_atm = pressure_hPa / 1013.25
    mol_per_s = (P_atm * Vdot_CO2_L_s) / (GAS_R * T_K)
    gC_per_s = mol_per_s * CARBON
    ugC_h_cm2 = (gC_per_s * 1e6 * 3600.0) / area_cm2
    return T_K, Vdot_CO2_L_s, P_atm, mol_per_s, gC_per_s, ugC_h_cm2

def safe_label(v):
    try:
        f=float(v); label=str(int(f)) if f.is_integer() else str(f)
    except:
        label=str(v)
    for ch in r'\/:*?[]': label=label.replace(ch,"_")
    return label

def parse_per_plot_skip(text):
    text=str(text or "").strip()
    if not text: return {}
    try:
        obj=json.loads(text); out={}
        for k,v in obj.items():
            try: out[float(k)]=float(v)
            except: out[k]=float(v)
        return out
    except Exception:
        out={}
        parts=[p for p in text.replace(";",",").split(",") if p.strip()]
        for p in parts:
            if ":" in p:
                k,v=p.split(":")
                try: kf=float(k.strip())
                except: kf=k.strip()
                out[kf]=float(v.strip())
        return out

def run_pipeline(input_xlsx, sheet_name, out_dir,
                 front_skip_s, window_s, min_pts, r2_list,
                 volume_ml, area_cm2, per_plot_overrides):
    input_xlsx=Path(input_xlsx); out_dir=Path(out_dir)
    if not input_xlsx.exists(): raise FileNotFoundError(f"Excel not found: {input_xlsx}")
    out_dir.mkdir(parents=True, exist_ok=True)

    dt_kst = datetime.now(timezone.utc).astimezone(KST)
    today_str = dt_kst.strftime("%Y%m%d")
    stage = out_dir/"package_contents"; plots_dir = stage/"plots"
    plots_dir.mkdir(parents=True, exist_ok=True)

    raw=pd.read_excel(input_xlsx, sheet_name=sheet_name, engine="openpyxl")
    time_col=detect_time_column(raw)

    data=raw.iloc[1:].copy()
    data[time_col]=pd.to_numeric(data[time_col], errors="coerce")
    for col in ["CO2","Pressure","Tsoil","Plot_No"]:
        if col in data.columns: data[col]=pd.to_numeric(data[col], errors="coerce")

    orig_ids=sorted([v for v in pd.unique(data["Plot_No"]) if pd.notna(v)], key=lambda x: float(x))

    results=[]
    for orig_plot_no in orig_ids:
        g=data.loc[data["Plot_No"]==orig_plot_no].sort_values(by=time_col).copy()
        local_skip=float(per_plot_overrides.get(orig_plot_no, front_skip_s))

        t=g[time_col].to_numpy(dtype=float)
        ppm=g["CO2"].to_numpy(dtype=float)

        win=choose_initial_window(t, ppm, local_skip, window_s, min_pts, r2_list)
        cut_time=win["t_end"] if np.isfinite(win["t_end"]) else (np.nanmin(t)+local_skip)

        g_after=g.loc[g[time_col] >= cut_time].copy()
        x=g_after[time_col].to_numpy(dtype=float)
        y=g_after["CO2"].to_numpy(dtype=float)

        a,b,r2 = lin_regression(x,y)
        pres_mean=g_after["Pressure"].mean()
        tsoil_mean_C=g_after["Tsoil"].mean()

        T_K, Vdot_CO2_L_s, P_atm, mol_CO2_per_s, gC_per_s, CO2_rate = compute_flux_with_TsoilK(
            a, pres_mean, tsoil_mean_C, volume_ml, area_cm2
        )

        results.append({
            "Original_Plot_No": orig_plot_no,
            "front_skip_applied_s": local_skip,
            "init_window_t_start": win["t_start"],
            "init_window_t_end": win["t_end"],
            "after_cut_slope_ppm_per_s": a,
            "after_cut_R2": r2,
            "fit_t_start_s": float(np.nanmin(x)) if len(x) else np.nan,
            "fit_t_end_s": float(np.nanmax(x)) if len(x) else np.nan,
            "Pressure_mean_hPa": pres_mean,
            "Tsoil_mean_C_after": tsoil_mean_C,
            "T_K_calibrated": T_K,
            "Vdot_CO2_L_s": Vdot_CO2_L_s,
            "P_atm": P_atm,
            "mol_CO2_per_s": mol_CO2_per_s,
            "gC_per_s": gC_per_s,
            "CO2_rate_ugC_h_cm2": CO2_rate,
        })

        # Plot 저장
        label = safe_label(orig_plot_no)
        fig, ax = plt.subplots(figsize=(6, 3.5))
        ax.scatter(x, y, s=15)
        if np.isfinite(a):
            xfit = np.array([np.nanmin(x), np.nanmax(x)])
            yfit = a * xfit + b
            ax.plot(xfit, yfit)
            annot = (
                f"y = {a:.4f}x + {b:.1f}\n"
                f"$R^2$ = {r2:.4f}\n"
                f"CO\u2082 rate = {CO2_rate:.2f} \u03BCg C-CO\u2082/(h·cm²)"
            )
            ax.text(0.60, 0.08, annot, transform=ax.transAxes,
                    ha="left", va="bottom",
                    bbox=dict(facecolor="white", alpha=0.7, edgecolor="none"))
        ax.set_title(f"plot {label}")
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("CO$_2$ (ppm)")
        fig.tight_layout()
        fig.savefig(plots_dir / f"plot_{label}.png", dpi=150)
        plt.close(fig)

    summary=pd.DataFrame(results).sort_values("Original_Plot_No").reset_index(drop=True)

    # 엑셀+이미지 시트 작성
    excel_out=stage/f"{today_str}_processed.xlsx"
    with pd.ExcelWriter(excel_out, engine="openpyxl", mode="w") as writer:
        summary.to_excel(writer, index=False, sheet_name="Summary")
        wb=writer.book; ws=wb.create_sheet("Plots")
        row,col=1,1
        for orig_plot_no in orig_ids:
            label=safe_label(orig_plot_no)
            img_path=plots_dir/f"plot_{label}.png"
            if img_path.exists():
                img=XLImage(str(img_path))
                ws.add_image(img, f"{get_column_letter(col)}{row}")
            col+=9
            if (col>9*3):
                col=1; row+=20
        for orig_plot_no in orig_ids:
            label=safe_label(orig_plot_no)
            local_skip=float(per_plot_overrides.get(orig_plot_no, front_skip_s))
            g=data.loc[data["Plot_No"]==orig_plot_no].sort_values(by=time_col).copy()
            t=g[time_col].to_numpy(dtype=float)
            ppm=g["CO2"].to_numpy(dtype=float)
            win=choose_initial_window(t, ppm, local_skip, window_s, min_pts, r2_list)
            cut_time=win["t_end"] if np.isfinite(win["t_end"]) else (np.nanmin(t)+local_skip)
            g_after=g.loc[g[time_col] >= cut_time, [time_col, "CO2", "Pressure", "Tsoil"]].copy()
            g_after.rename(columns={time_col: "Time_s"}, inplace=True)
            g_after.to_excel(writer, index=False, sheet_name=f"Plot_{label}")

    # ZIP
    zip_path = Path(out_dir)/f"{today_str}_processed.zip"
    with zipfile.ZipFile(zip_path,"w",zipfile.ZIP_DEFLATED) as z:
        z.write(excel_out, arcname=excel_out.name)
        for png in sorted((plots_dir).glob("*.png")):
            z.write(png, arcname=f"plots/{png.name}")
    shutil.rmtree(stage, ignore_errors=True)
    return summary, zip_path

def run_app(input_excel_path, output_dir, sheet_name,
            front_skip_s, window_s, min_pts, r2_text,
            per_plot_overrides_text):
    try:
        if not input_excel_path:
            return "엑셀(.xlsx)을 업로드하세요.", None, gr.update(visible=False)
        output_dir = output_dir or "/content/EGM5/output"
        os.makedirs(output_dir, exist_ok=True)
        r2_list=[float(x.strip()) for x in str(r2_text).replace(";",",").split(",") if x.strip()]
        overrides=parse_per_plot_skip(per_plot_overrides_text)

        summary, zip_path = run_pipeline(
            input_xlsx=input_excel_path,
            sheet_name=sheet_name,
            out_dir=output_dir,
            front_skip_s=float(front_skip_s),
            window_s=int(window_s),
            min_pts=int(min_pts),
            r2_list=r2_list,
            volume_ml=DEFAULT_VOLUME_ML,     # 내부 고정값 사용
            area_cm2=DEFAULT_AREA_CM2,       # 내부 고정값 사용
            per_plot_overrides=overrides
        )
        btn = gr.update(value=str(zip_path), visible=True,
                        label=f"결과 ZIP 다운로드 ({Path(zip_path).name})")
        return "완료!", summary, btn
    except Exception:
        return "오류 발생:\n" + traceback.format_exc(), None, gr.update(visible=False)

with gr.Blocks(theme=gr.themes.Soft()) as demo:
    gr.Markdown("## EGM5 Soil CO₂ Flux 분석기")
  # gr.Markdown(f"**고정 파라미터** · 챔버 부피 = {DEFAULT_VOLUME_ML} mL, 면적 = {DEFAULT_AREA_CM2} cm²", elem_classes="text-sm")

    with gr.Row():
        input_excel = gr.File(label="EGM5 Excel (.xlsx)", type="filepath")
        output_dir  = gr.Textbox(label="출력 폴더", value="/content/EGM5/output")

    sheet_name = gr.Textbox(label="시트명", value="20231110_raw")

    with gr.Row():
        front_skip_s = gr.Number(label="초반 스킵(초)", value=3.0)
        window_s     = gr.Number(label="기울기 완만성(초)", value=15)
        min_pts      = gr.Number(label="최소 포인트 수", value=50)

    r2_text = gr.Textbox(label="R² 기준(쉼표 구분)", value="0.995,0.99,0.985,0.98,0.97")


    per_plot_overrides_text = gr.Textbox(
        label="Plot별 초반 스킵 수동 설정",
        placeholder='예: 6:5, 14:8  또는  {"6":5, "14":8}'
    )

    run_btn  = gr.Button("실행", variant="primary")
    status   = gr.Textbox(label="상태/로그", interactive=False, lines=8)
    summary_df = gr.Dataframe(label="Summary", interactive=False)
    dl_btn   = gr.DownloadButton("결과 ZIP 다운로드", visible=False)

    run_btn.click(
        run_app,
        inputs=[input_excel, output_dir, sheet_name, front_skip_s, window_s, min_pts,
                r2_text, per_plot_overrides_text],
        outputs=[status, summary_df, dl_btn]
    )

demo.launch(share=True)