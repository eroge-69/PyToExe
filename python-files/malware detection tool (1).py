#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Malware Detection Tool - Pro (PyQt5)
------------------------------------
Features:
- File pick + SHA-256 hashing + immediate VirusTotal hash scan on file
- VirusTotal v3 hash lookup (GET /api/v3/files/{sha256})
- VirusTotal v3 URL scan (POST /api/v3/urls -> GET /api/v3/analyses/{id})
- Non-blocking background workers (QThreadPool + QRunnable)
- Unified in-app results + optional detailed modal
- Copy-to-clipboard, clear, and basic dark-ish styling
- 🔥 Project Info button on top with a rich text popup dialog
- Email report sending after analysis as PDF attachment (email input in main UI)
- Inline pop-up messages displayed on main GUI
- User auth and multi-user with role/profile support
Requirements:
    pip install PyQt5 requests reportlab
"""
import sys
import os
import json
import base64
import hashlib
import time
import traceback
import smtplib
import tempfile
import re
import random # Added missing import
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from email.message import EmailMessage
import requests
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QPushButton, QLabel, QVBoxLayout,
    QHBoxLayout, QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem,
    QProgressBar, QFileDialog, QMessageBox, QDialog, QScrollArea,
    QStackedLayout
)
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtCore import QUrl, Qt, QRunnable, QThreadPool, pyqtSignal, QObject, QTimer # Added missing QTimer
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QLineEdit, QPushButton, QTextEdit, QFileDialog, QSpacerItem,
    QSizePolicy, QDialog, QDialogButtonBox, QProgressBar
)
from PyQt5.QtGui import QFont, QPixmap, QPainter, QColor # Added missing QPainter and QColor
from PyQt5.QtCore import QRectF # Added missing import for QRectF

# ---------------- CONFIG ----------------
API_KEY = "1833d2e725ea6e79618ca67478eefbc6d7223f4ac99a683bd3ae9701cbe72330"  # <-- Insert your API key here
VT_BASE = "https://www.virustotal.com/api/v3"


# Email settings (Add your SMTP server details here)
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587
SMTP_USERNAME = "mdetectiontool@gmail.com"
SMTP_PASSWORD = "irhw anwi ipgk undd"
EMAIL_FROM = SMTP_USERNAME
EMAIL_SUBJECT = "VirusTotal Malware Scan Report"


# Simple user database (in production, replace with secure DB/storage)
USERS = {
    "admin": {"password": "adminpass", "role": "admin", "email": "admin@example.com"},
    "user1": {"password": "user1pass", "role": "user", "email": "user1@example.com"}
}


# ---------------- Helpers ----------------
def sha256_file(path, chunk_size=1024 * 1024):
    h = hashlib.sha256()
    with open(path, "rb") as f:
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break
            h.update(chunk)
    return h.hexdigest()

def vt_headers():
    return {
        "x-apikey": API_KEY,
        "Accept": "application/json",
    }

def b64_url_id(url_str: str) -> str:
    """VT v3 uses URL-safe base64 without padding for URL IDs."""
    encoded = base64.urlsafe_b64encode(url_str.encode("utf-8")).decode("utf-8")
    return encoded.strip("=")


# ---------------- PDF Generation ----------------
def generate_pdf_report(report_text: str) -> str:
    """Generate a PDF file from the report_text and return the file path."""
    temp_pdf = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
    c = canvas.Canvas(temp_pdf.name, pagesize=letter)
    width, height = letter

    lines = report_text.splitlines()
    y_position = height - 40  # Start near top

    for line in lines:
        if y_position < 40:  # Start new page if near bottom
            c.showPage()
            y_position = height - 40
        c.drawString(40, y_position, line)
        y_position -= 14

    c.save()
    return temp_pdf.name


# ---------------- Email Sending Function ----------------
def send_report_email(to_email: str, report_text: str):
    """Send the scan report as a PDF attachment to specified email address."""
    try:
        pdf_path = generate_pdf_report(report_text)

        msg = EmailMessage()
        msg["Subject"] = EMAIL_SUBJECT
        msg["From"] = EMAIL_FROM
        msg["To"] = to_email
        msg.set_content("Please find the attached malware scan report PDF.")

        with open(pdf_path, "rb") as f:
            pdf_data = f.read()

        msg.add_attachment(pdf_data, maintype="application", subtype="pdf", filename="MalwareScanReport.pdf")

        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls()
            server.login(SMTP_USERNAME, SMTP_PASSWORD)
            server.send_message(msg)

    except Exception as e:
        print(f"Email sending failed: {e}", file=sys.stderr)
        raise
    finally:
        if 'pdf_path' in locals() and os.path.exists(pdf_path):
            os.remove(pdf_path)


# ---------------- Worker infra ----------------
class WorkerSignals(QObject):
    success = pyqtSignal(object)  # payload
    error = pyqtSignal(str)       # error message
    done = pyqtSignal()           # finished (always)

class Worker(QRunnable):
    """Generic QRunnable worker that executes a callable(*args, **kwargs)."""
    def __init__(self, fn, *args, **kwargs):
        super().__init__()
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()
    def run(self):
        try:
            result = self.fn(*self.args, **self.kwargs)
            self.signals.success.emit(result)
        except Exception as e:
            tb = traceback.format_exc()
            self.signals.error.emit(f"{e}\n\n{tb}")
        finally:
            self.signals.done.emit()


# ---------------- VirusTotal functions ----------------
def vt_check_hash(sha256_hash: str):
    url = f"{VT_BASE}/files/{sha256_hash}"
    r = requests.get(url, headers=vt_headers(), timeout=30)
    if r.status_code == 200:
        data = r.json()
        attrs = data.get("data", {}).get("attributes", {})
        stats = attrs.get("last_analysis_stats", {})
        malicious = stats.get("malicious", 0)
        suspicious = stats.get("suspicious", 0)
        harmless = stats.get("harmless", 0)
        reputation = attrs.get("reputation", 0)
        meaningful_name = attrs.get("meaningful_name", "")
        summary = {
            "type": "hash_lookup",
            "hash": sha256_hash,
            "found": True,
            "meaningful_name": meaningful_name,
            "stats": stats,
            "reputation": reputation,
            "permalink": f"https://www.virustotal.com/gui/file/{sha256_hash}",
            "raw": data
        }
        if malicious > 0 or suspicious > 0:
            summary["verdict"] = "⚠ Possibly Malicious"
        elif harmless > 0 and malicious == 0 and suspicious == 0:
            summary["verdict"] = "✅ Likely Harmless"
        else:
            summary["verdict"] = "❓ Inconclusive"
        return summary
    elif r.status_code == 404:
        return {
            "type": "hash_lookup",
            "hash": sha256_hash,
            "found": False,
            "verdict": "❓ Hash not found on VirusTotal",
            "raw": r.json() if r.content else {}
        }
    else:
        try:
            j = r.json()
        except Exception:
            j = {}
        raise RuntimeError(f"VirusTotal error {r.status_code}: {j}")

def vt_scan_url(url_to_scan: str, poll_seconds: float = 1.5, max_wait: float = 30.0):
    submit_url = f"{VT_BASE}/urls"
    r = requests.post(submit_url, headers=vt_headers(), data={"url": url_to_scan}, timeout=30)
    if r.status_code not in (200, 202):
        try:
            j = r.json()
        except Exception:
            j = {}
        raise RuntimeError(f"URL submit failed {r.status_code}: {j}")
    data = r.json()
    analysis_id = data.get("data", {}).get("id")
    if not analysis_id:
        raise RuntimeError("No analysis ID returned from VirusTotal.")
    start = time.time()
    analysis_url = f"{VT_BASE}/analyses/{analysis_id}"
    while True:
        rr = requests.get(analysis_url, headers=vt_headers(), timeout=30)
        if rr.status_code != 200:
            try:
                jj = rr.json()
            except Exception:
                jj = {}
            raise RuntimeError(f"Analysis poll failed {rr.status_code}: {jj}")
        j = rr.json()
        status = j.get("data", {}).get("attributes", {}).get("status", "")
        if status == "completed":
            attrs = j.get("data", {}).get("attributes", {})
            stats = attrs.get("stats", {}) or attrs.get("results", {})
            malicious = stats.get("malicious", 0)
            suspicious = stats.get("suspicious", 0)
            harmless = stats.get("harmless", 0)
            summary = {
                "type": "url_scan",
                "url": url_to_scan,
                "analysis_id": analysis_id,
                "status": "completed",
                "stats": stats,
                "permalink": f"https://www.virustotal.com/gui/url/{b64_url_id(url_to_scan)}",
                "raw": j
            }
            if malicious > 0 or suspicious > 0:
                summary["verdict"] = "⚠ Possibly Malicious"
            elif harmless > 0 and malicious == 0 and suspicious == 0:
                summary["verdict"] = "✅ Likely Harmless"
            else:
                summary["verdict"] = "❓ Inconclusive"
            return summary
        if time.time() - start > max_wait:
            return {
                "type": "url_scan",
                "url": url_to_scan,
                "analysis_id": analysis_id,
                "status": status or "pending",
                "verdict": "⏳ Still analyzing (try again later)",
                "raw": j
            }
        time.sleep(poll_seconds)


# ---------------- Project Info Dialog ----------------
class ProjectInfoDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("📋 Project Information")
        self.setWindowFlags(self.windowFlags() | Qt.WindowMaximizeButtonHint | Qt.WindowMinimizeButtonHint)
        self.resize(900, 600)
        layout = QVBoxLayout(self)
        
        webview = QWebEngineView()
        layout.addWidget(webview)
        
        current_dir = os.path.dirname(os.path.abspath(__file__))
        html_file_path = os.path.join(current_dir, "project_info.html")
        
        if os.path.exists(html_file_path):
            webview.load(QUrl.fromLocalFile(html_file_path))
        else:
            webview.setHtml("<h1>Error: project_info.html not found!</h1>")
        
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.accept)
        layout.addWidget(close_button)


# ---------------- UI Components ----------------
class DetailsDialog(QDialog):
    def __init__(self, title: str, payload: dict, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.resize(800, 600)
        layout = QVBoxLayout(self)
        self.text = QTextEdit(self)
        self.text.setReadOnly(True)
        self.text.setPlainText(json.dumps(payload, indent=2))
        layout.addWidget(self.text)
        buttons = QDialogButtonBox(QDialogButtonBox.Close)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

# ---------------- Hacker Background ----------------
# The 'HackerBackground' class is a fun but non-essential element that has several errors.
# It attempts to draw an animated background, but relies on a local image file that is not included.
# It's been fixed to work without the image if it's missing, and imports have been corrected.
class HackerBackground(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update)
        self.timer.start(60)

        self.font = QFont('Consolas', 12, QFont.Bold)
        self.letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()"

        # Load background image
        self.bg_pixmap = QPixmap("44805821-4f7d-408d-8fd5-2c3225801593.png")

        self.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.setStyleSheet("background: black;")

    def paintEvent(self, event):
        painter = QPainter(self)

        # Draw static hacker-style background image
        if not self.bg_pixmap.isNull():
            scaled_bg = self.bg_pixmap.scaled(self.size(), Qt.KeepAspectRatioByExpanding, Qt.SmoothTransformation)
            painter.drawPixmap(0, 0, scaled_bg)
        else:
            # If the image is not found, fill with black
            painter.fillRect(self.rect(), QColor(0, 0, 0))

        # Draw animated hacker text on top
        painter.setFont(self.font)
        for i in range(0, self.width(), 24):
            y = random.randint(0, self.height())
            painter.setPen(QColor(0, random.randint(180, 255), 0, 200))
            painter.drawText(QRectF(i, y, 24, 32), Qt.AlignCenter, random.choice(self.letters))

            if random.random() < 0.08:
                ry = random.randint(0, self.height())
                painter.setPen(QColor(random.randint(180, 255), 0, 0, 160))
                painter.drawText(QRectF(i, ry, 24, 32), Qt.AlignCenter, random.choice(self.letters))

# ---------------- User Authentication Dialog ----------------
class LoginDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("🔐 User Login")
        self.resize(400, 180)
        layout = QVBoxLayout(self)
        self.username_edit = QLineEdit(self)
        self.username_edit.setPlaceholderText("Username")
        self.password_edit = QLineEdit(self)
        self.password_edit.setEchoMode(QLineEdit.Password)
        self.password_edit.setPlaceholderText("Password")
        self.login_btn = QPushButton("Login")
        self.login_btn.clicked.connect(self.authenticate)
        self.status_label = QLabel("")
        self.status_label.setStyleSheet("color: red;")
        layout.addWidget(QLabel("Enter your credentials:"))
        layout.addWidget(self.username_edit)
        layout.addWidget(self.password_edit)
        layout.addWidget(self.login_btn)
        layout.addWidget(self.status_label)
        self._user = None

    def authenticate(self):
        username = self.username_edit.text().strip()
        password = self.password_edit.text().strip()
        user = USERS.get(username)
        if user and user["password"] == password:
            self._user = {"username": username, "role": user["role"], "email": user.get("email", "")}
            self.accept()
        else:
            self.status_label.setText("Invalid username or password")

    def get_user(self):
        return self._user
class MalwareDetectionApp(QMainWindow):
    def __init__(self, user_info):
        super().__init__()
        self.setWindowTitle(f"🛡 Malware Detection Tool - Pro (PyQt5) - Logged in as '{user_info['username']}'")
        self.resize(900, 780)
        self.threadpool = QThreadPool()
        self.user_info = user_info

        # Central stacked container
        central = QWidget(self)
        self.setCentralWidget(central)

        # --- STACK LAYOUT (background + main UI) ---
        stack_layout = QStackedLayout(central)

        # Background widget (fills the window)
        self.bg_widget = HackerBackground(central)
        stack_layout.addWidget(self.bg_widget)

        # Main UI container (transparent)
        ui_container = QWidget(central)
        ui_container.setAttribute(Qt.WA_TranslucentBackground, True)
        main_ui_layout = QVBoxLayout(ui_container)
        main_ui_layout.setContentsMargins(14, 14, 14, 14)
        main_ui_layout.setSpacing(10)

        # Put UI inside
        self._build_ui(main_ui_layout)

        stack_layout.addWidget(ui_container)
        stack_layout.setCurrentWidget(ui_container)  # Show UI above background

        # Styling (dark theme)
        self.setStyleSheet("""
            QMainWindow {
                background-color: black;
            }
            QLabel, QLineEdit, QPushButton, QTextEdit { color: #e5e7eb; font-size: 14px; }
            QLineEdit, QTextEdit {
                background-color: #111827; border: 1px solid #374151; border-radius: 8px; padding: 8px;
                color: #e5e7eb;
            }
            QPushButton {
                background-color: #1f2937; border: 1px solid #374151; border-radius: 10px; padding: 8px 12px;
                font-size: 15px; font-weight: bold;
            }
            QPushButton:hover { background-color: #374151; }
            QProgressBar {
                border: 1px solid #374151; border-radius: 6px; text-align: center;
                background: #111827;
            }
            QProgressBar::chunk { background-color: #4b5563; }
        """)

# ---------------- Main Application ----------------
class MalwareDetectionApp(QMainWindow):
    def __init__(self, user_info):
        super().__init__()
        self.setWindowTitle(f"🛡 Malware Detection Tool - Pro (PyQt5) - Logged in as '{user_info['username']}'")
        self.resize(900, 780)
        self.threadpool = QThreadPool()
        self.user_info = user_info

        # Hacker background should be added to the central widget's layout as an overlay
        central = QWidget(self)
        self.setCentralWidget(central)
        
        # Overlay layout to stack the background and main UI
        stack_layout = QVBoxLayout(central)
        stack_layout.setContentsMargins(0, 0, 0, 0) # No margins for the background
        
        self.bg_widget = HackerBackground(central) # Create background widget
        stack_layout.addWidget(self.bg_widget)
        
        root = QVBoxLayout()
        root.setContentsMargins(14, 14, 14, 14)
        root.setSpacing(10)
        ui_container = QWidget(central)
        ui_container.setStyleSheet("background: transparent;") # Make container transparent
        main_ui_layout = QVBoxLayout(ui_container)
        main_ui_layout.setContentsMargins(14, 14, 14, 14)
        main_ui_layout.setSpacing(10)
         

        # File scan row
        file_row = QHBoxLayout()
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setPlaceholderText("Selected file path…")
        btn_browse = QPushButton("📂 Browse File")
        btn_browse.clicked.connect(self.on_browse_file)
        btn_scan_file = QPushButton("🔍 Scan File")
        btn_scan_file.clicked.connect(self.on_scan_file)
        btn_project_info = QPushButton("📋 Project Info")
        btn_project_info.clicked.connect(self.show_project_info)

        file_row.addWidget(self.file_path_edit, 3)
        file_row.addWidget(btn_browse, 0)
        file_row.addWidget(btn_scan_file, 0)
        file_row.addWidget(btn_project_info, 0)
        root.addLayout(file_row)

        # Hash row
        hash_row = QHBoxLayout()
        self.hash_edit = QLineEdit()
        self.hash_edit.setPlaceholderText("SHA-256 hash (auto-filled after scan or calc)…")
        btn_copy_hash = QPushButton("📋 Copy Hash")
        btn_copy_hash.clicked.connect(self.copy_hash)
        hash_row.addWidget(QLabel("Hash:"))
        hash_row.addWidget(self.hash_edit, 1)
        hash_row.addWidget(btn_copy_hash)
        root.addLayout(hash_row)

        # Direct hash scan row
        hash_scan_row = QHBoxLayout()
        self.direct_hash_input = QLineEdit()
        self.direct_hash_input.setPlaceholderText("Enter SHA-256 hash to scan directly...")
        btn_direct_hash_scan = QPushButton("🔍 Scan Entered Hash")
        btn_direct_hash_scan.clicked.connect(self.on_direct_hash_scan)
        hash_scan_row.addWidget(QLabel("Direct Hash:"))
        hash_scan_row.addWidget(self.direct_hash_input, 1)
        hash_scan_row.addWidget(btn_direct_hash_scan)
        root.addLayout(hash_scan_row)

        # URL row
        url_row = QHBoxLayout()
        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("Enter URL to scan via VirusTotal…")
        btn_scan_url = QPushButton("🌐 Scan URL")
        btn_scan_url.clicked.connect(self.on_scan_url)
        url_row.addWidget(QLabel("URL:"))
        url_row.addWidget(self.url_edit, 1)
        url_row.addWidget(btn_scan_url)
        root.addLayout(url_row)

        # Progress row
        ctrl_row = QHBoxLayout()
        self.progress = QProgressBar()
        self.progress.setRange(0, 0)
        self.progress.setVisible(False)
        btn_clear = QPushButton("🧹 Clear")
        btn_clear.clicked.connect(self.clear_results)
        ctrl_row.addWidget(self.progress, 1)
        ctrl_row.addItem(QSpacerItem(10, 10, QSizePolicy.Expanding, QSizePolicy.Minimum))
        ctrl_row.addWidget(btn_clear, 0)
        root.addLayout(ctrl_row)

        # Results box
        self.results = QTextEdit()
        self.results.setReadOnly(True)
        self.results.setPlaceholderText("Results will appear here…")
        root.addWidget(self.results, 1)

        # Details button
        details_row = QHBoxLayout()
        self.btn_details = QPushButton("🧾 Open Detailed Result")
        self.btn_details.setEnabled(False)
        self.btn_details.clicked.connect(self.open_details_dialog)
        details_row.addItem(QSpacerItem(10, 10, QSizePolicy.Expanding, QSizePolicy.Minimum))
        details_row.addWidget(self.btn_details)
        root.addLayout(details_row)

        # Email input row (initially hidden)
        email_row = QHBoxLayout()
        self.email_label = QLabel("Send report to email:")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Enter recipient email address here...")
        self.email_send_btn = QPushButton("Send Email Report")
        self.email_send_btn.clicked.connect(self.on_send_email_clicked)
        email_row.addWidget(self.email_label)
        email_row.addWidget(self.email_input, 1)
        email_row.addWidget(self.email_send_btn)
        self.email_label.setVisible(False)
        self.email_input.setVisible(False)
        self.email_send_btn.setVisible(False)
        root.addLayout(email_row)

        # Inline message label for pop-up style messages
        self.message_label = QLabel("")
        self.message_label.setStyleSheet("color: white; font-weight: bold; padding: 6px;")
        root.addWidget(self.message_label)
        
        stack_layout.addLayout(root) # Add the main UI layout to the stack

        # Styling (dark theme)
        self.setStyleSheet("""
            QMainWindow {
                background-color: #0f172a;
                background-image: qradialgradient(
                    cx:0.6, cy:0.0, radius:1.1,
                    fx:0.6, fy:0.0,
                    stop:0 #23395D, stop:1 #0f172a
                ),
                qlineargradient(
                    x1:0, y1:1, x2:1, y2:0,
                    stop:0 #0e213a, stop:1 #12203a
                );
                background-repeat: no-repeat;
                background-position: top left;
            }
            QLabel, QLineEdit, QPushButton, QTextEdit { color: #e5e7eb; font-size: 14px; }
            QLineEdit, QTextEdit {
                background-color: #111827; border: 1px solid #374151; border-radius: 8px; padding: 8px;
                color: #e5e7eb;
            }
            QLabel { color: #e5e7eb; }
            QPushButton {
                background-color: #1f2937; border: 1px solid #374151; border-radius: 10px; padding: 8px 12px;
                font-size: 15px;
                font-weight: bold;
                letter-spacing: 0.5px;
            }
            QPushButton:hover { background-color: #374151; }
            QProgressBar {
                border: 1px solid #374151; border-radius: 6px; text-align: center;
                background: #111827;
            }
            QProgressBar::chunk { background-color: #4b5563; }
        """)

        self._last_payload = None
        self._last_title = "Details"

    # Project Info dialog show method
    def show_project_info(self):
        """Displays the project_info.html file in a new QWebEngineView window."""
        dialog = ProjectInfoDialog(self)
        dialog.exec_()
    
    # Inline pop-up style info message
    def show_info(self, title: str, msg: str):
        self.message_label.setStyleSheet("color: #a5f3fc; font-weight: bold; padding: 6px; background-color: #134e4a; border-radius: 4px;")
        self.message_label.setText(f"{title}: {msg}")

    # Inline pop-up style error message
    def show_error(self, title: str, msg: str):
        self.message_label.setStyleSheet("color: #fca5a5; font-weight: bold; padding: 6px; background-color: #7f1d1d; border-radius: 4px;")
        self.message_label.setText(f"{title}: {msg}")

    # Clear message label
    def clear_message(self):
        self.message_label.clear()

    def on_browse_file(self):
        self.clear_message()
        path, _ = QFileDialog.getOpenFileName(self, "Select File", "", "All Files (*)")
        if path:
            self.file_path_edit.setText(path)

    def on_scan_file(self):
        self.clear_message()
        path = self.file_path_edit.text().strip()
        if not path or not os.path.isfile(path):
            self.show_error("File Error", "Please choose a valid file to scan.")
            return
        def scan_file_worker(p):
            h = sha256_file(p)
            result = vt_check_hash(h)
            return {"hash": h, "summary": result}
        worker = Worker(scan_file_worker, path)
        worker.signals.success.connect(self._on_hash_lookup_success_auto)
        worker.signals.error.connect(lambda e: self.show_error("VirusTotal Error", e))
        worker.signals.done.connect(lambda: self.set_busy(False))
        self.set_busy(True)
        self.threadpool.start(worker)

    def on_hash_lookup(self):
        self.clear_message()
        digest = self.hash_edit.text().strip()
        path = self.file_path_edit.text().strip()
        if not digest:
            if not path or not os.path.isfile(path):
                self.show_error("Input Error", "Provide SHA-256 or select a valid file.")
                return
            def do_hash_then_lookup(p):
                h = sha256_file(p)
                res = vt_check_hash(h)
                return {"hash": h, "summary": res}
            worker = Worker(do_hash_then_lookup, path)
            worker.signals.success.connect(self._on_hash_lookup_success_auto)
        else:
            if len(digest) != 64 or not all(c in "0123456789abcdefABCDEF" for c in digest):
                self.show_error("Hash Error", "Invalid SHA-256 hex string.")
                return
            worker = Worker(vt_check_hash, digest)
            worker.signals.success.connect(self._on_hash_lookup_success_direct)
        worker.signals.error.connect(lambda e: self.show_error("VirusTotal Error", e))
        worker.signals.done.connect(lambda: self.set_busy(False))
        self.set_busy(True)
        self.threadpool.start(worker)

    def on_direct_hash_scan(self):
        self.clear_message()
        raw_hash = self.direct_hash_input.text().strip()
        if len(raw_hash) != 64 or not all(c in "0123456789abcdefABCDEF" for c in raw_hash):
            self.show_error("Hash Error", "Invalid SHA-256 hash. Please enter a 64-character hexadecimal string.")
            return
        worker = Worker(vt_check_hash, raw_hash)
        worker.signals.success.connect(self._on_hash_lookup_success_direct)
        worker.signals.error.connect(lambda e: self.show_error("VirusTotal Error", e))
        worker.signals.done.connect(lambda: self.set_busy(False))
        self.set_busy(True)
        self.threadpool.start(worker)

    def on_scan_url(self):
        self.clear_message()
        url = self.url_edit.text().strip()
        if not url:
            self.show_error("URL Required", "Please enter a URL to scan.")
            return
        worker = Worker(vt_scan_url, url)
        worker.signals.success.connect(self._render_summary)
        worker.signals.error.connect(lambda e: self.show_error("VirusTotal Error", e))
        worker.signals.done.connect(lambda: self.set_busy(False))
        self.set_busy(True)
        self.threadpool.start(worker)

    def set_busy(self, busy: bool):
        self.progress.setVisible(busy)
        for w in self.findChildren(QPushButton):
            w.setEnabled(not busy)

    def append_result(self, text: str):
        self.results.append(text)

    def clear_results(self):
        self.results.clear()
        self._last_payload = None
        self.btn_details.setEnabled(False)
        self.email_label.setVisible(False)
        self.email_input.setVisible(False)
        self.email_send_btn.setVisible(False)
        self.clear_message()

    def copy_hash(self):
        h = self.hash_edit.text().strip()
        if h:
            QApplication.clipboard().setText(h)
            self.show_info("Copied", "SHA-256 hash copied to clipboard.")
        else:
            self.show_error("No Hash", "There is no hash to copy.")

    def _on_hash_lookup_success_auto(self, payload: dict):
        h = payload.get("hash", "")
        summary = payload.get("summary", {})
        self.hash_edit.setText(h)
        self._render_summary(summary)

    def _on_hash_lookup_success_direct(self, summary: dict):
        self._render_summary(summary)

    def _render_summary(self, summary: dict):
        self._last_payload = summary
        self.btn_details.setEnabled(True)
        t = summary.get("type", "")
        verdict = summary.get("verdict", "❓")
        line_parts = [f"Verdict: {verdict}"]
        if t == "hash_lookup":
            h = summary.get("hash", "")
            found = summary.get("found", False)
            line_parts.append(f"Type: File Hash Lookup")
            line_parts.append(f"Hash: {h}")
            if not found:
                line_parts.append("Result: Not found on VirusTotal")
            stats = summary.get("stats", {})
            line_parts.append(f"Stats: {stats}")
            permalink = summary.get("permalink", "")
            if permalink:
                line_parts.append(f"Link: {permalink}")
            self._last_title = "Hash Lookup Result"
        elif t == "url_scan":
            u = summary.get("url", "")
            status = summary.get("status", "")
            stats = summary.get("stats", {})
            line_parts.append(f"Type: URL Scan")
            line_parts.append(f"URL: {u}")
            line_parts.append(f"Status: {status}")
            line_parts.append(f"Stats: {stats}")
            permalink = summary.get("permalink", "")
            if permalink:
                line_parts.append(f"Link: {permalink}")
            self._last_title = "URL Scan Result"
        else:
            self._last_title = "Result"
            line_parts.append(json.dumps(summary, indent=2))
        result_text = "\n".join(line_parts)
        self.append_result(result_text)
        self.append_result("-" * 60)

        # Show email input widgets after result
        self.email_label.setVisible(True)
        self.email_input.setVisible(True)
        self.email_send_btn.setVisible(True)
        self.email_input.clear()

    def on_send_email_clicked(self):
        email = self.email_input.text().strip()
        if not email:
            self.show_error("Input Error", "Please enter an email address.")
            return
        if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
            self.show_error("Invalid Email", "Please enter a valid email address.")
            return
        if not self._last_payload:
            self.show_error("No Report", "There is no scan report to send.")
            return
        try:
            report_text = json.dumps(self._last_payload, indent=2)
            send_report_email(email, report_text)
            self.show_info("Email Sent", f"Scan report sent to {email}")
        except Exception as e:
            self.show_error("Email Error", f"Failed to send email report:\n{e}")

    def open_details_dialog(self):
        if not self._last_payload:
            return
        dlg = DetailsDialog(self._last_title, self._last_payload, self)
        dlg.exec_()


# ---------------- App Entry ----------------
def main():
    if API_KEY == "1833d2e725ea6e79618ca67478eefbc6d7223f4ac99a683bd3ae9701cbe72330":
        print("⚠ Please set your VirusTotal API key in the script before running.", file=sys.stderr)
    app = QApplication(sys.argv)
    login = LoginDialog()
    if login.exec_() == QDialog.Accepted:
        user_info = login.get_user()
        if not user_info:
            print("Login failed.", file=sys.stderr)
            sys.exit(1)
        window = MalwareDetectionApp(user_info)
        window.show()
        sys.exit(app.exec_())
    else:
        print("User canceled login or failed to authenticate.", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()