#!/usr/bin/env python3
"""
MAIN.EXE Desktop Editor (Tkinter)

Features:
- Open a local EXE/BIN file
- Display & edit single-byte movement values at a configurable start offset
- Scan a region for null-separated CP949 (EUC-KR) strings and list them
- Edit strings in-place (new byte-length must be <= original)
- Backup original file automatically before saving changes
- Save patched file (as new file or overwrite after backup)

Notes:
- Requires Python 3.x on Windows (tested with 3.8+). Tkinter is included in standard Python.
- For a true standalone .exe, use PyInstaller:
    pyinstaller --onefile --noconsole --name MAIN_Editor main_gui_editor.py
  Then distribute the generated dist/MAIN_Editor.exe
- Always keep a manual backup of your original EXE before applying patches.

Author: Generated by ChatGPT (GPT-5 Thinking mini)
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
import codecs
from pathlib import Path

CHUNK_READ = 4 * 1024 * 1024

def read_file_bytes(path):
    with open(path, "rb") as f:
        return bytearray(f.read())

def write_file_bytes(path, data_bytes):
    with open(path, "wb") as f:
        f.write(data_bytes)

def safe_backup(path: Path):
    bak = path.with_suffix(path.suffix + ".bak")
    if not bak.exists():
        path.replace(bak)
        # copy back original so file path remains the same for editing
        bak_bytes = read_file_bytes(bak)
        write_file_bytes(path, bak_bytes)
    return bak

class MainApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("MAIN.EXE Desktop Editor")
        self.geometry("980x660")
        self.resizable(True, True)
        self.filepath = None
        self.data = None  # bytearray
        self.moves_start = 0x3BD2E
        self.moves_count = 20
        self.scan_start = 0x3BD3E
        self.scan_end = 0x3BD6E
        self.create_widgets()

    def create_widgets(self):
        frm = ttk.Frame(self, padding=8)
        frm.pack(fill=tk.BOTH, expand=True)

        # Top controls
        top = ttk.Frame(frm)
        top.pack(fill=tk.X)

        btn_open = ttk.Button(top, text="Open EXE/BIN", command=self.open_file)
        btn_open.pack(side=tk.LEFT, padx=4)

        self.lbl_file = ttk.Label(top, text="No file loaded", foreground="gray")
        self.lbl_file.pack(side=tk.LEFT, padx=8)

        btn_save = ttk.Button(top, text="Save Patched File...", command=self.save_patched)
        btn_save.pack(side=tk.RIGHT, padx=4)

        btn_backup = ttk.Button(top, text="Create Backup", command=self.create_backup)
        btn_backup.pack(side=tk.RIGHT, padx=4)

        # Split panes
        pan = ttk.Panedwindow(frm, orient=tk.HORIZONTAL)
        pan.pack(fill=tk.BOTH, expand=True, pady=8)

        # Left: Movement editor
        left = ttk.Labelframe(pan, text="Movement Editor", width=420)
        pan.add(left, weight=1)

        controls = ttk.Frame(left)
        controls.pack(fill=tk.X, padx=6, pady=6)

        ttk.Label(controls, text="Start (hex/dec)").grid(row=0, column=0, sticky=tk.W)
        self.ent_moves_start = ttk.Entry(controls, width=12)
        self.ent_moves_start.insert(0, hex(self.moves_start))
        self.ent_moves_start.grid(row=0, column=1, padx=4)

        ttk.Label(controls, text="Count").grid(row=0, column=2, sticky=tk.W, padx=(8,0))
        self.spin_moves_count = ttk.Spinbox(controls, from_=1, to=200, width=6)
        self.spin_moves_count.set(str(self.moves_count))
        self.spin_moves_count.grid(row=0, column=3, padx=4)

        ttk.Button(controls, text="Load Moves", command=self.load_moves).grid(row=0, column=4, padx=8)

        # Treeview for moves
        cols = ("idx","offset","hex","dec","edit")
        self.tv_moves = ttk.Treeview(left, columns=cols, show="headings", selectmode="browse", height=18)
        for c, w in zip(cols, (40,120,80,60,120)):
            self.tv_moves.heading(c, text=c)
            self.tv_moves.column(c, width=w, anchor=tk.W)
        self.tv_moves.pack(fill=tk.BOTH, expand=True, padx=6, pady=(0,6))

        self.tv_moves.bind("<Double-1>", self.on_edit_move)

        # Right: String scanner/editor
        right = ttk.Labelframe(pan, text="String Table Scanner / Editor", width=520)
        pan.add(right, weight=2)

        scontrols = ttk.Frame(right)
        scontrols.pack(fill=tk.X, padx=6, pady=6)

        ttk.Label(scontrols, text="Start").grid(row=0, column=0, sticky=tk.W)
        self.ent_scan_start = ttk.Entry(scontrols, width=12)
        self.ent_scan_start.insert(0, hex(self.scan_start))
        self.ent_scan_start.grid(row=0, column=1, padx=4)

        ttk.Label(scontrols, text="End").grid(row=0, column=2, sticky=tk.W, padx=(8,0))
        self.ent_scan_end = ttk.Entry(scontrols, width=12)
        self.ent_scan_end.insert(0, hex(self.scan_end))
        self.ent_scan_end.grid(row=0, column=3, padx=4)

        ttk.Button(scontrols, text="Scan Strings", command=self.scan_strings).grid(row=0, column=4, padx=8)

        # Treeview for strings
        scols = ("idx","offset","text","bytes")
        self.tv_strings = ttk.Treeview(right, columns=scols, show="headings", selectmode="browse", height=18)
        for c, w in zip(scols, (40,120,260,80)):
            self.tv_strings.heading(c, text=c)
            self.tv_strings.column(c, width=w, anchor=tk.W)
        self.tv_strings.pack(fill=tk.BOTH, expand=True, padx=6, pady=(0,6))

        # Buttons below strings
        sbtns = ttk.Frame(right)
        sbtns.pack(fill=tk.X, padx=6, pady=(0,6))
        ttk.Button(sbtns, text="Edit Selected String (in-place)", command=self.on_edit_string).pack(side=tk.LEFT, padx=2)
        ttk.Button(sbtns, text="Export Strings CSV...", command=self.export_csv).pack(side=tk.LEFT, padx=2)
        ttk.Button(sbtns, text="Import CSV and Write (in-place only)", command=self.import_csv).pack(side=tk.LEFT, padx=2)

        # Status box
        self.status = tk.Text(frm, height=4, wrap=tk.WORD)
        self.status.pack(fill=tk.X, padx=6, pady=(0,6))
        self.log("Ready. Open a MAIN.EXE or other binary to begin.")

    def log(self, msg):
        self.status.insert(tk.END, msg + "\n")
        self.status.see(tk.END)

    def open_file(self):
        path = filedialog.askopenfilename(filetypes=[("EXE/BIN","*.exe;*.bin"),("All files","*.*")])
        if not path:
            return
        self.filepath = Path(path)
        try:
            self.data = read_file_bytes(self.filepath)
        except Exception as e:
            messagebox.showerror("Error", f"Could not read file: {e}")
            return
        self.lbl_file.config(text=f"Loaded: {self.filepath.name} ({len(self.data)} bytes)")
        self.log(f"Loaded {self.filepath} ({len(self.data)} bytes)")
        # refresh displays
        self.load_moves()
        self.scan_strings()

    def create_backup(self):
        if not self.filepath:
            messagebox.showinfo("Info", "No file loaded")
            return
        bak = safe_backup(self.filepath)
        messagebox.showinfo("Backup", f"Backup created: {bak}")
        self.log(f"Backup created at {bak}")

    def save_patched(self):
        if not self.data:
            messagebox.showinfo("Info", "No data to save")
            return
        # ask for save path
        path = filedialog.asksaveasfilename(defaultextension=".exe", initialfile=self.filepath.name.replace(".exe","_patched.exe") if self.filepath else "patched.exe", filetypes=[("EXE","*.exe"),("All files","*.*")])
        if not path:
            return
        try:
            write_file_bytes(Path(path), self.data)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to write file: {e}")
            return
        messagebox.showinfo("Saved", f"Patched file saved to: {path}")
        self.log(f"Patched file saved to {path}")

    def load_moves(self):
        if not self.data:
            messagebox.showinfo("Info", "No file loaded")
            return
        # parse start and count
        try:
            s = self.ent_moves_start.get().strip()
            start = int(s, 16) if s.lower().startswith("0x") else int(s, 10)
        except:
            messagebox.showerror("Error", "Invalid start offset")
            return
        try:
            cnt = int(self.spin_moves_count.get())
        except:
            cnt = 20
        self.moves_start = start
        self.moves_count = cnt
        self.tv_moves.delete(*self.tv_moves.get_children())
        for i in range(cnt):
            off = start + i
            if off >= len(self.data):
                break
            val = self.data[off]
            self.tv_moves.insert("", "end", values=(i, f"0x{off:06X}", f"0x{val:02X}", val, "double-click to edit"))
        self.log(f"Loaded {i+1} movement entries from 0x{start:X}")

    def on_edit_move(self, event):
        sel = self.tv_moves.selection()
        if not sel:
            return
        item = self.tv_moves.item(sel[0])
        vals = item["values"]
        idx = int(vals[0])
        off_text = vals[1]
        off = int(off_text, 16)
        old = self.data[off]
        new = simpledialog.askinteger("Edit Move", f"Offset {off_text}\\nCurrent value: {old}\\nEnter new value (0-255):", minvalue=0, maxvalue=255)
        if new is None:
            return
        self.data[off] = new
        self.load_moves()
        self.log(f"Updated offset 0x{off:X} => {new}")

    def scan_strings(self):
        if not self.data:
            messagebox.showinfo("Info", "No file loaded")
            return
        try:
            s = self.ent_scan_start.get().strip()
            e = self.ent_scan_end.get().strip()
            start = int(s, 16) if s.lower().startswith("0x") else int(s, 10)
            end = int(e, 16) if e.lower().startswith("0x") else int(e, 10)
        except Exception as ex:
            messagebox.showerror("Error", f"Bad offsets: {ex}")
            return
        if start < 0 or end <= start or end > len(self.data):
            messagebox.showerror("Error", "Invalid scan range")
            return
        self.scan_start = start
        self.scan_end = end
        region = self.data[start:end]
        parts = []
        cur = bytearray()
        offsets = []
        for i, b in enumerate(region):
            if b == 0x00:
                if cur:
                    offsets.append(start + i - len(cur))
                    parts.append(bytes(cur))
                    cur = bytearray()
            else:
                cur.append(b)
        if cur:
            offsets.append(start + len(region) - len(cur))
            parts.append(bytes(cur))
        # decode with cp949
        self.tv_strings.delete(*self.tv_strings.get_children())
        for idx, (off, part) in enumerate(zip(offsets, parts)):
            try:
                text = part.decode("cp949")
            except Exception:
                # show a fallback
                try:
                    text = part.decode("latin1")
                except:
                    text = "<undecodable>"
            self.tv_strings.insert("", "end", values=(idx, f"0x{off:06X}", text, len(part)))
        self.log(f"Scanned strings in region 0x{start:X}-0x{end:X}; found {len(parts)} items")

    def get_selected_string(self):
        sel = self.tv_strings.selection()
        if not sel:
            messagebox.showinfo("Info", "No string selected")
            return None
        item = self.tv_strings.item(sel[0])
        idx = int(item["values"][0])
        offset_text = item["values"][1]
        offset = int(offset_text, 16)
        text = item["values"][2]
        length = int(item["values"][3])
        return {"idx": idx, "offset": offset, "text": text, "length": length}

    def on_edit_string(self):
        rec = self.get_selected_string()
        if not rec:
            return
        new = simpledialog.askstring("Edit String (in-place)", f"Offset 0x{rec['offset']:X} (max {rec['length']} bytes)\\nCurrent: {rec['text']}\\nEnter new text (CP949):", initialvalue=rec['text'])
        if new is None:
            return
        # encode to cp949
        try:
            newb = new.encode("cp949")
        except Exception as e:
            messagebox.showerror("Encode Error", f"Failed to encode to CP949: {e}")
            return
        if len(newb) > rec["length"]:
            messagebox.showerror("Too long", f"New text encodes to {len(newb)} bytes which is longer than original {rec['length']} bytes. In-place edit not allowed.")
            return
        # write in-place
        off = rec["offset"]
        self.data[off:off+len(newb)] = newb
        # pad remainder with 0x00
        if len(newb) < rec["length"]:
            self.data[off+len(newb):off+rec["length"]] = b'\\x00' * (rec["length"] - len(newb))
        self.scan_strings()
        self.log(f"String at 0x{off:X} updated to '{new}'")

    def export_csv(self):
        if not self.data:
            messagebox.showinfo("Info", "No file loaded")
            return
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV","*.csv")])
        if not path:
            return
        # export current scanned strings
        rows = []
        for iid in self.tv_strings.get_children():
            vals = self.tv_strings.item(iid)["values"]
            rows.append(vals)
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write("idx,offset,text,bytes\\n")
                for r in rows:
                    f.write(f"{r[0]},{r[1]},{r[2].replace(',', '，')},{r[3]}\\n")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to write CSV: {e}")
            return
        messagebox.showinfo("Exported", f"CSV exported to {path}")
        self.log(f"Exported {len(rows)} strings to {path}")

    def import_csv(self):
        if not self.data:
            messagebox.showinfo("Info", "No file loaded")
            return
        path = filedialog.askopenfilename(filetypes=[("CSV","*.csv"),("All files","*.*")])
        if not path:
            return
        # CSV expected format: idx,offset,text,bytes (UTF-8)
        try:
            with open(path, "r", encoding="utf-8") as f:
                lines = f.read().splitlines()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read CSV: {e}")
            return
        changed = 0
        for line in lines[1:]:
            if not line.strip(): continue
            parts = line.split(",", 3)
            if len(parts) < 4: continue
            idx, offset_text, text, length_s = parts
            offset = int(offset_text, 16) if offset_text.strip().lower().startswith("0x") else int(offset_text)
            length = int(length_s)
            try:
                newb = text.encode("cp949")
            except Exception as e:
                self.log(f"Skipping idx {idx}: encode error {e}")
                continue
            if len(newb) > length:
                self.log(f"Skipping idx {idx} at 0x{offset:X}: encoded too long ({len(newb)} > {length})")
                continue
            # write in-place
            self.data[offset:offset+len(newb)] = newb
            if len(newb) < length:
                self.data[offset+len(newb):offset+length] = b'\\x00' * (length - len(newb))
            changed += 1
        self.scan_strings()
        messagebox.showinfo("Import complete", f"Wrote {changed} entries (in-place)")
        self.log(f"Imported CSV and wrote {changed} entries in-place")

if __name__ == "__main__":
    app = MainApp()
    app.mainloop()
