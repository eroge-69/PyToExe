import os
import re
import argparse
import sys
from collections import defaultdict

def main():
    parser = argparse.ArgumentParser(description="Generates a merged mod from several mod folders (manual order, grouped by folder)")
    parser.add_argument("-r", "--root", type=str, default=".", help="Location to use to create mod")
    parser.add_argument("-d", "--delete", action="store_true", help="run the script in delete mode")
    parser.add_argument("-v", "--vanilla", action="store_true", help="exclude vanilla outfit as a part of the mod")
    parser.add_argument("-e", "--enable", action="store_true", help="Delete disabled .ini files that were created")
    parser.add_argument("-f", "--renable", action="store_true", help="Re-enable disabled .ini files")
    parser.add_argument("-n", "--name", type=str, default="master.ini", help="(not functional)")
    args = parser.parse_args()

    # Always enable as if -e was passed
    args.enable = True

    if args.delete:
        delete_main(args.root)
        return

    print("\\Wuthering Waves Mod Merger/Toggle Script Utilizing Namespaces By Exomata (Manual Merge, Grouped)\n")

    print("\nSearching for .ini files")
    ini_files, group_names = collect_ini(args.root, args.name)

    if args.enable:
        print("Re-enabling all .ini files")
        enabled_files = enable_ini(args.root, delete_disabled=args.enable)
        print("Enabled .ini files:")
        for file in enabled_files:
            print(f"\t{file}")
        print()

    if args.renable:
        print("Re-enabling old .ini files")
        renable_ini(args.root)
        print()

    if not ini_files:
        print("Found no .ini files - make sure the mod folders are in the same folder as this script.")
        return

    print("\nThis script will merge using the order listed below (grouped by folder):")
    for idx, group in enumerate(ini_files):
        print(f"{idx}: {group_names[idx]}")
        for f in group:
            print(f"    {f}")
    print("If this is fine, please press ENTER. If not, please enter the order you want the script to merge the mods (example: 0 1 2 (3 4 5) 6)")
    if args.vanilla:
        print("The vanilla outfit will be removed at the end. It is safe to press enter or select an order.")
    ini_files = get_user_order(ini_files)
    if args.vanilla and ini_files[0] == None:
        ini_files.pop(0)

    print("\nPlease enter the name of the object this merged mod is for (no spaces)\n")
    name = input()
    while not name:
        print("\nPlease enter a name\n")
        name = input()

    # Use fixed keys as per your request
    key = "/"
    back = "."

    print("Generating backups")
    flat_ini_files = flatten_list(ini_files)
    generate_backup(flat_ini_files)

    # Check for existing Master.ini files and merge their contents
    existing_master_ini = None
    for file in flat_ini_files:
        if file is None:
            continue
        if "Master" in os.path.basename(file):
            existing_master_ini = file
            break

    if existing_master_ini:
        print(f"Found existing Master.ini file: {existing_master_ini}")
        with open(existing_master_ini, 'r', encoding="utf-8", errors='replace') as f:
            existing_content = f.read()
        # Extract constants and overrides from the existing Master.ini
        constants = re.search(r"; Constants ---------------------------\n(.*?); Overrides ---------------------------", existing_content, re.DOTALL)
        overrides = re.search(r"; Overrides ---------------------------\n(.*?); .ini generated by", existing_content, re.DOTALL)
        if constants:
            constants = constants.group(1).strip()
        else:
            constants = ""
        if overrides:
            overrides = overrides.group(1).strip()
        else:
            overrides = ""
    else:
        constants = f"namespace = {name}\\Master\n; Constants ---------------------------\n\n"
        overrides = "; Overrides ---------------------------\n\n"

    # Use a unique swapvar and KeySwap section for this character/object
    swapvar = "swapvar"
    if not existing_master_ini:
        swapvar_list = ",".join([str(x+1) for x in range(len(ini_files))])
        constants += f"[Constants]\nglobal persist ${swapvar} = 0\n"
        constants += f"global $active\n"
        constants += "global $creditinfo = 0\n"
        constants += f"\n[KeySwap]\n"
        constants += f"condition = $active == 1\n"
        constants += f"key = {key}\nback = {back}\ntype = cycle\n"
        constants += f"${swapvar} = {swapvar_list}\n"
        constants += f"$creditinfo = 0\n\n"
        constants += f"[Present]\n"
        constants += f"post $active = 0\n"

    # [TextureOverride{name}Position] section
    overrides += f"[TextureOverride{name}Position]\n"
    hash_lines = []
    for ini_group in ini_files:
        if isinstance(ini_group, list):
            for file in ini_group:
                if file is not None:
                    temp_hashes = get_position_hash(str(file))
                    if temp_hashes:
                        hash_lines.extend(temp_hashes)
        else:
            if ini_group is not None:
                temp_hashes = get_position_hash(str(ini_group))
                if temp_hashes:
                    hash_lines.extend(temp_hashes)

    # Remove duplicates while preserving order
    seen = set()
    unique_hash_lines = []
    for h in hash_lines:
        if h not in seen:
            unique_hash_lines.append(h)
            seen.add(h)

    if unique_hash_lines:
        overrides += ''.join(unique_hash_lines)
    overrides += "$active = 1\n"

    print("Modifying inis...")
    # For each top-level item (group or single), assign the same swapvar index to all files in the group
    for idx, ini_item in enumerate(ini_files):
        swapvar_index = idx + 1  # 1-based
        if isinstance(ini_item, list):
            for file in ini_item:
                if file is not None:
                    edit_ini(str(file), name, swapvar, swapvar_index)
        else:
            if ini_item is not None:
                edit_ini(str(ini_item), name, swapvar, swapvar_index)

    try:
        flat_ini_files.remove(None)
    except ValueError:
        print()

    # Use absolute paths in the header
    abs_paths = [os.path.abspath(x) for x in flat_ini_files if x is not None]
    print("Printing results")
    result = f"; Merged Mods: {', '.join(abs_paths)}\n\n"
    result += constants
    result += overrides
    result += "\n\n"
    result += "; .ini file generated by WWMI merge script, using namespace by SilentNightSound and Qwerty3Yuiop Edited For WWMI By Exomata\n"
    result += "; If you have any issues or encounter any bugs, please contact me (Discord: xxexomataxx)\n"

    with open(f"Master{name}.ini", "w", encoding="utf-8", errors='replace') as f:
        f.write(result)

    print("All operations completed")

def delete_main(root):
    print("\nNamespace Merged Mod Unmerger\n")
    print("\nTHIS SCRIPT WILL DELETE FILES FROM YOUR DEVICE USE WITH CAUTION AND MAKE BACKUPS")
    print("press enter to proceed or enter anything else to exit")
    userin = input()
    if userin != "":
        print("exiting")
        return

    print("\nSearching for paths containing active inis")
    ini_paths, _ = collect_ini(root, "none")
    if not ini_paths:
        print("Found no .ini files - make sure the mod folders are in the same folder as this script.")
        return

    print("\nFound:")
    for i, ini_file in enumerate(ini_paths):
        print(f"\t{i}:  {ini_file}")
    print("All inis displayed above will be deleted and their backups will be restored")
    print("Press enter to proceed with the delete or enter a number to remove a file from the deletion list.")
    print("ONLY ENTER ONE NUMBER! you will be able to remove other paths from the deletion list")
    userin = input()
    while userin != "":
        try:
            ini_paths.pop(int(userin))
            print(f"\nremoved path number {userin}")
        except:
            print(f"\nUnable to remove {userin} from deletion list")
        finally:
            print("Current Deletion List:")
            for i, ini_file in enumerate(ini_paths):
                print(f"\t{i}:  {ini_file}")
        print("Press enter to proceed with the delete or enter a number to remove a file from the deletion list.")
        print("ONLY ENTER ONE NUMBER! you will be able to remove other paths from the deletion list")
        userin = input()
    try:
        for file in ini_paths:
            os.remove(str(file))
            try:
                rename_file(file)
            except:
                print(f"No back up file found for {file}")
        
        print("All operations completed")
    except:
        print("something went wrong")

def collect_ini(path, ignore):
    """
    Returns:
        ini_groups: list of lists, each sublist is a group of .ini files in the same top-level folder
        group_names: list of group names (folder names)
    """
    ini_files = defaultdict(list)
    group_names = []
    for root, dirs, files in os.walk(path):
        # Find the group folder: the first folder under the root path
        rel = os.path.relpath(root, path)
        if rel == ".":
            continue  # skip the root itself
        group_folder = rel.split(os.sep)[0]
        
        # Ignore folders that start with "DISABLED" at any level
        if any(part.lower().startswith("disabled") for part in rel.split(os.sep)):
            continue
        
        for file in files:
            # Ignore .ini files that start with "DISABLED"
            if file.lower().startswith("disabled") or ignore.lower() in file.lower():
                continue
            if os.path.splitext(file)[1] == ".ini":
                ini_files[group_folder].append(os.path.join(root, file))
    # Prepare output
    ini_groups = []
    group_names = []
    for group, files in ini_files.items():
        ini_groups.append(files)
        group_names.append(group)
    return ini_groups, group_names

def enable_ini(path, delete_disabled=False):
    enabled_files = []
    for root, dirs, files in os.walk(path):
        for file in files:
            if os.path.splitext(file)[1] == ".ini" and "disabled" in file.lower():
                # Skip files containing "_backup" or "backup" in their names
                if "_backup" in file.lower() or "backup" in file.lower():
                    continue
                regular_file = file.lower().replace("disabled", "")
                regular_path = os.path.join(root, regular_file)
                disabled_path = os.path.join(root, file)

                if os.path.exists(regular_path):
                    print(f"\tDeleting {regular_path}")
                    os.remove(regular_path)

                    print(f"\tRe-enabling {disabled_path}")
                    os.rename(disabled_path, regular_path)
                    enabled_files.append(regular_path)  # Collect enabled files

    print("Disabled .ini files re-enabled.")
    return enabled_files  # Return the list of enabled files

def renable_ini(path):
    for root, dirs, files in os.walk(path):
        for file in files:
            if os.path.splitext(file)[1] == ".ini" and ("disabled" in root.lower() or "disabled" in file.lower()):
                # Skip files containing "_backup" or "backup" in their names
                if "_backup" in file.lower() or "backup" in file.lower():
                    continue
                print(f"\tRe-enabling {os.path.join(root, file)}")
                new_path = re.compile("disabled", re.IGNORECASE).sub("", os.path.join(root, file))
                os.rename(os.path.join(root, file), new_path)
            
    print("Old Merge Script Disabled .ini files re-enabled.")
    sys.exit()

def get_user_order(ini_files):
    choice = input()
    if not choice:
        return ini_files

    # Parse groups enclosed in parentheses
    groups = re.findall(r"\((.*?)\)", choice)
    for group in groups:
        choice = choice.replace(f"({group})", "").strip()

    # Split the remaining choices
    choices = choice.split()
    result = []

    for item in choices:
        if item.isdigit():
            index = int(item)
            if 0 <= index < len(ini_files):
                result.append(ini_files[index])
            else:
                print(f"\nERROR: Index {index} is out of range. Skipping.")
        else:
            print(f"\nERROR: Invalid input '{item}'. Skipping.")

    # Add grouped mods
    for group in groups:
        group_indices = group.split()
        group_mods = []
        for index in group_indices:
            if index.isdigit():
                index = int(index)
                if 0 <= index < len(ini_files):
                    group_mods.append(ini_files[index])
                else:
                    print(f"\nERROR: Index {index} in group is out of range. Skipping.")
            else:
                print(f"\nERROR: Invalid input '{index}' in group. Skipping.")
        if group_mods:
            # flatten the group
            group_flat = []
            for g in group_mods:
                if isinstance(g, list):
                    group_flat.extend(g)
                else:
                    group_flat.append(g)
            result.append(group_flat)

    return result

def flatten_list(nested_list):
    """Flatten a nested list into a single list."""
    flat_list = []
    for item in nested_list:
        if isinstance(item, list):
            flat_list.extend(flatten_list(item))
        else:
            flat_list.append(item)
    return flat_list

def edit_ini(path, name, swapvar, num):  # Added swapvar parameter
    with open(path, "r", encoding="utf-8", errors="replace") as file:
        lines = file.readlines()

    new_lines = []
    i = 0
    while i < len(lines):
        line = lines[i]
        # Look for a hash line that starts a block to be wrapped
        if line.strip().lower().startswith("hash = ") or line.strip().lower().startswith("hash="):
            # Store position to check for existing match_priority
            current_i = i
            original_match_priority_line = None
            
            # Search ahead for existing match_priority before inserting
            temp_i = current_i + 1
            while temp_i < len(lines) and not lines[temp_i].strip().startswith("["):
                if re.match(r"^\s*match_priority\s*=\s*(-?\d+)", lines[temp_i], re.IGNORECASE):
                    original_match_priority_line = lines[temp_i]
                    break
                temp_i += 1

            # Write the hash line
            new_lines.append(line.rstrip() + "\n")
            
            # Insert match_priority only if it was originally present
            if original_match_priority_line:
                new_lines.append(original_match_priority_line.rstrip() + "\n") # Re-add the original line

            # The if condition still uses `num` (required for cycling logic)
            new_lines.append(f"if $\\{name}\\Master\\{swapvar}=={num}\n")

            # Skip any existing match_priority/if/endif lines
            i += 1
            while i < len(lines) and (
                lines[i].strip().lower().startswith("match_priority")
                or lines[i].strip().startswith("if $\\")
                or lines[i].strip().startswith("endif")
            ):
                i += 1

            # Indent the rest of the block
            while i < len(lines) and not lines[i].startswith("["):
                if lines[i].strip() == "" and (i + 1 >= len(lines) or lines[i + 1].startswith("[")):
                    i += 1
                    continue
                new_lines.append("\t" + lines[i])
                i += 1
            new_lines.append("endif\n\n")
            continue  # Skip the increment at end
        else:
            new_lines.append(line)
        i += 1

    with open(path, "w", encoding="utf-8", errors="replace") as file:
        file.writelines(new_lines)

def generate_backup(file_list):
    for file_path in file_list:
        if file_path is not None and os.path.exists(file_path):
            dir_name = os.path.dirname(file_path)
            base_name = os.path.basename(file_path)
            new_file_path = os.path.join(dir_name, 'DISABLED' + base_name)
            # Ensure the directory exists before writing the backup file
            os.makedirs(dir_name, exist_ok=True)
            with open(file_path, 'r', encoding="utf-8", errors='replace') as original_file, open(new_file_path, 'w', encoding="utf-8", errors='replace') as new_file:
                new_file.write(original_file.read())
        else:
            print(f"File not found, skipping backup: {file_path}")

def get_position_hash(path):
    with open(path, 'r', encoding="utf-8", errors='replace') as file:
        lines = file.readlines()
    hashes = []
    i = 0
    while i < len(lines):
        line = lines[i]
        # Look for the start of a [TextureOverrideComponent0] section
        if line.strip() == '[TextureOverrideComponent0]':
            i += 1
            # Scan until next section or end of file
            while i < len(lines) and not lines[i].startswith('['):
                hash_line = lines[i].strip()
                if hash_line.lower().startswith('hash =') or hash_line.lower().startswith('hash='):
                    hashes.append(lines[i])
                    break  # Only the first hash in this section
                i += 1
        else:
            i += 1
    return hashes

def rename_file(file_path):
    if file_path is not None:
        dir_name = os.path.dirname(file_path)
        base_name = os.path.basename(file_path)
        src = os.path.join(dir_name, 'DISABLED' + base_name)
        dst = os.path.join(dir_name, base_name)
        if os.path.exists(src):
            os.rename(src, dst)
        else:
            print(f"No backup file found for {file_path}")

if __name__ == "__main__":
    main()
