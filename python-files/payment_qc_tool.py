"""
Payment Screening Quality Control (QC) Tool
========================================================

This script provides a simple way to select a random sample of
payment transactions for quality control or audit purposes.  It
demonstrates how to load data from a CSV file (or generate a sample
dataset), filter the data based on user‑specified criteria and
return a random subset of records.  The tool can be run either
interactively from the command line or through a Streamlit web
interface.  All code is heavily commented to make it accessible to
new programmers.

Key features:
  * Generates a dummy dataset if no CSV file is found.  This allows
    the tool to be demonstrated without needing any real data.  The
    generated data includes transaction numbers, message IDs,
    payment types, person IDs, amounts and dates.
  * Filters records by transaction number, message ID, payment type
    and person ID.  Each filter is optional – simply leave the
    prompt blank to ignore that field.
  * Randomly selects a user‑specified number of records (default
    five) from the filtered dataset.  Sampling uses a fixed seed
    when run from the command line so that results are reproducible.
  * Presents results either in the terminal (CLI mode) or in a
    browser window using Streamlit (Web UI mode).  The Streamlit
    version includes widgets for input and the ability to download
    the sample as a CSV file.

Usage:
  1. Place your payment data in a CSV file named ``payment_data.csv``
     in the same directory as this script.  The CSV file should
     include at least the following columns: ``transaction_number``,
     ``message_id``, ``payment_type``, ``person_id``, ``amount`` and
     ``date``.  If the file does not exist the script will create
     a synthetic dataset for you.
  2. Run the script via the command line:

         python payment_qc_tool.py

     Follow the prompts to enter your selection criteria and view
     the resulting table.
  3. Alternatively, to use the Streamlit interface you can run:

         streamlit run payment_qc_tool.py

     This will launch a local web page where you can select
     criteria using widgets and view/export the results.  Note that
     Streamlit must be installed in your environment for the web
     interface to work.

Security considerations:
  * No external network connections are made.  All data is loaded
    locally and only standard Python libraries (pandas, numpy) and
    Streamlit are used.
  * Sensitive data (e.g. names or account numbers) should never be
    included in the dummy dataset.  If you plug in your own data,
    ensure that it conforms to your organisation's security and
    compliance policies.

Author: Generated by ChatGPT for demonstration purposes.
Date: 31 July 2025
"""

import os
import sys
from datetime import datetime, timedelta
from typing import Iterable, List, Optional

import numpy as np
import pandas as pd


def generate_sample_data(num_records: int = 100) -> pd.DataFrame:
    """Generate a synthetic payment dataset.

    Each record contains:
      - transaction_number: an identifier like 'TX0001'
      - message_id: an identifier like 'MSG0001'
      - payment_type: one of several common payment types
      - person_id: an identifier for the person associated with the payment
      - amount: a random monetary value between 10 and 10,000
      - date: a random date within the last 365 days

    Args:
        num_records: Number of records to generate.

    Returns:
        pandas DataFrame with the synthetic dataset.
    """
    np.random.seed(42)  # For reproducibility
    payment_types = ["Wire Transfer", "Credit Card", "ACH", "PayPal"]
    person_ids = [f"PID{i:03d}" for i in range(1, 21)]  # 20 distinct persons

    # Generate sequential identifiers
    transaction_numbers = [f"TX{i:05d}" for i in range(1, num_records + 1)]
    message_ids = [f"MSG{i:05d}" for i in range(1, num_records + 1)]

    # Random selections
    types = np.random.choice(payment_types, size=num_records)
    persons = np.random.choice(person_ids, size=num_records)
    amounts = np.round(np.random.uniform(10, 10000, size=num_records), 2)

    # Generate random dates within the last year
    today = datetime.today()
    dates = [today - timedelta(days=int(x)) for x in np.random.uniform(0, 365, num_records)]

    data = {
        "transaction_number": transaction_numbers,
        "message_id": message_ids,
        "payment_type": types,
        "person_id": persons,
        "amount": amounts,
        "date": [d.strftime("%Y-%m-%d") for d in dates],
    }
    return pd.DataFrame(data)


def load_data(csv_path: str = "payment_data.csv", create_if_missing: bool = True) -> pd.DataFrame:
    """Load payment data from a CSV file or create sample data.

    Args:
        csv_path: Path to the CSV file to load.
        create_if_missing: If True and the file does not exist, a synthetic
            dataset is created and written to ``csv_path`` for reuse.

    Returns:
        pandas DataFrame containing the data.
    """
    if os.path.exists(csv_path):
        try:
            df = pd.read_csv(csv_path)
            # Basic validation: ensure required columns are present
            required_cols = {"transaction_number", "message_id", "payment_type", "person_id", "amount", "date"}
            missing = required_cols - set(df.columns)
            if missing:
                raise ValueError(f"CSV file is missing required columns: {missing}")
            return df
        except Exception as exc:
            print(f"Error loading CSV file: {exc}")
            if not create_if_missing:
                raise
    # If file is missing or invalid and creation is allowed, generate sample data
    df = generate_sample_data()
    if create_if_missing:
        # Save the generated data for later use
        df.to_csv(csv_path, index=False)
        print(f"Generated sample dataset saved to {csv_path}")
    return df


def filter_data(
    df: pd.DataFrame,
    transaction_numbers: Optional[List[str]] = None,
    message_ids: Optional[List[str]] = None,
    payment_types: Optional[List[str]] = None,
    person_ids: Optional[List[str]] = None,
) -> pd.DataFrame:
    """Filter the dataset based on optional criteria.

    Each argument may be a list of values to match.  If an argument is None
    or an empty list, it is ignored.  Matching is case‑insensitive for
    string fields.

    Args:
        df: The input DataFrame.
        transaction_numbers: List of transaction numbers to include.
        message_ids: List of message IDs to include.
        payment_types: List of payment types to include.
        person_ids: List of person IDs to include.

    Returns:
        Filtered DataFrame.
    """
    filtered = df.copy()
    if transaction_numbers:
        tn_lower = {x.lower() for x in transaction_numbers}
        filtered = filtered[filtered["transaction_number"].str.lower().isin(tn_lower)]
    if message_ids:
        mi_lower = {x.lower() for x in message_ids}
        filtered = filtered[filtered["message_id"].str.lower().isin(mi_lower)]
    if payment_types:
        pt_lower = {x.lower() for x in payment_types}
        filtered = filtered[filtered["payment_type"].str.lower().isin(pt_lower)]
    if person_ids:
        pid_lower = {x.lower() for x in person_ids}
        filtered = filtered[filtered["person_id"].str.lower().isin(pid_lower)]
    return filtered


def random_sample(df: pd.DataFrame, sample_size: int = 5, seed: Optional[int] = None) -> pd.DataFrame:
    """Return a random sample from the DataFrame.

    Args:
        df: DataFrame to sample from.
        sample_size: Number of rows to select.  If ``sample_size`` exceeds
            the number of rows, all rows are returned in random order.
        seed: Optional random seed for reproducibility.

    Returns:
        Sampled DataFrame.
    """
    if seed is not None:
        np.random.seed(seed)
    if sample_size >= len(df):
        # Return all rows in random order
        return df.sample(frac=1).reset_index(drop=True)
    else:
        return df.sample(n=sample_size).reset_index(drop=True)


def parse_input_list(user_input: str) -> Optional[List[str]]:
    """Parse a comma‑separated input string into a list of strings.

    Leading/trailing whitespace is stripped and empty inputs return None.

    Args:
        user_input: Raw input string from the user.

    Returns:
        List of values or None if input is blank.
    """
    if not user_input:
        return None
    # Split on commas and strip whitespace
    items = [item.strip() for item in user_input.split(",") if item.strip()]
    return items if items else None


def cli_mode():
    """Run the QC tool in command‑line (CLI) mode."""
    df = load_data()
    print("Payment Screening QC Tool (CLI Mode)")
    print("If you leave a field blank, it will not be used for filtering.")
    tn_input = input("Enter transaction number(s) (comma separated) or press Enter to skip: ")
    mi_input = input("Enter message ID(s) (comma separated) or press Enter to skip: ")
    pt_input = input("Enter payment type(s) (comma separated) or press Enter to skip (e.g., Wire Transfer, Credit Card): ")
    pid_input = input("Enter person ID(s) (comma separated) or press Enter to skip: ")
    sample_size_input = input("Enter number of samples to select (default 5): ")

    transaction_numbers = parse_input_list(tn_input)
    message_ids = parse_input_list(mi_input)
    payment_types = parse_input_list(pt_input)
    person_ids = parse_input_list(pid_input)
    try:
        sample_size = int(sample_size_input) if sample_size_input.strip() else 5
    except ValueError:
        print("Invalid sample size provided; defaulting to 5.")
        sample_size = 5

    # Filter and sample
    filtered_df = filter_data(df, transaction_numbers, message_ids, payment_types, person_ids)
    if filtered_df.empty:
        print("No records match the specified criteria.")
        return
    sampled_df = random_sample(filtered_df, sample_size=sample_size, seed=42)
    print("\nSelected records:")
    print(sampled_df.to_string(index=False))


def streamlit_mode():
    """Run the QC tool with a Streamlit web interface.

    Note: Streamlit must be installed for this to work.  Use 'pip install streamlit'
    if necessary.  If Streamlit is not installed, this function will notify
    the user and fall back to CLI mode.
    """
    try:
        import streamlit as st  # Import here to avoid requiring streamlit in CLI mode
    except ImportError:
        print("Streamlit is not installed. Falling back to CLI mode.")
        cli_mode()
        return

    df = load_data()
    st.title("Payment Screening QC Tool")
    st.write("Enter selection criteria below. Leave a field blank to ignore it.")

    # Sidebar filters for better organisation
    st.sidebar.header("Filter criteria")
    tn_input = st.sidebar.text_input("Transaction number(s) (comma separated)")
    mi_input = st.sidebar.text_input("Message ID(s) (comma separated)")
    pt_input = st.sidebar.text_input("Payment type(s) (comma separated)")
    pid_input = st.sidebar.text_input("Person ID(s) (comma separated)")
    sample_size = st.sidebar.number_input("Number of samples", min_value=1, max_value=100, value=5, step=1)

    transaction_numbers = parse_input_list(tn_input)
    message_ids = parse_input_list(mi_input)
    payment_types = parse_input_list(pt_input)
    person_ids = parse_input_list(pid_input)

    filtered_df = filter_data(df, transaction_numbers, message_ids, payment_types, person_ids)
    if filtered_df.empty:
        st.warning("No records match the specified criteria.")
    else:
        sampled_df = random_sample(filtered_df, sample_size=sample_size)
        st.write("### Selected records:")
        st.dataframe(sampled_df)
        # Optionally, allow users to download the sample as a CSV
        csv_bytes = sampled_df.to_csv(index=False).encode('utf-8')
        st.download_button(
            label="Download sample as CSV",
            data=csv_bytes,
            file_name="sampled_records.csv",
            mime="text/csv",
        )


def main():
    """Entry point for the script.

    Detects whether the script is run via Streamlit by checking for the
    'streamlit' key in the command line arguments.  If run with
    `streamlit run payment_qc_tool.py` the 'streamlit' module will be
    loaded first and this function will not be executed.  In that case
    the code in `streamlit_mode` will execute.  Otherwise, this
    function launches the CLI mode.
    """
    # In normal execution with `python payment_qc_tool.py` the script
    # enters here.  If executed with `streamlit run`, Streamlit calls
    # its internal runner which loads this module differently and
    # executes streamlit_mode directly.
    # To detect whether we're in Streamlit, check for the flag.
    if any("streamlit" in arg for arg in sys.argv[0:]):
        # Running through streamlit CLI; call the web UI
        streamlit_mode()
    else:
        # Fall back to CLI mode
        cli_mode()


if __name__ == "__main__":
    main()