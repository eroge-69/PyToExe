
#
# ===== Note =====
#
# This script was auto-generated by AG Remap's ScriptBuilder tool,
#   a build system tool used in AG Remap's CI pipeline that transforms the API source code
#   into a single script
#
# For more info, check out the Github to ScriptBuilder at:
# https://github.com/nhok0169/Anime-Game-Remap/tree/nhok0169/Tools/ScriptBuilder
#
# ***** ScriptBuilder Stats *****
#
# Version: 1.0.0
# Authors: Albert Gold#2696
# Datetime Ran: Tuesday, July 15, 2025 02:08:48.241 AM UTC
# Run Hash: 8951107c-1e86-468f-a972-c623776a5d40
# 
# *******************************
# ================
# 
# ########## START OF AUTO-GENERATED SCRIPT ##########


# ===== Anime Game Remap (AG Remap) =====
# Authors: Albert Gold#2696, NK#1321
#
# if you used it to remap your mods pls give credit for "Albert Gold#2696" and "Nhok0169"
# Special Thanks:
#   nguen#2011 (for support)
#   SilentNightSound#7430 (for internal knowdege so wrote the blendCorrection code)
#   HazrateGolabi#1364 (for being awesome, and improving the code)
#
# ***** AG Remap Script Stats *****
#
# Version: 4.5.4
# Authors: Albert Gold#2696, NK#1321
# Datetime Compiled: Tuesday, July 15, 2025 02:08:48.241 AM UTC
# Build Hash: 62017f86-fb86-4861-b795-798f1db83b41
#
# *********************************
#


import os, argparse, uuid, heapq, pip._internal as pip, importlib, re, shutil, ntpath, copy, hashlib, json, traceback, struct, configparser

from typing import List, Tuple, Any, Callable, Union, Set, TypeVar, Optional, Dict, Type, Hashable, Generic, TYPE_CHECKING, DefaultDict
from collections import OrderedDict, deque, defaultdict, UserDict
from enum import Enum
from functools import lru_cache, cmp_to_key, wraps
from types import ModuleType
from multiprocessing import Process
from threading import Thread



# change our current working directory to this file, allowing users to run program
#   by clicking on the script instead of running by CLI
if __name__ == "__main__":
    os.chdir(os.path.dirname(os.path.abspath(__file__)))


T = TypeVar('T')
N = TypeVar('N')
Pattern = TypeVar('Pattern')
TextIoWrapper = TypeVar('TextIoWrapper')
BuildCls = TypeVar("BuildCls")
Image = TypeVar("PIL.Image")
VersionType = TypeVar("packaging.version.Version")


class ListTools():
    """
    Tools for handling with Lists
    """

    @classmethod
    def getDistinct(cls, lst: List[Any], keepOrder: bool = False) -> List[Any]:
        """
        Makes all the elements in the list unique

        Parameters
        ----------
        lst: List[Any]
            The list we are working with

        keepOrder: bool
            Whehter to keep the order of the elements in the list :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        List[Any]
            The new list with only unique values
        """

        if (keepOrder):
            return list(OrderedDict.fromkeys(lst))
        return list(set(lst))
    

    @classmethod
    def removeParts(cls, lst: List[T], partIndices: List[Tuple[int, int]], nullifyRemoval: Callable[[], N], isNull: Callable[[Union[T, N]], bool]) -> List[T]:
        """
        Removes many sub-lists from a list

        Parameters
        ----------
        lst: List[T]
            The desired list to have its parts removed

        partIndices: List[Tuple[:class:`int`, :class:`int`]]:
            The indices relating to the parts to be removed from the lists :raw-html:`<br />` :raw-html:`<br />`

            The tuples contain:

                #. The starting index of the part
                #. The ending index of the part (excluded from the actual list)

        nullifyRemoval: Callable[[], N]:
            Function for creating a null element used to replace the removed part

        isNull: Callable[[Union[T, N]], :class:`bool`]
            Function for identifying whether an element in the list is the null element

        Returns
        -------
        List[T]
            The new list with its parts removed
        """

        null = nullifyRemoval()
        for indices in partIndices:
            startInd = indices[0]
            endInd = indices[1]
            lst[startInd:endInd] =  [null] * (endInd - startInd)

        lst = list(filter(lambda element: not isNull(element), lst))
        return lst
    
    @classmethod
    def removeByInds(cls, lst: List[T], inds: Set[int]) -> List[T]:
        """
        Removes many indices from a list

        Parameters
        ----------
        lst: List[T]
            The desired list to have its parts removed

        inds: Set[:class:`int`]
            The indices to the elements in the list that needs to be removed :raw-html:`<br />` :raw-html:`<br />`

        Returns
        -------
        List[T]
            The new list with elements specified by indices removed
        """

        return [element for ind, element in enumerate(lst) if ind not in inds]
    
    @classmethod
    def updateIndsAfterRemove(cls, removedInds: List[int], lstLen: int, updateInds: Callable[[int, int], T]):
        """
        Update the referenced list indices in some data structure,
        after the list got elements removed by indices

        Parameters
        ----------
        removedInds: List[:class:`int`] 
            The indices to elements that got removed from the list :raw-html:`<br />` :raw-html:`<br />`

            Assume that the list in sorted order

        lstLen: :class:`int`
            The length of the original list, before its elements got removed

        updateInds: Callable[[:class:`int`, :class:`int`], T]
            A function that updates the indices for the data structure :raw-html:`<br />` :raw-html:`<br />`

            The function takes in:

            #. The particular index in the list to update
            #. The change in how much to add upon for the particular index
        """

        removedIndsLen = len(removedInds)

        for i in range(removedIndsLen - 1, -1, -1):
            removedInd = removedInds[i]

            start = lstLen - 1 if (i == removedIndsLen - 1) else removedInds[i - 1] - 1
            end = removedInd

            for j in range(start, end, -1):
                updateInds(j, -(i + 1))


class TextTools():
    @classmethod
    def removeParts(cls, txt: str, partIndices: List[Tuple[int, int]]) -> str:
        """
        Remove multiple substrings from a text based off the indices of the substrings

        Parameters
        ----------
        txt: :class:`str`
            The target txt to have the substrings removed

        partIndices: List[Tuple[:class:`int`, :class:`int`]]
            The indices for the substrings to be removed :raw-html:`<br />` :raw-html:`<br />`

            The tuples contain the following data:

                #. The start index for the substring
                #. The ending index for the substring

        Returns 
        -------
        :class:`str`
            The new string with the substrings removed
        """

        chars = list(txt)
        chars = ListTools.removeParts(chars, partIndices, lambda: 0, lambda element: element == 0)
        result = "".join(chars)
        return result


    @classmethod
    def removeLines(cls, txtLines: List[str], partIndices: List[Tuple[int, int]]) -> List[str]:
        """
        Removes multiple sub-lists of lines from a list of text lines

        Parameters
        ----------
        txtLines: List[:class:`str`]
            The lines of text to have its lines removed

        partIndices: List[Tuple[:class:`int`, :class:`int`]]
            The indices for the list of lines to be removed :raw-html:`<br />` :raw-html:`<br />`

            The tuples contain the following data:

                #. The start index for the list of lines
                #. The ending index for the list of lines

        Returns 
        -------
        List[:class:`str`]
            The new lines of text with the removed lines
        """

        result = ListTools.removeParts(txtLines, partIndices, lambda: 0, lambda element: element == 0)
        return result
    
    @classmethod
    def getTextLines(cls, txt: str) -> List[str]:
        """
        Retrieves the lines of text, split by the newline character, similar to how python's `readlines`_ function works

        Parameters
        ----------
        txt: :class:`str`
            The target text to be split

        Returns
        -------
        List[:class:`str`]
            The lines of text that were split
        """

        txtLines = txt.split("\n")

        if (txt):
            txtLinesLen = len(txtLines)
            for i in range(txtLinesLen):
                if (i < txtLinesLen - 1):
                    txtLines[i] += "\n"
        else:
            txtLines = []

        return txtLines
    
    @classmethod
    def capitalize(cls, txt: str) -> str:
        """
        Capitalize the beginning letter of 'txt'

        Parameters
        ----------
        txt: :class:`str`
            The text to be capitalized

        Returns
        -------
        :class:`str`
            The new text with its first letter capitalized
        """

        if (not txt):
            return txt
        elif (len(txt) == 1):
            return txt.upper()
        
        return txt[0].upper() + txt[1:]
    
    @classmethod
    def capitalizeOnlyFirstChar(cls, txt: str) -> str:
        """
        Capitalize only the beginning letter of 'txt' while leaving the rest
        of 'txt' as lowercase

        Parameters
        ----------
        txt: :class:`str`
            The text to be capitalized

        Returns
        -------
        :class:`str`
            The new text with only the first letter capitalized
        """

        return cls.capitalize(txt.lower())
    
    @classmethod
    def reverse(cls, txt: str) -> str:
        """
        Reverses a string

        Parameters
        ----------
        txt: :class:`str`
            The text to be reversed

        Returns
        -------
        :class:`str`
            The reversed string
        """

        return txt[::-1]


# CommandFormatter: Text formatting for the help page of the command 
class CommandFormatter(argparse.MetavarTypeHelpFormatter, argparse.RawTextHelpFormatter):
    pass


class CommandOpts(Enum):
    Src = "--src"
    DeleteBackup = '--deleteBackup'
    FixOnly = '--fixOnly'
    Revert = '--undo'
    All = '--all'
    Types = "--types"
    FixedTypes = "--remappedTypes"
    ForceType = "--forceType"
    Version = "--version"
    Log = "--log"
    DefaultType = "--defaultType"
    HideOriginal = "--hideOriginal"
    Download = "--download"
    Proxy = "--proxy"


class ShortCommandOpts(Enum):
    Src = "-s"
    DeleteBackup = '-d'
    FixOnly = '-f'
    Revert = '-u'
    All = '-a'
    Types = "-t"
    FixedTypes = "-rt"
    ForceType = "-ft"
    Version = "-v"
    Log = "-l"
    DefaultType = "-dt"
    HideOriginal = "-ho"
    Download = "-dl"
    Proxy = "-p"


class FileExt(Enum):
    """
    Different file extensions for files
    """

    Ini = ".ini"
    """
    Initialization file extension
    """

    Txt = ".txt"
    """
    Text file extension
    """

    Buf = ".buf"
    """
    Buffer file extension    
    """

    DDS = ".dds"
    """
    `Direct Draw Surface`_ file extension
    """


class FileTypes(Enum):
    """
    Different types of files the software encounters
    """

    Default = "file"
    """
    Default file type
    """

    Ini = f"*{FileExt.Ini.value} file"
    """
    Initialization files
    """

    Blend = f"Blend{FileExt.Buf.value}"
    """
    Blend.buf files
    """

    Position = f"Position{FileExt.Buf.value}"
    """
    Position.buf files
    """

    Texture = f"*{FileExt.DDS.value}"
    """
    Texture .dds files
    """

    RemapBlend = f"Remap{Blend}"
    """
    RemapBlend.buf files    
    """

    RemapPosition = f"Remap{Position}"
    """
    RemapPostion.buf files
    """

    Log = f"RemapFixLog{FileExt.Txt.value}"
    """
    Log file
    """

    RemapTexture = f"RemapTex{FileExt.DDS.value}"
    """
    RemapTex.dds files
    """

    RemapDownload = f"RemapDL download"
    """
    RemapDL download files
    """


class BaseAhoCorasickDFA():
    """
    Base class for the `DFA (Deterministic Finite Automaton)`_ used in the `Aho-Corasick`_ algorithm

    Parameters
    ----------
    data: Optional[Dict[:class:`str`, T]]
        Any initial data to put into the `DFA`_ :raw-html:`<br />` :raw-html:`<br />`

        The keys are the keywords to put into the `DFA`_ and the values are the corresponding values to the keywords :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    handleDuplicate: Optional[Callable[[:class:`str`, T, T], T]]
        Function to handle the case where 2 `KVPs`_ inserted have the same key(word) :raw-html:`<br />` :raw-html:`<br />`

        The function takes in the following parameters:

        #. The duplicate keyword in both `KVPs`_
        #. The value of the existing `KVP`_
        #. The value of the new `KVP`_

        If this value is ``None``, will return the value of the new `KVP`_ by default :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, data: Optional[Dict[str, T]] = None, handleDuplicate: Optional[Callable[[str, T, T], T]] = None):
        self.handleDuplicate = handleDuplicate
        self._data = {}

        self.build(data)

    def __getitem__(self, txt: str) -> Tuple[Optional[str], T]:
        return self.getMaximal(txt)
    
    def __setitem__(self, keyword: int, value: T):
        self.add(keyword, value)

    def __contains__(self, txt: str) -> bool:
        keyword, ind = self.find(txt)
        return keyword is not None

    @property
    def handleDuplicate(self) -> Callable[[str, T, T], T]:
        """
        Function to handle the case where 2 `KVPs`_ inserted have the same key(word) :raw-html:`<br />` :raw-html:`<br />`

        The function takes in the following parameters:

        #. The duplicate keyword in both `KVPs`_
        #. The value of the existing `KVP`_
        #. The value of the new `KVP`_

        :getter: Retrieves the function
        :setter: Sets the new function
        :type: Callable[[:class:`str`, T, T], T]
        """

        return self._handleDuplicate
    
    @handleDuplicate.setter
    def handleDuplicate(self, newHandleDuplicate: Optional[Callable[[T, T], T]]):
        self._handleDuplicate = newHandleDuplicate if (newHandleDuplicate is not None) else lambda key, oldVal, newVal: newVal

    def clearCache(self):
        """
        Clears any cached search results
        """

        self.find.cache_clear()
        self.findMaximal.cache_clear()
        self.get.cache_clear()
        self.getMaximal.cache_clear()
        self.getKeyVal.cache_clear()

    def clear(self):
        """
        Clears the `DFA`_
        """

        self.clearCache()
        self._data.clear()

    def add(self, keyword: str, value: T):
        """
        Adds a new keyword

        .. caution::
            Adding a new keyword may trigger the entire `DFA`_ to be rebuilt

        Parameters
        ----------
        keyword: :class:`str`
            The keyword to add

        value: T
            The value associated with the keyword
        """

        self.clearCache()
        self._data[keyword] = self.handleDuplicate(keyword, self._data[keyword], value) if (keyword in self._data) else value

    def build(self, data: Optional[Dict[str, T]] = None):
        """
        Rebuilds the `DFA`_

        Parameters
        ----------
        data: Dict[:class:`str`, T]
            The new data to add to the `DFA`_ :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        pass

    def findAll(self, txt: str) -> Dict[str, List[Tuple[int, int]]]:
        """
        Finds all occurences of the keywords from the `DFA`_ in the given text

        Parameters
        ----------
        txt: :class:`str`
            The text to search for keywords

        Returns
        -------
        Dict[:class:`str`, List[Tuple[:class:`int`, :class:`int`]]]
            The indices for all the found keywords within the given text :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the keywords found
            * The values are all instances of the keyword found
            * The tuple contains the starting index of the found instance and the ending index of the found instance
        """

        pass
    
    def findFirstAll(self, txt: str) -> Dict[str, Tuple[int, int]]:
        """
        Finds the first occurences of the keywords from the `DFA`_ in the given text

        Parameters
        ----------
        txt: :class:`str`
            The text to search for keywords

        Returns
        -------
        Dict[:class:`str`, Tuple[:class:`int`, :class:`int`]]
            The indices for all the found keywords within the given text :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the keywords found
            * The tuple contains the starting index of the found instance and the ending index of the first found instance
        """

        pass
    
    @lru_cache(maxsize = 256)
    def find(self, txt: str) -> Tuple[Optional[str], int]:
        """
        Finds the first keyword within 'txt'

        Parameters
        ----------
        txt: :class:`str`
            The text to search for the keyword

        Returns
        -------
        Tuple[Optional[:class:`str`], :class:`int`]
            Data of the found keyword containing: :raw-html:`<br />` :raw-html:`<br />`

            #. The keyword found
            #. The starting index of where the keyword was found. If no keywords were found, this index is -1
        """

        pass
    
    @lru_cache(maxsize = 256)
    def findMaximal(self, txt: str, count: int = 1) -> Tuple[Union[Optional[str], List[str]], Union[int, List[int]]]:
        """
        Finds the first few largest keywords within 'txt'

        .. note::
            This function is a greedy version of :meth:`find` or `Maximal Munch`_ that consumes only a limited amount of tokens

        Parameters
        ----------
        txt: :class:`str`
            The text to search for the keyword

        count: :class:`int`
            The count of how many keywords to find in the search string :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``1``

        Returns
        -------
        Tuple[Union[Optional[:class:`str`], List[:class:`str`]], Union[:class:`int`, List[:class:`int`]]]
            Data of the found keyword: :raw-html:`<br />` :raw-html:`<br />`

            * If the 'count' argument is less than or equal to 1, then the data will contain:

                #. The keyword found
                #. The starting index of where the keyword was found. If no keywords were found, this index is -1

            * If the 'count' argument is greater than 1, then the data will contain:

                #. The list of keywords found
                #. The corresponding starting indices for where the keyword were found
        """

        pass
    
    @lru_cache(maxsize = 256) 
    def get(self, txt: str, errorOnNotFound: bool = True, default: Any = None) -> Tuple[Optional[str], Union[T, Any]]:
        """
        Retrieves the corresponding value from the first keyword fround in 'txt'

        .. note::
            This function retrieves the corresponding value after running :meth:`find`

        Parameters
        ----------
        txt: :class:`str`
            The text to search for a keyword

        errorOnNotFound: :class:`bool`  
            If no keywords are found, whether to raise an exception

        default: Any
            If 'errorOnNotFound' is ``False``, then the default value to return if no keywords are found

        Raises
        ------
        :class:`KeyError`
            If no keywords are found

        Returns
        -------
        Tuple[Optional[:class:`str`], Union[T, Any]]
            Retrieves the following resultant data:

            #. The first keyword found
            #. Either the found value for the first keyword found or the value specified at 'default', if no keywords were found and
               'errorOnNotFound' is set to ``False``
        """

        pass
    
    @lru_cache(maxsize = 256)
    def getMaximal(self, txt: str, errorOnNotFound: bool = True, default: Any = None, count: int = 1) -> Tuple[Union[Optional[str], List[str]], Union[T, Any, List[T]]]:
        """
        Retrieves the corresponding value from the first largest keyword fround in 'txt'

        .. note::
            This function retrieves the corresponding value after running :meth:`findMaximal`

        Parameters
        ----------
        txt: :class:`str`
            The text to search for a keyword

        errorOnNotFound: :class:`bool`  
            If no keywords are found, whether to raise an exception

        default: Any
            If 'errorOnNotFound' is ``False``, then the default value to return if no keywords are found

        count: :class:`int`
            The count of how many keywords to find in the search string :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``1``

        Raises
        ------
        :class:`KeyError`
            If no keywords are found

        Returns
        -------
        Tuple[Union[Optional[:class:`str`], List[:class:`str`]], Union[T, Any, List[T]]]
            Retrieves the following resultant data: :raw-html:`<br />` :raw-html:`<br />`

            * If the 'count' argument is less than or equal to 1, then the data contains:

                #. The first largest keyword found
                #. Either the found value for the first largest keyword found or the value specified at 'default', if no keywords were found and
                'errorOnNotFound' is set to ``False``

            * If the 'count' argument is greater than 1, then the data contains:

                #. The list of keywords found
                #. The corresponding found values to the keywords
        """

        pass
    
    @lru_cache(maxsize = 256)
    def getKeyVal(self, txt: str, errorOnNotFound: bool = True, default: Any = None) -> Union[T, Any]:
        """
        Retrieves the corresponding value of the key given in 'txt'

        Parameters
        ----------
        txt: :class:`str`
            The text to search for a keyword

        errorOnNotFound: :class:`bool`  
            If no keywords are found, whether to raise an exception

        default: Any
            If 'errorsOnNotFound' is ``False``, then the default value to return if no keywords are found

        Raises
        ------
        :class:`KeyError`
            If the keyword is found

        Returns
        -------
        Union[T, Any]
            Either the found value for the first largest keyword found or the value specified at 'default', if no keywords were found and
            'errorOnNotFound' is set to ``False``
        """

        pass

    def getAll(self, txt: str) -> Dict[str, T]:
        """
        Retrieves all the corresponding values to all the keywords found within 'txt'

        Parameters
        ----------
        txt: :class:`str`
            The text to search for keywords

        Returns
        -------
        Dict[:class:`str`, T]
            The corresponding values to the keywords :raw-html:`<br />` :raw-html:`<br />`

            The keys are the keywords found and the values are the values to the keywords
        """

        pass


class Node():
    """
    Class for a node in a `graph`_

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: hash(x)

            Retrieves the id of the node as the hash value

    Parameters
    ----------
    id: Hashable
        The id for the node
    """

    def __init__(self, id: Hashable):
        self._id = id

    def __hash__(self):
        return self._id

    @property
    def id(self) -> Hashable:
        """
        The id of the node

        :getter: Returns the id for the node
        :type: Hashable
        """

        return self._id


class HeapNode():
    """
    Class for a node in a `heap`_

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x < y

            Whether the value in the node x is smaller than the value in the node y

        .. describe:: x <= y
            Whether the value in the node x is smaller or equal to the value in the node y

        .. describe:: x > y

            Whether the value in the node x is bigger than the value in the node y

        .. describe:: x >= y

            Whether the value in the node x is bigger or equal to the value in the node y

        .. describe:: x == y

            Whether the value in the node x is equal to the value in node y

        .. describe:: x != y

            Whether the value in the node x is not equal to the value in node y

    Parameters
    ----------
    val: T
        The value to be stored in the node

    compare: Callable[[T, T], :class:`int`]
        The `compare function`_ for comparing elements in the heap

    Attributes
    ----------
    val: T
        The value within the node

    compare: Callable[[T, T], :class:`int`]
        The `compare function`_ for comparing elements in the heap
    """

    def __init__(self, val: T, compare: Callable[[T, T], int]):
        self.val = val
        self.compare = compare

    def __lt__(self, other: "HeapNode"):
        return self.compare(self.val, other.val) < 0
    
    def __le__(self, other: "HeapNode"):
        return self.compare(self.val, other.val) <= 0
    
    def __gt__(self, other: "HeapNode"):
        return self.compare(self.val, other.val) > 0
    
    def __ge__(self, other: "HeapNode"):
        return self.compare(self.val, other.val) >= 0
    
    def __eq__(self, other: "HeapNode"):
        return self.compare(self.val, other.val) == 0
    
    def __ne__(self, other: "HeapNode"):
        return self.compare(self.val, other.val) != 0


class Algo():
    """
    Tools for some basic algorithms
    """

    @classmethod
    def merge(cls, sortedLsts: List[List[T]], compare: Callable[[T, T], int]) -> List[T]:
        """
        Merges k sorted lists toghether

        .. note::
            Implemented using the `standard heap solution`_ (See `k-way merge problem`_ for more details)

        Parameters
        ----------
        sortedLsts: List[List[T]]
            The sorted lists to merge

        compare: Callable[[T, T], :class:`int`]
            The `compare function`_ for comparing elements in the lists

        Returns
        -------
        List[T]
            A new list with all elements from the given lists merged toghether, preserving ordering
        """

        minHeap = []
        heapCompare = lambda nodeData1, nodeData2: compare(nodeData1[0], nodeData2[0])

        numOfSortedLsts = len(sortedLsts)
        for i in range(numOfSortedLsts):
            lst = sortedLsts[i]
            lstLen = len(lst)

            if (lst):
                heapq.heappush(minHeap, HeapNode((lst[0], i, lstLen, 0), heapCompare))

        result = []
        while (minHeap):
            smallestData = heapq.heappop(minHeap).val
            result.append(smallestData[0])
            lstId, lstLen, lstInd = smallestData[1:]

            if (lstInd < lstLen - 1):
                lst = sortedLsts[lstId]
                lstInd += 1
                heapq.heappush(minHeap, HeapNode((lst[lstInd], lstId, lstLen, lstInd), heapCompare))

        return result

    @classmethod
    def _getMid(cls, left, right) -> int:
        return int(left + (right - left) / 2)

    @classmethod
    def binarySearch(cls, lst: List[T], target: T, compare: Callable[[T, T], int]) -> List[Union[int, bool]]:
        """
        Performs `binary search`_ to search for 'target' in 'lst'

        Parameters
        ----------
        lst: List[T]
            The sorted list we are searching from

        target: T
            The target element to search for in the list

        compare: Callable[[T, T], :class:`int`]
            The `compare function`_ for comparing elements in the list with the target element

        Returns
        -------
        [:class:`bool`, :class:`int`]
            * The first element is whether the target element is found in the list
            * The second element is the found index or the index that we expect the target element to be in the list
        """

        left = 0
        right = len(lst) - 1
        mid = cls._getMid(left, right)

        while (left <= right):
            midItem = lst[mid]
            compResult = compare(midItem, target)

            if (compResult == 0):
                return [True, mid]
            elif (compResult > 0):
                right = mid - 1
            else:
                left = mid + 1

            mid = cls._getMid(left, right)

        return [False, left]
    
    @classmethod
    def binaryInsert(cls, lst: List[T], target: T, compare: Callable[[T, T], int], optionalInsert: bool = False) -> bool:
        """
        Insert's 'target' into 'lst' using `binary search`_

        Parameters
        ----------
        lst: List[T]
            The sorted list we want to insert the target element

        target: T
            The target element to insert

        compare: Callable[[T, T], :class:`int`]
            The `compare function`_ for comparing elements in the list with the target element

        optionalInsert: :class:`bool`
            Whether to still insert the target element into the list if the element target element is found in the list :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`bool`
            Whether the target element has been inserted into the list
        """

        found = False
        inserted = False

        found, insertInd = cls.binarySearch(lst, target, compare)
        if (not optionalInsert or not found):
            lst.insert(insertInd, target)
            inserted = True

        return inserted


class Trie(Generic[T]):
    """
    A class for a basic `trie`_

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: key in x

            Determines if 'key' is found

        .. describe:: x[key]

            Retrieves the corresponding value to 'key'

        .. describe:: x[key] = val

            Sets the new `KVP`_

    Parameters
    ----------
    data: Optional[Dict[:class:`str`, T]]
        Any initial data to insert :raw-html:`<br />` :raw-html:`<br />`

        The keys are the keywords to put into the `trie`_ and the values are the corresponding values to the keywords :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    handleDuplicate: Optional[Callable[[:class:`str`, T, T], T]]
        Function to handle the case where 2 `KVPs`_ inserted have the same key(word) :raw-html:`<br />` :raw-html:`<br />`

        The function takes in the following parameters:

        #. The duplicate keyword in both `KVPs`_
        #. The value of the existing `KVP`_
        #. The value of the new `KVP`_

        If this value is ``None``, will return the value of the new `KVP`_ by default :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    nodeCls: Type[:class:`Node`]
        The class used to construct a node in the `trie`_

    Attributes
    ----------
    _nodes: Dict[:class:`str`, :class:`Node`]
        The nodes in the `trie`_ :raw-html:`<br />` :raw-html:`<br />`

        The keys are the ids for the node and the values are the physical node

    _children: Dict[:class:`int`, Dict[:class:`str`, :class:`int`]]
        The children nodes associated to a node :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the ids of the nodes
        * The inner keys are the string sequences of the edges between a node and its children
        * The inner values are the ids for the children

        .. note::
            This is the `adjacency list`_ for the trie

    _parent: Dict[:class:`int`, :class:`int`]
        The parent node associated to a node :raw-html:`<br />` :raw-html:`<br />`

        The keys are the ids of a node and the values are the ids of the parents

    _keywords: Dict[:class:`int`, :class:`str`]
        The keywords inside of the `trie`_ :raw-html:`<br />` :raw-html:`<br />`

        The keys are the ids for the keywords and the values are the text for the keywords

    _keywordIds: Dict[:class:`str`, :class:`int`]
        The inverse of :attr:`_keywords`

    _vals: Dict[:class:`int`, T]
        The corresponding values to the keywords :raw-html:`<br />` :raw-html:`<br />`

        The keys are the ids of the keywords and the values corresponding data values for the keyword

    _out: Dict[:class:`int`, List[:class:`int`]]
        The keywords found at a node :raw-html:`<br />` :raw-html:`<br />`

        The keys are the ids for the nodes and the values are the ids for the found keywords

    _accept: Set[:class:`int`]
        The ids to the nodes that are considered as accepting states

    _root: :class:`Node`
        The root node

    _nodeCls: Type[:class:`Node`]
        The class used to construct a node in the `trie`_
    """

    def __init__(self, data: Optional[Dict[str, T]] = None, handleDuplicate: Optional[Callable[[str, T, T], T]] = None, nodeCls: Type[Node] = Node):
        self._currentNodeId = uuid.uuid4().int
        self._currentKeywordId = uuid.uuid4().int

        self._nodeCls = nodeCls

        self._nodes: Dict[int, Node] = {}
        self._children: Dict[int, Dict[str, int]] = {}
        self._parent: Dict[int, int]
        self._vals: Dict[int, T] = {}
        self._out: Dict[int, List[int]] = {}
        self._accept: Set[int] = set()

        self._keywords: Dict[int, str] = {}
        self._keywordIds: Dict[str, int] = {}

        self.handleDuplicate = handleDuplicate
        self._root: Node = None

        self.build(data)

    def __getitem__(self, keyword: str) -> T:
        return self.get(keyword)
    
    def __setitem__(self, keyword: int, value: T):
        self.add(keyword, value)

    def __contains__(self, keyword: str) -> bool:
        try:
            self.get(keyword)
        except KeyError:
            return False

        return True

    @property
    def handleDuplicate(self) -> Callable[[str, T, T], T]:
        """
        Function to handle the case where 2 `KVPs`_ inserted have the same key(word) :raw-html:`<br />` :raw-html:`<br />`

        The function takes in the following parameters:

        #. The duplicate keyword in both `KVPs`_
        #. The value of the existing `KVP`_
        #. The value of the new `KVP`_

        :getter: Retrieves the function
        :setter: Sets the new function
        :type: Callable[[:class:`str`, T, T], T]
        """

        return self._handleDuplicate
    
    @handleDuplicate.setter
    def handleDuplicate(self, newHandleDuplicate: Optional[Callable[[T, T], T]]):
        self._handleDuplicate = newHandleDuplicate if (newHandleDuplicate is not None) else lambda key, oldVal, newVal: newVal

    @classmethod
    def _getNextNodeId(cls, currentId: int) -> int:
        return uuid.uuid4().int
    
    @classmethod
    def _getNextKeywordId(cls, currentId: int) -> int:
        return uuid.uuid4().int
    
    def _updateNextNodeId(self) -> int:
        self._currentNodeId = self._getNextNodeId(self._currentNodeId)
        return self._currentNodeId
    
    def _updateNextKeywordId(self) -> int:
        self._currentKeywordId = self._getNextKeywordId(self._currentKeywordId)
        return self._currentKeywordId
    
    def _resetNodeId(self) -> int:
        return self._updateNextNodeId()
    
    def _resetKeywordId(self) -> int:
        return self._updateNextKeywordId()
    
    def _constructNode(self, id: Hashable, *args, **kwargs) -> Node:
        """
        Constructs a a node used for the trie

        Parameters
        ----------
        id: Hashable
            The id for the node

        *args:
            Any extra arguments to pass to the node

        **kwargs:
            Any extra keyword arguments to pass to the node

        Returns
        -------
        :class:`Node`
            The constructed node
        """

        return self._nodeCls(id, *args, **kwargs)
    
    def clearCache(self):
        """
        Clears any cached search results
        """

        self.get.cache_clear()

    def clear(self):
        """
        Clears the data
        """

        self.clearCache()
        self._nodes = {}
        self._children = {}
        self._parent = {}
        self._vals = {}
        self._out = {}
        self._keywords = {}
        self._keywordIds = {}
        self._accept = set()

        self._resetNodeId()
        self._resetKeywordId()
        self._root = self._addNode()

    def _compareKeywordIds(self, keywordId1: int, keywordId2: int) -> int:
        """
        The `compare function`_ for the ids of the keywords :raw-html:`<br />` :raw-html:`<br />`

        The sorting order for keyword ids is as follows:

        #. ids to existing keywords go before ids that do not correspond to a keyword
        #. ids with longer length keywords go before ids with shorter length keywords
        #. keywords of ids are ordered in alphabetical order

        Paramters
        ---------
        keywordId1: :class:`int`
            The id for the first keyword

        keywordId2: :class:`int`
            The id for the second keyword

        Returns
        -------
        :class:`int`
            The comparison result of a `compare function`_
        """

        keyword1 = self._keywords.get(keywordId1)
        keyword2 = self._keywords.get(keywordId2)

        if (keyword1 is None and keyword2 is None):
            return 0
        elif (keyword1 is None):
            return 1
        elif (keyword2 is None):
            return -1
        
        keyword1Len = len(keyword1)
        keyword2Len = len(keyword2)
        if (keyword1Len > keyword2Len):
            return -1
        elif (keyword1Len < keyword2Len):
            return 1
        
        if (keyword1 > keyword2):
            return 1
        elif (keyword1 < keyword2):
            return -1
        
        return 0

    def build(self, data: Optional[Dict[str, T]] = None):
        """
        Rebuilds the `trie`_

        Parameters
        ----------
        data: Optional[Dict[:class:`str`, T]]
            Any initial data to put into the `trie`_ :raw-html:`<br />` :raw-html:`<br />`

            The keys are the keywords to put into the trie and the values are the corresponding values to the keywords :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        self.clear()
        if (data is None):
            data = {}

        for keyword in data:
            self._addKeyword(keyword, data[keyword])

    def _addNode(self) -> Node:
        """
        Add a node into the `trie`_

        Returns
        -------
        :class:`TrieNode`
            The node added to the trie
        """

        node = self._constructNode(self._currentNodeId)
        self._nodes[self._currentNodeId] = node
        self._updateNextNodeId()
        return node
    
    def _addKVP(self, keyword: str, value: T) -> int:
        """
        Adds in a new `KVP`_

        .. warning::
            If 'keyword' already exists, then the new value for the `KVP`_ will be
            determined based off the :attr:`handleDuplicate` function

        Returns
        -------
        :class:`int`
            The id to the keyword
        """

        if (keyword in self._keywordIds):
            keywordId = self._keywordIds[keyword]
            self._vals[keywordId] = self.handleDuplicate(keyword, self._vals[keywordId], value)
            return keywordId

        result = self._currentKeywordId
        self._keywords[self._currentKeywordId] = keyword
        self._keywordIds[keyword] = self._currentKeywordId
        self._vals[self._currentKeywordId] = value

        self._updateNextKeywordId()
        return result
    
    def add(self, keyword: str, value: T) -> Tuple[Node, bool]:
        """
        Adds a new keyword

        Parameters
        ----------
        keyword: :class:`str`
            The keyword to add

        value: T
            The value associated with the keyword

        Returns
        -------
        Tuple[:class:`Node`, :class:`bool`]
            Retrieves the following data:

            #. The node that at the end of the keyword
            #. Whether the keyword has already been inserted
        """
        
        return self._addKeyword(keyword, value)

    def _addKeyword(self, keyword: str, value: T) -> Tuple[Node, bool]:
        """
        Adds a keyword to the `trie`_

        Parameters
        ----------
        keyword: :class:`str`
            The keyword to add

        value: T
            The value associated with the keyword

        Returns
        -------
        Tuple[:class:`Node`, :class:`bool`]
            Retrieves the following data:

            #. The node that at the end of the keyword
            #. Whether the keyword has not already been inserted into the `trie`_
        """

        prevNode = self._root
        newKeyword = False

        for letter in keyword:
            prevChildren = {}
            try:
                prevChildren = self._children[prevNode.id]
            except KeyError:
                self._children[prevNode.id] = prevChildren

            nodeId = prevChildren.get(letter)
            if (nodeId is not None):
                prevNode = self._nodes[nodeId]
                continue

            if (not newKeyword):
                newKeyword = True

            node = self._addNode()
            self._parent[node.id] = prevNode.id
            prevChildren[letter] = node.id
            prevNode = node

        # if the keyword to be inserted is a proper prefix of some keyword that
        #   already exists in the trie
        if (not newKeyword and self._keywordIds.get(keyword) is None):
            newKeyword = True

        # add the KVP
        if (newKeyword):
            keywordId = self._addKVP(keyword, value)
            foundKeywordIds = self._out.get(prevNode.id)

            if (foundKeywordIds is None):
                self._out[prevNode.id] = [keywordId]
                self._accept.add(prevNode.id)
            else:
                Algo.binaryInsert(foundKeywordIds, keywordId, self._compareKeywordIds, optionalInsert = True)
        else:
            keywordId = self._keywordIds[keyword]
            self._vals[keywordId] = self.handleDuplicate(keyword, self._vals[keywordId], value)

        return (prevNode, newKeyword)

    @lru_cache(maxsize = 256)
    def get(self, keyword: str, errorOnNotFound: bool = True, default: Any = None) -> Union[T, Any]:
        """
        Retrieves the corresponding value to 'keyword'

        Parameters
        ----------
        keyword: :class:`str`
            The keyword to get the corresponding value for

        errorOnNotFound: :class:`bool`  
            If the keyword is not found, whether to raise an exception

        default: Any
            If 'errorOnNotFound' is ``False``, then the default value to return if 'keyword' is not found

        Raises
        ------
        :class:`KeyError`
            If 'keyword' is not found

        Returns
        -------
        Union[T, Any]
            Either the found value for the keyword or the value specified at 'default', if 'keyword' is not found and
            'errorOnNotFound' is set to ``False``
        """

        error = False
        prevNode = self._root

        for letter in keyword:
            if (prevNode.id not in self._children):
                error = True
                break

            nodeId = self._children[prevNode.id].get(letter)
            if (nodeId is None):
                error = True
                break
            
            node = self._nodes[nodeId]
            prevNode = node

        # when there is no output at the reached node
        if (self._out.get(prevNode.id) is None):
            error = True

        if (error and errorOnNotFound):
            raise KeyError(f"{type(self).__name__} does not contain the keyword, '{keyword}'")
        elif (error):
            return default
        
        keywordId = self._out[prevNode.id][0]
        return self._vals[keywordId]


class AhoCorasickDFA(Trie, BaseAhoCorasickDFA):
    """
    This class inherits from :class:`Trie` and :class:`BaseAhoCorasickDFA`

    The `DFA (Deterministic Finite Automaton)`_ used in the `Aho-Corasick`_ algorithm, implemented using pure Python

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: txt in x

            Determines if a keyword is found within 'txt'

        .. describe:: x[txt]

            Retrieves the following data:

            #. The found keyword
            #. The corresponding value to the found keyword

            .. note::
                See :meth:`getMaximal` for more details

        .. describe:: x[key] = val

            Sets the new `KVP`_

            .. caution::
                Please see the warning at :meth:`add`

    Parameters
    ----------
    data: Optional[Dict[:class:`str`, T]]
        Any initial data to put into the `DFA`_ :raw-html:`<br />` :raw-html:`<br />`

        The keys are the keywords to put into the `DFA`_ and the values are the corresponding values to the keywords :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    handleDuplicate: Optional[Callable[[:class:`str`, T, T], T]]
        Function to handle the case where 2 `KVPs`_ inserted have the same key(word) :raw-html:`<br />` :raw-html:`<br />`

        The function takes in the following parameters:

        #. The duplicate keyword in both `KVPs`_
        #. The value of the existing `KVP`_
        #. The value of the new `KVP`_

        If this value is ``None``, will return the value of the new `KVP`_ by default :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    nodeCls: Type[:class:`Node`]
        The class used to construct a node in the `trie`_

    Attributes
    ----------
    _fail: Dict[:class:`int`, :class:`int`]
        The failure edges in the `DFA`_ :raw-html:`<br />` :raw-html:`<br />`

        The keys are the ids to the sources node of the edges and the values are the ids to the sink nodes of the edges
    """

    def __init__(self, data: Optional[Dict[str, T]] = None, handleDuplicate: Optional[Callable[[str, T, T], T]] = None, nodeCls: Type[Node] = Node):
        self._fail: Dict[int, int] = {}
        Trie.__init__(self, data = data, handleDuplicate = handleDuplicate, nodeCls = nodeCls)

    def __getitem__(self, txt: str) -> Tuple[Optional[str], T]:
        return self.getMaximal(txt)
    
    def __setitem__(self, keyword: int, value: T):
        self.add(keyword, value)

    def __contains__(self, txt: str) -> bool:
        keyword, ind = self.find(txt)
        return keyword is not None
    
    def clearCache(self):
        Trie.clearCache(self)
        BaseAhoCorasickDFA.clearCache(self)
        self._getNextState.cache_clear()
        self._findMaximalMultiple.cache_clear()
        self._findMaximalSingle.cache_clear()

    def clear(self):
        Trie.clear(self)
        self._fail = {}

    def add(self, keyword: str, value: T):
        data = {}
        for currentKeyword in self._keywordIds:
            keywordId = self._keywordIds[currentKeyword]
            val = self._vals[keywordId]
            data[currentKeyword] = val

        data[keyword] = self._handleDuplicate(keyword, data[keyword], value) if (keyword in data) else value
        self.build(data)

    def build(self, data: Dict[str, T] = None):
        self.clearCache()
        Trie.build(self, data)

        node = self._root
        rootId = node.id
        childrenIds = self._children.get(node.id)

        # no keywords added
        if (childrenIds is None):
            return

        # all depth 1 children in the trie have a failure
        #   function that returns to the root
        for letter in childrenIds:
            childId = childrenIds[letter]
            self._fail[childId] = node.id

        # BFS to complete the failure function and the output results
        visitedNodes = set()
        nodeQueue = deque()

        nodeQueue.append(node.id)
        visitedNodes.add(node.id)

        while (nodeQueue):
            nodeId = nodeQueue.popleft()

            childrenIds = self._children.get(nodeId)
            if (childrenIds is None):
                continue
            
            # should be able to get the failure of every node
            # except for the root node
            failureId = self._fail.get(nodeId)
            if (failureId is None and nodeId != self._root.id):
                continue

            for letter in childrenIds:
                childId = childrenIds[letter]
                if (childId in visitedNodes):
                    continue

                visitedNodes.add(childId)
                nodeQueue.append(childId)

                currentFailureId = failureId
                childrenFailure = self._children.get(currentFailureId)
                childFailureId = childrenFailure.get(letter) if (childrenFailure is not None) else None

                # Failure node is the node that forms the longest proper suffix
                #   with the current substring read
                # Note: Longest proper suffix is the prefix of some keyword
                while (currentFailureId is not None and currentFailureId != rootId and childFailureId is None):
                    currentFailureId = self._fail.get(currentFailureId)
                    childrenFailure = self._children.get(currentFailureId)
                    childFailureId = childrenFailure.get(letter) if (childrenFailure is not None) else None

                # default failure node if no other keyword has a proper prefix
                #   that matches the proper suffix of the current substring read
                if (childFailureId is None):
                    childFailureId = rootId

                self._fail[childId] = childFailureId
                
                childOut = self._out.get(childId, [])
                childFailureOut = self._out.get(childFailureId, [])
                self._out[childId] = Algo.merge([childOut, childFailureOut], self._compareKeywordIds)

    @lru_cache(maxsize = 512)
    def _getNextState(self, currentStateId: int, letter: str) -> Tuple[int, bool]:
        """
        Retrieves the next state for travel to in the `DFA`_

        Parameters
        ----------
        currentStateId: :class:`int`
            The id of the current state

        letter: :class:`str`
            The transition letter to go to the next state

        Returns
        -------
        Tuple[:class:`int`, :class:`bool`]
        The resultant node data that contains: :raw-html:`<br />` :raw-html:`<br />`
        
            #. The id of the node to the next state
            #. Whether the next state is from a failure transition
        """

        nextStateChildren = self._children.get(currentStateId)
        nextStateId = nextStateChildren.get(letter) if (nextStateChildren is not None) else None
        isFail = False
        rootId = self._root.id

        while (nextStateId is None and currentStateId != rootId):
            currentStateId = self._fail.get(currentStateId, rootId)
            nextStateChildren = self._children.get(currentStateId)
            nextStateId = nextStateChildren.get(letter) if (nextStateChildren is not None) else None

            if (not isFail):
                isFail = True
            
        if (nextStateId is None):
            nextStateId = rootId
            isFail = True

        return (nextStateId, isFail)

    def findAll(self, txt: str) -> Dict[str, List[Tuple[int, int]]]:
        result = {}
        stateId = self._root.id
        txtLen = len(txt)

        for i in range(-1, txtLen):
            letter = txt[i] if (i >= 0) else ""
            stateId, isFail = self._getNextState(stateId, letter)

            currentKeywords = self._out.get(stateId)
            if (currentKeywords is None):
                continue

            for keywordId in currentKeywords:
                keyword = self._keywords[keywordId]

                currentResult = result.get(keyword)
                if (currentResult is None):
                    currentResult = []
                    result[keyword] = currentResult
                
                currentResult.append((i - len(keyword) + 1, i + 1))

        return result
    
    def findFirstAll(self, txt: str) -> Dict[str, Tuple[int, int]]:
        result = {}
        stateId = self._root.id
        txtLen = len(txt)
        keywordsLen = len(self._keywords)

        for i in range(-1, txtLen):
            letter = txt[i] if (i >= 0) else ""
            stateId, isFail = self._getNextState(stateId, letter)

            currentKeywords = self._out.get(stateId)
            if (currentKeywords is None):
                continue

            for keywordId in currentKeywords:
                keyword = self._keywords[keywordId]
                if (keyword in result):
                    continue
                
                result[keyword] = (i - len(keyword) + 1, i + 1)

                if (len(result) == keywordsLen):
                    break

        return result
    
    @lru_cache(maxsize = 256)
    def find(self, txt: str) -> Tuple[Optional[str], int]:
        keyword = None
        keywordInd = -1
        stateId = self._root.id
        txtLen = len(txt)

        for i in range(-1, txtLen):
            letter = txt[i] if (i >= 0) else ""
            stateId, isFail = self._getNextState(stateId, letter)

            currentKeywords = self._out.get(stateId)
            if (currentKeywords is not None and currentKeywords):
                keyword = self._keywords[currentKeywords[0]]
                keywordInd = i - len(keyword) + 1
                break

        return (keyword, keywordInd)

    # _findMaximalSingle(txt): Finds the first largest keyword in 'txt'
    @lru_cache(maxsize = 512)
    def _findMaximalSingle(self, txt: str) -> Tuple[Optional[str], int]:
        keyword = None
        keywordInd = -1

        rootId = self._root.id
        stateId = rootId
        txtLen = len(txt)

        for i in range(-1, txtLen):
            letter = txt[i] if (i >= 0) else ""
            stateId, isFail = self._getNextState(stateId, letter)

            keywordFound = keyword is not None
            if (keywordFound and isFail):
                break

            stateIsAccept = stateId in self._accept
            if (keyword and not stateIsAccept):
                continue

            currentKeywords = self._out.get(stateId)
            if (currentKeywords is not None and currentKeywords):
                keyword = self._keywords[currentKeywords[0]]
                keywordInd = i - len(keyword) + 1

        return (keyword, keywordInd)
    
    @lru_cache(maxsize = 256)
    def _findMaximalMultiple(self, txt: str, count: int) -> Tuple[List[str], List[int]]:
        keywordLst = []
        keywordIndLst = []
        currentTxtInd = 0
        txtLen = len(txt)
        numOfFoundKeywords = count

        while (currentTxtInd < txtLen and numOfFoundKeywords > 0):
            keyword, keywordInd = self._findMaximalSingle(txt[currentTxtInd:])
            if (keyword is None):
                break

            keywordLst.append(keyword)
            keywordIndLst.append(currentTxtInd + keywordInd)
            currentTxtInd += keywordInd + len(keyword) if (keyword) else 1
            numOfFoundKeywords -= 1

        if ("" in self._keywordIds and numOfFoundKeywords):
            keywordLst.append("")
            keywordIndLst.append(txtLen)

        return (keywordLst, keywordIndLst)

    @lru_cache(maxsize = 256)
    def findMaximal(self, txt: str, count: int = 1) -> Tuple[Union[Optional[str], List[str]], Union[int, List[int]]]:
        if (count <= 1):
            return self._findMaximalSingle(txt)
        
        return self._findMaximalMultiple(txt, count)
    
    @lru_cache(maxsize = 256)
    def get(self, txt: str, errorOnNotFound: bool = True, default: Any = None) -> Tuple[Optional[str], Union[T, Any]]:
        keyword, _ = self.find(txt)

        keywordFound = keyword is not None
        if (not keywordFound and errorOnNotFound):
            raise KeyError(f"The text, '{txt}', does not contain any matching keywords")
        elif (not keywordFound):
            return (keyword, default)
        
        keywordId = self._keywordIds[keyword]
        return (keyword, self._vals[keywordId])
    
    @lru_cache(maxsize = 256)
    def getMaximal(self, txt: str, errorOnNotFound: bool = True, default: Any = None, count: int = 1) -> Tuple[Union[Optional[str], List[str]], Union[T, Any, List[T]]]:
        keywords, _ = self.findMaximal(txt, count = count)
        findSingleKeyword = count <= 1

        keywordFound = keywords is not None and (findSingleKeyword or bool(keywords))
        if (not keywordFound and errorOnNotFound):
            raise KeyError(f"The text, '{txt}', does not contain any matching keywords")
        elif (not keywordFound and findSingleKeyword):
            return (keywords, default)
        elif (not keywordFound):
            return ([], [])
        
        if (count <= 1):
            keywordId = self._keywordIds[keywords]
            return (keywords, self._vals[keywordId])
        
        keywordVals = []
        for keyword in keywords:
            keywordId = self._keywordIds[keyword]
            keywordVals.append(self._vals[keywordId])

        return (keywords, keywordVals)

    
    @lru_cache(maxsize = 256)
    def getKeyVal(self, txt: str, errorOnNotFound: bool = True, default: Any = None) -> Union[T, Any]:
        if (txt in self._keywordIds):
            keywordId = self._keywordIds[txt]
            return self._vals[keywordId]
        
        if (errorOnNotFound):
            raise KeyError(f"The keyword, '{txt}', is not found")
        
        return default

    def getAll(self, txt: str) -> Dict[str, T]:
        result = {}
        stateId = self._root.id
        txtLen = len(txt)

        for i in range(-1, txtLen):
            letter = txt[i] if (i >= 0) else ""
            stateId, isFail = self._getNextState(stateId, letter)

            currentKeywords = self._out.get(stateId)
            if (currentKeywords is None):
                continue

            for keywordId in currentKeywords:
                keyword = self._keywords[keywordId]
                if (keyword in result):
                    continue

                result[keyword] = self._vals[keywordId]

        return result


class PackageData():
    """
    Data class to hold data relating to retrieving/installing a package at runtime

    Parameters
    ----------
    module: :class:`str`
        The name of the module to import

    install: Optional[:class:`str`]
        The name of the installation for the package when using `pip`_ to download from `pypi`_ :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then assume that the name of the installation is the same as the name of the package :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, module: str, installName: Optional[str] = None):
        self.module = module
        self.installName = module if (installName is None) else installName


class PackageManager():
    """
    Class to handle external packages for the library at runtime

    Attributes
    ----------
    proxy: Optional[:class:`str`]
        The link to the proxy server used for any internet network requests made :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    options: Optional[List[:class:`str`]]
        Additional options to supply to into `pip`_ :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Parameters
    ----------
    proxy: Optional[:class:`str`]
        The link to the proxy server used for any internet network requests made

    options: List[:class:`str`]
        Additional options to supply to into `pip`_
    """

    def __init__(self, proxy: Optional[str] = None, options: Optional[List[str]] = None):
        self._packages: Dict[str, ModuleType] = {}
        self.proxy = proxy
        self.options = [] if (options is None) else options

    def load(self, module: str, installName: Optional[str] = None, installOptions: Optional[List[str]] = None, save: bool = True) -> ModuleType:
        """
        Imports an external package

        Parameters
        ----------
        module: :class:`str`
            The name of the module to import

        install: Optional[:class:`str`]
            The name of the installation for the package when using `pip`_ to download from `pypi`_ :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then assume that the name of the installation is the same as the name of the package :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        installOptions: Optional[List[:class:`str`]]
            Additional installation options to supply into `pip`_ :raw-html:`<br />`

            .. note::
                The following `pip`_ options are already supplied by this class:

                * -U, --upgrade 
                * --proxy

            :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        save: :class:`bool`
            Whether to save the installed package into this class

        Returns
        -------
        `Module`_
            The module to the external package
        """

        if (installName is None):
            installName = module

        if (installOptions is None):
            installOptions = []

        try:
            return importlib.import_module(module)
        except ModuleNotFoundError:
            proxyOptions = ["--proxy", self.proxy] if (self.proxy is not None) else []

            pip.main(['install', '-U'] + proxyOptions + self.options + installOptions + [installName])

        result = importlib.import_module(module)
        if (save):
            self._packages[module] = result
        
        return result
    
    def get(self, packageData: PackageData, installOptions: Optional[List[str]] = None):
        """
        Retrieves an external package

        Parameters
        ----------
        packageData: :class:`PackageData`
            The data needed for install the external package

        installOptions: Optional[List[:class:`str`]]
            Additional installation options to supply to `pip`_

            .. note::
                Please see the ``installOptions`` argument in :meth:`load` for more details

        Returns
        -------
        `Module`_
            The module to the external package
        """

        result = None
        try:
            result = self._packages[packageData.module]
        except KeyError:
            result = self.load(packageData.module, installName = packageData.installName, installOptions = installOptions)

        return result


class GlobalPackageManager(Enum):
    """
    Global pacakge manager for handling external libraries

    Attributes
    ----------
    Packager: :class:`PackageManager`
        The pacakge manager used by the softwares
    """

    Packager = PackageManager()

    @classmethod
    def get(cls, packageData: PackageData) -> ModuleType:
        """
        Convenience function to call :meth:`PackageManager.get` from :attr:`Packager`

        Parameters
        ----------
        packageData: :class:`PackageData`
            The data needed for install the external package

        Returns
        -------
        `Module`_
            The module to the external package
        """

        return cls.Packager.value.get(packageData)


class DictTools():
    """
    Tools for handling with Dictionaries
    """

    @classmethod
    def getFirstKey(cls, dict: Dict[Any, Any]) -> Any:
        """
        Retrieves the first key in a dictionary

        Parameters
        ----------
        dict: Dict[Any, Any]
            The dictionary we are working with

            .. note::
                The dictionary must not be empty

        Returns
        -------
        Any
            The first key of the dictionary
        """

        return next(iter(dict))

    @classmethod
    def getFirstValue(cls, dict: Dict[Any, Any]) -> Any:
        """
        Retrieves the first value in a dictionary

        Parameters
        ----------
        dict: Dict[Any, Any]
            The dictionary we are working with

        Returns
        -------
        Any
            The first value of the dictionary
        """

        return dict[cls.getFirstKey(dict)]
    
    @classmethod
    def update(cls, srcDict: Dict[Hashable, Any], newDict: Dict[Hashable, Any], combineDuplicate: Optional[Callable[[Hashable, Any, Any], Any]] = None) -> Dict[Hashable, Any]:
        """
        Updates ``srcDict`` based off the new values from ``newDict``

        Parameters
        ----------
        srcDict: Dict[Hashable, Any]
            The dictionary to be updated

        newDict: Dict[Hashable, Any]
            The dictionary to help with updating ``srcDict``

        combineDuplicate: Optional[Callable[[`Hashable`_, Any, Any], Any]]
            Function for handling cases where there contains the same key in both dictionaries :raw-html:`<br />` :raw-html:`<br />`

            * The first parameter is the key that is in both dictionary
            * The second parameter is the value that comes from ``srcDict``
            * The third parameter is the value that comes from ``newDict``

            If this value is set to ``None``, then will use the key from ``newDict`` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Dict[Hashable, Any]
            Reference to the updated dictionary
        """

        if (combineDuplicate is None):
            srcDict.update(newDict)
            return srcDict
        
        combinedValues = {}
        srcDictLen = len(srcDict)
        newDictLen = len(newDict)
        
        shortDict = srcDict
        longDict = newDict
        if (srcDictLen > newDictLen):
            shortDict = newDict
            longDict = srcDict

        for key in shortDict:
            if (key in longDict):
                combinedValues[key] = combineDuplicate(key, srcDict[key], newDict[key])

        srcDict.update(newDict)
        srcDict.update(combinedValues)
        return srcDict


    @classmethod
    def combine(cls, dict1: Dict[Hashable, Any], dict2: Dict[Hashable, Any], combineDuplicate: Optional[Callable[[Hashable, Any, Any], Any]] = None) -> Dict[Hashable, Any]:
        """
        Creates a new dictionary from combining 2 dictionaries

        Parameters
        ----------
        dict1: Dict[Hashable, Any]
            The destination of where we want the combined dictionaries to be stored

        dict2: Dict[Hashable, Any]
            The dictionary we want to combine with

        combineDuplicate: Optional[Callable[[`Hashable`_, Any, Any], Any]]
            Function for handling cases where there contains the same key in both dictionaries :raw-html:`<br />` :raw-html:`<br />`

            * The first parameter is the key that is in both dictionary
            * The second parameter is the value that comes from ``srcDict``
            * The third parameter is the value that comes from ``newDict``

            If this value is set to ``None``, then will use the key from 'dict2' :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        makeNewCopy: :class:`bool`
            Whether we want the resultant dictionary to be newly created or to be updated into ``dict1``

        Returns
        -------
        Dict[Hashable, Any]
            The new combined dictionary
        """

        new_dict = {**dict1, **dict2}

        if (combineDuplicate is None):
            return new_dict

        for key in new_dict:
            if key in dict1 and key in dict2:
                new_dict[key] = combineDuplicate(key, new_dict[key], dict1[key])

        return new_dict
    
    @classmethod
    def invert(cls, dict: Dict[Hashable, Hashable]) -> Dict[Hashable, Hashable]:
        """
        Inverts a dictionary by making the keys the values and the values the keys

        Parameters
        ----------
        dict: Dict[Hashable, Hashable]
            The dictionary to invert

        Returns
        -------
        Dict[Hashable, Hashable]
            The inverted dictionary
        """

        return {v: k for k, v in dict.items()}
    
    @classmethod
    def filter(cls, dict: Dict[Hashable, Any], predicate: Callable[[Hashable, Any], bool]) -> Dict[Hashable, Any]:
        """
        Filters a dictionary

        Parameters
        ----------
        dict: Dict[Hashable, Hashable]
            The dictionary to filter

        predicate: Callable[[Hashable, Any], :class:`bool`]
            The predicate used for the filter :raw-html:`<br />` :raw-html:`<br />`

            The predicate has the following parameters

            #. The key of the dictionary
            #. The value of the dictionary

        Returns
        -------
        Dict[Hashable, Any]
            The filtered dictionary
        """

        return {key: value for key, value in dict.items() if predicate(key, value)}
    
    @classmethod
    def _forDict(cls, nestedDict: Dict[Hashable, Any], keyNames: List[str], func: Callable[[Dict[str, str], Dict[str, Any]], Any], currentKeyInd: int, keys: Dict[str, Hashable], values: Dict[str, Hashable]) -> Any:
        keyNamesLen = len(keyNames)
        if (currentKeyInd >= keyNamesLen):
            func(keys, values)
            return

        keyName = keyNames[currentKeyInd]
        for key in nestedDict:
            currentVal = nestedDict[key]
            keys[keyName] = key
            values[keyName] = currentVal
            cls._forDict(currentVal, keyNames, func, currentKeyInd + 1, keys, values)

    @classmethod
    def forDict(cls, nestedDict: Dict[Hashable, Any], keyNames: List[str], func: Callable[[Dict[str, Hashable], Dict[str, Any]], Any]):
        """
        Iterates over a nested dictionary

        Parameters
        ----------
        nestedDict: Dict[Hashable, Any]
            The nested dictionary to iterate over

        keyNames: List[:class:`str`]
            The variable names of the keys in the nested dictionary

        func: Callable[Dict[:class:`str`, Hashable], Dict[:class:`str`, Any], Any]
            callback function that will be called at the leaf node of the nested dictionary :raw-html:`<br />` :raw-html:`<br />`

            The function contains the following arguments:
            #. The dictionary keys encountered in the current iteration
            #. The corresponding values encountered at each dictionary layer in the current iteration
        """

        keys = {}
        values = {}
        cls._forDict(nestedDict, keyNames, func, 0, keys, values)
        


class PackageInstall(Enum):
    """
    Installation names for external packages to retrieve from `pypi`_
    """

    OrderedSet = "ordered-set"
    """
    Package for an ordered set
    """

    Pillow = "pillow"
    """
    Package for manipulating with images
    """

    PyAhoCorasick = "pyahocorasick"
    """
    Package for the `Aho-Corasick`_ algorithm, implemented at the C level
    """

    Requests = "requests"
    """
    Package for handling HTTP requests
    """

    Packaging = "packaging"
    """
    Package for handling Python packaging operations
    """


class PackageModules(Enum):
    """
    The data about modules from external packages used by the software

    Attributes
    ----------
    AhoCorasick: :class:`PackageData`
        Module for `pyahocorasick`_

    OrderedSet: :class:`PackageData`
        Module for `ordered_set`_

    PIL_Image: :class:`PackageData`
        Module for PIL.Image

    PIL_ImageChops: :class:`PackageData`
        Module for PIL.ImageChops

    PIL_ImageEnhance: :class:`PackageData`
        Module for PIL.ImageEnhance

    Requests: :class:`PackageData`
        Module for `requests`_

    Packaging_Version: :class:`PackageData`
        Modeule for `packaging.version`
    """

    AhoCorasick = PackageData("ahocorasick", PackageInstall.PyAhoCorasick.value)
    OrderedSet = PackageData("ordered_set", PackageInstall.OrderedSet.value)
    PIL_Image = PackageData("PIL.Image", PackageInstall.Pillow.value)
    PIL_ImageChops = PackageData("PIL.ImageChops", PackageInstall.Pillow.value)
    PIL_ImageEnhance = PackageData("PIL.ImageEnhance", PackageInstall.Pillow.value)
    Requests = PackageData("requests", PackageInstall.Requests.value)
    Packaging_Version = PackageData("packaging.version", PackageInstall.Packaging.value)


class FastAhoCorasickDFA(BaseAhoCorasickDFA):
    """
    A wrapper class over `pyahocorasick.Automaton`_

    The `DFA (Deterministic Finite Automaton)`_ used in the `Aho-Corasick`_ algorithm, implemented at the C level

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: txt in x

            Determines if a keyword is found within 'txt'

        .. describe:: x[txt]

            Retrieves the following data:

            #. The found keyword
            #. The corresponding value to the found keyword

            .. note::
                See :meth:`getMaximal` for more details

        .. describe:: x[key] = val

            Sets the new `KVP`_

            .. caution::
                Please see the warning at :meth:`add`

    Parameters
    ----------
    data: Optional[Dict[:class:`str`, T]]
        Any initial data to put into the `DFA`_ :raw-html:`<br />` :raw-html:`<br />`

        The keys are the keywords to put into the `DFA`_ and the values are the corresponding values to the keywords :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    handleDuplicate: Optional[Callable[[:class:`str`, T, T], T]]
        Function to handle the case where 2 `KVPs`_ inserted have the same key(word) :raw-html:`<br />` :raw-html:`<br />`

        The function takes in the following parameters:

        #. The duplicate keyword in both `KVPs`_
        #. The value of the existing `KVP`_
        #. The value of the new `KVP`_

        If this value is ``None``, will return the value of the new `KVP`_ by default :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    _dfa: `pyahocorasick.Automaton`_
        The internal `DFA`_

    _data: Dict[:class:`str`, T]
        The `KVP`_ data within the `DFA`_
    """

    def __init__(self, data: Optional[Dict[str, T]] = None, handleDuplicate: Optional[Callable[[str, T, T], T]] = None):
        ahocorasick = GlobalPackageManager.get(PackageModules.AhoCorasick.value)
        self._dfa = ahocorasick.Automaton()
        super().__init__(data, handleDuplicate = handleDuplicate)
        self.build(data)

    def clearCache(self):
        super().clearCache()
        self._findMaximalMultiple.cache_clear()
        self._findMaximalSingle.cache_clear()

    def clear(self):
        ahocorasick = GlobalPackageManager.get(PackageModules.AhoCorasick.value)
        self._dfa = ahocorasick.Automaton()
        super().clear()

    def add(self, keyword: str, value: T):
        self.clearCache()
        self._data[keyword] = self.handleDuplicate(keyword, self._data[keyword], value) if (keyword in self._data) else value

        self._dfa.add_word(keyword, keyword)
        self._dfa.make_automaton()

    def build(self, data: Optional[Dict[str, T]] = None, clear: bool = True):
        if (clear):
            self.clear()
        
        if (data is not None):
            self.clearCache()

        if (data is None):
            data = {}

        self._data = DictTools.update(self._data, data, combineDuplicate = self.handleDuplicate)

        for keyword in self._data:
            self._dfa.add_word(keyword, keyword)

        self._dfa.make_automaton()

    # _dfaOnlyHasEmptyStr(): Whether the internal AhoCorasick DFA only has the empty string
    def _dfaOnlyHasEmptyStr(self):
        return len(self._data) == 1 and "" in self._data

    def findAll(self, txt: str) -> Dict[str, List[Tuple[int, int]]]:
        result = {}
        if (not self._data):
            return result

        if (not self._dfaOnlyHasEmptyStr()):
            for endInd, keyword in self._dfa.iter(txt):
                keywordInds = result.get(keyword)
                if (keywordInds is None):
                    keywordInds = []
                    result[keyword] = keywordInds

                keywordInds.append((endInd - len(keyword) + 1, endInd + 1))

        if ("" not in self._data):
            return result

        # case where the empty string is a keyword
        emptyInds = []
        txtLen = len(txt)
        for i in range(txtLen + 1):
            emptyInds.append((i, i))

        result[""] = emptyInds
        return result
    
    def findFirstAll(self, txt: str) -> Dict[str, Tuple[int, int]]:
        result = {}
        if (not self._data):
            return result

        keywordsLen = len(self._data)

        if (not self._dfaOnlyHasEmptyStr()):
            for endInd, keyword in self._dfa.iter(txt):
                result[keyword] = (endInd - keywordsLen + 1, endInd + 1)
                if (len(result) >= keywordsLen):
                    break

        if ("" not in self._data):
            return result

        # case where the empty string is a keyword
        result[""] = [(0, 0)]
        return result
    
    @lru_cache(maxsize = 256)
    def find(self, txt: str) -> Tuple[Optional[str], int]:
        if ("" in self._data):
            return ("", 0)

        keyword = None
        keywordInd = -1

        if (not self._data):
            return (keyword, keywordInd)

        for endInd, foundKeyword in self._dfa.iter(txt):
            keyword = foundKeyword
            keywordInd = endInd - len(foundKeyword) + 1
            break

        return (keyword, keywordInd)

    # _findMaximalSingle(txt): Finds the first largest keyword in 'txt'
    @lru_cache(maxsize = 256)
    def _findMaximalSingle(self, txt: str) -> Tuple[Optional[str], int]:
        keyword = None
        keywordStartInd = -1

        if (not self._data):
            return (keyword, keywordStartInd)
        
        hasEmptyKeyword = "" in self._data
        if (hasEmptyKeyword):
            keyword = ""
            keywordStartInd = 0

        if (self._dfaOnlyHasEmptyStr()):
            return (keyword, keywordStartInd) 
        
        for endInd, foundKeyword in self._dfa.iter(txt):
            startInd = endInd - len(foundKeyword) + 1
            txtSuffix = txt[startInd:]
            longestKeywordPrefixLen = self._dfa.longest_prefix(txtSuffix)

            keywordStartInd = startInd
            keyword = foundKeyword

            if (longestKeywordPrefixLen <= endInd + 1 - startInd):
                break
            
            # found the longest search result, longer than the first result
            newKeyword = txtSuffix[:longestKeywordPrefixLen]
            if (newKeyword in self._data):
                keyword = newKeyword

            break

        return (keyword, keywordStartInd)
    
    # _findMaximalMultiple(txt, count): Finds the first few largest keywords in 'txt'
    @lru_cache(maxsize = 256)
    def _findMaximalMultiple(self, txt: str, count: int) -> Tuple[List[str], List[int]]:
        keywords = []
        keywordInds = []
        currentKeyword = None
        currentKeywordStartInd = -1
        numOfKeywordsToFind = count

        if (not self._data):
            return (keywords, keywordInds)
        
        hasEmptyKeyword = "" in self._data
        if (hasEmptyKeyword):
            currentKeyword = ""
            currentKeywordStartInd = 0

        if (self._dfaOnlyHasEmptyStr()):
            txtLen = len(txt)
            for i in range(0, min(txtLen + 1, count)):
                keywords.append("")
                keywordInds.append(i)

            return (keywords, keywordInds)
        
        currentTxtInd = 0
        txtLen = len(txt)

        while (numOfKeywordsToFind > 0 and currentTxtInd < txtLen):
            currentLongestFound = False

            # when the user requests multiple keywords returned and the empty string
            #   is a keyword
            if (hasEmptyKeyword):
                currentKeyword = ""
                currentKeywordStartInd = currentTxtInd

            for currentEndInd, foundKeyword in self._dfa.iter(txt[currentTxtInd:]):
                currentStartInd = currentEndInd - len(foundKeyword) + 1
                startInd = currentStartInd + currentTxtInd
                endInd = startInd + currentEndInd + 1

                # found keyword is not the next maximal keyword
                if (currentKeyword is not None and startInd > currentKeywordStartInd):
                    break

                txtSuffix = txt[startInd:]
                longestKeywordPrefixLen = self._dfa.longest_prefix(txtSuffix)

                currentKeywordStartInd = startInd
                currentKeyword = foundKeyword 

                if (longestKeywordPrefixLen <= currentEndInd + 1 - currentStartInd):
                    currentLongestFound = True
                
                # found the longest search result, longer than the first result
                if (not currentLongestFound):
                    newKeyword = txtSuffix[:longestKeywordPrefixLen]
                    currentLongestFound = True

                    if (newKeyword in self._data):
                        currentKeyword = newKeyword
                        endInd = startInd + longestKeywordPrefixLen

                currentTxtInd = endInd
                numOfKeywordsToFind -= 1

                # reset the keyword found
                keywords.append(currentKeyword)
                keywordInds.append(currentKeywordStartInd)
                currentKeyword = None
                currentKeywordStartInd = -1

                break

            # add the empty string as the current longest keyword
            if (currentKeyword is not None):
                numOfKeywordsToFind -= 1
                keywords.append(currentKeyword)
                keywordInds.append(currentKeywordStartInd)
                currentKeyword = None
                currentKeywordStartInd = -1
                currentTxtInd += 1
                currentLongestFound = True

            # no more keywords found
            if (not currentLongestFound):
                break

        # empty string at the very end of the text
        if (hasEmptyKeyword and numOfKeywordsToFind):
            keywords.append("")
            keywordInds.append(txtLen)

        return (keywords, keywordInds)

    @lru_cache(maxsize = 256)
    def findMaximal(self, txt: str, count: int = 1) -> Tuple[Union[Optional[str], List[str]], Union[int, List[int]]]:
        if (count <= 1):
            return self._findMaximalSingle(txt)

        return self._findMaximalMultiple(txt, count)
    
    @lru_cache(maxsize = 256) 
    def get(self, txt: str, errorOnNotFound: bool = True, default: Any = None) -> Tuple[Optional[str], Union[T, Any]]:
        keyword, _ = self.find(txt)

        keywordFound = keyword is not None
        if (not keywordFound and errorOnNotFound):
            raise KeyError(f"The text, '{txt}', does not contain any matching keywords")
        elif (not keywordFound):
            return (keyword, default)

        return (keyword, self._data[keyword])
    
    @lru_cache(maxsize = 256)
    def getMaximal(self, txt: str, errorOnNotFound: bool = True, default: Any = None, count: int = 1) -> Tuple[Union[Optional[str], List[str]], Union[T, Any, List[T]]]:
        keywords, _ = self.findMaximal(txt, count = count)
        findSingleKeyword = count <= 1

        keywordFound = keywords is not None and (findSingleKeyword or bool(keywords))
        if (not keywordFound and errorOnNotFound):
            raise KeyError(f"The text, '{txt}', does not contain any matching keywords")
        elif (not keywordFound and findSingleKeyword):
            return (keywords, default)
        elif (not keywordFound):
            return ([], [])

        if (findSingleKeyword):
            return (keywords, self._data[keywords])
        
        keywordVals = []
        for keyword in keywords:
            keywordVals.append(self._data[keyword])

        return (keywords, keywordVals)
    
    @lru_cache(maxsize = 256)
    def getKeyVal(self, txt: str, errorOnNotFound: bool = True, default: Any = None) -> Union[T, Any]:
        if (txt in self._data):
            return self._data[txt]
        
        if (errorOnNotFound):
            raise KeyError(f"The given key, '{txt}', is not found")
        
        return default

    def getAll(self, txt: str) -> Dict[str, T]:
        result = {}
        if (not self._data):
            return result
        
        keywordsLen = len(self._data)

        if (not self._dfaOnlyHasEmptyStr()):
            for endInd, keyword in self._dfa.iter(txt):
                result[keyword] = self._data[keyword]
                if (len(result) >= keywordsLen):
                    break
        
        if ("" in self._data):
            result[""] = self._data[""]
        return result


class Builder(Generic[BuildCls]):
    """
    Class to dynamically create a new object

    Parameters
    ----------
    buildCls: Type[T]
        The class for the objects to be built from

    args: Optional[List[Any]]
        The constant arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    _buildCls: Type[T]
        The class for the objects to be built from

    _args: List[Any]
        The constant arguments used to build the object

    _kwargs: Dict[str, Any]
        The constant keyword arguments used to build the object
    """
    def __init__(self, buildCls: Type[BuildCls], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        self._buildCls = buildCls

        if (args is None):
            args = []
        self._args = args

        if (kwargs is None):
            kwargs = {}
        self._kwargs = kwargs

    def build(self, *args, **kwargs) -> BuildCls:
        """
        Creates the object

        Parameters
        ----------
        *args
            arguments to build the object

        **kwargs
            keyword arguments to build the object

        Returns
        -------
        T
            The built objects
        """

        return self._buildCls(*args, *self._args, **kwargs, **self._kwargs)


class AhoCorasickBuilder(Builder[BaseAhoCorasickDFA]):
    """
    This class inherits from :class:`Builder`

    A class to build some implementation of the `Aho-Corasick`_ algorithm

    Parameters
    ----------
    buildCls: Optional[Type[:class:`BaseAhoCorasickDFA`]]
        The class to construct a :class:`BaseAhoCorasickDFA`  :raw-html:`<br />` :raw-html:`<br />`

        If this parameters is ``None``, the class will be a :class:`FastAhoCorasickDFA` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    args: Optional[List[Any]]
        The constant arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, buildCls: Optional[Type[BaseAhoCorasickDFA]] = None, args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        if (buildCls is None):
            buildCls = FastAhoCorasickDFA

        super().__init__(buildCls, args, kwargs)

    
    def build(self, *args, **kwargs):
        """
        Builds the `DFA`_

        .. warning::
            If failed to construct the `DFA`_ for the class given, will fallback to constructing a :class:`AhoCorasickDFA`

        Parameters
        ----------
        *args
            arguments to build the object

        **kwargs
            keyword arguments to build the object

        Returns
        -------
        :class:`BaseAhoCorasickDFA`
            The built `DFA`_
        """

        try:
            return super().build(*args, **kwargs)
        except ModuleNotFoundError as e:
            return AhoCorasickDFA(*args, *self._args, **kwargs, **self._kwargs)


class AhoCorasickSingleton():
    """
    Wrapper class to the :class:`BaseAhoCorasickDFA` that only setup the data in the `DFA`_ once
    at some point during runtime

    Parameters
    ----------
    builder: :class:`AhoCorasickBuilder`
        The builder that constructs the :class:`BaseAhoCorasickDFA`

    *args:
        Any extra arguments to provide into :meth:`AhoCorasickBuilder.build` during the initial construction of the :class:`BaseAhoCorasickDFA`

    **kwargs:
        Any extra keyword arguments to provide into :meth:`AhoCorasickBuilder.build` during the initial construction of the :class:`BaseAhoCorasickDFA`

    Attributes
    ----------
    dfa: :class:`BaseAhoCorasickDFA`
        The `DFA`_ used in the `Aho-Corasick`_ algorithm
    """

    def __init__(self, builder: AhoCorasickBuilder, *args, **kwargs):
        self.dfa = builder.build(*args, **kwargs)
        self._isSetup = False

    @property
    def isSetup(self):
        """
        Whether the data in the `DFA`_ has been setup

        :getter: Retrieves whether the data has been setup yet
        :type: :class:`bool`
        """

        return self._isSetup
    
    def reset(self):
        """
        Resets the state so that :attr:`dfa` can have its data updated
        """
        
        self._isSetup = False
    
    def setup(self, data: Dict[str, T]) -> bool:
        """
        Setup the data for the `DFA`_ , if the data has not been setup yet

        Parameters
        ----------
        data: Dict[:class:`str`, T]
            The data to pass into :meth:`BaseAhoCorasickDFA.build`

        Returns
        -------
        :class:`bool`
            Whether the data in :attr:`dfa` got updated
        """

        if (not self._isSetup):
            self._isSetup = True
            self.dfa.build(data = data)
            return True

        return False


class GlobalClassifiers(Enum):
    """
    Global modules used by the sofware to help classify strings into different sets

    Attributes
    ----------
    ModTypes: :class:`AhoCorasickSingleton`
        The classifier used to identify the :class:`ModType` for some string

    ModOptFiles: :class:`AhoCorasickSingleton`
        The classifier used to identify the type of file within a mod

    DownloadModes: :class:`AhoCorasickSingleton`
        The classifier used to identify the :class:`DownloadMode` for some string

    IniModelParts: :class:`AhoCorasickSingleton`
        The classfier for the different parts of the model of a mod, according to most .ini files
    """

    ModTypes = AhoCorasickSingleton(AhoCorasickBuilder())
    ModOptFiles = AhoCorasickSingleton(AhoCorasickBuilder())
    DownloadModes = AhoCorasickSingleton(AhoCorasickBuilder())
    IniModelParts = AhoCorasickSingleton(AhoCorasickBuilder())


class DownloadMode(Enum):
    """
    The download mode of how the software handles file downloads
    """

    Disabled = "disabled"
    """
    Will not perform any file downloads for any mods
    """

    Always = "always"
    """
    Will always perform file downloads for every mod, if possible
    """

    AlwaysTex = "alwaystex"
    """
    Only download textures or .ib files
    """

    AlwaysBuf = "alwaysbuf"
    """
    Only download .buf files, if possible
    """

    Tex = "tex"
    """
    Only download textures or .ib files if there is a specified branch in the texture `sections`_ that does not reference the files
    """

    Buf = "buf"
    """
    Only download .buf files if there is a specified branch in the .vb `sections`_ that does not reference the files
    """

    HardTexDriven = "hardtexdriven"
    """
    Will perform file downloads based off the following heuristics:

    #. Download textures or .ib files if there is a specified branch in the texture `sections`_ that does not reference the files
    #. If any texture/.ib downloads needed to be performed, then download .buf files at specified branches with missing resources
    """

    HardTexDrivenAll = "texdrivenall"
    """
    Will perform file downloads based off the following heuristics:

    #. Download textures or .ib files if there is a specified branch in the texture `sections`_ that does not reference the files
    #. If any texture/.ib downloads needed to be performed, then download model .buf files at specified/unspecified branch cases with missing resources
    """

    SoftTexDriven = "softtexdriven"
    """
    Will perform file downloads based off the following heuristics:

    #. Download textures or .ib files if there is a specified branch in the texture `sections`_ that does not reference the files
    #. Download .buf files if either texture/.ib downloads needed to be performed or there are specified branch cases with missing resources
    """

    SoftTexDrivenAll = "softtexdrivenall"
    """
    Will perform file downloads based off the following heuristics:

    #. Download textures or .ib files if there is a specified branch in the texture `sections`_ that does not reference the files
    #. Download .buf files if either texture/.ib downloads needed to be performed or there are specified/unspecified branch cases with missing resources
    """

    @classmethod
    def setup(cls):
        if (GlobalClassifiers.DownloadModes.value.isSetup):
            return
        
        data = {}
        for downloadMode in cls:
            data[downloadMode.value] = downloadMode
        
        GlobalClassifiers.DownloadModes.value.setup(data)

    @classmethod
    def search(cls, mode: str) -> Optional["DownloadMode"]:
        """
        Searches a download mode based off the provided name

        Parameters
        ----------
        mode: :class:`str`
            The name of the download mode to search for

        Returns
        -------
        Optional[:class:`DownloadMode`]
            The found download mode based off the provided name
        """

        cls.setup()
        keyword, downloadMode = GlobalClassifiers.DownloadModes.value.dfa.getMaximal(mode.lower().strip(), errorOnNotFound = False)
        return downloadMode


# CommandBuilder: Class for building the command
class CommandBuilder():
    def __init__(self):
        self._argParser = argparse.ArgumentParser(description='Ports mods from characters onto their skin counterparts', formatter_class=CommandFormatter)
        self._addArguments()
        self._args = argparse.Namespace()


    def parse(self) -> argparse.Namespace:
        self._args = self._argParser.parse_args()
        self.parseArgs()
        return self._args

    def parseArgs(self):
        if (self._args.types is not None):
            self._args.types = self._args.types.split(",")

        if (self._args.remappedTypes is not None):
            self._args.remappedTypes = self._args.remappedTypes.split(",")

    def _addArguments(self):
        self._argParser.add_argument(ShortCommandOpts.Src.value, CommandOpts.Src.value, action='store', type=str, help="The starting path to run this fix. If this option is not specified, then will run the fix from the current directory.")
        self._argParser.add_argument(ShortCommandOpts.Version.value, CommandOpts.Version.value, action='store', type=str, help="The game version we want the fix to be compatible with. If this option is not specified, then will use the latest game version")
        self._argParser.add_argument(ShortCommandOpts.DeleteBackup.value, CommandOpts.DeleteBackup.value, action='store_true', help=f'deletes backup copies of the original {FileExt.Ini.value} files')
        self._argParser.add_argument(ShortCommandOpts.FixOnly.value, CommandOpts.FixOnly.value, action='store_true', help='only fixes the mod without cleaning any previous runs of the script')
        self._argParser.add_argument(ShortCommandOpts.Revert.value, CommandOpts.Revert.value, action='store_true', help='Undo the previous runs of the script')
        self._argParser.add_argument(ShortCommandOpts.HideOriginal.value, CommandOpts.HideOriginal.value, action = 'store_true', help="Show only the mod on the remapped character and do not show the mod on the original character")
        self._argParser.add_argument(ShortCommandOpts.Log.value, CommandOpts.Log.value, action='store', type=str, help=f'The folder location to log the printed out text into a seperate {FileExt.Txt.value} file. If this option is not specified, then will not log the printed out text.')
        self._argParser.add_argument(ShortCommandOpts.All.value, CommandOpts.All.value, action='store_true', help=f"""Parses all {FileTypes.Ini.value}s that the program encounters. This option supersedes the {CommandOpts.Types.value} option

For {FileTypes.Ini.value} where a mod cannot be identified, usually, you would also need to specify what particular mod the {FileTypes.Ini.value} defaults to using the {CommandOpts.DefaultType.value} option. 
Otherwise, you will be defaulted to fixing 'raiden' mods.""")
        self._argParser.add_argument(ShortCommandOpts.DefaultType.value, CommandOpts.DefaultType.value, action='store', type=str, help=f'''The default mod type to use if the {FileTypes.Ini.value} belongs to some unknown mod.

- If {CommandOpts.ForceType.value} is set to True, this option has not effect                          
- If the {CommandOpts.All.value} is set to True and no values are specified for this option, the default argument for this option is set to 'raiden'
- Otherwise, this option has not effect and any unknown mods will be skipped

See below for the different names/aliases of the supported types of mods.''')
        
        self._argParser.add_argument(ShortCommandOpts.ForceType.value, CommandOpts.ForceType.value, action='store', type=str, help=f"""Forcibly assumes the mod type for all {FileTypes.Ini.value} parsed.

This option supersedes the {CommandOpts.Types.value} option and the {CommandOpts.All.value} option.

See below for the different names/aliases of the supported types of mods.""")

        self._argParser.add_argument('-t', CommandOpts.Types.value, action='store', type=str, help=f'''Parses {FileTypes.Ini.value}s that the program encounters for only specific types of mods. If the {CommandOpts.Types.value} option has been specified, this option has no effect. 
By default, if this option is not specified, will parse the {FileTypes.Ini.value}s for all the supported types of mods. 

Please specify the types of mods using the the mod type's name or alias, then seperate each name/alias with a comma(,)
eg. raiden,arlecchino,ayaya

See below for the different names/aliases of the supported types of mods.''')

        self._argParser.add_argument(ShortCommandOpts.FixedTypes.value, CommandOpts.FixedTypes.value, action='store', type=str, help=f"""From all the mods to fix, specified by the {CommandOpts.Types.value} option, will specifically remap those mods to the mods specified by this option. 
For a mod specified by the {CommandOpts.Types.value} option, if none of its corresponding remapped mods are specified by this option, then the mod specified by the {CommandOpts.Types.value} option will be remapped to all its corresponding mods.
 
-------------------
eg.

If this program was ran with the following options:
{CommandOpts.Types.value} kequeen,jean
{CommandOpts.FixedTypes.value} jeanSea

the program will do the following remap:
keqing --> keqingOpulent
Jean --> JeanSea

Note that Jean will not remap to JeanCN
-------------------


By default, if this option is not specified, will remap all the mods specified in {CommandOpts.Types.value} to their corresponding remapped mods. 

Please specify the types of mods using the the mod type's name or alias, then seperate each name/alias with a comma(,)
eg. raiden,arlecchino,ayaya

See below for the different names/aliases of the supported types of mods.""")

        allDownloadModes = list(map(lambda mode: f"\n- {TextTools.capitalize(mode.value)}", DownloadMode))
        allDownloadModes = "".join(allDownloadModes)

        hardTexDrivenStr = TextTools.capitalize(DownloadMode.HardTexDriven.value)
        self._argParser.add_argument(ShortCommandOpts.Download.value, CommandOpts.Download.value, action = 'store', type=str, help=f"""The download mode to handle file downloads need. Below is a condensed list of all the available download modes. By default, '{hardTexDrivenStr}' is selected
For more info on the download modes, please visit the link below:
https://anime-game-remap.readthedocs.io/en/latest/commandOpts.html#download-modes
{allDownloadModes}
""")
        self._argParser.add_argument(ShortCommandOpts.Proxy.value, CommandOpts.Proxy.value, action='store', type=str, help="The link to the proxy server for those whose internet access must go through a proxy. The software will make all internet network requests through this proxy")

    def addEpilog(self, epilog: str):
        self._argParser.epilog = epilog


class Heading():
    """
    Class for handling information about a heading for pretty printing

    Examples
    --------

    .. code-block:: python
        :linenos:
        :emphasize-lines: 1,3

        ======= Title: Fix Raiden Boss 2 =======
        ...
        ========================================

    Parameters
    ----------
    title: :class:`str`
        The title for the heading :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ""

    sideLen: :class:`int`
        The number of characters we want one side for the border of the opening heading to have :raw-html:`<br />` :raw-html:`<br />`

        **Default**: 0

    sideChar: :class:`str`
        The type of character we want the border for the heading to have  :raw-html:`<br />` :raw-html:`<br />`

        **Default**: "="

    Attributes
    ----------
    title: :class:`str`
        The title for the heading

    sideLen: :class:`int`
        The number of characters we want one side for the border of the opening heading to have

    sideChar: :class:`str`
        The type of character we want the border for the heading to have
    """

    def __init__(self, title: str = "", sideLen: int = 0, sideChar: str = "="):
        self.title = title
        self.sideLen = sideLen
        self.sideChar = sideChar

    def copy(self):
        """
        Makes a new copy of a heading

        Returns
        -------
        :class:`Heading`
            The new copy of the heading
        """
        return Heading(title = self.title, sideLen = self.sideLen, sideChar = self.sideChar)

    def open(self) -> str:
        """
        Makes the opening heading (see line 1 of the example at :class:`Heading`)

        Returns
        -------
        :class:`str`
            The opening heading created
        """

        side = self.sideLen * self.sideChar
        return f"{side} {self.title} {side}"

    def close(self) -> str:
        """
        Makes the closing heading (see line 3 of the example at :class:`Heading`)

        Returns
        -------
        :class:`str`
            The closing heading created
        """

        return self.sideChar * (2 * (self.sideLen + 1) + len(self.title))


class IniKeywords(Enum):
    """
    Common keywords used in the .ini file
    """

    Hash = "hash"
    """
    The unique id for a part in the mod
    """

    Vb0 = "vb0"
    """
    Vertex buffer #0
    """

    Vb1 = "vb1"
    """
    Vertex buffer #1
    """

    Ib = "ib"
    """
    Index buffer
    """

    Handling = "handling"
    """
    How to handle some resource
    """

    Draw = "draw"
    """
    Location to draw a resource
    """

    DrawIndexed = "drawindexed"
    """
    How to draw the triangular of the model
    """

    Resource = "Resource"
    """
    The starting prefix used for any `sections`_ that reference some file
    """

    Blend = "Blend"
    """
    The substring that usually occurs in the name of a `section`_ to indicate that the `section`_ will call some *.Blend.buf file
    """

    Position = "Position"
    """
    The substring that usually occurs in the name of a `section`_ to indicate that the `section`_ will call some *.Position.buf file
    """

    Texcoord = "Texcoord"
    """
    The substring that usually occurs in the name of a `section`_ to indicate that the `section`_ will call some *.Texcoord.buf file
    """

    Run = "run"
    """
    The subsection that will be called from a certain `section`_
    """

    MatchFirstIndex = "match_first_index"
    """
    The index location to map some resource
    """

    Remap = f"Remap"
    """
    The substring used to indicate a `section`_ is editted by this software
    """

    RemapBlend = f"{Remap}{Blend}"
    """
    The substring used to indicate that the `section`_ references some *.RemapBlend.buf file
    """

    RemapPosition = f"{Remap}{Position}"
    """
    The substring used to indicate that the `section`_ references some *.RemapPosition.buf file
    """

    RemapTexcoord = f"{Remap}{Texcoord}"
    """
    The substring used to indicate that the `section`_ is called by ``[TextureOverride.*Texcoord.*]`` section.
    """

    RemapFix = f"{Remap}Fix"
    """
    The substring used to indicate that the `section`_ was created by this program 
    """

    RemapTex = f"{Remap}Tex"
    """
    The substring used to indicate that the `section`_ contains some editted/created texture *.Remap.dds file
    """

    RemapDL = f"{Remap}DL"
    """
    The substring used to indicate that the `section`_ contains some downloaded file from the internet
    """

    RemapIb = f"{Remap}IB"
    """
    The substring used to indicate that the `section`_ is called by ``[TextureOverride.*Ib.*]`` section.
    """

    Filename = f"filename"
    """
    The filename for some resource
    """

    HashNotFound = "HashNotFound"
    """
    The hash for a mod has not been found
    """

    IndexNotFound = "IndexNotFound"
    """
    The index for a mod has not been found
    """

    ORFixPath = r"CommandList\global\ORFix\ORFix"
    """
    The sub command call to `ORFix`_
    """

    TexFxFolder = r"CommandList\TexFx"
    """
    The folder to the sub command call to the `TexFx`_ module
    """

    TexFxShortTransparency0 = TexFxFolder + r"\T.0"
    """
    Short alias of transparency sub command in `TexFx`_ module mapping to ps-t0
    """

    TexFxShortTransparency1 = TexFxFolder + r"\T.1"
    """
    Short alias of transparency sub command in `TexFx`_ module mapping to ps-t1
    """

    TexFxShortTransparency0Natlan = TexFxFolder + r"\TN.0"
    """
    Short alias of transparency sub command in `TexFx`_ module mapping to ps-t0 for GI version 5.0 +
    """

    TexFxShortTransparency1Natlan = TexFxFolder + r"\TN.1"
    """
    Short alias of transparency sub command in `TexFx`_ module mapping to ps-t1 for GI version 5.0 +
    """

    HideOriginalComment = r";RemapFixHideOrig -->"
    """
    Comment used to hide the `sections`_ or the original character
    """


class IniBoilerPlate(Enum):
    """
    Boilerplate constants used for fixing a .ini file    

    Attributes
    ----------
    ShortModTypeNameReplaceStr: :class:`str`
        Placeholder for the shortened name of the mod to fix

    ModTypeNameReplaceStr: :class:`str`
        Placeholder for the name of the mod to fix

    Credit: :class:`str`
        The credit text used in the .ini file

    OldHeading: :class:`Heading`
        The heading used for .ini files fixed by an older version of this software

    DefaultHeading: :class:`Heading`
        The current heading used when fixing .ini files
    """

    ShortModTypeNameReplaceStr = "{{shortModTypeName}}"
    ModTypeNameReplaceStr = "{{modTypeName}}"
    Credit = f'\n; {ModTypeNameReplaceStr}remapped by Albert Gold#2696 and NK#1321. If you used it to remap your {ShortModTypeNameReplaceStr}mods pls give credit for "Albert Gold#2696" and "Nhok0169"\n; Thank nguen#2011 SilentNightSound#7430 HazrateGolabi#1364 for support'

    OldHeading = Heading(".*Boss Fix", 15, "-")
    DefaultHeading = Heading(".*Remap", 15, "-")


class IniComments(Enum):
    GIMIObjMergerPreamble = """; This is really bad!! Don't do this!
; ************************************
;
; jk, but joking aside...
;
; The goal is to display n mod objects from the mod to be remapped to the mod onto a single mod object of the remapped mod.
;   Therefore we will have n sets of resources all mapping onto a single index (and same hash).
;
; Ideally, we would want all the sections to be within a single .ini file. The naive approach would be to create n sets of sections
;   (not a single section, cuz you need to include the case of sections depending on other sections, which form a section caller/callee graph) 
;    where the sections names are all unique. However, this approach will trigger a warning on GIMI (or any GIMI like importer) of multiple sections
;   mapping to the same hash and only 1 of the mod objects will be displayed
;
; The next attempt would be to take advantage of GIMI's overlapping mod bug/feature from loading multiple mods of the same character
;   Apart from the original .ini file, there would be n-1 newly generated .ini files (total of n .ini files). Each .ini file would uniquely
;   display a single set of sections from the n sets of sections. The overlapping property from the bug/feature would allow for all the objects to be displayed.
;
; For now, we were lazy and just simply copied the original .ini file onto the generated .ini files, which results in the original mod to have overlapping copies.
;  But since the mod used in all the .ini files are exactly the same, the user would not see the overlap (they may have some performance issues depending on the size of n. But
;   usually remaps only merge 2 mod objects into a single mod object, which should not cause much of an issue)
;   We could optimize the amount of space taken up by the newly generated .ini files, by only putting the necessary sections, but that is for another day..."""


class ModTypeNames(Enum):
    """
    The names of the different types of mods this fix will fix from or fix to
    """
    
    Amber = "Amber"
    """
    Amber from GI
    """

    AmberCN = "AmberCN"
    """
    Amber Chinese version from GI
    """

    Ayaka = "Ayaka"
    """
    Ayaka from GI
    """

    AyakaSpringbloom = "AyakaSpringBloom"
    """
    Ayaka Fontaine skin from GI
    """

    Arlecchino = "Arlecchino"
    """
    Arlecchino from GI
    """

    ArlecchinoBoss = "ArlecchinoBoss"
    """
    The first phase of the Arlecchino boss from GI
    """

    Barbara = "Barbara"
    """
    Barabara from GI
    """

    BarbaraSummertime = "BarbaraSummertime"
    """
    Barbara summer skin from GI
    """

    CherryHuTao = "CherryHuTao"
    """
    Hu Tao Lantern Rite skin from GI
    """

    Diluc = "Diluc"
    """
    Diluc from GI
    """

    DilucFlamme = "DilucFlamme"
    """
    Diluc Red Dead of the Night skin from GI
    """

    Fischl = "Fischl"
    """
    Fischl from GI
    """

    FischlHighness = "FischlHighness"
    """
    Fischl summer skin from GI
    """

    Ganyu = "Ganyu"
    """
    Ganyu from GI
    """

    GanyuTwilight = "GanyuTwilight"
    """
    Ganyu Lantern Rite skin from GI
    """

    HuTao = "HuTao"
    """
    HuTao from GI
    """

    Jean = "Jean"
    """
    Jean from GI
    """

    JeanCN = "JeanCN"
    """
    Jean Chinese version from GI
    """

    JeanSea = "JeanSea"
    """
    Jean summer skin from GI
    """

    Kaeya = "Kaeya"
    """
    Kaeya from GI
    """

    KaeyaSailwind = "KaeyaSailwind"
    """
    KaeyaSailwind from GI
    """

    Keqing = "Keqing"
    """
    Keqing from GI
    """

    KeqingOpulent = "KeqingOpulent"
    """
    Keqing Lantern Rite skin from GI
    """

    Kirara = "Kirara"
    """
    Kirara from GI
    """

    KiraraBoots = "KiraraBoots"
    """
    Kirara summer skin from GI
    """

    Klee = "Klee"
    """
    Klee from GI
    """

    KleeBlossomingStarlight = "KleeBlossomingStarlight"
    """
    Klee summer skin from GI
    """

    Lisa = "Lisa"
    """
    Lisa from GI
    """

    LisaStudent = "LisaStudent"
    """
    Lisa Sumeru skin from GI
    """

    Mona = "Mona"
    """
    Mona from GI
    """

    MonaCN = "MonaCN"
    """
    Mona Chinese version from GI
    """

    Nilou = "Nilou"
    """
    Nilou from GI
    """

    NilouBreeze = "NilouBreeze"
    """
    Nilou summer skin from GI
    """

    Ningguang = "Ningguang"
    """
    Ningguang from GI
    """

    NingguangOrchid = "NingguangOrchid"
    """
    Ningguang Lantern Rite from GI
    """

    Raiden = "Raiden"
    """
    Ei from GI
    """

    RaidenBoss = "RaidenBoss"
    """
    The first phase of the Raiden Shogun boss from GI
    """

    Rosaria = "Rosaria"
    """
    Rosaria from GI
    """

    RosariaCN = "RosariaCN"
    """
    Rosaria Chinese version from GI
    """

    Shenhe = "Shenhe"
    """
    Shenhe from GI
    """

    ShenheFrostFlower = "ShenheFrostFlower"
    """
    Shenhe Lantern Rite skin from GI
    """

    Xiangling = "Xiangling"
    """
    Xiangling from GI
    """

    XianglingCheer = "XianglingCheer"
    """
    Xiangling Lantern Rite skin from GI
    """

    Xingqiu = "Xingqiu"
    """
    Xingqiu from GI
    """

    XingqiuBamboo = "XingqiuBamboo"
    """
    Xingqiu Lantern Rite skin from GI
    """


class ModTypeBuilder():
    """
    Class to create a new :class:`ModType` for different mods
    """
    pass


class FlyweightBuilder(Builder[BuildCls]):
    """
    This class inherits from :class:`Builder`

    A flyweight builder for building the same reusable objects (based off `flyweight design pattern`_)

    Parameters
    ----------
    buildCls: Type[T]
        The class for the objects to be built from

    args: Optional[List[Any]]
        The constant arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, buildCls: Type[BuildCls], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        super().__init__(buildCls, args, kwargs)
        self._cache = {}

    def build(self, args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None, id: Optional[Hashable] = None, cache: bool = True) -> BuildCls:
        """
        Builds the object

        Parameters
        ----------
        args: Optional[List[Any]]
            arguments to build the object :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        kwargs: Optional[Dict[str, Any]]
            keyword arguments to build the object :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        id: Optional[Hashable]
            The id for the repeating states to be built by the object :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will auto-generate an id :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        cache: :class:`bool`
            Whether to cache the built object

            .. note::
                If this value is set to ``False``, then this function behaves the same as :meth:`Builder.build`

            **Default**: ``True``

        Returns
        -------
        T
            The built objects
        """

        if (args is None):
            args = []

        if (kwargs is None):
            kwargs = {}

        if (not cache):
            return super().build(*args, **kwargs)

        if (id is None):
            id = str(uuid.uuid4())

        result = None
        try:
            result = self._cache[id]
        except KeyError:
            result = super().build(*args, **kwargs)
            self._cache[id] = result

        return result


class BaseIniRemover():
    """
    Base class to remove fixes from a .ini file

    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to remove the fix from

    Attributes
    ----------
    iniFile: :class:`IniFile`
        The .ini file that will be parsed
    """

    def __init__(self, iniFile: "IniFile"):
        self.iniFile = iniFile

    @staticmethod
    def _readLines(func):
        """
        Decorator to read all the lines in the .ini file first before running a certain function

        All the file lines will be saved in :attr:`IniFile._fileLines`

        Examples
        --------
        .. code-block:: python
            :linenos:

            @_readLines
            def printLines(self):
                for line in self.iniFile.fileLines:
                    print(f"LINE: {line}")
        """

        def readLinesWrapper(self, *args, **kwargs):
            if (not self.iniFile._fileLinesRead):
                self.iniFile.readFileLines()
            return func(self, *args, **kwargs)
        return readLinesWrapper

    def remove(self, parse: bool = False, writeBack: bool = True) -> str:
        """
        Removes the fix from the .ini file

        Parameters
        ----------
        parse: :class:`bool`
            Whether to also parse for the .*RemapBlend.buf files that need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        writeBack: :class:`bool`
            Whether to write back the new text content of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        :class:`str`
            The new content of the .ini file
        """
        pass


class IniRemoveBuilder(FlyweightBuilder[BaseIniRemover]):
    """
    This class inherits from :class:`FlyweightBuilder`

    A class to help dynamically build a :class:`BaseIniRemover`

    Parameters
    ----------
    cls: Type[:class:`BaseIniRemover`]
        The class to construct a :class:`BaseIniRemover` 

    args: Optional[List[Any]]
        The constant arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    cache: :class:`bool`
        Whether to cache the built object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    Attributes
    ----------
    cache: :class:`bool`
        Whether to cache the built object
    """

    def __init__(self, cls: Type[BaseIniRemover], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None, cache: bool = True):
        super().__init__(cls, args, kwargs)
        self.cache = cache

    def build(self, iniFile: "IniFile", id: Optional[Hashable] = None) -> BaseIniRemover:
        """
        Builds the remover

        Parameters
        ----------
        iniFile: :class:`IniFile`
            The .ini file to parse
        
        id: Optional[`Hashable`_]
            The id to give the flyweight object that will be built

            .. note::
                By default, if argument is set to ``None``, the id of the flyweight class that is built is 
                determined by the class name of the :class:`IniFile` object passed. 

            **Default**: ``None``

        Returns
        -------
        :class:`BaseIniRemover`
            The built remover
        """

        if (id is None):
            id = self._buildCls.__name__

        result = super().build(args = [iniFile], id = id, cache = self.cache)
        result.iniFile = iniFile
        return result


class FilePrefixes(Enum):
    OldBackupFilePrefixV3 = "DISABLED_BossFixBackup_"
    OldBackupFilePrefixV4_3 = "DISABLED_RemapBackup_"
    BackupFilePrefix = "RemapBKUP"


class FilePathConsts():
    DefaultPath = os.getcwd()
    CurrentDir = "."

    @classmethod
    def getPath(cls, path: Optional[str]) -> str:
        if (path is None):
            return cls.DefaultPath
        return path


class FileEncodings(Enum):
    UTF8 = "utf-8"
    Latin1 = "latin1"


IniFileEncoding = FileEncodings.UTF8.value
ReadEncodings = [IniFileEncoding, FileEncodings.Latin1.value]


class FilePath():
    """
    Class for storing info about a file path

    Parameters
    ----------
    path: :class:`str`
        The file path
    """

    def __init__(self, path: str):
        self._folder = ""
        self._base = ""
        self._baseName = ""
        self.path = path

    @property
    def path(self):
        """
        The file path

        :getter: Retrieves the path
        :setter: Sets a new path
        :type: :class:`str`
        """
        return self._path
    
    @path.setter
    def path(self, newPath: str):
        self._path = newPath
        self._folder = os.path.dirname(newPath)
        self._base = os.path.basename(newPath)
        self._baseName = os.path.splitext(self._base)[0]

    @property
    def folder(self):
        """
        The parent folder for the path

        :getter: Retrieves the parent folder name
        :setter: Sets the new parent folder name
        :type: :class:`str`
        """
        return self._folder
    
    @folder.setter
    def folder(self, newFolder: str):
        self._folder = newFolder
        self._path = os.path.join(self._folder, self._base)
    
    @property
    def base(self):
        """
        The base for the file path (includes file extension)

        :getter: Retrieves the base
        :setter: Sets the new base for the file path
        :type: :class:`str`
        """
        return self._base
    
    @base.setter
    def base(self, newBase: str):
        self._base = newBase
        self._path = os.path.join(self._folder, self._base)
        self._baseName = os.path.splitext(self._base)[0]

    @property
    def baseName(self):
        """
        The basename for the file path without any file extensions

        :getter: Retrieves the basename
        :setter: Sets the new basename for the file path
        :type: :class:`str`
        """
        return self._baseName
    
    @baseName.setter
    def baseName(self, newBaseName: str):
        self._baseName = newBaseName
        oldBaseName, ext = os.path.splitext(self._base)
        self._base = f"{self._baseName}{ext}"
        self._path = os.path.join(self._folder, self._base)


class Error(Exception):
    """
    The base exception used by this module

    Parameters
    ----------
    message: :class:`str`
        the error message to print out
    """

    def __init__(self, message: str):
        super().__init__(f"ERROR: {message}")


class FileException(Error):
    """
    This Class inherits from :class:`Error`

    Exceptions relating to files

    Parameters
    ----------
    message: :class:`str`
        The error message to print out

    path: Optional[:class:`str`]
        The path where the error for the file occured. If this value is ``None``, then the path
        will be the current directory where this module is loaded :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, message: str, path: Optional[str] = None):
        path = FilePathConsts.getPath(path)

        if (path != FilePathConsts.DefaultPath):
            message += f" at {path}"

        super().__init__(message)


class MissingFileException(FileException):
    """
    This Class inherits from :class:`FileException`

    Exception when a certain type of file is missing from a folder

    Parameters
    ----------
    fileType: :class:`str`
        The type of file searching in the folder :raw-html:`<br />` :raw-html:`<br />`

        **Default**: "file"

    path: :class:`str`
        The path to the folder that is being searched. If this value is ``None``, then the path
        will be the current directory where this module is loaded :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    fileType: :class:`str`
        The type of file searching in the folder
    """
    def __init__(self, fileType: str = FileTypes.Default.value, path: Optional[str] = None):
        path = FilePathConsts.getPath(path)
        message = f"Unable to find {fileType}. Ensure it is in the folder"
        self.fileType = fileType
        super().__init__(message, path = path)


class DuplicateFileException(FileException):
    """
    This Class inherits from :class:`FileException`

    Exception when there are multiple files of the same type in a folder

    Parameters
    ----------
    files: List[:class:`str`]
        The files that triggered the exception

    fileType: :class:`str`
        The name for the type of files :raw-html:`<br />` :raw-html:`<br />`

        **Default**: "file"

    path: Optional[:class:`str`]
        The path to the folder where the files are located If this value is ``None``, then the path
        will be the current directory where this module is loaded :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    files: List[:class:`str`]
        The files that triggered the exception

    fileType: :class:`str`
        The name for the type of files

        **Default**: ``None``
    """

    def __init__(self, files: List[str], fileType: str = FileTypes.Default.value, path: Optional[str] = None):
        path = FilePathConsts.getPath(path)
        self.files = files
        self.fileType = fileType
        message = f"Ensure only one {fileType} exists"
        super().__init__(message, path = path)


class FileService():
    """
    Tools for handling with files and folders :raw-html:`<br />` :raw-html:`<br />`
    """

    @classmethod
    def getFilesAndDirs(cls, path: Optional[str] = None, recursive: bool = False) -> List[List[str]]:
        """
        Retrieves the files and folders contained in a certain folder

        Parameters
        ----------
        path: Optional[:class:`str`]
            The path to the target folder we are working with. If this argument is ``None``, then will use the current directory of where this module is loaded
            :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        recursive: :class:`bool`
            Whether to recursively check all the folders from our target folder :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        [List[:class:`str`], List[:class:`str`]]
            The files and directories within the folder. The order for the result is:

            #. files
            #. folders
        """
        path = cls.getPath(path)
        files = []
        dirs = []

        pathItems = []
        
        if (recursive):
            for root, currentDirs, currentFiles in os.walk(path, topdown = True):
                for dir in currentDirs:
                    dirs.append(os.path.join(root, dir))

                for file in currentFiles:
                    files.append(os.path.join(root, file))

            return [files, dirs]
        
        pathItems = os.listdir(path)
        for itemPath in pathItems:
            fullPath = os.path.join(path, itemPath)
            if (os.path.isfile(fullPath)):
                files.append(fullPath)
            else:
                dirs.append(fullPath)

        return [files, dirs]

    # filters and partitions the files based on the different filters specified
    @classmethod
    def getFiles(cls, path: Optional[str] = None, filters: Optional[List[Callable[[str], bool]]] = None, files: Optional[List[str]] = None) -> Union[List[str], List[List[str]]]:
        """
        Retrieves many different types of files within a folder

        .. note::
            Only retrieves files that are the direct children of the folder (will not retrieve files nested in a folder within the folder we are searching)

        Parameters
        ----------
        path: Optional[:class:`str`]
            The path to the target folder we are working with. If this value is set to ``None``, then will use the current directory of where this module is loaded
            :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        filters: Optional[List[Callable[[:class:`str`], :class:`bool`]]]
            Different filter functions for each type of file we are trying to get. If this values is either ``None`` or ``[]``, then will default to a filter to get all the files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        files: Optional[List[:class:`str`]]
            The files contained in the target folder

            If this value is set to ``None``, then the function will search for the files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Union[List[:class:`str`], List[List[:class:`str`]]]
            The files partitioned into the different types specified by the filters

            If 'filters' only has 1 element, then the function returns List[:class:`str`]
            Otherwise, will return List[List[:class:`str`]]
        """

        path = cls.getPath(path)
        result = []

        if (filters is None):
            filters = []

        if (not filters):
            filters.append(lambda itemPath: True)

        filtersLen = len(filters)
        usePathFiles = False
        if (files is None):
            files = os.listdir(path)
            usePathFiles = True

        for i in range(filtersLen):
            result.append([])
        
        for itemPath in files:
            for filterInd in range(filtersLen):
                pathFilter = filters[filterInd]
                if (not pathFilter(itemPath) or (usePathFiles and not os.path.isfile(os.path.join(path, itemPath)))):
                    continue

                fullPath = os.path.join(path, itemPath)

                result[filterInd].append(fullPath)

        if (filtersLen == 1):
            return result[0]
        
        return result
    
    # retrieves only a single file for each filetype specified by the filters
    @classmethod
    def getSingleFiles(cls, path: Optional[str] = None, filters: Optional[Dict[str, Callable[[str], bool]]] = None, files: Optional[List[str]] = None, optional: bool = False) -> Union[Optional[str], List[str], List[Optional[str]]]:
        """
        Retrieves exactly 1 of each type of file in a folder

        Parameters
        ----------
        path: Optional[:class:`str`]
            The path to the target folder we are searching. :raw-html:`<br />` :raw-html:`<br />`
            
            If this value is set to ``None``, then will use the current directory of where this module is loaded :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        filters: Optional[Dict[str, Callable[[:class:`str`], :class:`bool`]]]
            Different filter functions for each type of file we are trying to get. If this value is ``None`` or ``{}``, then will default to use a filter to get all files

            The keys are the names for the file type :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        files: Optional[List[:class:`str`]]
            The files contained in the target folder

            If this value is set to ``None``, then the function will search for the files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        optional: :class:`bool`
            Whether we want to send an exception if there is not exactly 1 file for a certain type of file :raw-html:`<br />` :raw-html:`<br />`

            #. If this value is ``False`` and there are no files for a certain type of file, then will raise a :class:`MissingFileException`
            #. If this value is ``False`` and there are more than 1 file for a certain type of file, then will raise a :class:`DuplicateFileException`
            #. If this value is ``True`` and there are no files for a certain type of file, then the file for that type of file will be ``None``
            #. If this value is ``True`` and there are more than 1 file for a certain type of file, then will retrieve the first file for that type of file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Raises
        ------
        :class:`MissingFileException`
            if ``optional`` is set to ``False`` and there are not files for a certain type of file

        :class:`DuplicateFileException`
            if ``optional`` is set to ``False`` and there are more than 1 file for a certain type of file

        Returns
        -------
        Union[Optional[:class:`str`], List[:class:`str`], List[Optional[:class:`str`]]]
            The files partitioned for each type of file

            * If ``filters`` only contains 1 element and ``optional`` is ``False``, then will return :class:`str`
            * If ``filters`` contains more than 1 element and ``optional`` is ``False`, then will return List[:class:`str`]
            * If ``filters`` only contains 1 element and ``optional`` is ``True``, then will return Optional[:class:`str`]
            * Otherwise, returns List[Optional[:class:`str`]]
        """
        path = cls.getPath(path)
        if (filters is None):
            filters = {}

        if (not filters):
            filters[FileTypes.Default.value] = lambda itemPath: True
        
        filesPerFileTypes = cls.getFiles(path = path, filters = list(filters.values()), files = files)
        filtersLen = len(filters)

        onlyOneFilter = filtersLen == 1
        if (onlyOneFilter):
            filesPerFileTypes = [filesPerFileTypes]

        result = []
        i = 0
        for fileType in filters:
            fileTypeFiles = filesPerFileTypes[i]
            filesLen = len(fileTypeFiles)

            if (not optional and not filesLen):
                raise MissingFileException(fileType = fileType, path = path)
            elif (not optional and filesLen > 1):
                raise DuplicateFileException(fileTypeFiles, fileType = fileType, path = path)
            
            if (fileTypeFiles):
                result.append(fileTypeFiles[0])
            else:
                result.append(None)
            i += 1

        if (onlyOneFilter):
            return result[0]
        
        return result
    
    @classmethod
    def rename(cls, oldFile: str, newFile: str):
        """
        Renames a file

        .. warning::
            If the new name for the file already exists, then the function deletes
            the file with the new name and renames the target file with the new name

        Parameters
        ----------
        oldFile: :class:`str`
            file path to the target file we are working with

        newFile: :class:`str`
            new file path for the target file 
        """
        if (oldFile == newFile):
            return

        try:
            os.rename(oldFile, newFile)
        except FileExistsError:
            os.remove(newFile)
            os.rename(oldFile, newFile)

    @classmethod
    def changeExt(cls, file: str, newExt: str) -> str:
        """
        Changes the extension for a file

        Parameters
        ----------
        file: :class:`str`
            The file path to the file we are working with

        newExt: :class:`str`
            The name of the new extension for the file (without the dot at front)

        Returns
        -------
        :class:`str`
            the new file path with the extension changed
        """

        dotPos = file.rfind(".")

        if (not newExt.startswith(".")):
            newExt = f".{newExt}"

        if (dotPos != -1):
            file = file[:dotPos] + newExt

        return file

    @classmethod
    def disableFile(cls, file: str, filePrefix: str = FilePrefixes.BackupFilePrefix.value) -> str:
        """
        Marks a file as disabled and changes the file to a .txt file

        Parameters
        ----------
        file: :class:`str`
            The file path to the file we are working with

        filePrefix: :class:`str`
            Prefix name we want to add in front of the file name :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``"RemapBKUP"``

        Returns
        -------
        :class:`str`
            The new name of the file
        """

        baseName = os.path.basename(file)
        baseName = FileService.changeExt(baseName, FileExt.Txt.value)

        backupFile = os.path.join(os.path.dirname(file), filePrefix + baseName)
        FileService.rename(file, backupFile)
        return backupFile

    @classmethod
    def copyFile(cls, src: str, dest: str):
        """
        Copies a file from ``src`` to ``dest``

        Parameters
        ----------
        src: :class:`str`
            The file path to the file to be copied

        dest: :class:`str`
            The new file path for the copied file
        """

        shutil.copy2(src, dest)

    @classmethod
    def parseOSPath(cls, path: str):
        """
        Retrieves a normalized file path from a string

        Parameters
        ----------
        path: :class:`str`
            The string containing some sort of file path
        """

        result = ntpath.normpath(path)
        result = cls.ntPathToPosix(result)
        return result

    @classmethod
    def ntPathToPosix(cls, path: str) -> str:
        """
        Converts a file path from the `ntpath <https://opensource.apple.com/source/python/python-3/python/Lib/ntpath.py.auto.html>`_ library to a file path for the `os <https://docs.python.org/3/library/os.html>`_ library

        .. note::
            The character for the folder paths (``/`` or ``\\``) used in both libraries may be different depending on the OS

        Parameters
        ----------
        path: :class:`str`
            The file path we are working that is generated from the 'ntpath' library

        Returns
        -------
        :class:`str`
            The file path generated by the 'os' library
        """

        return path.replace(ntpath.sep, os.sep)
    
    @classmethod
    def absPathOfRelPath(cls, dstPath: str, relFolder: str) -> str:
        """
        Retrieves the absolute path of the relative path of a file with respect to a certain folder

        Parameters
        ----------
        dstPath: :class:`str`
            The target file path we are working with

        relFolder: :class:`str`
            The folder that the target file path is relative to

        Returns
        -------
        :class:`str`
            The absolute path for the target file
        """

        relFolder = os.path.abspath(relFolder)
        result = dstPath
        if (not os.path.isabs(result)):
            result = os.path.join(relFolder, result)

        return cls.parseOSPath(result)
    
    @classmethod
    def getRelPath(cls, path: str, start: str) -> str:
        """
        Tries to get the relative path of a file/folder relative to another folder, if possible.

        If it is not possible to get the relative path, will return back the original file path

        .. note::
            An example where it would not be possible to get the relative path would be:
            
            * If the file is located in one mount (eg. C:/ drive) and the folder is located in another mount (eg. D:/ drive)

        Parameters
        ----------
        path: :class:`str`
            The path to the target file/folder we are working with

        start: :class:`str`
            The path that the target file/folder is relative to

        Returns
        -------
        :class:`str`
            Either the relative path or the original path if not possible to get the relative paths
        """

        result = path
        try:
            result = os.path.relpath(path, start)

        # if the path is in another mount than 'start'
        except ValueError:
            pass

        return cls.parseOSPath(result)
    
    # read(file, fileCode, postProcessor): Tries to read a file using different encodings
    @classmethod
    def read(cls, file: str, fileCode: str, postProcessor: Callable[[TextIoWrapper], Any]) -> Any:
        """
        Tries to read a file using different file encodings

        Will interact with the file using the following order of encodings:

        #. utf-8 
        #. latin1

        Parameters
        ----------
        file: :class:`str`
            The file we are trying to read from

        fileCode: :class:`str`
            What `file mode <https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files>`_ to interact with the file (eg. r, rb, r+, etc...)

        postProcessor: Callable[[`TextIoWrapper`_], Any]
            A function used to process the file pointer of the opened file

        Returns
        -------
        Any
            The result after processing the file pointer of the opened file
        """

        error = None
        for encoding in ReadEncodings:
            try:
                with open(file, fileCode, encoding = encoding) as f:
                    return postProcessor(f)
            except UnicodeDecodeError as e:
                error = e

        if (error is not None):
            raise UnicodeDecodeError(f"Cannot decode the file using any of the following encodings: {ReadEncodings}")
        
    @classmethod
    def readBinary(cls, src: Union[str, bytes]) -> bytes:
        """
        Reads a binary file

        Parameters
        ----------
        src: Union[:class:`str`, :class:`bytes`]
            The source to read from

        Returns
        -------
        :class:`bytes`
            The read bytes
        """

        result = None
        if (isinstance(src, str)):
            with open(src, "rb") as f:
                result = f.read()
        else:
            result = src

        return result
    
    @classmethod
    def writeBinary(cls, file: str, data: bytes):
        """
        Writes data into a binary file

        Parameters
        ----------
        file: :class:`str`
            The file to write into

        data: :class:`bytes`
            The data to write
        """

        with open(file, "wb") as f:
            f.write(data)

    @classmethod
    def getPath(cls, path: Optional[str]) -> str:
        return FilePathConsts.getPath(path)


class FileDownload():
    """
    Class to handle file downloads from some server

    Parameters
    ----------
    url: :class:`str`
        The link to the file download

    filename: :class:`str`
        The base name of the file (with extension)

    cache: :class:`bool`
        Whether to copy the previous downloaded file if possible instead of
        downloading another copy of the file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    Attributes
    ----------
    url: :class:`str`
        The link to the file download

    filename: :class:`str`
        The base name of the file (with extension)

    cache: :class:`bool`
        Whether to copy the previous downloaded file if possible instead of
        downloading another copy of the file

    _prevPath: Optional[:class:`str`]
        The previous full path to the downloaded file
    """

    def __init__(self, url: str, filename: str, cache: bool = True):
        self.url = url
        self.filename = filename
        self.cache = cache

        self._prevPath: Optional[str] = None

    def download(self, folder: str, proxy: Optional[str] = None) -> str:
        """
        Downloads the required file

        Parameters
        ----------
        folder: :class:`str`
            The folder to store the downloaded file

        proxy: Optional[:class:`str`]
            The link to the proxy server used for any internet network access :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        proxies = None if (proxy is None) else {"http": proxy, "https": proxy, "ftp": proxy}

        filename = os.path.join(folder, os.path.basename(self.filename))

        requests = GlobalPackageManager.Packager.get(PackageModules.Requests.value)
        fileRequest = requests.get(self.url, proxies = proxies)

        FileService.writeBinary(filename, fileRequest.content)
        return filename
    
    def get(self, folder: str, proxy: Optional[str] = None) -> Tuple[str, bool, bool]:
        """
        Retrieves the required file

        Parameters
        ----------
        folder: :class:`str`
            The folder to store the downloaded file

        proxy: Optional[:class:`str`]
            The link to the proxy server used for any internet network access :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns 
        -------
        Tuple[:class:`str`, :class:`bool`, :class:`bool`]
            A tuple that contains:

            #. The path to the downloaded file
            #. Whether a download occured
            #. Whether a previous download to the file existed
        """

        wasDownloaded = self._prevPath is None
        if (not self.cache or wasDownloaded):
            self._prevPath = self.download(folder, proxy = proxy)
            return (self._prevPath, True, wasDownloaded)

        filename = os.path.join(folder, os.path.basename(self.filename))
        downloadRequired = False

        if (self._prevPath == filename):
            return (filename, downloadRequired, wasDownloaded)

        try:
            shutil.copy(self._prevPath, filename)
        except Exception as e:
            self._prevPath = self.download(folder, proxy = proxy)
            downloadRequired = True
        
        return (filename, downloadRequired, wasDownloaded)


class IfPredPartType(Enum):
    """
    Enum for the possible types for an :class:`IfPredPart`
    """

    If = "if"
    """
    The part contains the staring keyword 'if'
    """

    Else = "else"
    """
    The part contains the staring keyword 'else'
    """

    Elif = "elif"
    """
    The part contains the starting keyword 'elif'
    """

    EndIf = "endif"
    """
    The part contains the staring keyword 'endif'
    """

    @classmethod
    def getType(cls, rawPredPart: str):
        """
        Retrieves the type for an :class:`IfPredPart`

        Parameters
        ----------
        rawPredPart: :class:`str`
            The predicate string for the :class:`IfPredPart`

        Returns
        -------
        Optional[:class:`IfPredPartType`]
            The type found based off 'rawPredPart'
        """

        cleanedRawPart = rawPredPart.strip().lower()

        if (cleanedRawPart.startswith(cls.If.value)):
            return cls.If
        elif (cleanedRawPart.startswith(cls.EndIf.value)):
            return cls.EndIf
        elif (cleanedRawPart.startswith(cls.Elif.value)):
            return cls.Elif
        elif (not cleanedRawPart.startswith(cls.Else.value)):
            return None
        
        cleanedRawPart = cleanedRawPart[len(cls.Else.value):].lstrip()
        if (cleanedRawPart.startswith(cls.If.value)):
            return cls.Elif
        return cls.Else


HashData = {
        1.0: {ModTypeNames.Barbara.value: {"draw_vb": "f41c47cf", "position_vb": "85282151", "blend_vb": "02089582", "texcoord_vb": "0f18519e", "ib": "231723d2",
                    "tex_head_diffuse": "d9d24fbf", "tex_head_lightmap": "f89f1ed6", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "d5fd9da6", "tex_body_lightmap": "0c0ce0ef", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_dress_diffuse": "d5fd9da6", "tex_dress_lightmap": "0c0ce0ef", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "d9f80241", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"}},
        3.7: {ModTypeNames.Lisa.value: {"draw_vb": "6f4a034a", "position_vb": "7d8a4e0f", "blend_vb": "de1311ae", "texcoord_vb": "50ae5602", "ib": "695e029f",
                                        "tex_head_diffuse": "b542085f", "tex_head_lightmap": "f69e017e", "tex_head_shadowramp": "7eb5b84e",
                                        "tex_body_diffuse": "2014031e", "tex_body_lightmap": "aa3b4074", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                                        "tex_dress_diffuse": "2014031e", "tex_dress_lightmap": "aa3b4074", "tex_dress_shadowramp": "7eb5b84e"}},
        4.0 : {ModTypeNames.Amber.value: {"draw_vb": "870a7499", "position_vb": "caddc4c6", "blend_vb": "ca5bd26e", "texcoord_vb": "e3047676", "ib": "9976d124",
                 "tex_head_diffuse": "ae27902d", "tex_head_lightmap": "29b001ba", "tex_head_shadowramp": "7eb5b84e",
                 "tex_body_diffuse": "bc86882f", "tex_body_lightmap": "9e1294dd", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                 "tex_face_diffuse": "1d064079", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.AmberCN.value: {"draw_vb": "da0adf2f", "position_vb": "7f94e8da", "blend_vb": "f35340d5", "texcoord_vb": "dbc594b6", "ib": "8cc9274b",
                    "tex_head_diffuse": "ae27902d", "tex_head_lightmap": "29b001ba", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "f683bcac", "tex_body_lightmap": "69b6e698", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "1d064079", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Ayaka.value: {"draw_vb": "14c9337a", "position_vb": "0107925f", "blend_vb": "3d534190", "texcoord_vb": "0c7e5f66", "ib": "347bb8f8",
                 "tex_head_diffuse": "b017ea8d", "tex_head_lightmap": "6922f755", "tex_head_shadowramp": "7eb5b84e",
                 "tex_body_diffuse": "2991152b", "tex_body_lightmap": "9e7eb1bf", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                 "tex_dress_diffuse": "2991152b", "tex_dress_lightmap": "9e7eb1bf", "tex_dress_shadowramp": "7eb5b84e",
                 "tex_face_diffuse": "146097c4", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.AyakaSpringbloom.value: {"draw_vb": "8d173084", "position_vb": "cf78a1d0", "blend_vb": "f47a5c08", "texcoord_vb": "3990db1d", "ib": "bb6ced0e",
                 "tex_head_normalmap": "379f92ff", "tex_head_diffuse": "1df6a5a7", "tex_head_lightmap": "e4ce0e6b", "tex_head_metalmap": "b0e08915",
                 "tex_body_normalmap": "2aca60d3", "tex_body_diffuse": "b3fc0184", "tex_body_lightmap": "f2f67036", "tex_body_metalmap": "b0e08915",
                 "tex_dress_diffuse": "b3fc0184", "tex_dress_lightmap": "f2f67036", "tex_dress_shadowramp": "7eb5b84e", "tex_dress_metalmap": "b0e08915"},
        ModTypeNames.Barbara.value: {"blend_vb": "22a31278"},
        ModTypeNames.BarbaraSummertime.value: {"draw_vb": "60fcbabe", "position_vb": "8b9e7c22", "blend_vb": "639d62b6", "texcoord_vb": "27057f58", "ib": "a411cfbc",
                    "tex_head_diffuse": "fa94dcc6", "tex_head_lightmap": "07b96e90", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "fa78e66c", "tex_body_lightmap": "a8eec489", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_dress_diffuse": "fa78e66c", "tex_dress_lightmap": "a8eec489", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "72a0dee8", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Diluc.value: {"draw_vb": "56159d74", "position_vb": "6fdb0963", "blend_vb": "6fd20cc4", "texcoord_vb": "aee0755a", "ib": "d1ac0687",
                  "tex_head_diffuse": "575af152", "tex_head_lightmap": "7112b952", "tex_head_shadowramp": "7eb5b84e",
                  "tex_body_diffuse": "6e2d28e9", "tex_body_lightmap": "deff7a87", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                  "tex_face_diffuse": "8b50c50f", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "f596208e", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.DilucFlamme.value: {"draw_vb": "aeab733d", "position_vb": "a2d909c8", "blend_vb": "105887c0", "texcoord_vb": "16350d1b", "ib": "9de6528c",
                  "tex_head_diffuse": "a8af7297", "tex_head_lightmap": "2e936e4a", "tex_head_shadowramp": "7eb5b84e",
                  "tex_body_diffuse": "d8f0b883", "tex_body_lightmap": "05a1b11e", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                  "tex_dress_diffuse": "d8f0b883", "tex_dress_lightmap": "05a1b11e", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                  "tex_face_diffuse": "8b50c50f", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "f596208e", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Fischl.value: {"draw_vb": "6c491d3b", "position_vb": "9838aedf", "blend_vb": "0d1c1932", "texcoord_vb": "d451d8d8", "ib": "5cfc7a92",
                   "tex_head_diffuse": "8b7f4637", "tex_head_lightmap": "3b8e30d7", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "9f758879", "tex_body_lightmap": "3c5e7327", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "59cd2559",
                   "tex_dress_diffuse": "9f758879", "tex_dress_lightmap": "3c5e7327", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "0cd456af", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398"},
        ModTypeNames.FischlHighness.value: {"draw_vb": "3cc8f82b", "position_vb": "8f473224", "blend_vb": "dbd6a5c3", "texcoord_vb": "a800a294", "ib": "95bf8d7e",
                   "tex_head_diffuse": "de37696a", "tex_head_lightmap": "2f2f6932", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "a132243b", "tex_body_lightmap": "61c02f66", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "0cd456af", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Ganyu.value: {"draw_vb": "721ca964", "position_vb": "a5169f1d", "blend_vb": "6f47a39d", "texcoord_vb": "cf27251f", "ib": "2da186bc",
                  "tex_head_diffuse": "6d78ac96", "tex_head_lightmap": "9b0d2126", "tex_head_shadowramp": "7eb5b84e",
                  "tex_body_diffuse": "8a151913", "tex_body_lightmap": "dbcf1d72", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                  "tex_dress_diffuse": "8a151913", "tex_dress_lightmap": "dbcf1d72", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                  "tex_face_diffuse": "b2657593", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.HuTao.value: {"draw_vb": "60345291", "position_vb": "dd16576c", "blend_vb": "153dba3f", "texcoord_vb": "51afdfcf", "ib": "0535853d",
                  "tex_head_diffuse": "565beee6", "tex_head_lightmap": "245dac60", "tex_head_shadowramp": "7eb5b84e",
                  "tex_body_diffuse": "e72dc049", "tex_body_lightmap": "ddfeb6b9", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                  "tex_face_diffuse": "d00bb0ef", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Jean.value: {"draw_vb": "e6055135", "position_vb": "191af650", "blend_vb": "3cb8153c", "texcoord_vb": "1722136c", "ib": "29835d20",
                 "tex_head_diffuse": "dba2791d", "tex_head_lightmap": "0bd77e81", "tex_head_shadowramp": "7eb5b84e",
                 "tex_body_diffuse": "d1ae8efe", "tex_body_lightmap": "cee17ba5", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                 "tex_face_diffuse": "c2d1a57e", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.JeanCN.value: {"draw_vb": "2a29e333", "position_vb": "93bb2522", "blend_vb": "d159bf31", "texcoord_vb": "0ffefb98", "ib": "920c0b3f",
                   "tex_head_diffuse": "6eca0f93", "tex_head_lightmap": "92ed604c", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "0f9c7705", "tex_body_lightmap": "617c45a0", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "c2d1a57e", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.JeanSea.value: {"draw_vb": "972d56ee", "position_vb": "16fef1eb", "blend_vb": "ac801371", "texcoord_vb": "3ffb0363", "ib": "5114a891",
                   "tex_head_diffuse": "3b4efe72", "tex_head_lightmap": "4b8a3da9", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "e555db10", "tex_body_lightmap": "15671abb", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "e555db10", "tex_dress_lightmap": "15671abb", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "c2d1a57e", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
       ModTypeNames.Kaeya.value: {"draw_vb": "4b0aa762", "position_vb": "8a081f34", "blend_vb": "763b60b9", "texcoord_vb": "fb2eff2a", "ib": "13eb3d85",
                   "tex_head_diffuse": "0fbefdbe", "tex_head_lightmap": "34e0c421", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "80a44a1a", "tex_body_lightmap": "5d9ff9ba", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "80a44a1a", "tex_dress_lightmap": "5d9ff9ba", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "6d5856da", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "f596208e", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.KaeyaSailwind.value: {"draw_vb": "bdb6e3b7", "position_vb": "b9b77eff", "blend_vb": "e026c9ae", "texcoord_vb": "74dce34a", "ib": "59f2a0f2",
                   "tex_head_diffuse": "8bdd311f", "tex_head_lightmap": "d0f3065c", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "58d2635b",
                   "tex_body_normalmap": "1077694d", "tex_body_diffuse": "a48a72a3", "tex_body_lightmap": "1f8619fc", "tex_body_metalmap": "b0e08915",
                   "tex_dress_diffuse": "8bdd311f", "tex_dress_lightmap": "d0f3065c", "tex_dress_shadowramp": "7eb5b84e", "tex_dress_metalmap": "b0e08915",
                   "tex_face_diffuse": "4e6a8e9d", "tex_face_lightmap": "830046fd", "tex_face_shadow": "5a1dc9f0", "tex_face_shadowramp": "58d2635b"},
        ModTypeNames.Keqing.value: {"draw_vb": "4526145e", "position_vb": "3aaf3e94", "blend_vb": "0bf8e621", "texcoord_vb": "723848fe", "ib": "f325e394",
                   "tex_head_diffuse": "58de714b", "tex_head_lightmap": "da3e4a28", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "874b8c0b", "tex_body_lightmap": "0695efb7", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "874b8c0b", "tex_dress_lightmap": "0695efb7", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "d8c9c399", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.KeqingOpulent.value: {"draw_vb": "efcc8769", "position_vb": "0d7e3cc5", "blend_vb": "6f010b58", "texcoord_vb": "52f78cb7", "ib": "44bba21c",
                   "tex_head_diffuse": "e2d7ae66", "tex_head_lightmap": "13e2b0ab", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "2af5bf71", "tex_body_lightmap": "195af53a", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "c2b17f84", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Kirara.value: {"draw_vb": "e656b9fd", "position_vb": "cc833025", "blend_vb": "01d54938", "texcoord_vb": "33b3d6e5", "ib": "ce3dc5a2",
                   "tex_head_normalmap": "6006d89d", "tex_head_diffuse": "0998fcda", "tex_head_lightmap": "c90298cc", "tex_head_metalmap": "b0e08915",
                   "tex_body_normalmap": "acf97111", "tex_body_diffuse": "9feba8b9", "tex_body_lightmap": "2fadf527", "tex_body_metalmap": "b0e08915",
                   "tex_dress_normalmap": "acf97111", "tex_dress_diffuse": "9feba8b9", "tex_dress_lightmap": "2fadf527", "tex_dress_metalmap": "b0e08915",
                   "tex_face_normalmap": "6eb20522", "tex_face_diffuse": "4e3376db", "tex_face_lightmap": "30180763"},
        ModTypeNames.Klee.value: {"draw_vb": "52469e36", "position_vb": "dcd74904", "blend_vb": "aec1d55e", "texcoord_vb": "c3448489", "ib": "3fe81b2a",
                 "tex_head_diffuse": "76672fcd", "tex_head_lightmap": "5f5c4d6e", "tex_head_shadowramp": "7eb5b84e",
                 "tex_body_diffuse": "20530946", "tex_body_lightmap": "a0d91469", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                 "tex_face_diffuse": "7fccd783", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "380a1467", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.KleeBlossomingStarlight.value: {"draw_vb": "6234ae22", "position_vb": "0f5fedb4", "blend_vb": "652497c2", "texcoord_vb": "4d6c496b", "ib": "742c4ed5",
                                    "tex_head_diffuse": "b0929218", "tex_head_lightmap": "db315fa4", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "58d2635b",
                                    "tex_body_diffuse": "27a8989a", "tex_body_lightmap": "c085a587", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "58d2635b",
                                    "tex_dress_diffuse": "b0929218", "tex_dress_lightmap": "db315fa4", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "58d2635b"},
        ModTypeNames.Lisa.value: {"position_vb": "2a557add", "blend_vb": "8bfa989d", "texcoord_vb": "92b87c71"},
        ModTypeNames.LisaStudent.value: {"draw_vb": "362fb2b3", "position_vb": "37c70461", "blend_vb": "5db2f8f4", "texcoord_vb": "d77ffc4f", "ib": "cbda8639", # Which mf classified ps-t0 as diffuse, in actuality, this a normal map
                                         "tex_head_normalmap": "438c9349", "tex_head_diffuse": "f7a42411", "tex_head_lightmap": "040d3ada", "tex_head_metalmap": "b0e08915",
                                         "tex_body_normalmap": "35136f7b", "tex_body_diffuse": "02cb9df7", "tex_body_lightmap": "cbf77c41", "tex_body_metalmap": "b0e08915"},
        ModTypeNames.Mona.value: {"draw_vb": "00741928", "position_vb": "20d0bfab", "blend_vb": "52f0e9a0", "texcoord_vb": "a8191396", "ib": "ef876207",
                 "tex_head_diffuse": "b518c5a5", "tex_head_lightmap": "0c679d22", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                 "tex_body_diffuse": "5f873d89", "tex_body_lightmap": "29d50a21", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                 "tex_face_diffuse": "8e116301", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.MonaCN.value: {"draw_vb": "41f18240", "position_vb": "ee5ed1dc", "blend_vb": "bad2731b", "texcoord_vb": "e543af5d", "ib": "ed79ea5b",
                   "tex_head_diffuse": "0320a4d2", "tex_head_lightmap": "df0f8b90", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "c043f913", "tex_body_lightmap": "a3369d08", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "8e116301", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Nilou.value:  {"draw_vb": "2f95abf6", "position_vb": "b2acc1df", "blend_vb": "fda8e783", "texcoord_vb": "583fba29", "ib": "265e34e3",
                   "tex_head_normalmap": "6f0680d3", "tex_head_diffuse": "9caa70ad", "tex_head_lightmap": "b2501b97", "tex_head_metalmap": "b0e08915",
                   "tex_body_normalmap": "a87ce1c0", "tex_body_diffuse": "91cb97a8", "tex_body_lightmap": "29cf0914", "tex_body_metalmap": "b0e08915",
                   "tex_dress_normalmap": "a87ce1c0", "tex_dress_diffuse": "91cb97a8", "tex_dress_lightmap": "29cf09   14", "tex_dress_metalmap": "b0e08915",
                   "tex_face_diffuse": "0957b10f", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_metalmap": "b0e08915"},
        ModTypeNames.Ningguang.value: {"draw_vb": "e4fc5902", "position_vb": "55b43e99", "blend_vb": "9f7dc19c", "texcoord_vb": "906ad233", "ib": "93085db7",
                   "tex_head_diffuse": "e0789f0d", "tex_head_lightmap": "5d182ae7", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "5ffe95c2", "tex_body_lightmap": "64e6b893", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "5ffe95c2", "tex_dress_lightmap": "64e6b893", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "4cc85338", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.NingguangOrchid.value: {"draw_vb": "10de9c78", "position_vb": "db37b198", "blend_vb": "a8246d4a", "texcoord_vb": "396aa3ec", "ib": "f1d09b47",
                   "tex_head_diffuse": "b68d7488", "tex_head_lightmap": "bc1034dd", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "a4597b85", "tex_body_lightmap": "0e26784e", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "a4597b85", "tex_dress_lightmap": "0e26784e", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "4cc85338", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Raiden.value: {"draw_vb": "a05e7bec", "position_vb": "e48c61f3", "blend_vb": "1a495487", "texcoord_vb": "0c37fc86", "ib": "428c56cd"},
        ModTypeNames.RaidenBoss.value: {"blend_vb": "fe5c0180"},
        ModTypeNames.Rosaria.value: {"draw_vb": "9e1868d9", "position_vb": "748f40a5", "blend_vb": "4de959bd", "texcoord_vb": "06b8fbf5", "ib": "5d18b9d6",
                    "tex_head_diffuse": "81b2d0ca", "tex_head_lightmap": "2f19c547", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "9abde85f", "tex_body_lightmap": "743ffc09", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_dress_diffuse": "81b2d0ca", "tex_dress_lightmap": "2f19c547", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                    "tex_extra_diffuse": "9abde85f", "tex_extra_lightmap": "743ffc09", "tex_extra_metalmap": "b0e08915", "tex_extra_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "2abd61ee", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.RosariaCN.value: {"draw_vb": "f3d4a01a", "position_vb": "59a1f8b1", "blend_vb": "a7bee046", "texcoord_vb": "86e0d16b", "ib": "851e4de1",
                      "tex_head_diffuse": "55280cb0", "tex_head_lightmap": "825c32a0", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                      "tex_body_diffuse": "bd6fcf34", "tex_body_lightmap": "cf7b6deb", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                      "tex_dress_diffuse": "55280cb0", "tex_dress_lightmap": "825c32a0", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                      "tex_extra_diffuse": "bd6fcf34", "tex_extra_lightmap": "cf7b6deb", "tex_extra_metalmap": "b0e08915", "tex_extra_shadowramp": "7eb5b84e",
                      "tex_face_diffuse": "2abd61ee", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Shenhe.value: {"draw_vb": "fde191d7", "position_vb": "e44b58b5", "blend_vb": "541cf273", "texcoord_vb": "86c4f5ec", "ib": "0b7d4e4d",
                   "tex_head_diffuse": "7da9c07b", "tex_head_lightmap": "e134c758", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "cba1d6ec", "tex_body_lightmap": "ce5176af", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "cba1d6ec", "tex_dress_lightmap": "ce5176af", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "f5f393cb", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Xiangling.value: {"draw_vb": "94523bab", "position_vb": "9427917d", "blend_vb": "2b663556", "texcoord_vb": "29744879", "ib": "5363ff5d",
                      "tex_head_diffuse": "499e89bf", "tex_head_lightmap": "ba6a810c", "tex_head_shadowramp": "7eb5b84e",
                      "tex_body_diffuse": "abd3a28e", "tex_body_lightmap": "7e12708e", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                      "tex_dress_diffuse": "abd3a28e", "tex_dress_lightmap": "7e12708e", "tex_dress_shadowramp": "7eb5b84e",
                      "tex_face_diffuse": "1d353f0b", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        ModTypeNames.Xingqiu.value: {"draw_vb": "f9caefa2", "position_vb": "25aed172", "blend_vb": "8f0e9948", "texcoord_vb": "4c25bd5f", "ib": "ba1d11c3",
                    "tex_head_diffuse": "d8e82984", "tex_head_lightmap": "69866236", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "5423a093", "tex_body_lightmap": "0f394cb6", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "e35f8bf8", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "59df7508", "tex_face_shadowramp": "7eb5b84e"}},
4.1 : {ModTypeNames.Amber.value: {"draw_vb":"0eef5bbe"},
       ModTypeNames.AmberCN.value: {"draw_vb":"53eff008"},
       ModTypeNames.Ayaka.value: {"draw_vb":"9d2c1c5d"},
       ModTypeNames.AyakaSpringbloom.value: {"draw_vb":"04f21fa3"},
       ModTypeNames.Barbara.value: {"draw_vb": "7df968e8"},
       ModTypeNames.BarbaraSummertime.value: {"draw_vb": "e9199599"},
       ModTypeNames.Diluc.value: {"draw_vb": "dff0b253"},
       ModTypeNames.DilucFlamme.value: {"draw_vb": "274e5c1a"},
       ModTypeNames.Fischl.value: {"draw_vb":"e5ac321c"},
       ModTypeNames.FischlHighness.value: {"draw_vb": "b52dd70c"},
       ModTypeNames.Ganyu.value: {"draw_vb": "fbf98643"},
       ModTypeNames.HuTao.value: {"draw_vb": "e9d17db6"},
       ModTypeNames.Jean.value: {"draw_vb":"6fe07e12"},
       ModTypeNames.JeanCN.value: {"draw_vb":"a3cccc14"},
       ModTypeNames.JeanSea.value: {"draw_vb": "1ec879c9"},
       ModTypeNames.Kaeya.value: {"draw_vb": "c2ef8845"},
       ModTypeNames.Keqing.value: {"draw_vb": "ccc33b79"},
       ModTypeNames.KeqingOpulent.value: {"draw_vb": "6629a84e"},
       ModTypeNames.Kirara.value: {"draw_vb": "6fb396da"},
       ModTypeNames.Klee.value: {"draw_vb": "dba3b111"},
       ModTypeNames.KleeBlossomingStarlight.value: {"draw_vb": "ebd18105"},
       ModTypeNames.Lisa.value: {"draw_vb": "e6af2c6d"},
       ModTypeNames.LisaStudent.value: {"draw_vb": "bfca9d94"},
       ModTypeNames.Mona.value: {"draw_vb":"8991360f"},
       ModTypeNames.MonaCN.value: {"draw_vb":"c814ad67"},
       ModTypeNames.Nilou.value: {"draw_vb": "a67084d1"},
       ModTypeNames.Ningguang.value: {"draw_vb": "6d197625"},
       ModTypeNames.NingguangOrchid.value: {"draw_vb": "993bb35f"},
       ModTypeNames.Raiden.value: {"draw_vb":"29bb54cb"},
       ModTypeNames.Rosaria.value: {"draw_vb":"17fd47fe"},
       ModTypeNames.RosariaCN.value: {"draw_vb":"7a318f3d"},
       ModTypeNames.Shenhe.value: {"draw_vb": "7404bef0"},
       ModTypeNames.Xingqiu.value: {"draw_vb": "702fc085"},
       ModTypeNames.Xiangling.value: {"draw_vb": "1db7148c"}},
4.3 : {ModTypeNames.Amber.value: {"ib":"a1a2bbfb"},
       ModTypeNames.AmberCN.value: {"ib":"b41d4d94"},
       ModTypeNames.Ayaka.value: {"ib":"0cafd227"},
       ModTypeNames.Barbara.value: {"ib": "1bc3490d"},
       ModTypeNames.BarbaraSummertime.value: {"ib": "9cc5a563"},
       ModTypeNames.Diluc.value: {"ib": "e9786c58"},
       ModTypeNames.DilucFlamme.value: {"ib": "a5323853"},
       ModTypeNames.Fischl.value: {"ib": "6428104d"},
       ModTypeNames.FischlHighness.value: {"ib": "ad6be7a1"},
       ModTypeNames.Ganyu.value: {"ib": "1575ec63"},
       ModTypeNames.HuTao.value: {"ib": "3de1efe2"},
       ModTypeNames.Jean.value: {"ib":"115737ff"},
       ModTypeNames.JeanCN.value: {"ib":"aad861e0"},
       ModTypeNames.JeanSea.value: {"ib": "69c0c24e"},
       ModTypeNames.Kaeya.value: {"ib": "2b3f575a"},
       ModTypeNames.Keqing.value: {"ib": "cbf1894b"},
       ModTypeNames.KeqingOpulent.value: {"ib": "7c6fc8c3"},
       ModTypeNames.Kirara.value: {"ib": "f6e9af7d"},
       ModTypeNames.Klee.value: {"ib": "073c71f5"},
       ModTypeNames.KleeBlossomingStarlight.value: {"ib": "4cf8240a"},
       ModTypeNames.Lisa.value: {"ib": "518a6840"},
       ModTypeNames.LisaStudent.value: {"ib": "f30eece6"},
       ModTypeNames.Mona.value: {"ib":"d75308d8"},
       ModTypeNames.MonaCN.value: {"ib":"d5ad8084"},
       ModTypeNames.Nilou.value: {"ib": "1e8a5e3c"},
       ModTypeNames.Ningguang.value: {"ib": "abdc3768"},
       ModTypeNames.NingguangOrchid.value: {"ib":"c904f198"},
       ModTypeNames.Raiden.value: {"ib":"7a583c12"},
       ModTypeNames.Rosaria.value: {"ib":"65ccd309"},
       ModTypeNames.RosariaCN.value: {"ib":"bdca273e"},
       ModTypeNames.Shenhe.value: {"ib": "33a92492"},
       ModTypeNames.Xingqiu.value: {"ib": "82c97b1c"},
       ModTypeNames.Xiangling.value: {"ib": "6bb79582"}},
4.4 : {ModTypeNames.Amber.value: {"position_vb": "a2ea4b2d", "blend_vb": "36d20a67", "texcoord_vb": "81b777ca", "ib": "b03c7e30"},
       ModTypeNames.AmberCN.value: {"position_vb": "557b2eff"},
       ModTypeNames.Diluc.value: {"draw_vb": "5b0cb984", "position_vb": "71625c4d", "blend_vb": "afb527f6", "texcoord_vb": "6d0e22f0", "ib": "e16fa548"},
       ModTypeNames.Fischl.value: {"position_vb": "bf6aef4d"},
       ModTypeNames.Mona.value: {"position_vb": "7a1dc890", "blend_vb": "b043715a"},
       ModTypeNames.MonaCN.value: {"position_vb": "515f3ce6"},
       ModTypeNames.Ningguang.value: {"draw_vb": "4c2f9a0a", "position_vb": "f9e1b52b", "blend_vb": "735eaea4", "texcoord_vb": "1f0ab400", "ib": "ad75352c"},
       ModTypeNames.ShenheFrostFlower.value: {"draw_vb": "6102c3ef", "position_vb": "ee0980eb", "blend_vb": "263019b8", "texcoord_vb": "d36f368d", "ib": "83a9116d",
                             "tex_head_normalmap": "4e5d638d", "tex_head_diffuse": "1ab2f510", "tex_head_lightmap": "b0e08915", "tex_head_shadowramp": "58d2635b",  # Seriously, which son of a gun added normal maps for ShenheFrostFlower. She has no normal maps. Im just going to follow what GIMI assets has even though I know it is wrong
                             "tex_body_normalmap": "625d0bb4", "tex_body_diffuse": "51529edd", "tex_body_lightmap": "b0e08915", "tex_body_shadowramp": "58d2635b",
                             "tex_dress_normalmap": "4e5d638d", "tex_dress_diffuse": "1ab2f510", "tex_dress_lightmap": "7eb5b84e", "tex_dress_shadowramp": "000050-ps-t3", # is the hash for "tex_dress_shadowramp" even valid? reference: https://github.com/SilentNightSound/GI-Model-Importer-Assets/commit/79d40a4d4708500f44035ade5a6be6c5d6cb0285#diff-2f0914f9ffdcb1e85d8a1e64ba1f12bc7521da3a7f184a2c2eccbaeb702c9290
                             "tex_extra_normalmap": "625d0bb4", "tex_extra_diffuse": "51529edd", "tex_extra_lightmap": "7eb5b84e", "tex_extra_shadowramp": "000049-ps-t3"},
       ModTypeNames.GanyuTwilight.value: {"draw_vb": "1ad9c181", "position_vb": "9b3f356e", "blend_vb": "9a5c01d2", "texcoord_vb": "5ff2f1d1", "ib": "cb283c86",
                         "tex_head_normalmap": "f8aa8a9d", "tex_head_diffuse": "ad1ed796", "tex_head_lightmap": "191ebe05", "tex_head_metalmap": "b0e08915",
                         "tex_body_normalmap": "e304bdcf", "tex_body_diffuse": "13fa0b53", "tex_body_lightmap": "b0e08915", "tex_body_shadowramp": "58d2635b",
                         "tex_dress_normalmap": "e304bdcf", "tex_dress_diffuse": "13fa0b53", "tex_dress_lightmap": "b0e089    15", "tex_dress_shadowramp": "58d2635b"},
       ModTypeNames.Kirara.value: {"position_vb": "b57d7fe2"},
       ModTypeNames.XingqiuBamboo.value: {"draw_vb": "3944dfbd", "position_vb": "cc158a1e", "blend_vb": "07c7c5b6", "texcoord_vb": "41426386", "ib": "76df4025",
                         "tex_head_diffuse": "520d5504", "tex_head_lightmap": "045244a0", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "58d2635b",
                         "tex_body_diffuse": "fe820a09", "tex_body_lightmap": "65bb84d8", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "58d2635b",
                         "tex_dress_diffuse": "fe820a09", "tex_dress_lightmap": "65bb84d8", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "58d2635b"}},
4.6 : {ModTypeNames.Arlecchino.value : {"draw_vb": "44e3487a", "position_vb": "6895f405", "blend_vb": "e211de60", "texcoord_vb": "8b17a419", "ib": "e811d2a1"},
       ModTypeNames.ArlecchinoBoss.value: {"draw_vb": "970e7336", "position_vb": "cf66bef6", "blend_vb": "5227c79e", "texcoord_vb": "a75e7052", "ib": "480f1267"}},
4.8 : {ModTypeNames.NilouBreeze.value: {"draw_vb": "3f79fabb", "position_vb": "7d53d78f", "blend_vb": "49bede49", "texcoord_vb": "b976b848", "ib": "00439fbb",
                   "tex_head_diffuse": "2593dea6", "tex_head_lightmap": "3f78afbf", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "58d2635b",
                   "tex_body_diffuse": "9f7e392b", "tex_body_lightmap": "e3e73b29", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "58d2635b", 
                   "tex_dress_diffuse": "9f7e392b", "tex_dress_lightmap": "e3e73b29", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "58d2635b"},
        ModTypeNames.KiraraBoots.value: {"draw_vb": "4955fc99", "position_vb": "f8013ba9", "blend_vb": "53a2502b", "texcoord_vb": "596e8fe0", "ib": "846979e2",
                   "tex_head_normalmap": "c715bcf7", "tex_head_diffuse": "16fbe9b0", "tex_head_lightmap": "f74f093d", "tex_head_metalmap": "b0e08915",
                   "tex_body_normalmap": "89a118ba", "tex_body_diffuse": "e3a21e6f", "tex_body_lightmap": "8ca27fd3", "tex_body_metalmap": "b0e08915",
                   "tex_dress_diffuse": "e3a21e6f", "tex_dress_lightmap": "8ca27fd3", "tex_dress_shadowramp": "7eb5b84e", "tex_dress_metalmap": "b0e08915"}},
5.2: {ModTypeNames.Diluc.value: {"tex_face_diffuse": "e698735e"},
      ModTypeNames.Lisa.value: {"tex_head_diffuse": "b8ed7d4b"}},
5.3: {ModTypeNames.CherryHuTao.value: {"draw_vb": "6715905e", "position_vb": "a78db232", "blend_vb": "6e718139", "texcoord_vb": "4b14b10e", "ib": "92fce51e",
                      "tex_head_normalmap": "efe5e3ed", "tex_head_diffuse": "99a26018", "tex_head_lightmap": "d6089bf8",
                      "tex_body_diffuse": "b932cd65", "tex_body_lightmap": "dd90b43c",
                      "tex_dress_normalmap": "e66b5b37", "tex_dress_diffuse": "b932cd65", "tex_dress_lightmap": "dd90b43c",
                      "tex_extra_diffuse": "99a26018"},
      ModTypeNames.XianglingCheer.value: {"draw_vb": "e71f5012", "position_vb": "05a65c3f", "blend_vb": "bd659168", "texcoord_vb": "c679abfe", "ib": "cc7a4851",
                         "tex_head_normalmap": "2725cfa6", "tex_head_diffuse": "7866ddd9", "tex_head_lightmap": "16a7176a",
                         "tex_body_normalmap": "25260201", "tex_body_diffuse": "a1ef63e6", "tex_body_lightmap": "17c172d2"}},
5.4: {ModTypeNames.LisaStudent.value: {"tex_head_normalmap": "a64a57de", "tex_head_diffuse": "438c9349", "tex_head_lightmap": "f7a42411",
                                       "tex_body_normalmap": "a64a57de", "tex_body_diffuse": "02cb9df7", "tex_body_lightmap": "cbf77c41"}}}


DefaultCacheSize = 128

class Cache(Generic[T]):
    """
    Class for a generic cache

    .. container:: operations

        **Supported Operations:**

        .. describe:: len(x)

            Retrieves the size of the :class:`Cache`, ``x``

        .. describe:: x[key]

            Retrieves the value from the :class:`Cache`, ``x``, from the key ``key``

        .. describe:: x[key] = newValue

            Sets the key ``key`` of the :class:`Cache`, ``x``, to have the value of ``newValue``

    :raw-html:`<br />`

    Parameters
    ----------
    capacity: :class:`int`
        The maximum capacity of the cache :raw-html:`<br />` :raw-html:`<br />`

        **Default**: 128

    cacheStorage: Optional[Any]
        The type of `KVP`_ (Key-value pair) data structure to use for the cache. If this parameter is ``None``, then will use a dictionary :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    capacity: :class:`int`
        The maximum capacity of the cache

    cacheStorage: Any
        The type of `KVP`_ (Key-value pair) data structure to use for the cache.
    """

    def __init__(self, capacity: int = DefaultCacheSize, cacheStorage: Optional[Any] = None):
        self.capacity = capacity

        if (cacheStorage is None):
            self._cache = {}
        else:
            self._cache = cacheStorage

    def __getitem__(self, key: Hashable) -> Optional[T]:
        return self._cache[key]

    def __setitem__(self, key: Hashable, value: T) -> None:
        self._cache[key] = value

    def __len__(self) -> int:
        return len(self._cache)

    def clear(self) -> None:
        """
        Clears the cache
        """
        self._cache.clear()


class LruCache(Cache):
    """
    This class inherits from :class:`Cache`

    Class for an `LRU cache`_

    .. container:: operations

        **Supported Operations:**

        .. describe:: len(x)

            Retrieves the size of the :class:`LruCache`, ``x``

        .. describe:: x[key]

            Retrieves the value from the :class:`LruCache`, ``x``, from the key ``key``

        .. describe:: x[key] = newValue

            Sets the key ``key`` of the :class:`LruCache`, ``x``, to have the value of ``newValue``

    :raw-html:`<br />`

    Parameters
    ----------
    capacity: :class:`int`
        The maximum capacity of the cache :raw-html:`<br />` :raw-html:`<br />`

        **Default**: 128
    """

    def __init__(self, capacity: int = DefaultCacheSize):
        super().__init__(capacity, OrderedDict())

    def __getitem__(self, key: Hashable) -> Optional[T]:
        if key not in self._cache:
            raise KeyError(f"{key}")

        self._cache.move_to_end(key)
        return self._cache[key]

    def __setitem__(self, key: Hashable, value: T) -> None:
        if len(self._cache) == self.capacity:
            self._cache.popitem(last=False)

        self._cache[key] = value
        self._cache.move_to_end(key)


class Version():
    """
    Class for handling game versions

    Parameters
    ----------
    versions: Optional[List[Union[:class:`float`, :class:`str`, `packaging.version.Version`_]]]
        The versions available

        **Default**: ``None``

    Attributes
    ----------
    _versionCache: :class:`LruCache`
        Cache to store the closest available versions based off the versions that the user searches :raw-html:`<br />` :raw-html:`<br />`

        * The keys in the `LRU cache`_ are the versions the user searches
        * The values in the  `LRU cache`_ are the corresponding versions available to the versions the user searches
    """

    def __init__(self, versions: Optional[List[Union[float, str, VersionType]]] = None):
        if (versions is None):
            versions = []

        self._latestVersion: Optional[float] = None
        self._versionCache = LruCache()
        self.versions = versions

    @property
    def versions(self):
        """
        The available versions

        :getter: The versions in sorted ascending order
        :setter: Sets the new versions
        :type: List[`packaging.version.Version`_]
        """

        return self._versions
    
    @versions.setter
    def versions(self, newVersions: List[Union[float, VersionType]]) -> List[float]:
        self.clear()

        versionModule = GlobalPackageManager.get(PackageModules.Packaging_Version.value)
        versionCls = versionModule.Version

        newVersions = list(map(lambda version: versionCls(f"{version}") if (isinstance(version, float) or isinstance(version, int) or isinstance(version, str)) else version, newVersions))

        self._versions = list(set(newVersions))
        self._versions.sort()
        if (self._versions):
            self._latestVersion = self._versions[-1]

    @property
    def latestVersion(self) -> Optional[VersionType]:
        """
        The latest version available

        :getter: The latest version
        :type: Optional[`packaging.version.Version`_]
        """

        return self._latestVersion

    def clear(self):
        """
        Clears all the version data
        """

        self._versions = []
        self._latestVersion = None
        self._versionCache.clear()

    @classmethod
    def getVersion(cls, rawVersion: Union[float, str, VersionType]) -> Optional[VersionType]:
        """
        Retrieves the corresponding version

        Parameters
        ----------
        rawVersion: Union[:class:`float`, :class:`str`, `packaging.version.Version`_]
            The version to translate

        Returns
        -------
        Optional[`packaging.version.Version`_]
            The corresponding version, if possible to translate
        """

        versionModule = GlobalPackageManager.get(PackageModules.Packaging_Version.value)
        versionCls = versionModule.Version
        invalidVersionError = versionModule.InvalidVersion

        if (isinstance(rawVersion, versionCls)):
            return rawVersion
        
        try:
            return versionCls(f"{rawVersion}")
        except invalidVersionError as e:
            return None
        
    @classmethod
    def compareVersions(cls, version1: VersionType, version2: VersionType) -> int:
        """
        Compares two versions

        Parameters
        ----------
        version1: `packaging.version.Version`_
            The first version to compare

        version2: `packaging.version.Version`_
            The second version to compare

        Returns
        -------
        :class:`int`
            A negative number if `version1` is less than `version2`, a positive number if `version1` is greater than `version2`, and zero if they are equal
        """

        if (version1 == version2):
            return 0
        elif (version1 < version2):
            return -1
        return 1
    
    def _updateLatestVersion(self, newVersion: VersionType):
        """
        Updates the latest version

        Parameters
        ----------
        newVersion: `packaging.version.Version`_
            The new available version
        """

        if (self._latestVersion is None):
            self._latestVersion = newVersion
            return
        
        self._latestVersion = max(self._latestVersion, newVersion)

    def _add(self, newVersion: Union[VersionType]):
        if (not self._versions or newVersion > self._versions[-1]):
            self._versions.append(newVersion)
        elif (newVersion < self._versions[0]):
            self._versions.insert(0, newVersion)
        else:
            Algo.binaryInsert(self._versions, newVersion, lambda v1, v2: self.compareVersions(v1, v2), optionalInsert = True)

    def add(self, newVersion: Union[str, float, VersionType]):
        """
        Adds a new version

        Parameters
        ----------
        newVersion: Union[:class:`str`, :class:`float`, `packaging.version.Version`_]
            The new version to add
        """

        newVersion = self.getVersion(newVersion)
        if (newVersion is None):
            return

        self._add(newVersion)
        self._updateLatestVersion(newVersion)

    def findClosest(self, version: Optional[Union[str, float, VersionType]], fromCache: bool = True) -> Optional[float]:
        """
        Finds the closest version available

        Parameters
        ----------
        version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
            The version to be searched :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will assume we want the latest version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fromCache: :class:`bool`
            Whether we want the result to be accessed from the cache :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        Optional[`packaging.version.Version`_]
            The closest version available or ``None`` if there are no versions available
        """

        if (self._latestVersion is None):
            return None

        if (version is None):
            return self._latestVersion
        
        version = self.getVersion(version)

        if (fromCache):
            try:
                return self._versionCache[version]
            except KeyError:
                pass

        found, ind = Algo.binarySearch(self._versions, version, lambda v1, v2: self.compareVersions(v1, v2))

        result = 0
        if (found):
            result = self._versions[ind]
        elif (ind > 0):
            result = self._versions[ind - 1]
        else:
            result = self._versions[0]

        self._versionCache[version] = result
        return result


class ModAssets(Generic[T]):
    """
    Class to handle assets of any type for a mod

    Parameters
    ----------
    repo: Dict[:class:`float`, Dict[:class:`str`, T]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value is the content for the asset

    Attributes
    ----------
    repo: Dict[:class:`float`, Dict[:class:`str`, T]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value is the content for the asset
    """

    def __init__(self, repo: Dict[float, Dict[str, T]]):
        self._repo = repo
        self._versions: Dict[str, Version] = {}

    @property
    def versions(self) -> Dict[str, Version]:
        """
        The game versions available for the assets :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the names of the assets
        * The values are versions for the asset

        :getter: Returns all the available game versions for the assets
        :type: Dict[:class:`str`, :class:`Version`]
        """

        return self._versions

    def clearCache(self):
        """
        Clears out any cached data
        """

        self._versions.clear()

    def _updateAssetContent(self, srcAsset: T, newAsset: T) -> T:
        """
        Combines the content of 2 assets

        Parameters
        ----------
        srcAsset: T
            The content of the asset to be updates

        newAsset: T
            The new asset to update into ``srcAsset`` 

        Returns
        -------
        T
            The updated asset
        """

        return newAsset

    def _updateDupAssets(self, srcAsset: Dict[str, Any], newAsset: Dict[str, Any]):
        return DictTools.update(srcAsset, newAsset, combineDuplicate = lambda assetId, srcAsset, newAsset: self._updateAssetContent(srcAsset, newAsset))
    
    def updateRepo(self, srcRepo: Dict[float, Dict[str, Any]], newRepo: Dict[float, Dict[str, Any]]) -> Dict[float, Dict[str, Any]]:
        """
        Updates the values in ``srcRepo``

        Parameters
        ----------
        srcRepo: Dict[:class:`float`, Dict[:class:`str`, Any]]
            The first repo to be combined

        newRepo: Dict[:class:`float`, Dict[:class:`str`, Any]]
            The second repo to be combined

        Returns
        -------
        Dict[:class:`float`, Dict[:class:`str`, Any]]
            The combined repo
        """

        result = DictTools.update(srcRepo, newRepo, combineDuplicate = lambda version, srcRepo, newRepo: self._updateDupAssets(srcRepo, newRepo))
        return result

    def _addVersion(self, name: str, version: Union[str, float, VersionType]):
        """
        Adds a new version for a particular asset

        Parameters
        ----------
        name: :class:`str`
            The name of the asset

        version: :class:`float`
            The game version
        """
        try:
            self._versions[name]
        except KeyError:
            self._versions[name] = Version()

        self._versions[name].add(version)

    def _getVersionAssets(self, version: VersionType, data: Dict[Union[str, float, VersionType], Any]) -> Any:
        versionStr = str(version)
        versionKey = None

        try:
            versionKey = float(versionStr)
        except ValueError:
            pass

        if (isinstance(versionKey, float)):
            try:
                return data[versionKey]
            except KeyError:
                pass

        try:
            return data[versionStr]
        except KeyError:
            pass

        return data[version]

    def findClosestVersion(self, name: str, version: Optional[Union[str, float, VersionType]] = None, fromCache: bool = True) -> VersionType:
        """
        Finds the closest available game version from :attr:`ModStrAssets._toAssets` for a particular asset

        Parameters
        ----------
        name: :class:`str`
            The name of the asset to search

        version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
            The game version to be searched :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will assume we want the latest version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fromCache: :class:`bool`
            Whether to use the result from the cache

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            The name for the particular asset is not found

        Returns
        -------
        `packaging.version.Version`_
            The latest game version from the assets that corresponds to the desired version 
        """

        try:
            self._versions[name]
        except KeyError as e:
            raise KeyError(f"Asset name, '{name}', not found in the available versions") from e

        result = self._versions[name].findClosest(version, fromCache = fromCache)
        if (result is None):
            raise KeyError(f"No available versions for the asset by the name, '{name}'")

        return result


class ModMappedAssets(ModAssets[T]):
    """
    This class inherits from :class:`ModAssets`

    Class to handle assets of any type where asset retrieval is based on a mapping

    .. note::
        This is a `bipartite graph`_ that maps assets to fix from to assets to fix to

    Parameters
    ----------
    repo: Dict[:class:`float`, Dict[:class:`str`, T]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value is the content for the asset

    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the assets to fix from to the assets to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Dict[float, Dict[str, T]], map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(repo)

        self._fixFrom: Set[str] = set()
        self._fixTo: Set[str] = set()
        self._map = map

        if (self._map is None):
            self._map = {}

    @property
    def fixFrom(self) -> Set[str]:
        """
        The names of the assets to fix from using the predefined mods

        :getter: Retrieves the names of assets used to fix from
        :type: Set[:class:`str`]
        """
        
        return self._fixFrom

    @property
    def fixTo(self) -> Set[str]:
        """
        The names of the assets to fix to using the predefined mods

        :getter: Retrives the names of assets to fix to
        :type: Set[:class:`str`]
        """

        return self._fixTo
    
    @property
    def map(self) -> Dict[str, Set[str]]:
        """
        The `adjacency list`_ used to map assets to fix from to assets to fix to

        :getter: Retrieves the `adjacency list`_
        :setter: Sets a new `adjacency list`_
        :type: Dict[:class:`str`, Set[:class:`str`]]
        """

        return self._map
    
    @map.setter
    def map(self, newMap: Dict[str, Set[str]]):
        self.clear(flush = True, clearMap = True)
        self.addMap(newMap)

    def clear(self, flush: bool = True, clearMap: bool = False):
        """
        Clears all the assets

        Parameters
        ----------
        flush: :class:`bool`
            Whether to flush out (reload) any cached data
            
            **Default**: ``False``

        clearMap: :class:`bool`
            Whether to clear out the mapping for the assets 

            **Default**: ``False``
        """

        if (flush):
            self.clearCache()

        if (clearMap):
            self._fixFrom = set()
            self._fixTo = set()
            self._map = {}

    def loadFromPreset(self):
        """
        Reinitializes to load the predefined mods
        """

        map = self._map
        self.clear(clearMap = True)
        self.map = map

    @classmethod
    def updateMap(cls, srcMap: Dict[str, Set[str]], newMap: Dict[str, Set[str]]) -> Dict[str, Set[str]]:
        """
        Combines 2 maps together

        Parameters
        ----------
        srcMap: Dict[:class:`str`, Set[:class:`str`]]
            The map to be updates

        newMap: Dict[:class:`str`, Set[:class:`str`]]
            The new map to update ``srcMap``

        Returns
        -------
        Dict[:class:`str`, Set[:class:`str`]]
            The updated map
        """

        return DictTools.update(srcMap, newMap, combineDuplicate = lambda assetId, oldToAssets, newToAssets: oldToAssets.union(newToAssets))
        
    def _partition(self, map: Dict[str, Set[str]], assets: Dict[float, Dict[str, Any]]) -> Tuple[Dict[str, Set[str]], Set[str], Set[str]]:
        """
        * Creates the `bipartition`_ for the assets to fix from vs the assets to fix to
        * Filters the mapping such that all the asset names in the new mapping exist in `assets`

        Parameters
        ----------
        map: Dict[:class:`str`, Set[:class:`str`]]
            The desired mapping for the assets for fixing

        assets: Dict[:class:`float`, Dict[:class:`str`, Any]]
            The source for all the assets :raw-html:`<br />` :raw-html:`<br />`

            * The outer key is the game version number for the assets
            * The first inner key is the name of the asset
            * The second inner key is the type of asset
            * The most inner value is the id for the asset (must be unique)

        Returns
        -------
        Tuple[Dict[:class:`str`, Set[:class:`str`]], Set[:class:`str`], Set[:class:`str`]]
            The following output is in the same order as listed below: :raw-html:`<br />` :raw-html:`<br />`

            #. The new mapping with all asset names being in `assets`
            #. The names of the assets to fix from
            #. The names of the assets to fix to
        """

        newMap = {}
        fixFrom = set()
        fixTo = set()

        vertices = set()
        visited = {}

        # retrieve all the vertices in the map
        for fromAsset in map:
            vertices.add(fromAsset)
            currentToAssets = map[fromAsset]
            vertices = vertices.union(currentToAssets)

        visited = {}
        for vertex in vertices:
            visited[vertex] = False

        # get all the vertices in the map that are visited in the assets repo
        for version in assets:
            versionAssets = assets[version]

            for assetName in versionAssets:
                if (assetName in vertices and not visited[assetName]):
                    visited[assetName] = True

        # creates the new sub-map and bipartition with vertices definitely being in the assets repo
        for fromAsset in map:
            if (not visited[fromAsset]):
                continue
            
            currentToAssets = map[fromAsset]
            newCurrentToAssets = set(filter(lambda toAsset: visited[toAsset], currentToAssets))

            if (not newCurrentToAssets):
                continue

            newMap[fromAsset] = newCurrentToAssets
            fixFrom.add(fromAsset)
            fixTo = fixTo.union(newCurrentToAssets)

        return (newMap, fixFrom, fixTo)
    
    def _updateVersions(self, assets: Dict[float, Dict[str, T]]):
        """
        Updates the versioning of the assets

        Parameters
        ----------
        assets: T
            The assets for checking the versioning
        """
        pass
    
    def addMap(self, assetMap: Dict[str, Set[str]], assets: Optional[Dict[float, Dict[str, T]]] = None):
        """
        Adds a new map to the existing map on how to retrieve the assets

        Parameters
        ----------
        assetMap: Dict[:class:`str`, Set[:class:`str`]]
            The new `adjacency list`_ used to map assets to fix from to assets to fix to

        assets: Optional[T]
            Any new assets that needs to be added/updated to the existing assets to support the given map

            **Default**: ``None``
        """

        if (assets is None):
            assets = {}

        self._repo = self.updateRepo(self._repo, assets)
        newAddMap, addFixFrom, addFixTo = self._partition(assetMap, self._repo)

        self._repo = self._repo
        if (not addFixFrom or not addFixTo):
            return

        self._map = self.updateMap(self._map, newAddMap)
        self._fixFrom = self._fixFrom.union(addFixFrom)
        self._fixTo = self._fixTo.union(addFixTo)

        # update the versions
        self._updateVersions(assets)


    def addMapping(self, fromAsset: str, toAssets: Set[str], assets: Any):
        """
        Adds a new mapping of how to fix the assets

        Parameters
        ----------
        fromAsset: :class:`str`
            The name of the asset to fix from

        toAssets: Set[:class:`str`]
            The names of the assets to fix to

        assets: Any
            Any new assets that needs to be added/updated to the existing assets to support the new mapping
        """

        map = {fromAsset: toAssets}
        self.addMap(map, assets)


class ModIdAssets(ModMappedAssets[Dict[str, str]]):
    """
    This class inherits from :class:`ModMappedAssets`

    Class to handle hashes, indices, and other string id type assets for a mod

    Parameters
    ----------
    repo: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version of the assets
        * The first inner key is the name of the asset
        * The second inner key is the type of asset
        * The most inner value is the id for the asset

        .. note::
            The id value for each asset should be unique

    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the assets to fix from to the assets to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Dict[float, Dict[str, Dict[str, str]]], map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(repo, map = map)

        self._fromAssets: Dict[str, List[Tuple[str, str]]] = {}
        self._toAssets: Dict[float, Dict[str, Dict[str, str]]] = {}
        self.loadFromPreset()

    @property
    def fromAssets(self) -> Dict[str, Tuple[Set[str], str]]:
        """
        The assets to fix from :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the ids for the asset
        * The values contains metadata about the assets to fix to where each tuple contains:

            # The names of the assets
            # The type of asset

        :getter: Returns the assets needed to be fixed
        :type: Dict[:class:`str`, Tuple[Set[:class:`str`], :class:`str`]]
        """

        return self._fromAssets
    
    @property
    def toAssets(self) -> Dict[float, Dict[str, Dict[str, str]]]:
        """
        The assets to fix to: :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The first inner key is the name of the assets
        * The most inner key is the type of asset
        * The most inner value is the id for the asset

        :getter: Returns the new assets that will replace the old assets
        :type: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
        """
        return self._toAssets

    def clear(self, flush: bool = True, clearMap: bool = False):
        self._fromAssets = {}
        self._toAssets = {}
        super().clear(flush = flush, clearMap = clearMap)

    def loadFromPreset(self):
        super().loadFromPreset()
        self._loadFromAssets()
        self._loadToAssets()

    def get(self, assetName: str, assetType: str, version: Optional[float] = None) -> str:
        """
        Retrieves the corresponding id asset from :attr:`ModStrAssets._toAssets`

        Parameters
        ----------
        assetName: :class:`str`
            The name of the assets we want

        assetType: :class:`str`
            The name of the type of asset we want.

        version: Optional[:class:`float`]
            The game version we want the asset to come from :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will retrieve the asset of the latest version. :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            If the corresponding asset based on the search parameters is not found
            
        Returns
        -------
        :class:`str`
            The found asset
        """

        closestVersion = self.findClosestVersion(assetName, version = version)
        assets = self._getVersionAssets(closestVersion, self._toAssets)
        return assets[assetName][assetType]
    
    def replace(self, fromAsset: str, version: Optional[float] = None, toAssets: Optional[Union[str, Set[str]]] = None) -> Union[Optional[str], Dict[str, str]]:
        """
        Retrieves the corresponding asset to replace 'fromAsset'

        Parameters
        ----------
        fromAsset: :class:`str`
            The asset to be replaced

        version: Optional[:class:`float`]
            The game version we want the asset to come from :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will retrieve the asset of the latest version. :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        toAssets: Optional[Union[:class:`str`, Set[:class:`str`]]]
            The assets to used for replacement

        Returns
        -------
        Union[:class:`str`, Dict[:class:`str`, :class:`str`]]
            The corresponding assets for the fix to replace, if available :raw-html:`<br />` :raw-html:`<br />`

            The result is a string if the passed in parameter 'toAssets' is also a string :raw-html:`<br />` :raw-html:`<br />`
            
            Otherwise, the result is a dictionary such that: :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the names of the assets
            * The values are the corresponding asset ids to replace
        """

        if (fromAsset not in self._fromAssets):
            if (isinstance(toAssets, str)):
                return None
            else:
                return {}

        toAssetMetadata = self._fromAssets[fromAsset]
        toAssetType = toAssetMetadata[1]
        toAssetNames = toAssetMetadata[0]

        resultAsStr = False
        if (toAssets is not None and isinstance(toAssets, str)):
            toAssetNames = {toAssets}
            resultAsStr = True
        elif (toAssets is not None and toAssets):
            toAssetNames = toAssetNames.intersection(toAssets)

        result = {}
        for toAssetName in toAssetNames:
            try:
                currentReplacement = self.get(toAssetName, toAssetType, version = version)
            except KeyError:
                continue
            else:
                result[toAssetName] = currentReplacement

        if (not resultAsStr):
            return result
        
        try:
            return result[toAssets]
        except KeyError:
            return None
    
    def _loadFromAssets(self):
        self._fromAssets = self._getFromAssets(self._map, self._repo)  

    def _loadToAssets(self):
        self._toAssets = self._getToAssets(self._fixTo, self._repo)
        
    def _updateAssetContent(self, srcAsset: Dict[str, str], newAsset: Dict[str, str]) -> Dict[str, str]:
        return DictTools.update(srcAsset, newAsset)

    def _getAssetChanges(self, oldAssets: Dict[float, Dict[str, Dict[str, str]]], newAssets: Dict[float, Dict[str, Dict[str, str]]]) -> Tuple[Dict[str, str], Dict[float, Dict[str, Dict[str, str]]], Dict[float, Dict[str, Dict[str, str]]]]:
        assetsToRemove = {}
        assetsToUpdate = {}
        changedIds = {}
        commonVersions = set(oldAssets.keys()).intersection(set(newAssets.keys()))
        
        for version in commonVersions:
            oldVersionAssets = oldAssets[version]
            newVersionAssets = newAssets[version]
            commonAssetNames = set(oldVersionAssets).intersection(set(newVersionAssets.keys()))

            for assetName in commonAssetNames:
                oldVersionNameAssets = oldVersionAssets[assetName]
                newVersionNameAssets = newVersionAssets[assetName]
                commonAssetTypes = set(oldVersionNameAssets.keys()).intersection(set(newVersionNameAssets.keys()))

                for assetType in commonAssetTypes:
                    oldAsset = oldVersionNameAssets[assetType]
                    newAsset = newVersionNameAssets[assetType]

                    if (oldAsset != newAsset):
                        assetsToRemove[version][assetName][assetType] = oldAsset
                        assetsToUpdate[version][assetName][assetType] = newAsset
                        changedIds[oldAsset] = newAsset

        return [changedIds, assetsToRemove, assetsToUpdate]

    @classmethod
    def _updateFromAssetsIds(self, fromAssets: Dict[str, Tuple[Set[str], str]], changedAssetIds: Dict[str, str]):
        for oldAssetId in changedAssetIds:
            newAssetId = changedAssetIds[oldAssetId]
            assetMetadata = fromAssets[oldAssetId]
            fromAssets.pop(oldAssetId)
            fromAssets[newAssetId] = assetMetadata

    @classmethod
    def _getFromAssets(cls, map: Dict[str, Set[str]], assets: Dict[float, Dict[str, Dict[str, str]]]) -> Dict[str, Tuple[Set[str], str]]:
        """
        Retrieves the assets to fix from

        Parameters
        ----------
        map: Dict[str, Set[str]]
            The mapping for fixing the assets

        assets: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
            The source for all the assets :raw-html:`<br />` :raw-html:`<br />`

            * The outer key is the game version number for the assets
            * The first inner key is the name of the asset
            * The second inner key is the type of asset
            * The most inner value is the id for the asset (must be unique)

        Returns
        -------
        Dict[:class:`str`, Tuple[Set[:class:`str`], :class:`str`]]
            The assets to fix from :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the ids for the asset
            * The values contains metadata about the assets to fix to where each tuple contains:

                # The names of the assets
                # The type of asset

        """

        result = {}
        if (not map):
            return result

        invertedAssets = defaultdict(lambda: {})
        toAssets = defaultdict(lambda: set())

        for version in assets:
            versionAssets = assets[version]

            # get all the available assets to fix from
            for name in map:
                try:
                    asset = versionAssets[name]
                except KeyError:
                    continue
                else:
                    asset = DictTools.invert(asset)
                    DictTools.update(invertedAssets[name], asset)

            # get the available assets to fix to
            for name in map:
                toAssetNames = map[name]
                for toAssetName in toAssetNames:
                    try:
                        asset = versionAssets[toAssetName]
                    except:
                        continue
                    else:
                        toAssets[toAssetName] = toAssets[toAssetName].union(set(asset.keys()))

        # organize the assets
        for fromAssetName in invertedAssets:
            asset = invertedAssets[fromAssetName]
            toAssetNames = map[fromAssetName]

            for assetId in asset:
                assetType = asset[assetId]
                toNames = set()

                for toAssetName in toAssetNames:
                    toAssetTypes = toAssets[toAssetName]
                    if (assetType in toAssetTypes):
                        toNames.add(toAssetName)

                metadata = (toNames, assetType)
                result[assetId] = metadata

        return result
    
    @classmethod
    def _removeToAssets(cls, toAssets: Dict[float, Dict[str, Dict[str, str]]], assetsToRemove: Dict[float, Dict[str, Dict[str, str]]]):
        for version in toAssets:
            versionAssets = toAssets[version]
            
            for name in versionAssets:
                currentAssets = versionAssets[name]

                for type in currentAssets:
                    try:
                        assetsToRemove[version][name][type]
                    except:
                        continue
                    else:
                        toAssets[version][name].pop(type)

                if (not toAssets[version][name]):
                    toAssets[version].pop(name)

            if (not toAssets[version]):
                toAssets.pop(version)
    
    def _getToAssets(self, assetNames: Set[str], assets: Dict[float, Dict[str, Dict[str, str]]]) -> Dict[float, Dict[str, Dict[str, str]]]:
        """
        Retrieves the assets to fix to

        Parameters
        ----------
        assetNames: Set[:class:`str`]
            The names of the assets to fix to

        assets: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
            The source for all the assets :raw-html:`<br />` :raw-html:`<br />`

            * The outer key is the game version number for the assets
            * The first inner key is the name of the asset
            * The second inner key is the type of asset
            * The most inner value is the id for the asset (must be unique)

        Returns
        -------
        Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
            The assets to fix to  :raw-html:`<br />` :raw-html:`<br />`

            * The outer key is the game version number for the assets
            * The first inner key is the name of the asset
            * The second inner key is the type of asset
            * The most inner value is the id for the asset (must be unique)
        """

        result = {}
        if (not assetNames):
            return result
        
        prevToAssets = defaultdict(lambda: {})

        for version, versionAssets in assets.items():
            currentToAssets = {}

            for name in assetNames:
                try:
                    asset = versionAssets[name]
                except KeyError:
                    continue
                else:
                    prevAsset = prevToAssets[name]
                    DictTools.update(prevAsset, asset)
                    
                    if (prevAsset):
                        currentToAssets[name] = copy.deepcopy(prevAsset)
                        self._addVersion(name, version)

            if (currentToAssets):
                result[version] = currentToAssets

        return result


    def addMap(self, assetMap: Dict[str, Set[str]], assets: Optional[Dict[float, Dict[str, Dict[str, str]]]] = None):
        super().addMap(assetMap, assets = assets)
        if (assets is None):
            assets = {}

        changedIds, assetsIdsToRemove, assetsIdsToUpdate = self._getAssetChanges(self._repo, assets)
        self._repo = self.updateRepo(self._repo, assets)
        newAddMap, addFixFrom, addFixTo = self._partition(assetMap, self._repo)

        self._repo = self._repo
        if (not addFixFrom or not addFixTo):
            return

        self._map = self.updateMap(self._map, newAddMap)
        self._fixFrom = self._fixFrom.union(addFixFrom)
        self._fixTo = self._fixTo.union(addFixTo)

        # update the assets to fix from
        self._updateFromAssetsIds(self._fromAssets, changedIds)
        addFromAssets = self._getFromAssets(newAddMap, self._repo)
        DictTools.update(self._fromAssets, addFromAssets)

        # update the assets to fix to
        self._removeToAssets(self._toAssets, assetsIdsToRemove)

        addToAssetNames = set(map(lambda versionAssets: versionAssets.keys(), assetsIdsToUpdate.values()))
        addToAssetNames = addToAssetNames.union(addFixTo)
        addToAssets = self._getToAssets(addToAssetNames, self._repo)

        DictTools.update(self._toAssets, addToAssets, combineDuplicate = lambda version, srcToAssets, newToAssets: self._updateDupAssets(srcToAssets, newToAssets))


class Hashes(ModIdAssets):
    """
    This class inherits from :class:`ModDictStrAssets`
    
    Class for managing hashes for a mod

    Parameters
    ----------
    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the hashes to fix from to the hashes to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(HashData, map = map)


IndexData = {4.0 : {ModTypeNames.Amber.value: {"head": "0", "body": "5670"},
        ModTypeNames.AmberCN.value: {"head": "0", "body": "5670"},
        ModTypeNames.Ayaka.value: {"head": "0", "body": "11565", "dress": "58209"},
        ModTypeNames.AyakaSpringbloom.value: {"head": "0", "body": "56223", "dress": "69603"},
        ModTypeNames.Barbara.value: {"head": "0", "body": "12015", "dress": "46248"},
        ModTypeNames.BarbaraSummertime.value: {"head": "0", "body": "11943", "dress": "45333"},
        ModTypeNames.Diluc.value: {"head": "0", "body": "10896"},
        ModTypeNames.DilucFlamme.value: {"head": "0", "body": "38061", "dress": "56010"},
        ModTypeNames.Fischl.value: {"head": "0", "body": "11535", "dress": "42471"},
        ModTypeNames.FischlHighness.value: {"head": "0", "body": "23091"},
        ModTypeNames.Ganyu.value: {"head": "0", "body": "12822", "dress": "47160"},
        ModTypeNames.HuTao.value: {"head": "0", "body": "16509"},
        ModTypeNames.Jean.value: {"head": "0", "body": "7779"},
        ModTypeNames.JeanCN.value: {"head": "0", "body": "7779"},
        ModTypeNames.JeanSea.value: {"head": "0", "body": "7662", "dress": "52542"},
        ModTypeNames.Kaeya.value: {"head": "0", "body": "7596", "dress": "47349", "extra": "47727"}, # there seem to be 378 extra triangular faces not included in the original assets repo
        ModTypeNames.KaeyaSailwind.value: {"head": "0", "body": "23109", "dress": "76839"},
        ModTypeNames.Keqing.value: {"head": "0", "body": "10824", "dress": "48216"},
        ModTypeNames.KeqingOpulent.value: {"head": "0", "body": "19623"},
        ModTypeNames.Kirara.value: {"head": "0", "body": "37128", "dress": "75234"},
        ModTypeNames.Klee.value: {"head": "0", "body": "8436"},
        ModTypeNames.KleeBlossomingStarlight.value: {"head": "0", "body": "32553", "dress": "82101"},
        ModTypeNames.Lisa.value: {"head": "0", "body": "16815", "dress": "45873"},
        ModTypeNames.LisaStudent.value: {"head": "0", "body": "29730"},
        ModTypeNames.Mona.value: {"head": "0", "body": "17688"},
        ModTypeNames.MonaCN.value: {"head": "0", "body": "17688"},
        ModTypeNames.Nilou.value: {"head": "0", "body": "44844", "dress": "64080"},
        ModTypeNames.Ningguang.value: {"head": "0", "body": "12384", "dress": "47157"},
        ModTypeNames.NingguangOrchid.value: {"head": "0", "body": "43539", "dress": "56124"},
        ModTypeNames.Rosaria.value: {"head": "0", "body": "11139", "dress": "44088", "extra": "45990"},
        ModTypeNames.RosariaCN.value: {"head": "0", "body": "11025", "dress": "46539", "extra": "48441"},
        ModTypeNames.Shenhe.value: {"head": "0", "body": "14385", "dress": "48753"},
        ModTypeNames.Xiangling.value: {"head": "0", "body": "11964", "dress": "48120"},
        ModTypeNames.Xingqiu.value: {"head": "0", "body": "6132"}},
        4.4: {ModTypeNames.ShenheFrostFlower.value: {"head": "0", "body": "31326", "dress": "66588", "extra": "70068"},
              ModTypeNames.GanyuTwilight.value: {"head": "0", "body": "50817", "dress": "74235"},
              ModTypeNames.XingqiuBamboo.value: {"head": "0", "body": "32508", "dress": "62103"}},
        4.6: {ModTypeNames.Arlecchino.value: {"head": "0", "body": "40179", "dress": "74412"},
              ModTypeNames.ArlecchinoBoss.value: {"head": "0", "body": "40179", "dress": "74412"}},
        4.8: {ModTypeNames.NilouBreeze.value: {"head": "0", "body": "44538", "dress": "73644"},
              ModTypeNames.KiraraBoots.value: {"head": "0", "body": "36804", "dress": "80295"}},
        5.3: {ModTypeNames.CherryHuTao.value: {"head": "0", "body": "43968", "dress": "77301", "extra": "86808"},
              ModTypeNames.XianglingCheer.value: {"head": "0", "body": "46374"}}}


class Indices(ModIdAssets):
    """
    This class inherits from :class:`ModDictStrAssets`
    
    Class for managing indices for a mod

    Parameters
    ----------
    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the indices to fix from to the indices to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(IndexData, map = map)


class IfTemplatePart():
    """
    Base class for some part in an :class:`IfTemplates`    
    """

    def toStr(self) -> str:
        """
        Retrieves the part as a string

        Returns
        -------
        :class:`str`
            The string representation of the part        
        """

        pass


class IfPredPart(IfTemplatePart):
    """
    This class inherits from :class:`IfTemplatePart`

    Class for defining the predicate part of an :class:`IfTemplate`

    .. note::
        see :class:`IfTemplate` for more details

    Parameters
    ----------
    pred: :class:`str`
        The predicate string within the :class:`IfTemplate`

    type: :class:`IfPredPartType`
        The type of predicate encountered

    Attributes
    ----------
    pred: :class:`str`
        The predicate string within the :class:`IfTemplate`

    type: :class:`IfPredPartType`
        The type of predicate encountered
    """

    def __init__(self, pred: str, type: IfPredPartType):
        self.pred = pred
        self.type = type


    def toStr(self) -> str:
        return f"{self.pred}"


class RemappedKeyData():
    """
    Class to store data about a remapped register within a .ini `section`_

    Parameters
    ----------
    key: :class:`str`
        The new register name to remap the old register to

    check: Optional[Callable[[:class:`str`, :class:`str`], :class:`bool`]]
        Predicate to check whether to remap to the new register :raw-html:`<br />` :raw-html:`<br />`

        The predicate takes in:
         
        #. the old register name 
        #. the old register value

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    toInd: Optional[:class:`int`]
        Whether to shift the remapped register to a particular index within the :class:`IfContentPart` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    key: :class:`str`
        The new register name to remap the old register to

    check: Callable[[:class:`str`, :class:`str`], :class:`bool`]
        Predicate to check whether to remap to the new register

    toInd: Optional[:class:`int`]
        Whether to shift all the remapped register to a particular index within the :class:`IfContentPart`
    """

    def __init__(self, key: str, check: Optional[Callable[[str, str], bool]] = None, toInd: Optional[int] = None):
        self.key = key
        self.check = check
        self.toInd = toInd

    @classmethod
    def build(cls, data: Union[str, Tuple[str, Callable[[str, str], bool]], "RemappedKeyData"]) -> "RemappedKeyData":
        """
        Builds the object based off the raw 'data' provided

        Parameters
        ----------
        data: Union[:class:`str`, Tuple[:class:`str`, Callable[[:class:`str`, :class:`str`], :class:`bool`]]]
            The data to provide into the :class:`RemappedKeyData` class :raw-html:`<br />` :raw-html:`<br />`

            The provided data either contains:
            
            * The new name of the key to remap to OR
            * A tuple containing a new name for the key to remap to and a predicate that takes in the old key and old value of whether to remap the key. OR
            * The object that contains all the necessary information for remapping to the new key

        Returns
        -------
        :class:`RemappedKeyData`
            The constructed object
        """

        if (isinstance(data, cls)):
            return data
        elif (isinstance(data, str)):
            return cls(data)
        return cls(data[0], check = data[1])
    

class KeyRemapData():
    """
    Class to store data about a remapping a particular register

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x[ind]

            Retrieves the corresponding :class:`RemappedKeyData` based off the index, 'ind'

        .. describe:: len(x)

            Retrieves the number of keys to remap to

        .. describe:: for remapped key in x

            Iterates through all the data of the keys to remap to

    Parameters
    ----------
    remappedKeys: List[:class:`RemappedKeyData`]
        The new registers to remap the old register to

    keepKeyWithoutRemap: :class:`bool`
        Whether retain the old register, if the old register does not get remapped :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    Attributes
    ----------
    remappedKeys: List[:class:`RemappedKeyData`]
        The new registers to remap the old register to

    keepKeyWithoutRemap: :class:`bool`
        Whether retain the old register, if the old register does not get remapped
    """

    def __init__(self, remappedKeys: List[RemappedKeyData], keepKeyWithoutRemap: bool = False):
        self.keepKeyWithoutRemap = keepKeyWithoutRemap
        self.remappedKeys = remappedKeys

    def __getitem__(self, key: int) -> RemappedKeyData:
        return self.remappedKeys[key]
    
    def __len__(self) -> int:
        return len(self.remappedKeys)
    
    def __iter__(self):
        for remappedKey in self.remappedKeys:
            yield remappedKey

    @classmethod
    def build(cls, remappedKeys: Union["KeyRemapData", List[Union[str, Tuple[str, Callable[[str, str], bool]], RemappedKeyData]]], keepKeyWithoutRemap: bool = False) -> "KeyRemapData":
        """
        Build the object based off the raw 'remappedKeys' provided

        Parameters
        ----------
        remappedKeys: Union[:class:`KeyRemapData`, List[Union[:class:`str`, Tuple[:class:`str`, Callable[[:class:`str`, :class:`str`], :class:`bool`]], :class:`RemappedKeyData`]]]
            raw data to provide into the object that contains either: :raw-html:`<br />` :raw-html:`<br />`

            * The data for remapping a particular key OR
            * A list containing:

                * The new names of the keys to remap to OR
                * A tuple containing a new name for the key to remap to and a predicate that takes in the old key and value of whether to remap the key. OR
                * A class that contains all the necessary information for remapping to the new key

        keepKeyWithoutRemap: :class:`bool`
            Whether retain the old register, if the old register does not get remapped :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        if (isinstance(remappedKeys, cls)):
            return remappedKeys

        remappedKeys = list(map(lambda remappedKey: RemappedKeyData.build(remappedKey), remappedKeys))
        return cls(remappedKeys, keepKeyWithoutRemap)


class IfContentPart(IfTemplatePart):
    """
    This class inherits from :class:`IfTemplatePart`

    Class for defining the content part of an :class:`IfTemplate`

    .. note::
        see :class:`IfTemplate` for more details

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: key in x

            Determines if 'key' exists in the content part of the :class:`IfContentPart`

        .. describe:: x[key]

            Retrieves the corresponding data value from the :class:`IfContentPart` based off 'key' :raw-html:`<br />` :raw-html:`<br />`

            * If 'key' is an :class:`int`, then will retrieve a tuple containing:

                #. The corresponding key for the `KVP`_ found
                #. The corresponding value to the found `KVP`_
                #. The occurence index for the key of the `KVP`_

            * Otherwise, will retrieve the corresponding value from :meth:`IfContentPart.src`

        .. describe:: for key, val, keyInd, orderInd in x

            Iterates over all the key/value initializations and updates within the :class:`IfContentPart`, ``x`` :raw-html:`<br />` :raw-html:`<br />`

            The tuples to iterate over are as follows:

            #. key: (:class:`str`) A particular key in the :class:`IfContentPart`
            #. val: (:class:`str`) The corresponding value to the key
            #. keyInd: (:class:`int`) The occurence index of the same key within the :class:`IfContentPart`
            #. orderInd: (:class:``int) The order index the `KVP`_ appears in the overall :class:`IfContentPart`

    Parameters
    ----------
    src: Dict[:class:`str`, List[Tuple[:class:`int`, :class:`str`]]]
        The source for the part in the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the name of the keys in the part
        * The values are the coresponding values for the keys for all instances where the particular key got instantiated/updated. Each element in the list contains:

            #. The order index the `KVP`_ was called within the part
            #. The value of the `KVP`_

    depth: :class:`int`
        The depth the part is within the :class:`IfTemplate`

    Attributes
    ----------
    src: Dict[:class:`str`, List[Tuple[:class:`int`, :class:`str`]]]
        The source for the part in the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the name of the keys in the part
        * The values are the coresponding values for the keys for all instances where the particular key got instantiated/updated. Each element in the list contains:
            #. The order index the `KVP`_ was called within the part
            #. The value of the `KVP`_

    depth: :class:`int`
        The depth the part is within the :class:`IfTemplate`

    _order: List[Tuple[:class:`str`, :class:`int`]]
        The order the `KVP`_s appear in the part. The elements contain:
            #. The name of the key for the `KVP`_
            #. The occurence index of the key within the part
    """

    def __init__(self, src: Dict[str, List[Tuple[int, str]]], depth: int):
        self._order: List[Tuple[str, int]] = []
        self.src = src
        self.depth = depth

    def __iter__(self):
        for key, keyInd in self._order:
            valTuple = self.src[key][keyInd]
            orderInd = valTuple[0]
            val = valTuple[1]
            result = (key, val, keyInd, orderInd)
            yield result

    def __contains__(self, key: str):
        return key in self.src

    def __getitem__(self, key: Union[str, int]) -> Union[List[Tuple[int, str]], Tuple[str, str, int]]:
        if (isinstance(key, int)):
            kvpRef = self._order[key]
            val = self.src[kvpRef[0]][kvpRef[1]][1]
            return (kvpRef[0], val, kvpRef[1])

        return self.src[key]
    
    def get(self, key: Union[str, int], default: Optional[Any] = None) -> Union[List[Tuple[int, str]], str, Any]:
        """
        Retrieves the corresponding data value from the :class:`IfContentPart` based off 'key' :raw-html:`<br />` :raw-html:`<br />`

            * If 'key' is an :class:`int`, then will retrieve a tuple containing:

                #. The corresponding key for the `KVP`_ found
                #. The corresponding value to the found `KVP`_
                #. The occurence index for the key of the `KVP`_

            * Otherwise, will retrieve the corresponding value from :meth:`IfContentPart.src` :raw-html:`<br />` :raw-html:`<br />`

        If the 'key' is not found, then will return the value from 'default'

        .. note::
            This is the same as the `getitem operator`_ specified for this class, but will return a default value
            if the key is not found

        Paramters
        ---------
        key: Union[:class:`str`, :class:`int`]
            The key to search for in this class

        default: Optional[Any]
            The default value to return if the key is not found :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns 
        -------
        Union[List[Tuple[:class:`int`, :class:`str`]], Tuple[:class:`str`, :class:`str`, :class:`int`], Any]
            Either the found value or the default value
        """

        try:
            return self.__getitem__(key)
        except KeyError:
            return default
        except IndexError:
            return default

    @property
    def src(self):
        """
        The raw content of the part :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the names of the keys in the content part of the :class:`IfTemplate`. Note that the same key can appear multiple times in a particular content part.
        * The values consists of:
            #. The order index the `KVP`_ appeared in the :class:`IfContentPart`
            #. The corresponding value for the key

        :getter: Retrieves the raw content of the part
        :setter: Sets the raw content for the part
        :type: Dict[:class:`str`, List[:class:`int`, :class:`str`]]
        """

        return self._src
    
    @src.setter
    def src(self, newSrc: Dict[str, List[Tuple[int, str]]]):
        self._src = newSrc
        self._setupOrder()

    def _setupOrder(self):
        self._order = []
        for key in self.src:
            values = self.src[key]
            valuesLen = len(values)
            for i in range(valuesLen):
                orderInd, _ = values[i]
                keyRef = (key, i, orderInd)
                Algo.binaryInsert(self._order, keyRef, lambda keyRef1, keyRef2: keyRef1[2] - keyRef2[2])

        self._order = list(map(lambda orderData: orderData[:-1], self._order))

    def toStr(self, linePrefix: str = "") -> str:
        """
        Retrieves the part as a string

        Parameters
        ----------
        linePrefix: :class:`str`
            The string that will prefix every line :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`str`
            The string representation of the part        
        """

        result = ""
        orderLen = len(self._order)
        i = 0
        for key, val, keyInd, orderInd in self:
            result += f"{linePrefix}{key} = {val}"
            if (i < orderLen - 1):
                result += "\n"
            i += 1

        return result
    
    def getVals(self, key: str) -> List[str]:
        """
        Retrieves the corresponding values based off 'key'
        
        Parameters
        ----------
        key: :class:`str`
            The key to the values belong to

        Returns
        -------
        List[:class:`str`]
            The corresponding values found for the key
        """

        result = []

        values = None
        try:
            values = self._src[key]
        except KeyError:
            return result
        
        result = list(map(lambda valData: valData[1], values))
        return result
    
    def _updateOrderOccurrencesAfterRemoval(self, key: str, ind: int, change: int):
        newInd = ind + change
        valData = self._src[key][newInd]
        orderInd = valData[0]

        keyData = self._order[orderInd]
        self._order[orderInd] = (keyData[0], newInd)
    
    def removeKey(self, key: Union[str, Tuple[str, Callable[[Tuple[int, str]], bool]]]):
        """
        Removes a key from the part.

        Parameters
        ----------
        key: :class:`str`
            The key to remove. :raw-html:`<br />` :raw-html:`<br />`

            * If given only a string, will delete all instances of the key.
            * If given a tuple containing a string and a predicate, will delete all the keys that satisfy the predicate.
              The predicate takes in a tuple that contains:

                #. The order index where the corresponding `KVP`_ appeared
                #. The corresponding value for the `KVP`_
        """

        orderIndsToRemove = set()
        values = None
        pred = lambda val: True
        targetKey = key

        if (isinstance(key, tuple) and len(key) >= 2):
            pred = key[1]
            targetKey = key[0]

        try:
            values = self.src[targetKey]
        except KeyError:
            return
        
        currentValRemovedInds = set()
        valuesLen = len(values)

        for i in range(valuesLen):
            value = values[i]
            if (pred(value)):
                orderIndsToRemove.add(value[0])
                currentValRemovedInds.add(i)

        if (len(currentValRemovedInds) == len(values)):
            del self.src[targetKey]
        else:
            keyValsLen = len(self.src[targetKey])
            self.src[targetKey] = ListTools.removeByInds(values, currentValRemovedInds)

            currentValRemovedInds = list(currentValRemovedInds)
            currentValRemovedInds.sort()

            ListTools.updateIndsAfterRemove(currentValRemovedInds, keyValsLen, lambda ind, change: self._updateOrderOccurrencesAfterRemoval(targetKey, ind, change))

        self._order = ListTools.removeByInds(self._order, orderIndsToRemove)

        # update the order indices
        orderLen = len(self._order)
        for i in range(orderLen):
            orderData = self._order[i]
            valData = self.src[orderData[0]][orderData[1]]
            self.src[orderData[0]][orderData[1]] = (i, valData[1])

    def removeKeys(self, keys: Set[Union[str, Tuple[str, Callable[[Tuple[int, str]], bool]]]]):
        """
        Removes multiple keys from the part

        Parameters
        ----------
        keys: Set[Union[:class:`str`, Callable[[Tuple[:class:`int`, :class:`str`]], :class:`bool`]]]
            The keys to remove. :raw-html:`<br />` :raw-html:`<br />`

            * If given only a string, will delete all instances of the key.
            * If given a tuple containing a string and a predicate, will delete all the keys that satisfy the predicate.
              The predicate takes in a tuple that contains:

              #. The order index where the corresponding `KVP`_ appeared
              #. The corresponding value for the `KVP`_
        """

        orderIndsToRemove = set()

        for key in keys:
            pred = lambda val: True
            targetKey = key

            if (isinstance(key, tuple) and len(key) >= 2):
                pred = key[1]
                targetKey = key[0]

            values = None
            try:
                values = self.src[targetKey]
            except KeyError:
                continue
            
            currentValRemovedInds = set()
            valuesLen = len(values)

            for i in range(valuesLen):
                value = values[i]
                if (pred(value)):
                    orderIndsToRemove.add(value[0])
                    currentValRemovedInds.add(i)

            if (len(currentValRemovedInds) == len(values)):
                del self.src[targetKey]
            else:
                keyValsLen = len(self.src[targetKey])
                self.src[targetKey] = ListTools.removeByInds(values, currentValRemovedInds)

                currentValRemovedInds = list(currentValRemovedInds)
                currentValRemovedInds.sort()

                ListTools.updateIndsAfterRemove(currentValRemovedInds, keyValsLen, lambda ind, change: self._updateOrderOccurrencesAfterRemoval(targetKey, ind, change))

        if (not orderIndsToRemove):
            return
        
        self._order = ListTools.removeByInds(self._order, orderIndsToRemove)

        # update the order indices
        orderLen = len(self._order)
        for i in range(orderLen):
            orderData = self._order[i]
            valData = self.src[orderData[0]][orderData[1]]
            self.src[orderData[0]][orderData[1]] = (i, valData[1])

    def addKVPToFront(self, key: str, value: str):
        """
        Adds a new `KVP`_ into the part
        
        .. warning::
            This operation will take `O(n)` time, where `n` is the # of `KVP`_s within the part

        Parameters
        ----------
        key: :class:`str`
            The name of the key

        value: :class:`str`
            The corresponding value to the key
        """

        try:
            self.src[key]
        except KeyError:
            self.src[key] = []

        valData = (-1, value)
        self.src[key].insert(0, valData)
        self._order.insert(0, (key, -1))

        # update the indices of the other KVPs
        for keyName in self.src:
            kvps = self.src[keyName]
            kvpsLen = len(kvps)

            for i in range(kvpsLen):
                valData = kvps[i]
                kvps[i] = (valData[0] + 1, valData[1])

            if (keyName != key):
                continue
            
            kvpsLen = len(kvps)
            for i in range(kvpsLen):
                valData = kvps[i]
                orderInd = valData[0]
                self._order[orderInd] = (key, i)
        

    def addKVP(self, key: str, value: str, toFront: bool = False):
        """
        Adds a new `KVP`_ into the part

        Parameters
        ----------
        key: :class:`str`
            The name of the key

        value: :class:`str`
            The corresponding value to the key

        toFront: :class:`bool`
            Whether to add the new `KVP`_ to the front of the part

            .. warning::
                Please see the warning at :meth:`addKVPToFront`
        """

        if (toFront):
            self.addKVPToFront(key, value)
            return

        try:
            self.src[key]
        except KeyError:
            self.src[key] = []
        
        valData = (len(self._order), value)
        self.src[key].append(valData)
        self._order.append((key, len(self.src[key]) - 1))

    def replaceVals(self, newVals: Dict[str, Union[str, List[str], Tuple[str, Callable[[str], bool]]]], addNewKVPs: bool = True):
        """
        Replaces the values in the `KVP`_s of the parts or adds in new `KVP`_s if the original key did not exist

        Parameters
        ----------
        newVals: Dict[:class:`str`, Union[:class:`str`, List[:class:`str`], Tuple[:class:`str`, Callable[[:class:`str`], :class:`bool`]]]]
            The new values for the `KVP`_s in the parts :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the corresponding keys for the `KVP`_s
            * The values can either contain:
                
                * A string, which represents the new value for all instances of the key OR
                * A list of strings, representing the individual new values for each instance of the key OR
                * A tuple containing a string and a predicate, representing the new value for certain instances of the key that satisfy the predicate.
                  The predicate takes in the old value of the `KVP`_ as an argument

        addNewKVPs: :class:`bool`
            Whether to add new KVPs if the corresponding key in 'newVals' does not exist :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        for key in newVals:
            vals = newVals[key]

            valsIsStr = isinstance(vals, str)
            valsIsCond = isinstance(vals, tuple) and len(vals) >= 2

            currentVals = None
            try:
                currentVals = self.src[key]
            except KeyError:
                if (not addNewKVPs):
                    continue

                if (valsIsStr):
                    self.addKVP(key, vals)
                elif (valsIsCond):
                    self.addKVP(key, vals[0])
                else:
                    for val in vals:
                        self.addKVP(key, val)

                continue

            if (valsIsStr):
                self.src[key] = list(map(lambda valData: (valData[0], vals), currentVals))
                continue

            elif (valsIsCond):
                currentValsLen = len(currentVals)
                pred = vals[1]

                for i in range(currentValsLen):
                    valData = currentVals[i]
                    if (pred(valData[1])):
                        self.src[key][i] = (valData[0], vals[0])

                continue

            smallerValLen = min(len(currentVals), len(vals))
            for i in range(smallerValLen):
                valData = self.src[key][i]
                self.src[key][i] = (valData[0], vals[i])

    def remapKeys(self, keyRemap: Dict[str, Union[KeyRemapData, List[Union[str, Tuple[str, Callable[[str, str], bool]], RemappedKeyData]]]]):
        """
        Remaps the keys in the `KVP`_s of the parts

        Parameters
        ----------
        keyRemap: Dict[:class:`str`, Union[:class:`KeyRemapData`, List[Union[:class:`str`, Tuple[:class:`str`, Callable[[:class:`str`, :class:`str`], :class:`bool`]], :class:`RemappedKeyData`]]]]
            The remap for the keys, where: :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the old names of the keys to be remapped
            * the values are either:

                * The data for remapping a particular key OR
                * A list containing either:

                    * The new names of the keys to remap to OR
                    * A tuple containing a new name for the key to remap to and a predicate that takes in the old key and value of whether to remap the key. OR
                    * A class that contains all the necessary information for remapping to the new key
        """

        occurences = defaultdict(lambda: 0)
        i = 0
        orderLen = len(self._order)
        keysToRemove = set()
        keysToAdd = set()
        convertedKeyRemap = {}

        newOrder = []
        orderNewOccurences = []
        for i in range(orderLen):
            newOrder.append([])
            orderNewOccurences.append(-1)

        newSrc = defaultdict(lambda: [])
        for key in self._src:
            newSrc[key]

        for i in range(orderLen):
            keyData = self._order[i]
            key = keyData[0]
            keyOccurence = keyData[1]
            currentMaxOccurence = occurences[key]
            
            # update the occurence of the key
            if (keyOccurence < currentMaxOccurence):
                self._order[i] = (key, currentMaxOccurence)
                orderNewOccurences[i] = currentMaxOccurence

            keyValData = self.src[key][keyOccurence]
            keyVal = keyValData[1]

            inKeyRemap = key in keyRemap
            if (not inKeyRemap):
                occurences[key] += 1
                newSrc[key].append((i, keyVal))
                continue

            newKeys = keyRemap[key]
            newKeysLen = len(newKeys)

            if (key not in convertedKeyRemap):
                convertedKeyRemap[key] = KeyRemapData.build(newKeys)

            newKeys = convertedKeyRemap[key]
            keepKeyWithoutRemap = newKeys.keepKeyWithoutRemap
            keyRemapped = False

            # construct the remapped keys
            for j in range(newKeysLen):
                newKeyData = newKeys[j]
                newKey = newKeyData.key
                check = newKeyData.check
                toInd = newKeyData.toInd

                if (check is not None and not check(key, keyVal)):
                    continue

                if (not keyRemapped):
                    keyRemapped = True

                if (toInd is None):
                    toInd = i

                newOrder[toInd].append((newKey, occurences[newKey]))
                newSrc[newKey].append((-1, keyVal))

                keysToAdd.add(newKey)
                occurences[newKey] += 1

            if (not keyRemapped and keepKeyWithoutRemap):
                occurences[key] += 1
                newSrc[key].append((i, keyVal))

            if (not keepKeyWithoutRemap or (keyRemapped and keepKeyWithoutRemap)):
                keysToRemove.add(key)
            
        # remove the keys that do not appear after the remap
        for key in keysToRemove:
            if (key not in keysToAdd):
                del newSrc[key]

        # construct the new order
        for i in range(orderLen):
            keyData = self._order[i]
            key = keyData[0]

            if (key not in keysToRemove):
                newOrder[i].insert(0, self._order[i])

        self._order = []
        for i in range(orderLen):
            self._order += newOrder[i]

        # construct the new src
        self._src = dict(newSrc)

        orderLen = len(self._order)
        for i in range(orderLen):
            keyData = self._order[i]
            key = keyData[0]
            occurence = keyData[1]

            kvpData = self._src[key][occurence]

            self._src[key][occurence] = (i, kvpData[1])


class IfTemplateNode(Node):
    """
    This class inherits from :class:`Node`

    A node within the parse tree of the :class:`IfTemplate`. 
    This node contains a subset of the :class:`IfContentPart` from the original :class:`IfTemplate`

    .. note::
        For more details on the structure of the parse tree of an :class:`IfTemplate`, see :class:`IfTemplateTree`

    Parameters
    ----------
    id: Optional[Hashable]
        The id for the node :raw-html:`<br />` :raw-html:`<br />`

        If this argument is ``None``, then will generate the id for the node using :meth:`generateId`

    ifPredPart: Optional[:class:`IfPredPart`]
        The predicate part that is associated with this node

    Attributes
    ----------
    id: Hashable
        The id for the node

    children: Dict[Hashable, :class:`IfTemplateNode`]
        The children to this node :raw-html:`<br />` :raw-html:`<br />`

        The keys are the ids of the children nodes and the values are the corresponding nodes for the children

    parts: List[Union[:class:`IfContentPart`, :class:`IfTemplateNode`]]
        The parts of the :class:`IfTemplate` within the node

    partInd: Dict[:class:`int`, :class:`int`]
        The index of some :class:`IfContentPart` within the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

        The keys are the index position of the :class:`IfContentPart` within this node and the values are the index position
        of the :class:`IfContentPart` within the :class:`IfTemplate`
    """

    def __init__(self, id: Optional[Hashable] = None, ifPredPart: Optional[IfPredPart] = None):
        if (id is None):
            id = self.generateId()

        super().__init__(id)

        self.ifPredPart = ifPredPart
        self.parts: List[Union[IfContentPart, "IfTemplateNode"]] = []
        self.children: Dict[Hashable, "IfTemplateNode"] = {}

    @classmethod
    def generateId(self) -> Hashable:
        """
        Generates a new id for the node
        """
        return uuid.uuid4().int

    def addChild(self, node: "IfTemplateNode"):
        """
        Adds a child to the node

        Parameters
        ----------
        node: :class:`IfTemplateNode`
            The child to be added
        """

        self.parts.append(node)
        self.children[node.id] = node

    def addIfContentPart(self, part: IfContentPart):
        """
        Adds an :class:`IfContentPart` to the node

        Parameters
        ----------
        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` to add to this node
        """

        self.parts.append(part)

    def hasKey(self, key: str) -> bool:
        """
        Purely checkes whether the key exists within the parts of the node without accounting for
        whether the key exists in other subcommands called by this node or other children nodes that have the key

        Paramters
        ---------
        key: :class:`str`
            The key to check

        Returns
        -------
        :class:`bool`
            Whether the key exists
        """

        result = False

        for part in self.parts:
            if (not isinstance(part, IfContentPart) or key not in part):
                continue

            keyValues = part[key]
            if (not keyValues):
                continue
            
            result = True
            break

        return result
    
    def getKeyValues(self, key: str) -> List[List[Tuple[int, str]]]:
        """
        Retrieves all the corresponding values to a certain key within the node

        Parameters
        ----------
        key: :class:`str`
            The key to find

        Returns
        -------
        List[List[Tuple[:class:`int`, :class:`str`]]]
            All the corresponding values to the key in the node :raw-html:`<br />` :raw-html:`<br />`

            * The outer elements in the list are the values for each part in the node
            * The inner elements of the list are the different instance of the `KVP`_ within each part
            * The tuple contains the order index an occurence of the `KVP`_ appears in the part and the corresponding value for the `KVP`_
        """

        result = []
        for part in self.parts:
            if (not isinstance(part, IfContentPart) or key not in part):
                continue

            result.append(part[key])

        return result
    
    def getKeyMissingPart(self, key: str) -> Tuple[Optional[IfContentPart], bool]:
        """
        Retrieves the first :class:`IfContentPart` if 'key' is not found in this node, without accounting for
        the key being in any other subcommands or other children nodes

        Parameters
        ----------
        key: :class:`str`
            The key to find

        Returns
        -------
        Tuple[Optional[:class:`IfContentPart`], :class:`bool`]
            A tuple containing:

            #. The first part found, if all the :class:`IfContent`s within the node does not contain the key
            #. Whether a :class:`IfContentPart` is found within the node
        """

        result = None
        hasContentPart = False

        for part in self.parts:
            if (not isinstance(part, IfContentPart)):
                continue

            if (not hasContentPart):
                hasContentPart = True

            if (key in part and part[key]):
                result = None
                break
            
            if (result is None):
                result = part

        return (result, hasContentPart)


class IfTemplateTree():
    """
    The parse tree for some :class:`IfTemplate` :raw-html:`<br />`

    .. note::
        The parse tree for the :class:`IfTemplate` is structured such that:

        * A node conposes of :class:`IfContentPart` or other nodes
        * The children to the node occurs when the node enters a specific branching condition :raw-html:`<br />` :raw-html:`<br />`

        eg. Suppose we have this branching structure

        .. code-block:: ini
            :linenos:

            ...(does stuff)...
            if ...(bool)...
                if ...(bool)...
                    ...(does stuff)...
                else if ...(bool)...
                    ...(does stuff)...
                endif
            else ...(bool)...
                ...(does stuff)...
                if ...(bool)...
                    if ...(bool)...
                        ...(does stuff)...
                    endif
                    ...(does stuff)...
                endif
                ...(does stuff)...
                if
                endif
            endif
            ...(does stuff)...
        
        :raw-html:`<br />`

        Let `C` be some :class:`IfContentPart` (the parts that says `...(does stuff)...`)
        Let `B` be some branching point (the parts that say `if` or `else`)
        Let `[...]` be some node
        Let `X` be a node without any parts

        The parse tree generated for the above code would be:

        .. code-block::

                   [C B B C]
                      | |                       
                 +----+ +----+
                 |           | 
               [B B]     [C B C B]
                | |         |   |
             +--+ +--+    [B C] X
             |       |     |
            [C]     [C]   [C]
    """

    def __init__(self):
        self._root: Optional[IfTemplateNode] = None

    @property
    def root(self):
        """
        The root node in the parse tree

        :getter: Retrieves the root node
        :type: :class:`IfTemplateNode`
        """

        return self._root

    def clear(self):
        """
        Clears the tree
        """

        self._root = None

    @classmethod
    def construct(cls, parts: List[IfTemplatePart]):
        """
        Constructs the parse tree

        Parameters
        ----------
        parts: List[:class:`IfTemplatePart`]
            The parts within the :class:`IfTemplate`
        """

        node = IfTemplateNode()
        root = node
        nodeStack = deque()
        partsLen = len(parts)

        for i in range(partsLen):
            part = parts[i]
            if (isinstance(part, IfContentPart)):
                node.addIfContentPart(part)
                continue

            predType = part.type

            if (predType == IfPredPartType.If):
                nodeStack.append(node)
                node = IfTemplateNode(ifPredPart = part)
                continue

            isChild = bool(nodeStack)
            if (not isChild):
                continue

            parent = nodeStack[-1]
            parent.addChild(node)

            if (predType == IfPredPartType.EndIf):
                node = nodeStack.pop()
            elif (predType == IfPredPartType.Else or predType == IfPredPartType.Elif):
                node = IfTemplateNode(ifPredPart = part)

        result = cls()
        result._root = root
        return result
    

class IfTemplateNonEmptyNodeTree(IfTemplateTree):
    """
    This class inherits from :class:`IfTemplateTree`

    A variation of :class:`IfTemplateTree` such that leaf nodes that do not have any parts (eg. empty conditions)
    will include a empty :class:`IfContentPart` placeholder.

    .. tip::
        See :class:`IfTemplateTree` on the basic structure of the parse tree for an :class:`IfTemplate`

    :raw-html:`<br />` :raw-html:`<br />`

    So conditions with forms of:

    .. code-block:: ini

        if
        endif

    that have the following parse subtree:

    .. code-block::

       [B]
        |
        X

    will now become:

    .. code-block:: ini

        if
            ...(does nothing)...
        endif

    with the following parse subtree:
    
    .. code-block::

       [B]
        |
       [C]

    :raw-html:`<br />` :raw-html:`<br />`

    .. note::
        eg. Suppose we have this branching structure (same structure from the example at :class:`IfTemplateTree`)

        .. code-block:: ini
            :linenos:

            ...(does stuff)...
            if ...(bool)...
                if ...(bool)...
                    ...(does stuff)...
                else if ...(bool)...
                    ...(does stuff)...
                endif
            else ...(bool)...
                ...(does stuff)...
                if ...(bool)...
                    if ...(bool)...
                        ...(does stuff)...
                    endif
                    ...(does stuff)...
                endif
                ...(does stuff)...
                if
                endif
            endif
            ...(does stuff)...
        
        :raw-html:`<br />`

        Let `C` be some :class:`IfContentPart` (the parts that says `...(does stuff)...`)
        Let `B` be some branching point (the parts that say `if` or `else`)
        Let `[...]` be some node
        Let `X` be a node without any parts

        The parse tree generated for the above code would be:

        .. code-block::

                   [C B B C]
                      | |                       
                 +----+ +----+
                 |           | 
               [B B]     [C B C B]
                | |         |   |
             +--+ +--+    [B C] |
             |       |     |    |
            [C]     [C]   [C]  [C]
    """

    @classmethod
    def construct(cls, parts: List[IfTemplatePart]):
        """
        Constructs the parse tree

        .. note::
            The construction may change 'parts'

        Parameters
        ----------
        parts: List[:class:`IfTemplatePart`]
            The parts within the :class:`IfTemplate`
        """

        node = IfTemplateNode()
        root = node
        nodeStack = deque()
        partsLen = len(parts)
        depth = 0
        i = 0

        while (i < partsLen):
            part = parts[i]
            if (isinstance(part, IfContentPart)):
                node.addIfContentPart(part)
                i += 1
                continue

            predType = part.type

            if (predType == IfPredPartType.If):
                nodeStack.append(node)
                node = IfTemplateNode(ifPredPart = part)
                depth += 1
                i += 1
                continue

            isChild = bool(nodeStack)
            if (not isChild):
                i += 1
                continue

            parent = nodeStack[-1]
            parent.addChild(node)

            if (predType == IfPredPartType.EndIf):
                if (not node.parts):
                    ifContentPlaceholder = IfContentPart({}, depth)
                    parts.insert(i, ifContentPlaceholder)
                    node.addIfContentPart(ifContentPlaceholder)
                    i += 1
                    partsLen += 1

                node = nodeStack.pop()
                depth -= 1
            elif (predType == IfPredPartType.Else or predType == IfPredPartType.Elif):
                node = IfTemplateNode(ifPredPart = part)

            i += 1

        result = cls()
        result._root = root
        return result
    
class IfTemplateNormTree(IfTemplateNonEmptyNodeTree):
    """
    This class inherits from :class:`IfTemplateNonEmptyNodeTree`

    A variation of :class:`IfTemplateNonEmptyNodeTree` such that an empty ``else`` clause will be added for branches that do not end with a single ``else`` :raw-html:`<br />`

    .. tip::
        See :class:`IfTemplateTree` on the basic structure of the parse tree for an :class:`IfTemplate`

    :raw-html:`<br />` :raw-html:`<br />`

    So conditions with forms of:

    .. code-block:: ini

        if
            ...(does stuff)...
        else if
            ...(does stuff)...
        endif

    that have the following parse subtree:

    .. code-block::

          [B B]
           | |
         +-+ +-+
         |     |
        [C]   [C]

    will now become:

    .. code-block:: ini

        if
            ...(does stuff)...
        else if
            ...(does stuff)...
        else
            ...(does nothing)...
        endif

    with the following parse subtree:
    
    .. code-block::

        [B B B]
         | | |
       +-+ | +-+
       |  [C]  |
      [C]     [C]

    :raw-html:`<br />` :raw-html:`<br />`

    .. note::
        eg. Suppose we have this branching structure (same structure from the example at :class:`IfTemplateTree`)

        .. code-block:: ini
            :linenos:

            ...(does stuff)...
            if ...(bool)...
                if ...(bool)...
                    ...(does stuff)...
                else if ...(bool)...
                    ...(does stuff)...
                endif
            else ...(bool)...
                ...(does stuff)...
                if ...(bool)...
                    if ...(bool)...
                        ...(does stuff)...
                    endif
                    ...(does stuff)...
                endif
                ...(does stuff)...
                if
                endif
            endif
            ...(does stuff)...
        
        :raw-html:`<br />`

        This class will turn this branching structure into:

        .. code-block:: ini
            :linenos:

            ...(does stuff)...
            if ...(bool)...
                if ...(bool)...
                    ...(does stuff)...
                else if ...(bool)...
                    ...(does stuff)...
                else
                    ...(does nothing)...
                endif
            else ...(bool)...
                ...(does stuff)...
                if ...(bool)...
                    if ...(bool)...
                        ...(does stuff)...
                    else
                        ...(does nothing)...
                    endif
                    ...(does stuff)...
                else
                    ...(does nothing)...
                endif
                ...(does stuff)...
                if
                    ...(does nothing)...
                else
                    ...(does nothing)...
                endif
            endif
            ...(does stuff)...

        Let `C` be some :class:`IfContentPart` (the parts that says `...(does stuff)...`)
        Let `B` be some branching point (the parts that say `if` or `else`)
        Let `[...]` be some node
        Let `X` be a node without any parts

        The parse tree generated for the above code would be:

        .. code-block::

                     [C B B C]
                        | |                       
                    +----+ +-------+
                    |              | 
               [B B B]         [C B B C B B]
                | | |             | |   | |
             +--+ | +-+         +-+ +-+ | +--+
             |    |   |         |     | |    |
            [C]  [C] [C]     [B B C]  | +-+  |
                              | |     |   | [C]
                            +-+ |    [C]  |
                            |   |        [C]
                           [C] [C]
    """

    @classmethod
    def construct(cls, parts: List[IfTemplatePart]):
        node = IfTemplateNode()
        root = node
        nodeStack = deque()
        partsLen = len(parts)
        elseEncountered = False
        elseEncounteredStack = deque() 
        depth = 0
        i = 0

        while (i < partsLen):
            part = parts[i]
            if (isinstance(part, IfContentPart)):
                node.addIfContentPart(part)
                i += 1
                continue

            predType = part.type

            if (predType == IfPredPartType.If):
                nodeStack.append(node)
                node = IfTemplateNode(ifPredPart = part)
                elseEncounteredStack.append(elseEncountered)
                elseEncountered = False
                depth += 1
                i += 1
                continue

            isChild = bool(nodeStack)
            if (not isChild):
                i += 1
                continue

            parent = nodeStack[-1]
            parent.addChild(node)

            if (predType == IfPredPartType.EndIf):
                node = nodeStack.pop()
                elseEncountered = elseEncounteredStack.pop()

                # construct the 'empty else' if an 'else' has not been encountered
                if (not elseEncountered):
                    linePrefix = re.match(r"^[( |\t)]*", part.pred)
                    if (linePrefix):
                        linePrefix = linePrefix.group(0)
                        linePrefixLen = len(linePrefix)
                        linePrefix = part.pred[:linePrefixLen]
                    else:
                        linePrefix = ""

                    emptyElse = IfPredPart(linePrefix + "else\n", IfPredPartType.Else)
                    emptyElseContent = IfContentPart({}, depth = depth)

                    emptyElseChild = IfTemplateNode(ifPredPart = emptyElse)
                    emptyElseChild.addIfContentPart(emptyElseContent)

                    parts.insert(i, emptyElseContent)
                    parts.insert(i, emptyElse)
                    node.addChild(emptyElseChild)

                    i += 2
                    partsLen += 2

                depth -= 1
                elseEncountered = False

            elif (predType == IfPredPartType.Else or predType == IfPredPartType.Elif):
                node = IfTemplateNode(ifPredPart = part)

                if (predType == IfPredPartType.Else):
                    elseEncounteredStack[-1] = True

            i += 1

        result = cls()
        result._root = root
        return result


# IfTemplate: Data class for the if..else template of the .ini file
class IfTemplate():
    """
    Data for storing information about a `section`_ in a .ini file

    :raw-html:`<br />`

    .. note::
        Assuming every `if/else` clause must be on its own line, we have that an :class:`IfTemplate` have a form looking similar to this:

        .. code-block:: ini
            :linenos:
            :emphasize-lines: 1,2,5,7,12,16,17

            ...(does stuff)...
            ...(does stuff)...
            if ...(bool)...
                if ...(bool)...
                    ...(does stuff)...
                else if ...(bool)...
                    ...(does stuff)...
                endif
            else ...(bool)...
                if ...(bool)...
                    if ...(bool)...
                        ...(does stuff)...
                    endif
                endif
            endif
            ...(does stuff)...
            ...(does stuff)...

        We split the above structure into parts (:class:`IfTemplatePart`) where each part is either:

        #. **An If Predicate Part (:class:`IfPredPart`)**: a single line containing the keywords "if", "else" or "endif" :raw-html:`<br />` **OR** :raw-html:`<br />`
        #. **A Content Part (:class:`IfContentPart`)**: a group of lines that *"does stuff"*

        **Note that:** an :class:`ifTemplate` does not need to contain any parts containing the keywords "if", "else" or "endif". This case covers the scenario
        when the user does not use if..else statements for a particular `section`_
        
        Based on the above assumptions, we can assume that every ``[section]`` in a .ini file contains this :class:`IfTemplate`

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: for element in x

            Iterates over all the parts of the :class:`IfTemplate`, ``x``

        .. describe:: x[num]

            Retrieves the part from the :class:`IfTemplate`, ``x``, at index ``num``

        .. describe:: x[num] = newPart

            Sets the part at index ``num`` of the :class:`IfTemplate`, ``x``, to have the value of ``newPart``

    :raw-html:`<br />`

    Parameters
    ----------
    parts: List[:class:`IfTemplatePart`]
        The individual parts of how we divided an :class:`IfTemplate` described above

    name: :class:`str`
        The name of the `section`_ for this :class:`IfTemplate`

        **Default**: ``""``

    Attributes
    ----------
    parts: List[:class:`IfTemplatePart`]
        The individual parts of how we divided an :class:`IfTemplate` described above

    tree: :class:`IfTemplateTree`
        The parse tree for the :class:`IfTemplate` . Details on the structure of the tree can be found at :class:`IfTemplateTree`

    calledSubCommands: Dict[:class:`int`, List[:class:`str`]]
        Any other sections that this :class:`IfTemplate` references :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` in the :class:`IfTemplate` that the section is called
        * The values are the referenced sections within the :class:`IfContentPart`

    hashes: Set[:class:`str`]
        The hashes this :class:`IfTemplate` references

    indices: Set[:class:`str`]
        The indices this :class:`IfTemplate` references

    treeCls: Type[:class:`IfTemplateTree`]
        The class to construct the parse tree for the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: :class:`IfTemplateTree`
    """

    def __init__(self, parts: List[IfTemplatePart], name: str = "", treeCls: Type[IfTemplateTree] = IfTemplateNonEmptyNodeTree):
        self.name = name
        self.parts = parts

        self.calledSubCommands = {}
        self.hashes = set()
        self.indices = set()

        self.tree = treeCls.construct(parts)

        self.find(pred = self._hasNeededAtts, postProcessor = self._setupIfTemplateAtts)

    def _hasNeededAtts(self, ifTemplate, partIndex: int, part: IfTemplatePart) -> bool:
        return isinstance(part, IfContentPart) and (IniKeywords.Run.value in part or IniKeywords.Hash.value in part or IniKeywords.MatchFirstIndex.value in part)
    
    def _setupIfTemplateAtts(self, ifTemplate, partIndex: int, part: IfContentPart):
        if (IniKeywords.Run.value in part):
            ifTemplate.calledSubCommands[partIndex] = part[IniKeywords.Run.value]
        
        if (IniKeywords.Hash.value in part):
            ifTemplate.hashes.update(set(map(lambda valData: valData[1], part[IniKeywords.Hash.value])))

        if (IniKeywords.MatchFirstIndex.value in part):
            ifTemplate.indices.update(set(map(lambda valData: valData[1], part[IniKeywords.MatchFirstIndex.value])))

    @classmethod
    def build(cls, rawParts: List[Union[str, Dict[str, List[Tuple[int, str]]]]], name: str = ""):
        parts = []
        rawPartsLen = len(rawParts)
        depth = 0

        for i in range(rawPartsLen):
            rawPart = rawParts[i]
            part = None

            if (isinstance(rawPart, str)):
                predType = IfPredPartType.getType(rawPart)
                if (predType is None):
                    continue
                elif (predType == IfPredPartType.If):
                    depth += 1
                elif (predType == IfPredPartType.EndIf):
                    depth -= 1

                part = IfPredPart(rawPart, predType)

            elif (isinstance(rawPart, dict)):
                part = IfContentPart(rawPart, depth)

            if (part is not None):
                parts.append(part)

        return cls(parts, name = name)


    def __iter__(self):
        return self.parts.__iter__()
    
    def __getitem__(self, key: int) -> Union[str, Dict[str, Any]]:
        return self.parts[key]
    
    def __setitem__(self, key: int, value: Union[str, Dict[str, Any]]):
        self.parts[key] = value

    def normalize(self):
        """
        Normalizes the branching structure within this :class:`ifTemplate` to follosw the structure described at :class:`IfTemplateNormTree`
        """

        self.tree = IfTemplateNormTree.construct(self.parts)

    def add(self, part: IfTemplatePart, updateTree: bool = False):
        """
        Adds a part to the :class:`ifTemplate`

        Parameters
        ----------
        part: :class:`IfTemplatePart`
            The part to add to the :class:`IfTemplate`

        updateTree: :class:`bool`
            Whether to update the parse tree for the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """
        self.parts.append(part)

        if (updateTree):
            self.tree = IfTemplateTree.construct(self.parts)

    # find(pred, postProcessor): Searches each part in the if template based on 'pred'
    def find(self, pred: Optional[Callable[["IfTemplate", int, IfTemplatePart], bool]] = None, postProcessor: Optional[Callable[["IfTemplate", int, IfTemplatePart], Any]] = None) -> Dict[int, Any]:
        """
        Searches the :class:`IfTemplate` for parts that meet a certain condition

        Parameters
        ----------
        pred: Optional[Callable[[:class:`IfTemplate`, :class:`int`, :class:`IfTemplatePart`], :class:`bool`]]
            The predicate used to filter the parts :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then this function will return all the parts :raw-html:`<br />` :raw-html:`<br />`

            The order of arguments passed into the predicate will be:

            #. The :class:`IfTemplate` that this method is calling from
            #. The index for the part in the :class:`IfTemplate`
            #. The current part of the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        postProcessor: Optional[Callable[[:class:`IfTemplate`, :class:`int`, :class:`IfTemplatePart`], Any]]
            A function that performs any post-processing on the found part that meets the required condition :raw-html:`<br />` :raw-html:`<br />`

            The order of arguments passed into the post-processor will be:

            #. The :class:`IfTemplate` that this method is calling from
            #. The index for the part in the :class:`IfTemplate`
            #. The current part of the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will return the found :class:`IfTemplatePart` :raw-html:`<br />` :raw-html:`<br />`
        
            **Default**: ``None``

        Returns
        -------
        Dict[:class:`int`, Any]
            The filtered parts that meet the search condition :raw-html:`<br />` :raw-html:`<br />`

            The keys are the index locations of the parts and the values are the found parts
        """

        result = {}
        if (pred is None):
            pred = lambda ifTemplate, partInd, part: True

        if (postProcessor is None):
            postProcessor = lambda ifTemplate, partInd, part: part

        partsLen = len(self.parts)
        for i in range(partsLen):
            part = self.parts[i]
            if (pred(self, i, part)):
                result[i] = (postProcessor(self, i, part))

        return result
    
    def getMods(self, hashRepo: Hashes, indexRepo: Indices, version: Optional[float] = None) -> Set[str]:
        """
        Retrieves the corresponding mods the :class:`IfTemplate` will fix to

        Parameters
        ----------
        hashRepo: :class:`Hashes`
            The data source for the hashes

        indexRepo: :class:`Indices`
            The data source for the indices

        version: Optional[:class:`float`]
            What version we want to fix :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, will assume we want to fix to the latest version :raw-html:`<br />` :raw-html:`<br />`
            
             **Default**: ``None``

        Returns
        -------
        Set[:class:`str`]
            Names of all the types of mods the :class:`IfTemplate` will fix to
        """

        result = set()

        for hash in self.hashes:
            replacments = hashRepo.replace(hash, version = version)
            result = result.union(set(replacments.keys()))

        for index in self.indices:
            replacments = indexRepo.replace(index, version = version)
            result = result.union(set(replacments.keys()))

        return result

    def _isKeyFullyCover(self, node: IfTemplateNode, key: str, sections: Dict[str, "IfTemplate"], visited: Set[str], sectionsKeyFullCover: Dict[str, bool]):
        result = node.hasKey(key)
        if (result):
            return result

        childrenResult = True
        branchChildren = node.children

        OrderedSet = GlobalPackageManager.get(PackageModules.OrderedSet.value).OrderedSet
        runValues = node.getKeyValues(IniKeywords.Run.value)
        subCommandsToCheck = OrderedSet([])
        subCommandsChecked = set()

        for partValues in runValues:
            for valueData in partValues:
                subCommand = valueData[1]
                if (subCommand not in visited):
                    subCommandsToCheck.add(subCommand)
                elif (subCommand in sectionsKeyFullCover):
                    subCommandsChecked.add(subCommand)

        if (not branchChildren and not subCommandsToCheck and not subCommandsChecked):
            return result

        for subCommand in subCommandsChecked:
            childrenResult &= sectionsKeyFullCover[subCommand]
            if (not childrenResult):
                return result

        for childId in branchChildren:
            child = branchChildren[childId]
            childrenResult &= self._isKeyFullyCover(child, key, sections, visited, sectionsKeyFullCover)
            if (not childrenResult):
                return result
            
        for subCommand in subCommandsToCheck:

            # we assume the .ini file has correct syntax and does not reference some
            #   command that does not exist. It is not within this project's scope to help the
            #   person fix their own mistakes in the .ini file. Assume that an incorrect referenced
            #   command refers to some global command not in the file. So this command will be a sink in the
            #   command call graph and a leaf in the DFS tree 
            if (subCommand not in sections):
                continue

            ifTemplate = sections[subCommand]
            childrenResult &= ifTemplate.isKeyFullyCover(key, sections, visited, sectionsKeyFullCover)
            if (not childrenResult):
                return result

        result |= childrenResult
        return result
    
    def _getKeyMissingParts(self, node: IfTemplateNode, key: str, sections: Dict[str, "IfTemplate"], visited: Set[str], 
                            sectionsMissingParts: Dict[str, Set[IfContentPart]], sectionAllBranchesMissing: Dict[str, bool]) -> Tuple[Set[IfContentPart], bool]:
        nodeMissingPart, hasContentPart = node.getKeyMissingPart(key)
        if (hasContentPart and nodeMissingPart is None):
            return (set(), False)
        
        result = set() if (nodeMissingPart is None) else {nodeMissingPart}
        childrenResult = set()
        branchChildren = node.children

        OrderedSet = GlobalPackageManager.get(PackageModules.OrderedSet.value).OrderedSet
        runValues = node.getKeyValues(IniKeywords.Run.value)
        subCommandsToCheck = OrderedSet([])
        subCommandsChecked = set()

        for partValues in runValues:
            for valueData in partValues:
                subCommand = valueData[1]
                if (subCommand not in visited):
                    subCommandsToCheck.add(subCommand)
                elif (subCommand in sectionsMissingParts):
                    subCommandsChecked.add(subCommand)

        if (not branchChildren and not subCommandsToCheck and not subCommandsChecked):
            return (result, True)
        
        branchChildrenLen = len(branchChildren)
        subCommandsToCheckLen = len(subCommandsToCheck)
        subCommandsCheckedLen = len(subCommandsChecked)

        missingKeyBranchChildren = 0
        missingKeySubCommandsToCheck = 0
        missingKeySubCommandsChecked = 0
        currentChildMissingKeys = set()
        currentAllBranchesMissing = False
        
        for subCommand in subCommandsChecked:
            currentChildMissingKeys = sectionsMissingParts[subCommand]
            if (subCommand not in sectionAllBranchesMissing):
                continue
            
            currentAllBranchesMissing = sectionAllBranchesMissing[subCommand]
            if (currentChildMissingKeys):
                childrenResult.update(currentChildMissingKeys)

                if (currentAllBranchesMissing):
                    missingKeyBranchChildren += 1

        for childId in branchChildren:
            child = branchChildren[childId]
            currentChildMissingKeys, currentAllBranchesMissing = self._getKeyMissingParts(child, key, sections, visited, sectionsMissingParts, sectionAllBranchesMissing)

            if (currentChildMissingKeys):
                childrenResult.update(currentChildMissingKeys)

                if (currentAllBranchesMissing):
                    missingKeyBranchChildren += 1


        for subCommand in subCommandsToCheck:

            # we assume the .ini file has correct syntax and does not reference some
            #   command that does not exist. It is not within this project's scope to help the
            #   person fix their own mistakes in the .ini file. Assume that an incorrect referenced
            #   command refers to some global command not in the file. So this command will be a sink in the
            #   command call graph and a leaf in the DFS tree 
            if (subCommand not in sections):
                continue

            ifTemplate = sections[subCommand]
            currentChildMissingKeys = ifTemplate.getKeyMissingParts(key, sections, visited, sectionsMissingParts, sectionAllBranchesMissing)

            if (currentChildMissingKeys):
                childrenResult.update(currentChildMissingKeys)

                if (currentAllBranchesMissing):
                    missingKeyBranchChildren += 1

        missingKeyChildrenTotal = missingKeyBranchChildren + missingKeySubCommandsToCheck + missingKeySubCommandsChecked
        childrenTotal = branchChildrenLen + subCommandsToCheckLen + subCommandsCheckedLen

        if (result and missingKeyChildrenTotal == childrenTotal):
            return (result, True)

        return (childrenResult, False)
    
    def isKeyFullyCover(self, key: str, sections: Dict[str, "IfTemplate"], visited: Set[str], sectionsKeyFullCover: Dict[str, bool]) -> bool:
        """
        Checks whether a key appears in all branches of the :class:`IfTemplate`

        Parameters
        ----------
        key: :class:`str`
            The key to search

        sections: Dict[:class:`str`, :class:`IfTemplate`]
            The available sections in the graph (:class:`IniSectionGraph`) where this :class:`IfTemplate` belongs to :raw-html:`<br />` :raw-html:`<br />`

            The keys are the names for each section and the values are the corresponding :class:`IfTemplate` for each section

        visited: Set[:class:`str`]
            The names of the sections that have been visited by this method

        sectionsKeyFullCover: Dict[:class:`str`, :class:`bool`]
            The result of whether a particular section has the target key after searching of its branches (names of sections that this method has finished visiting)

        Returns
        -------
        :class:`bool`
            Whether the key appears in all conditional branches
        """

        visited.add(self.name)

        node = self.tree.root
        result = self._isKeyFullyCover(node, key, sections, visited, sectionsKeyFullCover)
        sectionsKeyFullCover[self.name] = result
        return result

    def getKeyMissingParts(self, key: str, sections: Dict[str, "IfTemplate"], visited: Set[str], sectionsMissingParts: Dict[str, Set[IfContentPart]],
                           sectionAllBranchesMissing: Dict[str, bool]) -> Set[IfContentPart]:
        """
        Finds all the :class:`IfContentPart`s that are referenced by this :class:`IfTemplate` that do not have the search 'key'

        Parameters
        ----------
        key: :class:`str`
            The key to search

        sections: Dict[:class:`str`, :class:`IfTemplate`]
            The available `sections`_ in the graph (:class:`IniSectionGraph`) where this :class:`IfTemplate` belongs to :raw-html:`<br />` :raw-html:`<br />`

            The keys are the names for each `section`_ and the values are the corresponding :class:`IfTemplate` for each section

        visited: Set[:class:`str`]
            The names of the `sections`_ that have been visited by this method

        sectionsMissingParts: Dict[:class:`str`, :class:`bool`]
            The result of the :class:`IfContentPart` with missing keys for a particular `section`_ after searching all of its branches (names of sections that this method has finished visiting)

        sectionallBranchesMissing: Dict[:class:`str`, :class:`bool`]
            Whether all the branches within some `section`_ are missing the key to search :raw-html:`<br />` :raw-html:`<br />`

            The keys are the names for each `section`_ and the values are whether the `section`_ has the key missing in all its branches
        """

        visited.add(self.name)

        node = self.tree.root
        result, allBranchesMissing = self._getKeyMissingParts(node, key, sections, visited, sectionsMissingParts, sectionAllBranchesMissing)
        sectionsMissingParts[self.name] = result
        sectionAllBranchesMissing[self.name] = allBranchesMissing
        return result


class IniSectionGraph():
    """
    Class for constructing a directed subgraph for how the `sections`_ in the .ini file are ran

    :raw-html:`<br />`

    .. note::
        * The nodes are the `sections`_ of the .ini file
        * The directed edges are the command calls from the `sections`_ , where the source of the edge is the caller and the sink of the edge is the callee

    Parameters
    ----------
    sections: Set[:class:`str`]
        Names of the desired `sections`_ we want our subgraph to have from the `sections`_ of the .ini file

    allSections: Dict[:class:`str`, :class:`IfTemplate`]
        All the `sections`_ for the .ini file

        :raw-html:`<br />`

        .. note::
            You can think of this as the `adjacency list`_ for the directed graph of all `sections`_ in the .ini file

    remapNameFunc: Optional[Callable[[:class:`str`, :class:`str`], :class:`str`]]
        Function to get the corresponding remap names for the section names :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will not get the remap names for the sections :raw-html:`<br />` :raw-html:`<br />`

        The parameters for the function are:

            #. Name of the `section`_
            #. Name fo the type of mod to fix
        
        **Default**: ``False``

    modsToFix: Optional[Set[:class:`str`]]
        The names of the mods that will be fixed by the .ini file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    remapNameFunc: Optional[Callable[[:class:`str`, :class:`str`], :class:`str`]]
        Function to get the corresponding remap names for the section names :raw-html:`<br />` :raw-html:`<br />`

        The parameters for the function are:

            #. Name of the `section`_
            #. Name fo the type of mod to fix
    """

    def __init__(self, targetSections: Union[Set[str], List[str]], allSections: Dict[str, IfTemplate], 
                 remapNameFunc: Optional[Callable[[str, str], str]] = None, modsToFix: Optional[Set[str]] = None):
        self._modsToFix = modsToFix
        if (modsToFix is None):
            self._modsToFix = {}
        
        self._setTargetSections(targetSections)
        self._sections: Dict[str, IfTemplate] = {}
        self._allSections = allSections
        self._remapNames: Dict[str, Dict[str, str]] = {}
        self._runSequence: List[Tuple[str, IfTemplate]] = []
        self.remapNameFunc = remapNameFunc

        self.build()

    @property
    def targetSections(self) -> List[str]:
        """
        Names of the desired `sections`_ we want our subgraph to have from the `sections`_ of the .ini file

        :getter: The names of the desired `sections`_ we want in the subgraph
        :setter: Constructs a new subgraph based on the new desired `sections`_ we want
        :type: List[:class:`str`]
        """

        return self._targetSections
    
    def _setTargetSections(self, newTargetSections: Union[Set[str], List[str]]):
        self._targetSections = ListTools.getDistinct(newTargetSections, keepOrder = True)
    
    @targetSections.setter
    def targetSections(self, newTargetSections: Union[Set[str], List[str]]):
        self._setTargetSections(newTargetSections)
        self.build()

    @property
    def sections(self):
        """
        The `sections`_ that are part of the contructed subgraph based on the desired sections specified at :attr:`IniSectionGraph.targetSections`

        :raw-html:`<br />`

        .. note::
            You can think of this as the `adjacency list`_ for the subgraph

        :getter: All the `sections`_ for the subgraph
        :type: Dict[:class:`str`, :class:`IfTemplate`]
        """

        return self._sections
    
    @property
    def allSections(self):
        """
        All the `sections`_ of the .ini file

        :raw-html:`<br />`

        .. note::
            You can think of this as the `adjacency list`_ for the directed graph of all `sections`_ in the .ini file

        :getter: All the `sections`_ for the .ini file
        :setter: Constructs a new subgraph based on the new `sections`_ for the .ini file
        :type: Dict[:class:`str`, :class:`IfTemplate`]
        """

        return self._allSections
    
    @allSections.setter
    def allSections(self, newAllSections: Dict[str, IfTemplate]):
        self._allSections = newAllSections
        self.build()

    @property
    def remapNames(self):
        """
        The corresponding names for the `sections`_ that the fix will make :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the name of the original `section`_
        * The inner key is the name for the type of mod to fix
        * The inner value is the corresponding name for the `section`_ and mod type

        :getter: All the corresponding names for the `sections`_
        :type: Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]
        """

        return self._remapNames
    
    @property
    def runSequence(self):
        """
        The order the `sections`_ will be ran

        :getter: Retrieves the order the `sections`_ will be ran
        :type: List[Tuple[:class:`str`, :class:`IfTemplate`]]
        """

        return self._runSequence
    
    @property
    def modsToFix(self):
        """
        The names of the mods that will be fixed by the .ini file

        :getter: Retrieves the names of the mods to fix
        :type: Set[:class:`str`]
        """

        return self._modsToFix

    def build(self, newTargetSections: Optional[Union[Set[str], List[str]]] = None, newAllSections: Optional[Dict[str, IfTemplate]] = None,
              newModsToFix: Optional[Set[str]] = None):
        """
        Performs the initialization for rebuilding the subgraph

        Parameters
        ----------
        newTargetSections: Optional[Set[:class:`str`], List[:class:`str`]]
            The new desired `sections`_ we want in our subgraph :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newAllSections: Optional[Dict[:class:`str`, :class:`IfTemplate`]]
            The new `sections`_ for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newModsToFix: Optional[Set[:class:`str`]]
            The new desired names of the mods that we want to fix for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (newTargetSections is not None):
            self._setTargetSections(newTargetSections)

        if (newAllSections is not None):
            self._allSections = newAllSections

        self.construct()
        if (self.remapNameFunc is not None):
            self.getRemapNames(newModsToFix = newModsToFix)
        else:
            self._remapNames = {}


    def getSection(self, sectionName: str, raiseException: bool = True) -> Optional[IfTemplate]:
        """
        Retrieves the :class:`IfTemplate` for a certain `section`_

        Parameters
        ----------
        sectionName: :class:`str`
            The name of the `section`_

        raiseException: :class:`bool`
            Whether to raise an exception when the section's :class:`IfTemplate` is not found

        Raises
        ------
        :class:`KeyError`
            If the :class:`IfTemplate` for the `section`_ is not found and ``raiseException`` is set to ``True``

        Returns
        -------
        Optional[:class:`IfTemplate`]
            The corresponding :class:`IfTemplate` for the `section`_
        """
        try:
            ifTemplate = self._allSections[sectionName]
        except Exception as e:
            if (raiseException):
                raise KeyError(f"The section by the name '{sectionName}' does not exist") from e
            else:
                return None
        else:
            return ifTemplate

    def _dfsExplore(self, section: IfTemplate, visited: Dict[str, IfTemplate], runSequence: List[Tuple[str, IfTemplate]]):
        """
        The typical recursive implementation of `DFS`_ for exploring a particular `section`_ (node)

        Parameters
        ----------
        section: :class:`IfTemplate`
            The `section`_ that is currently being explored
        
        visited: Dict[:class:`str`, :class:`ifTemplate`]
            The `sections`_ that have already been visited

        runSequence: List[Tuple[:class:`str`, :class:`IfTemplate`]]
            The order the `sections`_ will be ran
        """

        calledSubCommands = section.calledSubCommands
        for partInd in calledSubCommands:
            subSections = calledSubCommands[partInd]

            for subSectionData in subSections:
                subSection = subSectionData[1]
                if (subSection not in visited):

                    # we assume the .ini file has correct syntax and does not reference some
                    #   command that does not exist. It is not within this project's scope to help the
                    #   person fix their own mistakes in the .ini file. Assume that an incorrect referenced
                    #   command refers to some global command not in the file. So this command will be a sink in the
                    #   command call graph and a leaf in the DFS tree 
                    neighbourSection = self.getSection(subSection, raiseException = False)
                    if (neighbourSection is None):
                        continue

                    visited[subSection] = neighbourSection
                    
                    runSequence.append((subSection, neighbourSection))
                    self._dfsExplore(neighbourSection, visited, runSequence)

    def construct(self) -> Dict[str, IfTemplate]:
        """
        Constructs the subgraph for the `sections`_ using `DFS`_

        Returns
        -------
        Dict[:class:`str`, :class:`IfTemplate`]
            The `sections` that are part of the subgraph
        """

        visited = {}
        runSequence = []
        sections = {}

        for sectionName in self._targetSections:
            ifTemplate = self.getSection(sectionName)
            sections[sectionName] = ifTemplate

        # perform the main DFS algorithm
        for sectionName in sections:
            section = sections[sectionName]

            if (sectionName not in visited):
                visited[sectionName] = section
                runSequence.append((sectionName, section))
                self._dfsExplore(section, visited, runSequence)

        self._sections = visited
        self._runSequence = runSequence
        return self._sections
    
    def isKeyFullyCover(self, key: str) -> Dict[str, bool]:
        """
        Determines whether a key fully covers all the conditional branches of a `section`_

        Parameters
        ----------
        key: :class:`key`
            The target key to search

        Returns
        -------
        Dict[:class:`str`, :class:`bool`]
            The result for each `section`_ of whether the section has the key fully covering all its conditional branches :raw-html:`<br />` :raw-html:`<br />`

            .. tip::
                To filter only the result for `sections`_ that are the source nodes of the graph, you can call :meth:`targetsAreFullyCovered` instead
        """

        visited = set()
        sections = {}
        sectionsKeyFullCover = {}

        for sectionName in self._targetSections:
            ifTemplate = self.getSection(sectionName)
            sections[sectionName] = ifTemplate

        for sectionName in sections:
            section = sections[sectionName]
            section.isKeyFullyCover(key, self._sections, visited, sectionsKeyFullCover)

        return sectionsKeyFullCover
    
    def targetsAreFullyCovered(self, key: str) -> Dict[str, bool]:
        """
        Convenience function of :meth:`isKeyFullyCover` to determine whether the target `sections`_ from :meth:`targetSections` are
        fully covered by a key in all their conditional branches

        Parameters
        ----------
        key: :class:`key`
            The target key to search

        Returns
        -------
        Dict[:class:`str`, :class:`bool`]
            The result for the target `sections`_ of whether the section has the key fully covering all its conditional branches
        """

        sectionsKeyFullCover = self.isKeyFullyCover(key)
        
        result = {}
        for sectionName in self._targetSections:
            result[sectionName] = sectionsKeyFullCover[sectionName]

        return result
    
    def getKeyMissingParts(self, key: str) -> Dict[str, Set[IfContentPart]]:
        """
        Retrieves the parts in the `sections`_ that are not covered by 'key'

        Parameters
        ----------
        key: :class:`key`
            The target key to search

        Returns
        -------
        Dict[:class:`str`, :class:`bool`]
            The result for each `section`_ of the parts that 'key' does not cover :raw-html:`<br />` :raw-html:`<br />`

            .. tip::
                To filter only the result for `sections`_ that are the source nodes of the graph, you can call :meth:`targetsGetKeyMissingParts` instead
        """

        visited = set()
        sections = {}
        sectionsMissingParts = {}
        sectionAllBranchesMissing = {}

        for sectionName in self._targetSections:
            ifTemplate = self.getSection(sectionName)
            sections[sectionName] = ifTemplate

        for sectionName in sections:
            section = sections[sectionName]
            section.getKeyMissingParts(key, self._sections, visited, sectionsMissingParts, sectionAllBranchesMissing)

        return sectionsMissingParts
    
    def targetsGetKeyMissingParts(self, key: str) -> Dict[str, bool]:
        """
        Convenience function of :meth:`getKeyMissingParts` to get the parts referenced by the target `sections`_ from :meth:`targetSections`
        that do not contain 'key'

        Parameters
        ----------
        key: :class:`key`
            The target key to search

        Returns
        -------
        Dict[:class:`str`, :class:`bool`]
            The result for the target `sections`_ for the parts that do not contain 'key'
        """

        sectionsMissingParts = self.getKeyMissingParts(key)
        
        result = {}
        for sectionName in self._targetSections:
            result[sectionName] = sectionsMissingParts[sectionName]

        return result

    def getRemapNames(self, newModsToFix: Optional[Set[str]] = None) -> Dict[str, Dict[str, str]]:
        """
        Retrieves the corresponding remap names of the sections made by this fix

        Parameters
        ----------
        newModsToFix: Optional[Set[:class:`str`]]
            The new desired names of the mods that we want to fix for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Dict[:class:`str`, :class:`str`]
            The new names for the `sections`_ with the 'FixRemap' keyword added
        """

        result = {}
        if (newModsToFix is not None):
            self._modsToFix = newModsToFix

        if (not self._modsToFix):
            self._remapNames = result
            return result

        for sectionName in self._sections:
            for modName in self._modsToFix:
                try:
                    result[sectionName]
                except KeyError:
                    result[sectionName] = {}

                result[sectionName][modName] = self.remapNameFunc(sectionName, modName)

        self._remapNames = result
        return result
    
    def getCommonMods(self, hashRepo: Hashes, indexRepo: Indices, version: Optional[float] = None) -> Set[str]:
        """
        Retrieves the common mods to fix to based off all the :class:`IfTemplate`s in the graph

        Parameters
        ----------
        hashRepo: :class:`Hashes`
            The data source for all the hashes

        indexRepo: :class:`Indices`
            The data source for all the indices

        version: Optional[:class:`float`]
            The version we want to fix to :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will assume we want to fix to the latest version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Set[:class:`str`]
            The common mods to fix to
        """

        result = set()

        for sectionName in self._sections:
            ifTemplate = self._sections[sectionName]
            ifTemplateMods = ifTemplate.getMods(hashRepo, indexRepo, version = version)

            if (not result):
                result = ifTemplateMods
            elif (ifTemplateMods):
                result = result.intersection(ifTemplateMods)

        return result


class BaseTexEditor():
    """
    Base class to edit some .dds file
    """

    def fix(self, texFile: "TextureFile", fixedTexFile: str):
        """
        Edits the texture file

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture .dds file to be modified

        fixedTexFile: :class:`str`
            The name of the fixed texture file
        """
        pass


class IniRemover(BaseIniRemover):
    """
    This class inherits from :class:`BaseIniRemover`

    Class for the basic removal of the fixes from .ini files
    
    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to remove the fix from
    """

    _fixRemovalPattern = re.compile(f"(; {IniBoilerPlate.OldHeading.value.open()}" + r"((.|\n)*?);" + f" {IniBoilerPlate.OldHeading.value.close()[:-2]}(-)*)|(; {IniBoilerPlate.DefaultHeading.value.open()}" + r"((.|\n)*?);" + f" {IniBoilerPlate.DefaultHeading.value.close()[:-2]}(-)*)")
    _removalPattern = re.compile(r"^\s*\[" + f".*{IniKeywords.Remap.value}(" + IniKeywords.Blend.value + "|" + IniKeywords.Position.value + r"|Fix|Tex).*\]")
    _sectionRemovalPattern = re.compile(f".*{IniKeywords.Remap.value}(" + IniKeywords.Blend.value + "|" + IniKeywords.Position.value +  r"|Fix|Tex).*")
    _remapTexRemovalPattern = re.compile(IniKeywords.Resource.value + f".*" + IniKeywords.RemapTex.value + r".*")
    _remapDLRemovalPattern = re.compile(IniKeywords.Resource.value + f".*" + IniKeywords.RemapDL.value + r".*")

    def __init__(self, iniFile: "IniFile"):
        super().__init__(iniFile)

    #_makeRemovalRemapBlendModels(sectionNames): Retrieves the data needed for removing Blend.buf files from the .ini file
    def _makeRemovalRemapBlendModels(self, sectionNames: Set[str]):
        ifTemplates = self.iniFile.sectionIfTemplates
        for sectionName in sectionNames:
            if (sectionName in ifTemplates):
                ifTemplate = ifTemplates[sectionName]
                self.iniFile.remapBlendModels[sectionName] = self.iniFile.makeFixResourceModel(ifTemplate, toFix = {""}, getFixedFile = lambda origFile, modName: origFile)

    # _makeRemovalRemapPositionModels(sectionNames): Retrieves the data needed for removing Position.buf files from the .ini file
    def _makeRemovalRemapPositionModels(self, sectionNames: Set[str]):
        ifTemplates = self.iniFile.sectionIfTemplates
        for sectionName in sectionNames:
            if (sectionName in ifTemplates):
                ifTemplate = ifTemplates[sectionName]
                self.iniFile.remapPositionModels[sectionName] = self.iniFile.makeFixResourceModel(ifTemplate, toFix = {""}, getFixedFile = lambda origFile, modName: origFile)

    # _makeRemovalRemapTexModels(sectionNames): Retrieves the data needed for removing RemapTex.dds files from the .ini file
    def _makeRemovalRemapTexModels(self, sectionNames: Set[str]):
        ifTemplates = self.iniFile.sectionIfTemplates
        for sectionName in sectionNames:
            if (sectionName in ifTemplates):
                ifTemplate = ifTemplates[sectionName]
                self.iniFile.texAddModels[sectionName] = {}
                self.iniFile.texAddModels[sectionName][""] = self.iniFile.makeTexModel(ifTemplate, {""}, BaseTexEditor(), getFixedFile = lambda origFile, modName: origFile)

    # _makeRemovalRemapDLModels(sectionNames): Retrieves the data needed for removing RemapDL files from the .ini file
    def _makeRemovalRemapDLModels(self, sectionNames: Set[str]):
        ifTemplates = self.iniFile.sectionIfTemplates
        for sectionName in sectionNames:
            if (sectionName in ifTemplates):
                ifTemplate = ifTemplates[sectionName]
                self.iniFile.fileDownloadModels[sectionName] = {}
                self.iniFile.fileDownloadModels[sectionName] = self.iniFile.makeDLModel(ifTemplate, FileDownload("", ""))

    # _getRemovalResourceByKey(sectionsToRemove, key): Retrieves the names of specific resource sections
    #   to remove based off the 'key' that holds the resource
    def _getRemovalResourceByKey(self, sectionsToRemove: Set[str], key: str) -> Set[str]:
        result = set()
        allSections = self.iniFile.getIfTemplates()
        removalSectionGraph = IniSectionGraph(sectionsToRemove, allSections)
        self.iniFile.getResources(removalSectionGraph, lambda part: key in part, lambda part: part.getVals(key),
                                  lambda resource, part: result.update(set(resource)))

        result = set(filter(lambda section: re.match(self._sectionRemovalPattern, section), result))
        return result

    # _getRemovalBlendResource(sectionsToRemove): Retrieves the names of the Blend.buf resource sections to remove
    def _getRemovalBlendResource(self, sectionsToRemove: Set[str]) -> Set[str]:
        return self._getRemovalResourceByKey(sectionsToRemove, IniKeywords.Vb1.value)
    
    # _getRemovalPositionResource(sectionsToRemove): Retrieves the names of the Position.buf resource sections to remove
    def _getRemovalPositionResource(self, sectionsToRemove: Set[str]) -> Set[str]:
        return self._getRemovalResourceByKey(sectionsToRemove, IniKeywords.Vb0.value)
    
    # _getRemovalTexResource(sectionToRemove): Retrieves the names of the texture resource sections to remove
    def _getRemovalTexResource(self, sectionsToRemove: Set[str]) -> Set[str]:
        return set(filter(lambda section: re.match(self._remapTexRemovalPattern, section), sectionsToRemove))
    
    # _getRemovalDLResource(sectionsToRemove): Retrieves the names of the download resource sections to remove
    def _getRemovalDLResource(self, sectionsToRemove: Set[str]) -> Set[str]:
        return set(filter(lambda section: re.match(self._remapDLRemovalPattern, section), sectionsToRemove))

    @BaseIniRemover._readLines
    def _removeScriptFix(self, parse: bool = False, writeBack: bool = True) -> str:
        """
        Removes the dedicated section of the code in the .ini file that this script has made

        Parameters
        ----------
        parse: :class:`bool`
            Whether to keep track of the Blend.buf files that also need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        writeBack: :class:`bool`
            Whether to write back the new text content of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file
        """

        if (not parse):
            self.iniFile._fileTxt = re.sub(self._fixRemovalPattern, "", self.iniFile._fileTxt)
        else:
            removedSectionsIndices = []
            txtLinesToRemove = []

            # retrieve the indices the dedicated section is located
            rangesToRemove = [match.span() for match in re.finditer(self._fixRemovalPattern, self.iniFile._fileTxt)]
            for range in rangesToRemove:
                start = range[0]
                end = range[1]
                txtLines = TextTools.getTextLines(self.iniFile._fileTxt[start : end])

                removedSectionsIndices.append(range)
                txtLinesToRemove += txtLines

            # retrieve the names of the sections the dedicated sections reference
            sectionNames = set()
            for line in txtLinesToRemove:
                if (re.match(self.iniFile._sectionPattern, line)):
                    sectionName = self.iniFile._getSectionName(line)
                    sectionNames.add(sectionName)

            blendResourceSections = self._getRemovalBlendResource(sectionNames)
            positionResourceSections = self._getRemovalPositionResource(sectionNames)
            texSections = self._getRemovalTexResource(sectionNames)
            dlSections = self._getRemovalDLResource(sectionNames)

            # get the required files that need to be removed
            self._makeRemovalRemapBlendModels(blendResourceSections)
            self._makeRemovalRemapPositionModels(positionResourceSections)
            self._makeRemovalRemapTexModels(texSections)
            self._makeRemovalRemapDLModels(dlSections)

            for sectionName in sectionNames:
                self.iniFile.sectionIfTemplates.pop(sectionName, None)
            
            # remove the dedicated section
            self.iniFile._fileTxt = TextTools.removeParts(self.iniFile._fileTxt, removedSectionsIndices)

        self.iniFile.fileTxt = self.iniFile._fileTxt.strip()

        result = ""
        if (writeBack):
            result = self.iniFile.write()
            self.iniFile.clearRead()
        else:
            result = self.iniFile._fileTxt

        self.iniFile._isFixed = False
        return result

    @BaseIniRemover._readLines
    def _removeFixSections(self, parse: bool = False, writeBack: bool = True) -> str:
        """
        Removes the [.*RemapBlend.*] sections of the .ini file that this script has made

        Parameters
        ----------
        parse: :class:`bool`
            Whether to keep track of the Blend.buf files that also need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        writeBack: :class:`bool`
            Whether to write back the new text content of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file
        """

        if (not parse):
            self.iniFile.removeSectionOptions(self._removalPattern)
        else:
            sectionsToRemove = self.iniFile.getSectionOptions(self._removalPattern, postProcessor = self.iniFile._removeSection)

            sectionNames = set()
            removedSectionIndices = []

            # get the indices and sections to remove
            for sectionName in sectionsToRemove:
                sectionRanges = sectionsToRemove[sectionName]
                sectionNames.add(sectionName)

                for range in sectionRanges:
                    removedSectionIndices.append(range)

            blendResourceSections = self._getRemovalBlendResource(sectionNames)
            positionResourceSections = self._getRemovalPositionResource(sectionNames)
            texSections = self._getRemovalTexResource(sectionNames)
            dlSections = self._getRemovalDLResource(sectionNames)

            self._makeRemovalRemapBlendModels(blendResourceSections)
            self._makeRemovalRemapPositionModels(positionResourceSections)
            self._makeRemovalRemapTexModels(texSections)
            self._makeRemovalRemapDLModels(dlSections)

            for sectionName in sectionNames:
                self.iniFile.sectionIfTemplates.pop(sectionName, None)

            self.iniFile.fileLines = TextTools.removeLines(self.iniFile.fileLines, removedSectionIndices)

        result = ""
        if (writeBack):
            result = self.iniFile.write()
            self.iniFile.clearRead()
        else:
            result = self.iniFile._fileTxt

        self.iniFile._isFixed = False
        return result

    @BaseIniRemover._readLines
    def _removeFixComment(self, writeBack: bool = True) -> str:
        """
        Removes the ";RemapFixHideOrig -->" comment prefix that this script has made

        Parameters
        ----------
        writeBack: :class:`bool`
            Whether to write back the new text content of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file
        """

        self.iniFile.fileTxt = self.iniFile.fileTxt.replace(IniKeywords.HideOriginalComment.value, "")

        result = ""
        if (writeBack):
            result = self.iniFile.write()
            self.iniFile.clearRead()
        else:
            result = self.iniFile._fileTxt

        self.iniFile._isFixed = False
        self.iniFile._hideOriginalReplaced = True
        return result

    def remove(self, parse: bool = False, writeBack: bool = True) -> str:
        if (not self.iniFile.isModIni):
            parse = False

        self._removeScriptFix(parse = parse, writeBack = False)  
        self._removeFixSections(parse = parse, writeBack = False)
        result = self._removeFixComment(writeBack = writeBack)

        return result


class GlobalIniRemoveBuilders(Enum):
    """
    Global builders used by the software to dynamically create modules to remove fixes from the .ini file

    Attributes
    ----------
    RemoveBuilder: :class:`IniRemoveBuilder`
        The builder to dynamically create modules that remove fixes from the .ini file
    """

    RemoveBuilder = IniRemoveBuilder(IniRemover)


VertexCountData = {4.0 : {ModTypeNames.Amber.value: 10406,
        ModTypeNames.AmberCN.value: 10514,
        ModTypeNames.Ayaka.value: 15700,
        ModTypeNames.AyakaSpringbloom.value: 19401,
        ModTypeNames.Barbara.value: 12498,
        ModTypeNames.BarbaraSummertime.value: 13580,
        ModTypeNames.Diluc.value: 13618,
        ModTypeNames.DilucFlamme.value: 16897,
        ModTypeNames.Fischl.value: 11834,
        ModTypeNames.FischlHighness.value: 22225,
        ModTypeNames.Ganyu.value: 14871,
        ModTypeNames.HuTao.value: 14427,
        ModTypeNames.Jean.value: 13279,
        ModTypeNames.JeanCN.value: 12061,
        ModTypeNames.JeanSea.value: 14672,
        ModTypeNames.Kaeya.value: 14711,
        ModTypeNames.KaeyaSailwind.value: 21365,
        ModTypeNames.Keqing.value: 15009,
        ModTypeNames.KeqingOpulent.value: 16066,
        ModTypeNames.Kirara.value: 20396,
        ModTypeNames.Klee.value: 13647,
        ModTypeNames.KleeBlossomingStarlight.value: 24110,
        ModTypeNames.Lisa.value: 13644,
        ModTypeNames.LisaStudent.value: 19683,
        ModTypeNames.Mona.value: 13529,
        ModTypeNames.MonaCN.value: 13333,
        ModTypeNames.Nilou.value: 18458,
        ModTypeNames.Ningguang.value: 12931,
        ModTypeNames.NingguangOrchid.value: 16612,
        ModTypeNames.Raiden.value: 13251,
        ModTypeNames.Rosaria.value: 12515,
        ModTypeNames.RosariaCN.value: 13992,
        ModTypeNames.Shenhe.value: 13830,
        ModTypeNames.Xiangling.value: 12352,
        ModTypeNames.Xingqiu.value: 13068},
        4.4: {ModTypeNames.ShenheFrostFlower.value: 19357,
              ModTypeNames.GanyuTwilight.value: 24118,
              ModTypeNames.XingqiuBamboo.value: 20494},
        4.6: {ModTypeNames.Arlecchino.value: 22510},
        4.8: {ModTypeNames.NilouBreeze.value: 21830,
              ModTypeNames.KiraraBoots.value: 20854},
        5.3: {ModTypeNames.CherryHuTao.value: 23136,
              ModTypeNames.XianglingCheer.value: 22151}}


class ModDictAssets(ModAssets[T]):
    """
    This class inherits from :class:`ModAssets`

    Class to handle assets of any type for a mod where retrieval is based on some key

    .. note::
        This is a dictionary that retrieves a certain asset for some game version

    Parameters
    ----------
    repo: Dict[:class:`float`, Dict[:class:`str`, T]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value is the content for the asset
    """

    def __init__(self, repo:  Dict[float, Dict[str, T]]):
        super().__init__(repo)
        self._updateVersions(repo)

    def _updateVersions(self, assets: Dict[float, Dict[str, T]]):
        for version, versionAssets in assets.items():
            for assetName in versionAssets:
                self._addVersion(assetName, version)

    def updateRepo(self, srcRepo: Dict[float, Dict[str, Any]], newRepo: Dict[float, Dict[str, Any]]) -> Dict[float, Dict[str, Any]]:
        result = super().updateRepo(srcRepo, newRepo)
        self._updateVersions(newRepo)
        return result
        
    def get(self, assetName: str, version: Optional[float] = None) -> T:
        """
        Retrieves the corresponding asset

        Parameters
        ----------
        assetName: :class:`str`
            The name of the assets we want

        version: Optional[:class:`float`]
            The game version we want the asset to come from :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will retrieve the asset of the latest version. :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            If the corresponding asset based on the search parameters is not found
            
        Returns
        -------
        T
            The found asset
        """

        closestVersion = self.findClosestVersion(assetName, version = version)
        versionAssets = self._getVersionAssets(closestVersion, self._repo)
        return versionAssets[assetName]


class VertexCounts(ModDictAssets[int]):
    """
    This class inherits from :class:`ModDictAssets`
    
    Class for managing vertex counts of a mod

    Parameters
    ----------
    repo: Optional[Dict[Union[:class:`str`, :class:`float`, `packaging.version.Version`_], Dict[:class:`str`, :class:`int`]]]
        The original source for the vertex counts:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, will use the default vertex counts provided by the software :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Optional[Dict[Union[str, float, VersionType], Dict[str, int]]] = None):
        if (repo is None):
            repo = VertexCountData

        super().__init__(repo)


class VGRemap():
    """
    Class for handling the vertex group remaps for mods

    Parameters
    ----------
    vgRemap: Dict[:class:`int`, :class:`int`] 
        The vertex group remap from one type of mod to another
    """

    def __init__(self, vgRemap: Dict[int, int]):
        self._maxIndex = 0
        self.remap = vgRemap

    @property
    def remap(self):
        """
        The vertex group remap

        :getter: Retrieves the remap
        :setter: Sets a new remap
        :type: Dict[:class:`int`, :class:`int`]
        """

        return self._remap

    @remap.setter
    def remap(self, newVgRemap: Dict[int, int]):
        self._remap = newVgRemap
        if (self._remap):
            self._maxIndex = max(list(self._remap.keys()))
        else:
            self._maxIndex = None

    @property
    def maxIndex(self):
        """
        The maximum index in the vertex group remap

        :getter: Retrieves the max index
        :type: :class:`int`
        """

        return self._maxIndex


VGRemapData = {4.0: { ModTypeNames.Amber.value : {ModTypeNames.AmberCN.value: VGRemap({0: 7, 1: 6, 2: 9, 3: 10, 4: 11, 5: 29, 6: 8, 7: 12, 8: 13, 9: 14, 10: 15, 11: 16, 12: 17, 
                               13: 77, 14: 1, 15: 0, 16: 73, 17: 18, 18: 19, 19: 20, 20: 21, 21: 53, 22: 70, 23: 74, 24: 50, 
                               25: 30, 26: 47, 27: 51, 28: 76, 29: 75, 30: 24, 31: 71, 32: 28, 33: 27, 34: 54, 35: 52, 36: 31, 
                               37: 72, 38: 55, 39: 56, 40: 61, 41: 58, 42: 62, 43: 64, 44: 65, 45: 67, 46: 68, 47: 57, 48: 59, 49: 60, 
                               50: 63, 51: 66, 52: 69, 53: 48, 54: 26, 55: 25, 56: 49, 57: 32, 58: 33, 59: 38, 60: 35, 61: 39, 62: 41, 
                               63: 42, 64: 44, 65: 45, 66: 34, 67: 36, 68: 37, 69: 40, 70: 43, 71: 46, 72: 22, 73: 23, 74: 2, 75: 3, 76: 4, 77: 5})},
        ModTypeNames.AmberCN.value: {ModTypeNames.Amber.value : VGRemap({0: 15, 1: 14, 2: 74, 3: 75, 4: 76, 5: 77, 6: 1, 7: 0, 8: 6, 9: 2, 10: 3, 11: 4, 12: 7, 13: 8, 14: 9, 15: 10, 
                               16: 11, 17: 12, 18: 17, 19: 18, 20: 19, 21: 20, 22: 72, 23: 73, 24: 30, 25: 55, 26: 54, 27: 33, 28: 32, 
                               29: 5, 30: 25, 31: 36, 32: 57, 33: 58, 34: 66, 35: 60, 36: 67, 37: 68, 38: 59, 39: 61, 40: 69, 41: 62, 42: 
                               63, 43: 70, 44: 64, 45: 65, 46: 71, 47: 26, 48: 53, 49: 56, 50: 24, 51: 27, 52: 35, 53: 21, 54: 34, 55: 38, 
                               56: 39, 57: 47, 58: 41, 59: 48, 60: 49, 61: 40, 62: 42, 63: 50, 64: 43, 65: 44, 66: 51, 67: 45, 68: 46, 69: 52, 
                               70: 22, 71: 31, 72: 37, 73: 16, 74: 23, 75: 29, 76: 28, 77: 13})},
        ModTypeNames.Ayaka.value: {ModTypeNames.AyakaSpringbloom.value: VGRemap({0: 0, 1: 7, 2: 10, 3: 11, 4: 87, 5: 87, 6: 87, 7: 87, 8: 12, 9: 13, 10: 20, 11: 1, 12: 2, 13: 113, 14: 32, 
                                               15: 14, 16: 15, 17: 17, 18: 18, 19: 31, 20: 32, 21: 33, 22: 34, 23: 35, 24: 25, 25: 26, 26: 36, 27: 37, 28: 38, 
                                               29: 39, 30: 29, 31: 30, 32: 40, 33: 41, 34: 42, 35: 43, 36: 44, 37: 45, 38: 46, 39: 47, 40: 48, 41: 49, 42: 50, 
                                               43: 51, 44: 52, 45: 53, 46: 54, 47: 55, 48: 56, 49: 57, 50: 58, 51: 59, 52: 60, 53: 60, 54: 86, 55: 86, 56: 86, 
                                               57: 86, 58: 61, 59: 61, 60: 110, 61: 110, 62: 110, 63: 110, 64: 60, 65: 86, 66: 61, 67: 110, 68: 62, 69: 63, 70: 64, 
                                               71: 65, 72: 66, 73: 67, 74: 68, 75: 69, 76: 70, 77: 71, 78: 72, 79: 73, 80: 74, 81: 75, 82: 76, 83: 77, 84: 78, 85: 79, 
                                               86: 80, 87: 81, 88: 82, 89: 83, 90: 84, 91: 85, 92: 87, 93: 88, 94: 89, 95: 90, 96: 91, 97: 92, 98: 93, 99: 94, 100: 95, 
                                               101: 96, 102: 97, 103: 98, 104: 99, 105: 100, 106: 101, 107: 102, 108: 103, 109: 104, 110: 105, 111: 106, 112: 107, 
                                               113: 108, 114: 109, 115: 111, 116: 112, 117: 113})},
        ModTypeNames.AyakaSpringbloom.value: {ModTypeNames.Ayaka.value: VGRemap({0: 0, 1: 11, 2: 12, 3: 71, 4: 71, 5: 71, 6: 71, 7: 1, 8: 11, 9: 12, 10: 2, 11: 3, 12: 8, 13: 9, 14: 15, 15: 16, 16: 69, 
                                               17: 17, 18: 18, 19: 69, 20: 10, 21: 20, 22: 21, 23: 21, 24: 22, 25: 24, 26: 25, 27: 27, 28: 28, 29: 30, 30: 31, 31: 19, 
                                               32: 20, 33: 21, 34: 22, 35: 23, 36: 26, 37: 27, 38: 28, 39: 29, 40: 32, 41: 33, 42: 34, 43: 35, 44: 36, 45: 37, 46: 38, 
                                               47: 39, 48: 40, 49: 41, 50: 42, 51: 43, 52: 44, 53: 45, 54: 46, 55: 47, 56: 48, 57: 49, 58: 50, 59: 51, 60: 52, 61: 58, 
                                               62: 68, 63: 69, 64: 70, 65: 71, 66: 72, 67: 73, 68: 74, 69: 75, 70: 76, 71: 77, 72: 78, 73: 79, 74: 80, 75: 81, 76: 82, 
                                               77: 83, 78: 84, 79: 85, 80: 86, 81: 87, 82: 88, 83: 89, 84: 90, 85: 91, 86: 65, 87: 92, 88: 93, 89: 94, 90: 95, 91: 96, 
                                               92: 97, 93: 98, 94: 99, 95: 100, 96: 101, 97: 102, 98: 103, 99: 104, 100: 105, 101: 106, 102: 107, 103: 108, 104: 109, 
                                               105: 110, 106: 111, 107: 112, 108: 113, 109: 114, 110: 67, 111: 115, 112: 116, 113: 117})},
        ModTypeNames.Barbara.value: {ModTypeNames.BarbaraSummertime.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 86, 7: 86, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: 12, 
                                          15: 13, 16: 14, 17: 15, 18: 16, 19: 17, 20: 18, 21: 19, 22: 19, 23: 20, 24: 20, 25: 21, 26: 21, 
                                          27: 22, 28: 22, 29: 84, 30: 18, 31: 57, 32: 57, 33: 23, 34: 23, 35: 24, 36: 24, 37: 25, 38: 25, 
                                          39: 26, 40: 26, 41: 27, 42: 27, 43: 28, 44: 28, 45: 29, 46: 29, 47: 30, 48: 30, 49: 31, 50: 59, 
                                          51: 33, 52: 83, 53: 35, 54: 36, 55: 37, 56: 38, 57: 39, 58: 40, 59: 41, 60: 42, 61: 43, 62: 44, 
                                          63: 45, 64: 46, 65: 47, 66: 48, 67: 49, 68: 50, 69: 51, 70: 52, 71: 53, 72: 54, 73: 55, 74: 56, 
                                          75: 57, 76: 58, 77: 60, 78: 61, 79: 62, 80: 63, 81: 64, 82: 65, 83: 66, 84: 67, 85: 68, 86: 69, 
                                          87: 70, 88: 71, 89: 72, 90: 73, 91: 74, 92: 75, 93: 76, 94: 77, 95: 78, 96: 79, 97: 80, 98: 81, 
                                          99: 82, 100: 84, 101: 85, 102: 86 })},
        ModTypeNames.BarbaraSummertime.value: {ModTypeNames.Barbara.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 8, 7: 9, 8: 10, 9: 11, 10: 12, 11: 13, 12: 14, 13: 15, 14: 16, 
                                          15: 17, 16: 18, 17: 19, 18: 20, 19: 22, 20: 23, 21: 26, 22: 27, 23: 34, 24: 35, 25: 38, 26: 39, 27: 42, 
                                          28: 43, 29: 46, 30: 47, 31: 49, 32: 50, 33: 51, 34: 52, 35: 53, 36: 54, 37: 55, 38: 56, 39: 57, 40: 58, 
                                          41: 59, 42: 60, 43: 61, 44: 62, 45: 63, 46: 64, 47: 65, 48: 66, 49: 67, 50: 68, 51: 69, 52: 70, 53: 71, 
                                          54: 72, 55: 73, 56: 74, 57: 75, 58: 76, 59: 50, 60: 77, 61: 78, 62: 79, 63: 80, 64: 81, 65: 82, 66: 83, 
                                          67: 84, 68: 85, 69: 86, 70: 87, 71: 88, 72: 89, 73: 90, 74: 91, 75: 92, 76: 93, 77: 94, 78: 95, 79: 96, 
                                          80: 97, 81: 98, 82: 99, 83: 52, 84: 100, 85: 101, 86: 102 })},
        ModTypeNames.Diluc.value: {ModTypeNames.DilucFlamme.value: VGRemap({0: 12, 1: 10, 2: 14, 3: 11, 4: 16, 5: 17, 6: 19, 7: 20, 8: 21, 9: 22, 10: 25, 11: 42, 12: 44, 13: 42, 14: 96, 
                                          15: 96, 16: 96, 17: 42, 18: 116, 19: 116, 20: 116, 21: 42, 22: 96, 23: 42, 24: 116, 25: 42, 26: 96, 27: 96, 28: 42, 
                                          29: 116, 30: 116, 31: 75, 32: 74, 33: 77, 34: 76, 35: 42, 36: 96, 37: 78, 38: 79, 39: 80, 40: 81, 41: 82, 42: 83, 43: 84, 
                                          44: 85, 45: 86, 46: 87, 47: 88, 48: 89, 49: 90, 50: 91, 51: 92, 52: 93, 53: 94, 54: 95, 55: 96, 56: 97, 57: 98, 58: 99, 59: 100, 
                                          60: 101, 61: 102, 62: 103, 63: 104, 64: 105, 65: 106, 66: 107, 67: 108, 68: 109, 69: 110, 70: 111, 71: 112, 72: 113, 73: 114, 
                                          74: 115, 75: 116, 76: 117, 77: 118, 78: 119, 79: 120, 80: 121, 81: 122, 82: 123, 83: 124, 84: 125, 85: 126})},
        ModTypeNames.DilucFlamme.value: {ModTypeNames.Diluc.value: VGRemap({0: 39, 1: 59, 2: 53, 3: 73, 4: 52, 5: 72, 6: 53, 7: 73, 8: 39, 9: 59, 10: 1, 11: 3, 12: 0, 13: 0, 14: 2, 15: 2, 16: 4, 
                                          17: 5, 18: 37, 19: 6, 20: 7, 21: 8, 22: 9, 23: 37, 24: 57, 25: 10, 26: 77, 27: 11, 28: 12, 29: 14, 30: 80, 31: 54, 
                                          32: 54, 33: 54, 34: 54, 35: 83, 36: 74, 37: 74, 38: 74, 39: 74, 40: 21, 41: 23, 42: 11, 43: 12, 44: 15, 45: 16, 46: 13, 
                                          47: 14, 48: 15, 49: 16, 50: 17, 51: 18, 52: 19, 53: 20, 54: 25, 55: 26, 56: 27, 57: 27, 58: 28, 59: 29, 60: 30, 61: 30, 
                                          62: 53, 63: 53, 64: 53, 65: 53, 66: 53, 67: 53, 68: 73, 69: 73, 70: 73, 71: 73, 72: 73, 73: 73, 74: 32, 75: 31, 76: 34, 
                                          77: 33, 78: 37, 79: 38, 80: 39, 81: 40, 82: 41, 83: 42, 84: 43, 85: 44, 86: 45, 87: 46, 88: 47, 89: 48, 90: 49, 91: 50, 
                                          92: 51, 93: 52, 94: 53, 95: 54, 96: 55, 97: 56, 98: 57, 99: 58, 100: 59, 101: 60, 102: 61, 103: 62, 104: 63, 105: 64, 
                                          106: 65, 107: 66, 108: 67, 109: 68, 110: 69, 111: 70, 112: 71, 113: 72, 114: 73, 115: 74, 116: 75, 117: 76, 118: 77, 
                                          119: 78, 120: 79, 121: 80, 122: 81, 123: 82, 124: 83, 125: 84, 126: 85})},
        ModTypeNames.Fischl.value : {ModTypeNames.FischlHighness.value: VGRemap({1: 40, 2: 0, 3: 1, 4: 3, 5: 4, 6: 5, 7: 6, 8: 7, 9: 8, 10: 9, 11: 10, 12: 11, 13: 12, 14: 13, 15: 14, 
                                               16: 15, 17: 16, 18: 17, 19: 17, 20: 19, 21: 20, 22: 21, 23: 22, 24: 23, 25: 24, 26: 25, 27: 26, 28: 27, 
                                               29: 28, 30: 29, 31: 30, 32: 29, 33: 30, 34: 31, 35: 32, 36: 31, 37: 32, 38: 33, 39: 34, 40: 35, 41: 36, 
                                               42: 37, 43: 38, 44: 39, 45: 40, 46: 41, 47: 42, 48: 43, 49: 44, 50: 45, 51: 46, 52: 47, 53: 48, 54: 49, 
                                               55: 50, 56: 51, 57: 52, 58: 53, 59: 54, 60: 55, 61: 56, 62: 57, 63: 58, 64: 59, 65: 60, 66: 61, 67: 62, 
                                               68: 63, 69: 64, 70: 65, 71: 66, 72: 67, 73: 68, 74: 69, 75: 70, 76: 71, 77: 72, 78: 73, 79: 74, 80: 75, 
                                               81: 76, 82: 77, 83: 78, 84: 79, 85: 80, 86: 81, 87: 82, 88: 83, 89: 84, 90: 85, 91: 86, 92: 87, 93: 88, 94: 89})},
        ModTypeNames.FischlHighness.value: {ModTypeNames.Fischl.value: VGRemap({0: 2, 1: 3, 2: 46, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10, 10: 11, 11: 12, 12: 13, 13: 14, 14: 15, 
                                               15: 16, 16: 17, 17: 18, 18: 19, 19: 20, 20: 21, 21: 22, 22: 23, 23: 24, 24: 25, 25: 26, 26: 27, 27: 28, 
                                               28: 29, 29: 30, 30: 31, 31: 34, 32: 35, 33: 38, 34: 39, 35: 40, 36: 41, 37: 42, 38: 43, 39: 44, 40: 0, 41: 46, 
                                               42: 47, 43: 48, 44: 49, 45: 50, 46: 51, 47: 52, 48: 53, 49: 54, 50: 55, 51: 56, 52: 57, 53: 58, 54: 59, 55: 60, 
                                               56: 61, 57: 62, 58: 63, 59: 64, 60: 65, 61: 66, 62: 67, 63: 68, 64: 69, 65: 70, 66: 71, 67: 72, 68: 73, 69: 74, 
                                               70: 75, 71: 76, 72: 77, 73: 78, 74: 79, 75: 80, 76: 81, 77: 82, 78: 83, 79: 84, 80: 85, 81: 86, 82: 87, 83: 88, 
                                               84: 89, 85: 90, 86: 91, 87: 92, 88: 93, 89: 94})},
        ModTypeNames.Jean.value : {ModTypeNames.JeanCN.value: VGRemap({0: 50, 1: 102, 2: 103, 3: 104, 4: 79, 5: 56, 6: 24, 7: 25, 8: 33, 9: 34, 10: 35, 11: 30, 12: 31, 13: 32, 14: 26, 
                             15: 27, 16: 28, 17: 29, 18: 58, 19: 75, 20: 76, 21: 59, 22: 60, 23: 61, 24: 62, 25: 63, 26: 64, 27: 65, 28: 66, 
                             29: 67, 30: 68, 31: 69, 32: 70, 33: 71, 34: 72, 35: 73, 36: 52, 37: 51, 38: 6, 39: 7, 40: 10, 41: 11, 42: 12, 
                             43: 13, 44: 2, 45: 3, 46: 81, 47: 98, 48: 99, 49: 82, 50: 83, 51: 84, 52: 85, 53: 86, 54: 87, 55: 88, 56: 89, 
                             57: 90, 58: 91, 59: 92, 60: 93, 61: 94, 62: 95, 63: 96, 64: 53, 65: 54, 66: 4, 67: 5, 68: 16, 69: 17, 70: 14, 
                             71: 15, 72: 8, 73: 9, 74: 19, 75: 18, 76: 0, 77: 1, 78: 21, 79: 23, 80: 20, 81: 22, 82: 47, 83: 48, 84: 49, 85: 43, 
                             86: 44, 87: 45, 88: 46, 89: 40, 90: 41, 91: 42, 92: 36, 93: 37, 94: 38, 95: 39, 96: 55, 97: 77, 98: 57, 99: 74, 
                             100: 78, 101: 100, 102: 80, 103: 97, 104: 101}),
                  ModTypeNames.JeanSea.value: VGRemap({0: 30, 1: 82, 2: 83, 3: 84, 4: 59, 5: 36, 6: 4, 7: 5, 8: 13, 9: 14, 10: 15, 11: 10, 12: 11, 13: 12, 14: 6, 15: 7,
                                    16: 8, 17: 9, 18: 38, 19: 55, 20: 56, 21: 39, 22: 40, 23: 41, 24: 42, 25: 43, 26: 44, 27: 45, 28: 46, 29: 47, 
                                    30: 48, 31: 49, 32: 50, 33: 51, 34: 52, 35: 53, 36: 32, 37: 31, 46: 61, 47: 78, 48: 79, 49: 62, 50: 63, 51: 
                                    64, 52: 65, 53: 66, 54: 67, 55: 68, 56: 69, 57: 70, 58: 71, 59: 72, 60: 73, 61: 74, 62: 75, 63: 76, 64: 33, 
                                    65: 34, 74: 2, 75: 0, 82: 27, 83: 28, 84: 29, 85: 23, 86: 24, 87: 25, 88: 26, 89: 20, 90: 21, 91: 22, 92: 16, 
                                    93: 17, 94: 18, 95: 19, 96: 35, 97: 57, 98: 37, 99: 54, 100: 58, 101: 80, 102: 60, 103: 77, 104: 81})},
        ModTypeNames.JeanCN.value: {ModTypeNames.Jean.value: VGRemap({0: 76, 1: 77, 2: 44, 3: 45, 4: 66, 5: 67, 6: 38, 7: 39, 8: 72, 9: 73, 10: 40, 11: 41, 12: 42, 13: 43, 14: 70, 15: 71, 
                            16: 68, 17: 69, 18: 75, 19: 74, 20: 80, 21: 78, 22: 81, 23: 79, 24: 6, 25: 7, 26: 14, 27: 15, 28: 16, 29: 17, 30: 11, 
                            31: 12, 32: 13, 33: 8, 34: 9, 35: 10, 36: 92, 37: 93, 38: 94, 39: 95, 40: 89, 41: 90, 42: 91, 43: 85, 44: 86, 45: 87, 
                            46: 88, 47: 82, 48: 83, 49: 84, 50: 0, 51: 37, 52: 36, 53: 64, 54: 65, 55: 96, 56: 5, 57: 98, 58: 18, 59: 21, 60: 22, 
                            61: 23, 62: 24, 63: 25, 64: 26, 65: 27, 66: 28, 67: 29, 68: 30, 69: 31, 70: 32, 71: 33, 72: 34, 73: 35, 74: 99, 75: 19, 
                            76: 20, 77: 97, 78: 100, 79: 4, 80: 102, 81: 46, 82: 49, 83: 50, 84: 51, 85: 52, 86: 53, 87: 54, 88: 55, 89: 56, 90: 57, 
                            91: 58, 92: 59, 93: 60, 94: 61, 95: 62, 96: 63, 97: 103, 98: 47, 99: 48, 100: 101, 101: 104, 102: 1, 103: 2, 104: 3}),
                   ModTypeNames.JeanSea.value: VGRemap({18: 0, 19: 2, 24: 4, 25: 5, 26: 6, 27: 7, 28: 8, 29: 9, 30: 10, 31: 11, 32: 12, 33: 13, 34: 14, 35: 15, 
                                       36: 16, 37: 17, 38: 18, 39: 19, 40: 20, 41: 21, 42: 22, 43: 23, 44: 24, 45: 25, 46: 26, 47: 27, 48: 28, 
                                       49: 29, 50: 30, 51: 31, 52: 32, 53: 33, 54: 34, 55: 35, 56: 36, 57: 37, 58: 38, 59: 39, 60: 40, 61: 41, 62: 42, 
                                       63: 43, 64: 44, 65: 45, 66: 46, 67: 47, 68: 48, 69: 49, 70: 50, 71: 51, 72: 52, 73: 53, 74: 54, 75: 55, 76: 56, 
                                       77: 57, 78: 58, 79: 59, 80: 60, 81: 61, 82: 62, 83: 63, 84: 64, 85: 65, 86: 66, 87: 67, 88: 68, 89: 69, 90: 70, 
                                       91: 71, 92: 72, 93: 73, 94: 74, 95: 75, 96: 76, 97: 77, 98: 78, 99: 79, 100: 80, 101: 81, 102: 82, 103: 83, 104: 84})},
        ModTypeNames.JeanSea.value: {ModTypeNames.Jean.value: VGRemap({0: 75, 1: 75, 2: 74, 3: 74, 4: 6, 5: 7, 6: 14, 7: 15, 8: 16, 9: 17, 10: 11, 11: 12, 12: 13, 13: 8, 14: 9, 15: 10, 16: 92, 
                                     17: 93, 18: 94, 19: 95, 20: 89, 21: 90, 22: 91, 23: 85, 24: 86, 25: 87, 26: 88, 27: 82, 28: 83, 29: 84, 30: 0, 
                                     31: 37, 32: 36, 33: 64, 34: 65, 35: 96, 36: 5, 37: 98, 38: 18, 39: 21, 40: 22, 41: 23, 42: 24, 43: 25, 44: 26, 
                                     45: 27, 46: 28, 47: 29, 48: 30, 49: 31, 50: 32, 51: 33, 52: 34, 53: 35, 54: 99, 55: 19, 56: 20, 57: 97, 58: 100, 
                                     59: 4, 60: 102, 61: 46, 62: 49, 63: 50, 64: 51, 65: 52, 66: 53, 67: 54, 68: 55, 69: 56, 70: 57, 71: 58, 72: 59, 
                                     73: 60, 74: 61, 75: 62, 76: 63, 77: 103, 78: 47, 79: 48, 80: 101, 81: 104, 82: 1, 83: 2, 84: 3}),
                    ModTypeNames.JeanCN.value: VGRemap({0: 18, 1: 18, 2: 19, 3: 19, 4: 24, 5: 25, 6: 26, 7: 27, 8: 28, 9: 29, 10: 30, 11: 31, 12: 32, 13: 33, 14: 34, 15: 35, 16: 36, 17: 37, 
                                       18: 38, 19: 39, 20: 40, 21: 41, 22: 42, 23: 43, 24: 44, 25: 45, 26: 46, 27: 47, 28: 48, 29: 49, 30: 50, 31: 51, 32: 52, 
                                       33: 53, 34: 54, 35: 55, 36: 56, 37: 57, 38: 58, 39: 59, 40: 60, 41: 61, 42: 62, 43: 63, 44: 64, 45: 65, 46: 66, 47: 67, 
                                       48: 68, 49: 69, 50: 70, 51: 71, 52: 72, 53: 73, 54: 74, 55: 75, 56: 76, 57: 77, 58: 78, 59: 79, 60: 80, 61: 81, 62: 82, 
                                       63: 83, 64: 84, 65: 85, 66: 86, 67: 87, 68: 88, 69: 89, 70: 90, 71: 91, 72: 92, 73: 93, 74: 94, 75: 95, 76: 96, 77: 97, 
                                       78: 98, 79: 99, 80: 100, 81: 101, 82: 102, 83: 103, 84: 104})},
        ModTypeNames.Keqing.value: {ModTypeNames.KeqingOpulent.value: VGRemap({0: 100, 1: 101, 2: 102, 3: 76, 4: 52, 5: 3, 6: 2, 7: 16, 8: 17, 9: 9, 10: 10, 11: 11, 12: 12,
                                    13: 13, 14: 14, 15: 15, 16: 4, 17: 5, 18: 6, 19: 7, 20: 8, 21: 54, 22: 71, 23: 72, 24: 55, 25: 56,
                                    26: 57, 27: 58, 28: 59, 29: 60, 30: 61, 31: 62, 32: 63, 33: 64, 34: 65, 35: 66, 36: 67, 37: 68, 38: 69,
                                    39: 46, 40: 47, 41: 38, 42: 39, 43: 40, 44: 41, 45: 47, 46: 47, 47: 78, 48: 95, 49: 96, 50: 79, 51: 80,
                                    52: 81, 53: 82, 54: 83, 55: 84, 56: 85, 57: 86, 58: 87, 59: 88, 60: 89, 61: 90, 62: 91, 63: 92, 64: 93,
                                    65: 48, 66: 49, 67: 42, 68: 43, 69: 44, 70: 45, 71: 49, 72: 49, 73: 1, 74: 0, 75: 50, 76: 51, 77: 28,
                                    78: 29, 79: 30, 80: 19, 81: 20, 82: 21, 83: 34, 84: 35, 85: 22, 86: 23, 87: 24, 88: 36, 89: 37, 90: 31,
                                    91: 32, 92: 33, 93: 25, 94: 26, 95: 27, 101: 73, 102: 53, 103: 70, 104: 74, 105: 97, 106: 77, 107: 94, 108: 98, 109: 18})},
         ModTypeNames.Kaeya.value: {ModTypeNames.KaeyaSailwind.value: VGRemap({0: 64, 1: 65, 2: 66, 3: 44, 4: 24, 5: 15, 6: 17, 7: 18, 8: 16, 9: 26, 10: 21, 11: 20, 12: 40, 13: 41, 
                                                                               14: 36, 15: 37, 16: 38, 17: 33, 18: 34, 19: 35, 20: 30, 21: 31, 22: 32, 23: 27, 24: 28, 25: 29, 26: 67, 
                                                                               27: 68, 28: 69, 29: 0, 30: 1, 31: 2, 32: 3, 33: 46, 34: 23, 35: 22, 36: 60, 37: 61, 38: 56, 39: 57, 
                                                                               40: 58, 41: 53, 42: 54, 43: 55, 44: 50, 45: 51, 46: 52, 47: 47, 48: 48, 49: 49, 50: 70, 51: 71, 52: 72, 
                                                                               53: 46, 54: 12, 55: 14, 56: 14, 57: 14, 58: 12, 59: 13, 60: 13, 61: 13, 62: 13, 63: 13, 64: 12, 65: 12, 
                                                                               66: 9, 67: 10, 68: 10, 69: 10, 70: 10, 71: 11, 72: 4, 73: 5, 74: 6, 75: 7, 76: 8, 77: 42, 78: 25, 79: 39, 
                                                                               80: 43, 81: 62, 82: 45, 83: 59, 84: 63, 85: 19, 86: 19})},
         ModTypeNames.KaeyaSailwind.value: {ModTypeNames.Kaeya.value: VGRemap({0: 29, 1: 30, 2: 31, 3: 32, 4: 72, 5: 73, 6: 74, 7: 75, 8: 76, 9: 69, 10: 70, 11: 71, 12: 54, 13: 64, 14: 56, 
                                                                               15: 5, 16: 8, 17: 6, 18: 7, 19: 86, 20: 11, 21: 10, 22: 35, 23: 34, 24: 4, 25: 78, 26: 9, 27: 23, 28: 24, 29: 25, 
                                                                               30: 20, 31: 21, 32: 22, 33: 17, 34: 18, 35: 19, 36: 14, 37: 15, 38: 16, 39: 79, 40: 12, 41: 13, 42: 77, 43: 80, 
                                                                               44: 3, 45: 82, 46: 33, 47: 47, 48: 48, 49: 49, 50: 44, 51: 45, 52: 46, 53: 41, 54: 42, 55: 43, 56: 38, 57: 39, 
                                                                               58: 40, 59: 83, 60: 36, 61: 37, 62: 81, 63: 84, 64: 0, 65: 1, 66: 2, 67: 26, 68: 27, 69: 28, 70: 50, 71: 51, 72: 52})},
        ModTypeNames.KeqingOpulent.value: {ModTypeNames.Keqing.value: VGRemap({0: 74, 1: 73, 2: 6, 3: 5, 4: 16, 5: 17, 6: 18, 7: 19, 8: 20, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 7, 17: 8, 18: 109, 
                                    19: 80, 20: 81, 21: 82, 22: 85, 23: 86, 24: 87, 25: 93, 26: 94, 27: 95, 28: 77, 29: 78, 30: 79, 31: 90, 32: 91, 33: 92, 34: 83, 35: 84, 
                                    36: 88, 37: 89, 38: 41, 39: 42, 40: 43, 41: 44, 42: 67, 43: 68, 44: 69, 45: 70, 46: 39, 47: 40, 48: 65, 49: 66, 50: 75, 51: 76, 52: 4, 
                                    53: 102, 54: 21, 55: 24, 56: 25, 57: 26, 58: 27, 59: 28, 60: 29, 61: 30, 62: 31, 63: 32, 64: 33, 65: 34, 66: 35, 67: 36, 68: 37, 69: 38, 
                                    70: 103, 71: 22, 72: 23, 73: 101, 74: 104, 76: 3, 77: 106, 78: 47, 79: 50, 80: 51, 81: 52, 82: 53, 83: 54, 84: 55, 85: 56, 86: 57, 87: 58, 
                                    88: 59, 89: 60, 90: 61, 91: 62, 92: 63, 93: 64, 94: 107, 95: 48, 96: 49, 97: 105, 98: 108, 100: 0, 101: 1, 102: 2})},
        ModTypeNames.Klee.value: {ModTypeNames.KleeBlossomingStarlight.value: VGRemap({0: 89, 1: 90, 2: 91, 3: 66, 4: 43, 5: 7, 6: 8, 7: 43, 8: 23, 9: 23, 10: 15, 11: 16, 12: 5, 13: 6, 14: 11, 15: 12, 
                                                     16: 17, 17: 18, 18: 9, 19: 10, 20: 13, 21: 14, 22: 45, 23: 62, 24: 63, 25: 46, 26: 47, 27: 48, 28: 49, 29: 50, 30: 51, 
                                                     31: 52, 32: 53, 33: 54, 34: 55, 35: 56, 36: 57, 37: 58, 38: 59, 39: 60, 40: 39, 41: 40, 42: 68, 43: 85, 44: 86, 45: 69, 
                                                     46: 70, 47: 71, 48: 72, 49: 73, 50: 74, 51: 75, 52: 76, 53: 77, 54: 78, 55: 79, 56: 80, 57: 81, 58: 82, 59: 83, 60: 41, 
                                                     61: 42, 62: 91, 63: 0, 64: 3, 65: 4, 66: 4, 67: 0, 68: 0, 69: 0, 70: 0, 71: 29, 72: 30, 73: 33, 74: 34, 75: 37, 76: 38, 
                                                     77: 27, 78: 28, 79: 25, 80: 26, 81: 35, 82: 36, 83: 31, 84: 32, 85: 64, 86: 44, 87: 61, 88: 65, 89: 87, 90: 67, 91: 84, 
                                                     92: 88, 93: 24})},
        ModTypeNames.KleeBlossomingStarlight.value: {ModTypeNames.Klee.value: VGRemap({0: 63, 1: 63, 2: 63, 3: 64, 4: 65, 5: 12, 6: 13, 7: 5, 8: 6, 9: 18, 10: 19, 11: 14, 12: 15, 13: 20, 14: 21, 15: 10, 
                                                     16: 11, 17: 16, 18: 17, 19: 4, 20: 4, 21: 4, 22: 4, 23: 4, 24: 93, 25: 79, 26: 80, 27: 77, 28: 78, 29: 71, 30: 72, 
                                                     31: 83, 32: 84, 33: 73, 34: 74, 35: 81, 36: 82, 37: 75, 38: 76, 39: 40, 40: 41, 41: 60, 42: 61, 43: 4, 44: 86, 45: 22, 
                                                     46: 25, 47: 26, 48: 27, 49: 28, 50: 29, 51: 30, 52: 31, 53: 32, 54: 33, 55: 34, 56: 35, 57: 36, 58: 37, 59: 38, 60: 39, 
                                                     61: 87, 62: 23, 63: 24, 64: 85, 65: 88, 66: 3, 67: 90, 68: 42, 69: 45, 70: 46, 71: 47, 72: 48, 73: 49, 74: 50, 75: 51, 
                                                     76: 52, 77: 53, 78: 54, 79: 55, 80: 56, 81: 57, 82: 58, 83: 59, 84: 91, 85: 43, 86: 44, 87: 89, 88: 92, 89: 0, 90: 1, 91: 2})},
        ModTypeNames.Lisa.value: {ModTypeNames.LisaStudent.value: VGRemap({0: 37, 1: 96, 2: 97, 3: 98, 4: 73, 5: 50, 6: 8, 7: 9, 8: 10, 9: 10, 10: 10, 11: 10, 12: 10, 13: 10, 14: 10, 
                                                                           15: 10, 16: 50, 17: 75, 18: 98, 19: 52, 20: 69, 21: 70, 22: 53, 23: 54, 24: 55, 25: 56, 26: 57, 27: 58, 
                                                                           28: 59, 29: 60, 30: 61, 31: 62, 32: 63, 33: 64, 34: 65, 35: 66, 36: 67, 37: 47, 38: 46, 39: 98, 40: 0, 
                                                                           41: 0, 42: 0, 43: 75, 44: 92, 45: 93, 46: 76, 47: 77, 48: 78, 49: 79, 50: 80, 51: 81, 52: 82, 53: 83, 
                                                                           54: 84, 55: 85, 56: 86, 57: 87, 58: 88, 59: 89, 60: 90, 61: 48, 62: 49, 63: 1, 64: 2, 65: 3, 66: 6, 
                                                                           67: 7, 68: 4, 69: 5, 70: 29, 71: 30, 72: 31, 73: 32, 74: 33, 75: 34, 76: 35, 77: 36, 78: 25, 79: 26, 
                                                                           80: 27, 81: 28, 82: 20, 83: 21, 84: 22, 85: 23, 86: 24, 87: 16, 88: 17, 89: 18, 90: 19, 91: 11, 
                                                                           92: 12, 93: 13, 94: 14, 95: 15, 96: 71, 97: 51, 98: 68, 99: 72, 100: 94, 101: 74, 102: 91, 103: 95})},
        ModTypeNames.LisaStudent.value: {ModTypeNames.Lisa.value: VGRemap({0: 40, 1: 63, 2: 64, 3: 65, 4: 68, 5: 69, 6: 66, 7: 67, 8: 6, 9: 7, 10: 8, 11: 91, 12: 92, 13: 93, 
                                                                           14: 94, 15: 95, 16: 87, 17: 88, 18: 89, 19: 90, 20: 82, 21: 83, 22: 84, 23: 85, 24: 86, 25: 78, 26: 79, 
                                                                           27: 80, 28: 81, 29: 70, 30: 71, 31: 72, 32: 73, 33: 74, 34: 75, 35: 76, 36: 77, 37: 0, 38: 20, 39: 44, 
                                                                           40: 20, 41: 44, 42: 20, 43: 20, 44: 44, 45: 44, 46: 38, 47: 37, 48: 61, 49: 62, 50: 5, 51: 97, 52: 19, 
                                                                           53: 22, 54: 23, 55: 24, 56: 25, 57: 26, 58: 27, 59: 28, 60: 29, 61: 30, 62: 31, 63: 32, 64: 33, 65: 34, 
                                                                           66: 35, 67: 36, 68: 98, 69: 20, 70: 21, 71: 96, 72: 99, 73: 4, 74: 101, 75: 43, 76: 46, 77: 47, 78: 48, 
                                                                           79: 49, 80: 50, 81: 51, 82: 52, 83: 53, 84: 54, 85: 55, 86: 56, 87: 57, 88: 58, 89: 59, 90: 60, 91: 102, 
                                                                           92: 44, 93: 45, 94: 100, 95: 103, 96: 1, 97: 2, 98: 3})},
        ModTypeNames.Mona.value: {ModTypeNames.MonaCN.value: VGRemap({0: 37, 1: 38, 2: 39, 3: 36, 4: 58, 5: 30, 6: 31, 7: 32, 8: 29, 9: 57, 10: 26, 11: 25, 12: 24, 13: 27, 14: 28, 15: 34, 
                            16: 35, 17: 40, 18: 33, 19: 81, 20: 106, 21: 102, 22: 47, 23: 43, 24: 46, 25: 44, 26: 42, 27: 41, 28: 45, 29: 105, 30: 104, 
                            31: 60, 32: 54, 33: 53, 34: 20, 35: 83, 36: 56, 37: 55, 38: 21, 39: 15, 40: 10, 41: 16, 42: 11, 43: 5, 44: 23, 45: 0, 46: 6, 
                            47: 1, 48: 22, 49: 77, 50: 49, 51: 50, 52: 100, 53: 51, 54: 52, 55: 79, 56: 2, 57: 7, 58: 3, 59: 4, 60: 8, 61: 9, 62: 12, 
                            63: 17, 64: 13, 65: 14, 66: 18, 67: 19, 68: 59, 69: 76, 70: 82, 71: 99, 72: 80, 73: 103, 74: 48, 75: 101, 76: 84, 77: 90, 
                            78: 87, 79: 93, 80: 96, 81: 97, 82: 85, 83: 86, 84: 88, 85: 89, 86: 91, 87: 92, 88: 94, 89: 95, 90: 98, 91: 78, 92: 61, 
                            93: 67, 94: 64, 95: 70, 96: 73, 97: 74, 98: 62, 99: 63, 100: 65, 101: 66, 102: 68, 103: 69, 104: 71, 105: 72, 106: 75})},
        ModTypeNames.MonaCN.value: {ModTypeNames.Mona.value: VGRemap({0: 45, 1: 47, 2: 56, 3: 58, 4: 59, 5: 43, 6: 46, 7: 57, 8: 60, 9: 61, 10: 40, 11: 42, 12: 62, 13: 64, 14: 65, 15: 39, 
                            16: 41, 17: 63, 18: 66, 19: 67, 20: 34, 21: 38, 22: 48, 23: 44, 24: 12, 25: 11, 26: 10, 27: 13, 28: 14, 29: 8, 30: 5, 
                            31: 6, 32: 7, 33: 18, 34: 15, 35: 16, 36: 3, 37: 0, 38: 1, 39: 2, 40: 17, 41: 27, 42: 26, 43: 23, 44: 25, 45: 28, 46: 24, 
                            47: 22, 48: 74, 49: 50, 50: 51, 51: 53, 52: 54, 53: 33, 54: 32, 55: 37, 56: 36, 57: 9, 58: 4, 59: 68, 60: 31, 61: 92, 
                            62: 98, 63: 99, 64: 94, 65: 100, 66: 101, 67: 93, 68: 102, 69: 103, 70: 95, 71: 104, 72: 105, 73: 96, 74: 97, 75: 106, 
                            76: 69, 77: 49, 78: 91, 79: 55, 80: 72, 81: 19, 82: 70, 83: 35, 84: 76, 85: 82, 86: 83, 87: 78, 88: 84, 89: 85, 90: 77, 
                            91: 86, 92: 87, 93: 79, 94: 88, 95: 89, 96: 80, 97: 81, 98: 90, 99: 71, 100: 52, 101: 75, 102: 21, 103: 73, 104: 30, 
                            105: 29, 106: 20})},
        ModTypeNames.Ningguang.value: {ModTypeNames.NingguangOrchid.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14,
                            15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 29: 28, 30: 29,
                            31: 30, 32: 31, 33: 32, 34: 33, 35: 34, 36: 35, 37: 36, 38: 37, 39: 38, 40: 39, 41: 40, 42: 41, 43: 42, 44: 43, 45: 44,
                            46: 45, 47: 46, 48: 47, 52: 48, 53: 49, 54: 50, 55: 51, 56: 52, 57: 53, 58: 54, 59: 55, 60: 56, 61: 57, 62: 58, 63: 59,
                            64: 60, 65: 61, 66: 62, 67: 63, 68: 64, 69: 65, 70: 66, 71: 67, 72: 68, 73: 69, 74: 70, 75: 71, 76: 72, 77: 73, 78: 74,
                            79: 75, 80: 76, 81: 77, 82: 78, 83: 79, 84: 80, 85: 81, 86: 82, 87: 83, 88: 84, 89: 85, 90: 86, 91: 87, 92: 88, 93: 89,
                            94: 90, 95: 91, 96: 92, 97: 93, 98: 94, 99: 95, 100: 96, 101: 97, 102: 98, 103: 99, 104: 100, 105: 101, 106: 102, 107: 103,
                            108: 104, 109: 105, 110: 106, 111: 107, 112: 108, 113: 109, 114: 110, 115: 111, 116: 112, 117: 113, 118: 114})},
        ModTypeNames.NingguangOrchid.value: {ModTypeNames.Ningguang.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 
                               17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 29, 29: 30, 30: 31, 31: 32, 
                               32: 33, 33: 34, 34: 35, 35: 36, 36: 37, 37: 38, 38: 39, 39: 40, 40: 41, 41: 42, 42: 43, 43: 44, 44: 45, 45: 46, 46: 47, 
                               47: 48, 48: 52, 49: 53, 50: 54, 51: 55, 52: 56, 53: 57, 54: 58, 55: 59, 56: 60, 57: 61, 58: 62, 59: 63, 60: 64, 61: 65, 
                               62: 66, 63: 67, 64: 68, 65: 69, 66: 70, 67: 71, 68: 72, 69: 73, 70: 74, 71: 75, 72: 76, 73: 77, 74: 78, 75: 79, 76: 80, 
                               77: 81, 78: 82, 79: 83, 80: 84, 81: 85, 82: 86, 83: 87, 84: 88, 85: 89, 86: 90, 87: 91, 88: 92, 89: 93, 90: 94, 91: 95, 
                               92: 96, 93: 97, 94: 98, 95: 99, 96: 100, 97: 101, 98: 102, 99: 103, 100: 104, 101: 105, 102: 106, 103: 107, 104: 108, 
                               105: 109, 106: 110, 107: 111, 108: 112, 109: 113, 110: 114, 111: 115, 112: 116, 113: 117, 114: 118})},
        ModTypeNames.Rosaria.value: {ModTypeNames.RosariaCN.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 
                                  16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 
                                  30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 
                                  44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 
                                  58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 
                                  72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 82: 82, 83: 83, 84: 84, 85: 85,
                                  86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97})},
        ModTypeNames.RosariaCN.value: {ModTypeNames.Rosaria.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 
                                  16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 
                                  30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 
                                  44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 
                                  58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 
                                  72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 82: 82, 83: 83, 84: 84, 85: 85,
                                  86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97})},
        ModTypeNames.Raiden.value: {ModTypeNames.RaidenBoss.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 60, 9: 61, 10: 66, 11: 67,
                                12: 8, 13: 9, 14: 10, 15: 11, 16: 12, 17: 13, 18: 14, 19: 15, 20: 16, 21: 17,
                                22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: 23, 28: 24, 29: 25, 30: 26, 31: 27,
                                32: 28, 33: 29, 34: 30, 35: 31, 36: 32, 37: 33, 38: 34, 39: 35, 40: 36, 41: 37,
                                42: 38, 43: 39, 44: 40, 45: 41, 46: 42, 47: 94, 48: 43, 49: 44, 50: 45, 51: 46,
                                52: 47, 53: 48, 54: 49, 55: 50, 56: 51, 57: 52, 58: 53, 59: 54, 60: 55, 61: 56,
                                62: 57, 63: 58, 64: 59, 65: 114, 66: 116, 67: 115, 68: 117, 69: 74, 70: 62, 71: 64,
                                72: 106, 73: 108, 74: 110, 75: 75, 76: 77, 77: 79, 78: 87, 79: 89, 80: 91, 81: 95,
                                82: 97, 83: 99, 84: 81, 85: 83, 86: 85, 87: 68, 88: 70, 89: 72, 90: 104, 91: 112,
                                92: 93, 93: 63, 94: 65, 95: 107, 96: 109, 97: 111, 98: 76, 99: 78, 100: 80, 101: 88,
                                102: 90, 103: 92, 104: 96, 105: 98, 106: 100, 107: 82, 108: 84, 109: 86, 110: 69,
                                111: 71, 112: 73, 113: 105, 114: 113, 115: 101, 116: 102, 117: 103})},
         ModTypeNames.RaidenBoss.value: {ModTypeNames.Raiden.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 12, 9: 13, 10: 14, 11: 15, 12: 16, 13: 17, 14: 18, 15: 19, 16: 20, 
                                           17: 21, 18: 22, 19: 23, 20: 24, 21: 25, 22: 26, 23: 27, 24: 28, 25: 29, 26: 30, 27: 31, 28: 32, 29: 33, 30: 34, 31: 35, 
                                           32: 36, 33: 37, 34: 38, 35: 39, 36: 40, 37: 41, 38: 42, 39: 43, 40: 44, 41: 45, 42: 46, 43: 48, 44: 49, 45: 50, 46: 51,
                                           47: 52, 48: 53, 49: 54, 50: 55, 51: 56, 52: 57, 53: 58, 54: 59, 55: 60, 56: 61, 57: 62, 58: 63, 59: 64, 60: 8, 61: 9, 62: 70, 
                                           63: 93, 64: 71, 65: 94, 66: 10, 67: 11, 68: 87, 69: 110, 70: 88, 71: 111, 72: 89, 73: 112, 74: 69, 75: 75, 76: 98, 77: 76, 78: 99, 
                                           79: 77, 80: 100, 81: 84, 82: 107, 83: 85, 84: 108, 85: 86, 86: 109, 87: 78, 88: 101, 89: 79, 90: 102, 91: 80, 92: 103, 93: 92, 
                                           94: 47, 95: 81, 96: 104, 97: 82, 98: 105, 99: 83, 100: 106, 101: 115, 102: 116, 103: 117, 104: 90, 105: 113, 106: 72, 107: 95, 
                                           108: 73, 109: 96, 110: 74, 111: 97, 112: 91, 113: 114, 114: 65, 115: 67, 116: 66, 117: 68})}},
4.4: {ModTypeNames.Amber.value: {ModTypeNames.AmberCN.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 
                            17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 
                            32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 
                            48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 
                            64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77})},
      ModTypeNames.AmberCN.value: {ModTypeNames.Amber.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 
                            17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 
                            32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 
                            48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 
                            64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77})},
      ModTypeNames.Ganyu.value: {ModTypeNames.GanyuTwilight.value: VGRemap({0: 91, 1: 92, 2: 93, 3: 68, 4: 45, 5: 3, 6: 2, 7: 10, 8: 11, 9: 15, 10: 16, 11: 12, 12: 17, 13: 19, 14: 13, 15: 18, 
                                          16: 4, 17: 6, 18: 7, 19: 8, 20: 47, 21: 64, 22: 65, 23: 48, 24: 49, 25: 50, 26: 51, 27: 52, 28: 53, 29: 54, 30: 55, 
                                          31: 56, 32: 57, 33: 58, 34: 59, 35: 60, 36: 61, 37: 62, 38: 37, 39: 38, 40: 70, 41: 87, 42: 88, 43: 71, 44: 72, 45: 
                                          73, 46: 74, 47: 75, 48: 76, 49: 77, 50: 78, 51: 79, 52: 80, 53: 81, 54: 82, 55: 83, 56: 84, 57: 85, 58: 39, 59: 40, 
                                          60: 1, 61: 0, 62: 24, 63: 24, 64: 20, 65: 21, 66: 22, 67: 23, 68: 28, 69: 29, 70: 30, 71: 24, 72: 25, 73: 26, 74: 27, 
                                          75: 31, 76: 32, 77: 33, 78: 36, 79: 35, 80: 41, 81: 42, 82: 43, 83: 44, 84: 66, 85: 46, 86: 63, 87: 67, 88: 89, 89: 69, 
                                          90: 86, 91: 90, 92: 34})},
      ModTypeNames.GanyuTwilight.value: {ModTypeNames.Ganyu.value: VGRemap({0: 61, 1: 60, 2: 6, 3: 5, 4: 16, 5: 16, 6: 17, 7: 18, 8: 19, 9: 4, 10: 7, 11: 8, 12: 11, 13: 14, 14: 4, 15: 9, 16: 10, 
                                          17: 12, 18: 15, 19: 13, 20: 64, 21: 65, 22: 66, 23: 67, 24: 71, 25: 72, 26: 73, 27: 74, 28: 68, 29: 69, 30: 70, 31: 75, 
                                          32: 76, 33: 77, 34: 92, 35: 79, 36: 78, 37: 38, 38: 39, 39: 58, 40: 59, 41: 80, 42: 81, 43: 82, 44: 83, 45: 4, 46: 85, 
                                          47: 20, 48: 23, 49: 24, 50: 25, 51: 26, 52: 27, 53: 28, 54: 29, 55: 30, 56: 31, 57: 32, 58: 33, 59: 34, 60: 35, 61: 36, 
                                          62: 37, 63: 86, 64: 21, 65: 22, 66: 84, 67: 87, 68: 3, 69: 89, 70: 40, 71: 43, 72: 44, 73: 45, 74: 46, 75: 47, 76: 48, 
                                          77: 49, 78: 50, 79: 51, 80: 52, 81: 53, 82: 54, 83: 55, 84: 56, 85: 57, 86: 90, 87: 41, 88: 42, 89: 88, 90: 91, 91: 0, 92: 1, 93: 2})},
      ModTypeNames.Mona.value: {ModTypeNames.MonaCN.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 
                              18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 
                              34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 
                              50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 
                              66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 
                              82: 82, 83: 83, 84: 84, 85: 85, 86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97, 
                              98: 98, 99: 99, 100: 100, 101: 101, 102: 102, 103: 103, 104: 104, 105: 105, 106: 106})},
      ModTypeNames.MonaCN.value: {ModTypeNames.Mona.value: VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 
                              18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 
                              34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 
                              50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 
                              66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 
                              82: 82, 83: 83, 84: 84, 85: 85, 86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97, 
                              98: 98, 99: 99, 100: 100, 101: 101, 102: 102, 103: 103, 104: 104, 105: 105, 106: 106})},
      ModTypeNames.Shenhe.value: {ModTypeNames.ShenheFrostFlower.value: VGRemap({0: 106, 1: 106, 2: 106, 3: 106, 4: 0, 5: 1, 6: 81, 7: 2, 8: 3, 9: 4, 10: 5, 11: 6, 12: 7, 13: 8, 14: 9, 15: 10, 16: 11, 17: 12, 
                                            18: 13, 19: 14, 20: 15, 21: 18, 22: 19, 23: 20, 24: 21, 25: 2, 26: 2, 27: 106, 28: 4, 29: 4, 30: 106, 31: 22, 32: 22, 33: 56, 
                                            34: 56, 35: 56, 36: 56, 37: 57, 38: 57, 39: 57, 40: 57, 41: 22, 42: 25, 43: 26, 44: 27, 45: 28, 46: 29, 47: 28, 48: 29, 49: 39, 
                                            50: 40, 51: 41, 52: 42, 53: 45, 54: 46, 55: 47, 56: 48, 57: 0, 58: 1, 59: 56, 60: 57, 61: 58, 62: 59, 63: 60, 64: 61, 65: 62, 
                                            66: 63, 67: 64, 68: 65, 69: 66, 70: 67, 71: 68, 72: 69, 73: 70, 74: 71, 75: 72, 76: 73, 77: 74, 78: 75, 79: 76, 80: 77, 81: 78, 
                                            82: 79, 83: 80, 84: 81, 85: 82, 86: 83, 87: 84, 88: 85, 89: 86, 90: 87, 91: 88, 92: 89, 93: 90, 94: 91, 95: 92, 96: 93, 97: 94, 
                                            98: 95, 99: 96, 100: 97, 101: 98, 102: 99, 103: 100, 104: 101, 105: 102, 106: 103, 107: 104, 108: 105, 109: 106})},
      ModTypeNames.ShenheFrostFlower.value: {ModTypeNames.Shenhe.value: VGRemap({0: 57, 1: 58, 2: 7, 3: 8, 4: 9, 5: 10, 6: 11, 7: 12, 8: 13, 9: 14, 10: 15, 11: 16, 12: 17, 13: 18, 14: 19, 15: 20, 16: 61, 17: 61, 18: 21, 
                                            19: 22, 20: 23, 21: 24, 22: 41, 23: 109, 24: 109, 25: 42, 26: 43, 27: 44, 28: 47, 29: 48, 30: 41, 31: 82, 32: 82, 33: 62, 34: 41, 35: 105, 
                                            36: 105, 37: 85, 38: 81, 39: 49, 40: 50, 41: 51, 42: 52, 43: 57, 44: 104, 45: 53, 46: 54, 47: 55, 48: 56, 49: 58, 50: 81, 51: 104, 52: 81, 
                                            53: 57, 54: 104, 55: 58, 56: 59, 57: 60, 58: 61, 59: 62, 60: 63, 61: 64, 62: 65, 63: 66, 64: 67, 65: 68, 66: 69, 67: 70, 68: 71, 69: 72, 
                                            70: 73, 71: 74, 72: 75, 73: 76, 74: 77, 75: 78, 76: 79, 77: 80, 78: 81, 79: 82, 80: 83, 81: 84, 82: 85, 83: 86, 84: 87, 85: 88, 86: 89, 
                                            87: 90, 88: 91, 89: 92, 90: 93, 91: 94, 92: 95, 93: 96, 94: 97, 95: 98, 96: 99, 97: 100, 98: 101, 99: 102, 100: 103, 101: 104, 102: 105, 
                                            103: 106, 104: 107, 105: 108, 106: 109})},
      ModTypeNames.Xingqiu.value: {ModTypeNames.XingqiuBamboo.value: VGRemap({0: 71, 1: 72, 2: 73, 3: 48, 4: 25, 5: 0, 6: 1, 7: 25, 8: 4, 9: 2, 10: 3, 11: 50, 12: 67, 13: 68, 14: 51, 15: 52, 16: 53, 17: 54, 18: 55, 
                                            19: 56, 20: 57, 21: 58, 22: 59, 23: 60, 24: 61, 25: 62, 26: 63, 27: 64, 28: 65, 29: 67, 30: 67, 31: 67, 32: 67, 33: 67, 34: 22, 35: 23, 
                                            36: 27, 37: 44, 38: 45, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 
                                            53: 42, 54: 44, 55: 44, 56: 44, 57: 44, 58: 44, 59: 21, 60: 20, 61: 5, 62: 46, 63: 46, 64: 14, 65: 15, 66: 16, 67: 19, 68: 9, 69: 10, 
                                            70: 11, 71: 12, 72: 17, 73: 18, 74: 24, 75: 24, 76: 6, 77: 7, 78: 8, 79: 13, 80: 46, 81: 46, 82: 26, 83: 43, 84: 47, 85: 69, 86: 49, 
                                            87: 66, 88: 70, 89: 49, 90: 49, 91: 5})},
      ModTypeNames.XingqiuBamboo.value: {ModTypeNames.Xingqiu.value: VGRemap({0: 5, 1: 6, 2: 9, 3: 10, 4: 8, 5: 91, 6: 76, 7: 77, 8: 78, 9: 68, 10: 69, 11: 70, 12: 71, 13: 79, 14: 64, 15: 65, 16: 66, 17: 72, 18: 73, 
                                            19: 67, 20: 60, 21: 59, 22: 34, 23: 35, 24: 74, 25: 4, 26: 82, 27: 36, 28: 39, 29: 40, 30: 41, 31: 42, 32: 43, 33: 44, 34: 45, 35: 46, 
                                            36: 47, 37: 48, 38: 49, 39: 50, 40: 51, 41: 52, 42: 53, 43: 83, 44: 37, 45: 38, 46: 81, 47: 84, 48: 3, 49: 86, 50: 11, 51: 14, 52: 15, 
                                            53: 16, 54: 17, 55: 18, 56: 19, 57: 20, 58: 21, 59: 22, 60: 23, 61: 24, 62: 25, 63: 26, 64: 27, 65: 28, 66: 87, 67: 12, 68: 13, 69: 85, 
                                            70: 88, 71: 0, 72: 1, 73: 2})}},
4.6: {ModTypeNames.Arlecchino.value: {ModTypeNames.ArlecchinoBoss.value: VGRemap({0: 47, 1: 49, 2: 48, 3: 50, 4: 51, 5: 52, 6: 53, 7: 54, 8: 55, 9: 56, 10: 57, 11: 58, 12: 59, 13: 61, 14: 60, 15: 62, 16: 65, 17: 63, 
                                                18: 64, 19: 66, 20: 67, 21: 69, 22: 71, 23: 73, 24: 75, 25: 77, 26: 79, 27: 81, 28: 68, 29: 70, 30: 72, 31: 74, 32: 76, 33: 78, 34: 80, 
                                                35: 82, 36: 83, 37: 84, 38: 85, 39: 86, 40: 88, 41: 90, 42: 87, 43: 89, 44: 91, 45: 92, 46: 94, 47: 96, 48: 98, 49: 100, 50: 93, 51: 95, 
                                                52: 97, 53: 99, 54: 101, 55: 102, 56: 103, 57: 104, 58: 106, 59: 107, 60: 110, 61: 105, 62: 108, 63: 109, 64: 111, 65: 112, 66: 113, 
                                                67: 114, 68: 115, 69: 0, 70: 1, 71: 2, 72: 3, 73: 4, 74: 5, 75: 6, 76: 7, 77: 8, 78: 9, 79: 10, 80: 11, 81: 12, 82: 13, 83: 14, 84: 15,
                                                85: 16, 86: 17, 87: 18, 88: 19, 89: 20, 90: 21, 91: 22, 92: 23, 93: 24, 94: 25, 95: 26, 96: 27, 97: 28, 98: 29, 99: 30, 100: 31, 
                                                101: 32, 102: 33, 103: 34, 104: 35, 105: 36, 106: 37, 107: 38, 108: 39, 109: 40, 110: 41, 111: 42, 112: 43, 113: 44, 114: 45, 115: 46})},
      ModTypeNames.ArlecchinoBoss.value: {ModTypeNames.Arlecchino.value: VGRemap({0: 47, 1: 49, 2: 48, 3: 50, 4: 51, 5: 52, 6: 53, 7: 54, 8: 55, 9: 56, 10: 57, 11: 58, 12: 59, 13: 61, 14: 60, 15: 62, 16: 65, 17: 63, 
                                                18: 64, 19: 66, 20: 67, 21: 69, 22: 71, 23: 73, 24: 75, 25: 77, 26: 79, 27: 81, 28: 68, 29: 70, 30: 72, 31: 74, 32: 76, 33: 78, 34: 80, 
                                                35: 82, 36: 83, 37: 84, 38: 85, 39: 86, 40: 88, 41: 90, 42: 87, 43: 89, 44: 91, 45: 92, 46: 94, 47: 96, 48: 98, 49: 100, 50: 93, 51: 95, 
                                                52: 97, 53: 99, 54: 101, 55: 102, 56: 103, 57: 104, 58: 106, 59: 107, 60: 110, 61: 105, 62: 108, 63: 109, 64: 111, 65: 112, 66: 113, 
                                                67: 114, 68: 115, 69: 0, 70: 1, 71: 2, 72: 3, 73: 4, 74: 5, 75: 6, 76: 7, 77: 8, 78: 9, 79: 10, 80: 11, 81: 12, 82: 13, 83: 14, 84: 15,
                                                85: 16, 86: 17, 87: 18, 88: 19, 89: 20, 90: 21, 91: 22, 92: 23, 93: 24, 94: 25, 95: 26, 96: 27, 97: 28, 98: 29, 99: 30, 100: 31, 
                                                101: 32, 102: 33, 103: 34, 104: 35, 105: 36, 106: 37, 107: 38, 108: 39, 109: 40, 110: 41, 111: 42, 112: 43, 113: 44, 114: 45, 115: 46})}},
4.8: {ModTypeNames.Kirara.value: {ModTypeNames.KiraraBoots.value: VGRemap({0: 89, 1: 89, 2: 87, 3: 19, 4: 19, 5: 23, 6: 23, 7: 89, 8: 1, 9: 1, 10: 89, 11: 2, 12: 2, 13: 89, 14: 1, 15: 2, 16: 3, 17: 4, 18: 5, 19: 6, 
                                         20: 7, 21: 8, 22: 9, 23: 10, 24: 43, 25: 8, 26: 8, 27: 11, 28: 12, 29: 43, 30: 43, 31: 13, 32: 14, 33: 15, 34: 16, 35: 17, 36: 18, 37: 19, 
                                         38: 20, 39: 21, 40: 22, 41: 23, 42: 24, 43: 25, 44: 26, 45: 18, 46: 18, 47: 18, 48: 18, 49: 18, 50: 18, 51: 18, 52: 18, 53: 40, 54: 42, 
                                         55: 40, 56: 42, 57: 27, 58: 28, 59: 29, 60: 30, 61: 31, 62: 32, 63: 33, 64: 34, 65: 35, 66: 36, 67: 37, 68: 38, 69: 39, 70: 40, 71: 41, 
                                         72: 42, 73: 43, 74: 44, 75: 45, 76: 46, 77: 47, 78: 48, 79: 49, 80: 50, 81: 51, 82: 52, 83: 53, 84: 54, 85: 55, 86: 56, 87: 57, 88: 58, 
                                         89: 59, 90: 60, 91: 64, 92: 61, 93: 62, 94: 63, 95: 64, 96: 65, 97: 66, 98: 67, 99: 68, 100: 69, 101: 70, 102: 71, 103: 72, 104: 73, 
                                         105: 74, 106: 75, 107: 76, 108: 77, 109: 78, 110: 79, 111: 80, 112: 81, 113: 82, 114: 86, 115: 83, 116: 84, 117: 85, 118: 86, 119: 87, 120: 88, 121: 89})},
      ModTypeNames.KiraraBoots.value: {ModTypeNames.Kirara.value: VGRemap({0: 0, 1: 14, 2: 15, 3: 16, 4: 17, 5: 18, 6: 19, 7: 20, 8: 21, 9: 22, 10: 23, 11: 27, 12: 28, 13: 31, 14: 32, 15: 33, 16: 34, 17: 35, 18: 36, 
                                         19: 37, 20: 38, 21: 39, 22: 40, 23: 41, 24: 42, 25: 43, 26: 44, 27: 57, 28: 58, 29: 59, 30: 60, 31: 61, 32: 62, 33: 63, 34: 64, 35: 65, 
                                         36: 66, 37: 67, 38: 68, 39: 69, 40: 70, 41: 71, 42: 72, 43: 73, 44: 74, 45: 75, 46: 76, 47: 77, 48: 78, 49: 79, 50: 80, 51: 81, 52: 82, 
                                         53: 83, 54: 84, 55: 85, 56: 86, 57: 87, 58: 88, 59: 89, 60: 90, 61: 92, 62: 93, 63: 94, 64: 95, 65: 96, 66: 97, 67: 98, 68: 99, 69: 100, 
                                         70: 101, 71: 102, 72: 103, 73: 104, 74: 105, 75: 106, 76: 107, 77: 108, 78: 109, 79: 110, 80: 111, 81: 112, 82: 113, 83: 115, 84: 116, 
                                         85: 117, 86: 118, 87: 119, 88: 120, 89: 121})},
      ModTypeNames.Nilou.value: {ModTypeNames.NilouBreeze.value: VGRemap({0: 48, 1: 48, 2: 52, 3: 56, 4: 56, 5: 56, 6: 10, 7: 11, 8: 12, 9: 13, 10: 16, 11: 17, 12: 18, 13: 19, 14: 20, 
                                              15: 21, 16: 22, 17: 23, 18: 24, 19: 25, 20: 30, 21: 31, 22: 32, 23: 35, 24: 36, 25: 37, 26: 78, 27: 16, 28: 
                                              16, 29: 21, 30: 78, 31: 41, 32: 42, 33: 43, 34: 78, 35: 44, 36: 45, 37: 46, 38: 48, 39: 48, 40: 49, 41: 50, 
                                              42: 99, 43: 122, 44: 47, 45: 69, 46: 62, 47: 69, 48: 69, 49: 52, 50: 48, 51: 49, 52: 50, 53: 51, 54: 3, 55: 52, 
                                              56: 53, 57: 54, 58: 55, 59: 8, 60: 56, 61: 57, 62: 58, 63: 122, 64: 59, 65: 60, 66: 61, 67: 61, 68: 62, 69: 63, 
                                              70: 64, 71: 64, 72: 65, 73: 66, 74: 67, 75: 68, 76: 68, 77: 69, 78: 70, 79: 71, 80: 72, 81: 72, 82: 73, 83: 74, 
                                              84: 75, 85: 76, 86: 78, 87: 79, 88: 80, 89: 81, 90: 82, 91: 83, 92: 84, 93: 85, 94: 86, 95: 87, 96: 88, 97: 89, 
                                              98: 90, 99: 91, 100: 92, 101: 93, 102: 94, 103: 95, 104: 96, 105: 97, 106: 98, 107: 99, 108: 100, 109: 101, 
                                              110: 102, 111: 103, 112: 104, 113: 105, 114: 106, 115: 107, 116: 108, 117: 109, 118: 110, 119: 111, 120: 112, 
                                              121: 113, 122: 114, 123: 115, 124: 116, 125: 117, 126: 118, 127: 119, 128: 120, 129: 121, 130: 122, 131: 123, 
                                              132: 124, 133: 125, 134: 126})},
      ModTypeNames.NilouBreeze.value: {ModTypeNames.Nilou.value: VGRemap({0: 50, 1: 52, 2: 53, 3: 54, 4: 134, 5: 55, 6: 57, 7: 58, 8: 59, 9: 134, 10: 6, 11: 7, 12: 8, 13: 9, 14: 64, 15: 67, 16: 10, 17: 11, 18: 12, 19: 
                                        13, 20: 14, 21: 15, 22: 16, 23: 17, 24: 18, 25: 19, 26: 86, 27: 86, 28: 86, 29: 86, 30: 20, 31: 21, 32: 22, 33: 21, 34: 21, 35: 23, 36: 24, 
                                        37: 25, 38: 24, 39: 24, 40: 26, 41: 31, 42: 32, 43: 33, 44: 35, 45: 36, 46: 37, 47: 44, 48: 50, 49: 51, 50: 52, 51: 53, 52: 55, 53: 56, 
                                        54: 57, 55: 58, 56: 60, 57: 61, 58: 62, 59: 64, 60: 65, 61: 66, 62: 68, 63: 69, 64: 70, 65: 72, 66: 73, 67: 74, 68: 75, 69: 77, 70: 78, 
                                        71: 79, 72: 80, 73: 82, 74: 83, 75: 84, 76: 85, 77: 64, 78: 86, 79: 87, 80: 88, 81: 89, 82: 90, 83: 91, 84: 92, 85: 93, 86: 94, 87: 95, 
                                        88: 96, 89: 97, 90: 98, 91: 99, 92: 100, 93: 101, 94: 102, 95: 103, 96: 104, 97: 105, 98: 106, 99: 107, 100: 108, 101: 109, 102: 110, 
                                        103: 111, 104: 112, 105: 113, 106: 114, 107: 115, 108: 116, 109: 117, 110: 118, 111: 119, 112: 120, 113: 121, 114: 122, 115: 123, 
                                        116: 124, 117: 125, 118: 126, 119: 127, 120: 128, 121: 129, 122: 130, 123: 131, 124: 132, 125: 133, 126: 134})}},
5.3: {ModTypeNames.CherryHuTao.value: {ModTypeNames.HuTao.value: VGRemap({0: 6, 1: 6, 2: 6, 3: 6, 4: 6, 5: 6, 6: 33, 7: 33, 8: 0, 9: 20, 10: 29, 11: 101, 12: 75, 13: 0, 14: 1, 15: 10, 16: 9, 17: 19, 18: 18, 
                                        19: 17, 20: 15, 21: 16, 22: 11, 23: 0, 24: 4, 25: 28, 26: 27, 27: 25, 28: 24, 29: 23, 30: 21, 31: 22, 32: 13, 33: 3, 34: 2, 35: 41, 
                                        36: 40, 37: 33, 38: 6, 39: 6, 40: 31, 41: 33, 42: 31, 43: 33, 44: 48, 45: 50, 46: 6, 47: 31, 48: 33, 49: 31, 50: 33, 51: 42, 52: 44, 
                                        53: 56, 54: 56, 55: 56, 56: 56, 57: 58, 58: 58, 59: 58, 60: 58, 61: 37, 62: 38, 63: 39, 64: 48, 65: 34, 66: 35, 67: 36, 68: 42, 69: 33, 
                                        70: 33, 71: 33, 72: 33, 73: 33, 74: 33, 75: 70, 76: 64, 77: 32, 78: 33, 79: 6, 80: 32, 81: 33, 82: 57, 83: 57, 84: 59, 85: 59, 86: 0, 
                                        87: 72, 88: 56, 89: 103, 90: 108, 91: 96, 92: 104, 93: 100, 94: 95, 95: 105, 96: 99, 97: 94, 98: 106, 99: 97, 100: 93, 101: 107, 
                                        102: 98, 103: 92, 104: 116, 105: 67, 106: 102, 107: 41, 108: 117, 109: 66, 110: 5, 111: 73, 112: 58, 113: 77, 114: 83, 115: 91, 
                                        116: 78, 117: 87, 118: 88, 119: 79, 120: 89, 121: 90, 122: 80, 123: 84, 124: 85, 125: 81, 126: 82, 127: 86, 128: 115, 129: 61, 
                                        130: 76, 131: 40, 132: 118, 133: 60, 134: 32, 135: 31, 136: 6})},
      ModTypeNames.HuTao.value: {ModTypeNames.CherryHuTao.value: VGRemap({0: 86, 1: 14, 2: 34, 3: 33, 4: 24, 5: 110, 6: 136, 7: 86, 8: 14, 9: 16, 10: 15, 11: 22, 12: 22, 13: 32, 14: 32, 15: 20, 16: 21, 17: 19, 
                                        18: 18, 19: 17, 20: 9, 21: 30, 22: 31, 23: 29, 24: 28, 25: 27, 26: 24, 27: 26, 28: 25, 29: 10, 30: 87, 31: 135, 32: 134, 33: 37, 34: 65, 
                                        35: 66, 36: 67, 37: 61, 38: 62, 39: 63, 40: 131, 41: 107, 42: 68, 43: 131, 44: 131, 45: 111, 46: 111, 47: 131, 48: 64, 49: 107, 50: 107, 
                                        51: 87, 52: 87, 53: 107, 54: 131, 55: 107, 56: 88, 57: 83, 58: 112, 59: 85, 60: 133, 61: 129, 62: 76, 63: 76, 64: 76, 65: 76, 66: 109, 
                                        67: 105, 68: 75, 69: 75, 70: 75, 71: 75, 72: 87, 73: 111, 74: 111, 75: 12, 76: 130, 77: 113, 78: 116, 79: 119, 80: 122, 81: 125, 82: 126, 
                                        83: 114, 84: 123, 85: 124, 86: 127, 87: 117, 88: 118, 89: 120, 90: 121, 91: 115, 92: 103, 93: 100, 94: 97, 95: 94, 96: 91, 97: 99, 98: 102, 
                                        99: 96, 100: 93, 101: 11, 102: 106, 103: 89, 104: 92, 105: 95, 106: 98, 107: 101, 108: 90, 109: 69, 110: 69, 111: 70, 112: 69, 113: 69, 
                                        114: 70, 115: 128, 116: 104, 117: 108, 118: 132})},
      ModTypeNames.Xiangling.value: {ModTypeNames.XianglingCheer.value: VGRemap({0: 47, 1: 97, 2: 71, 3: 5, 4: 4, 5: 11, 6: 14, 7: 11, 8: 28, 9: 72, 10: 89, 11: 93, 12: 48, 13: 65, 14: 69, 15: 96, 16: 22, 17: 32, 
                                               18: 92, 19: 68, 20: 90, 21: 91, 22: 75, 23: 74, 24: 81, 25: 80, 26: 77, 27: 83, 28: 78, 29: 84, 30: 86, 31: 87, 32: 76, 33: 79, 
                                               34: 82, 35: 85, 36: 88, 37: 94, 38: 66, 39: 67, 40: 51, 41: 50, 42: 57, 43: 56, 44: 53, 45: 59, 46: 54, 47: 60, 48: 62, 49: 63, 
                                               50: 52, 51: 55, 52: 58, 53: 61, 54: 64, 55: 70, 56: 45, 57: 73, 58: 49, 59: 43, 60: 3, 61: 2, 62: 34, 63: 33, 64: 33, 65: 33, 
                                               66: 35, 67: 36, 68: 35, 69: 35, 70: 41, 71: 41, 72: 22, 73: 24, 74: 25, 75: 23, 76: 23})},
      ModTypeNames.XianglingCheer.value: {ModTypeNames.Xiangling.value: VGRemap({0: 65, 1: 15, 2: 61, 3: 60, 4: 4, 5: 3, 6: 38, 7: 20, 8: 0, 9: 0, 10: 0, 11: 0, 12: 7, 13: 
                                                                                 0, 14: 0, 15: 6, 16: 65, 17: 65, 18: 63, 19: 64, 20: 68, 21: 69, 22: 16, 23: 72, 24: 16, 25: 73, 
                                                                                 26: 16, 27: 17, 28: 16, 29: 17, 30: 19, 31: 18, 32: 17, 33: 65, 34: 66, 35: 65, 36: 66, 37: 38, 
                                                                                 38: 20, 39: 38, 40: 20, 41: 70, 42: 71, 43: 59, 44: 59, 45: 56, 46: 56, 47: 0, 48: 12, 49: 58, 
                                                                                 50: 41, 51: 40, 52: 50, 53: 44, 54: 46, 55: 51, 56: 43, 57: 42, 58: 52, 59: 45, 60: 47, 61: 53, 
                                                                                 62: 48, 63: 49, 64: 54, 65: 13, 66: 38, 67: 39, 68: 19, 69: 14, 70: 55, 71: 2, 72: 9, 73: 57, 
                                                                                 74: 23, 75: 22, 76: 32, 77: 26, 78: 28, 79: 33, 80: 25, 81: 24, 82: 34, 83: 27, 84: 29, 85: 35, 
                                                                                 86: 30, 87: 31, 88: 36, 89: 10, 90: 20, 91: 21, 92: 18, 93: 11, 94: 37, 95: 16, 96: 15, 97: 1})}}}


class ModDoubleDictAssets(ModMappedAssets[Dict[str, T]]):
    """
    This class inherits from :class:`ModMappedAssets`

    Class to handle retrieval of assets requiring 2 keys:

        * Assets to fix from
        * Assets to fix to

    .. note::
        This is a nested dictionary that retrieves a certain asset from:
        
        * The assets to fix from
        * The assets to fix to
        * The version of the game

    Parameters
    ----------
    repo: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, T]]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value is the content for the asset

    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the assets to fix from to the assets to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Dict[float, Dict[str, Dict[str, T]]], map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(repo, map = map)

        self._versions: Dict[str, Dict[str, Version]] = {}
        self.loadFromPreset()

    @property
    def versions(self) -> Dict[str, Version]:
        """
        The game versions available for the assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the assets to map from
        * The inner keys are the names of the assets to map to
        * The inner values are versions for the assets

        :getter: Returns all the available game versions for the assets
        :type: Dict[:class:`str`, Dict[:class:`str`, :class:`Version`]]
        """

        return self._versions

    def _updateAssetContent(self, asset1: Dict[str, T], asset2: Dict[str, T]) -> T:
        return DictTools.update(asset1, asset2)

    def loadFromPreset(self):
        super().loadFromPreset()
        self._updateVersions(self._repo)
    
    def _addVersion(self, fromAsset: str, toAsset: str, version: Union[str, float, VersionType]):
        """
        Adds a new version for a particular asset

        Parameters
        ----------
        name: :class:`str`
            The name of the asset

        version: :class:`float`
            The game version
        """

        try:
            self._versions[fromAsset]
        except KeyError:
            self._versions[fromAsset] = {}

        try:
            self._versions[fromAsset][toAsset]
        except KeyError:
            self._versions[fromAsset][toAsset] = Version()

        self._versions[fromAsset][toAsset].add(version)

    def findClosestVersion(self, fromAsset: str, toAsset: str, version: Optional[Union[str, float, VersionType]] = None, fromCache: bool = True) -> VersionType:
        """
        Finds the closest available game version from :attr:`ModStrAssets._toAssets` for a particular asset

        Parameters
        ----------
        fromAsset: :class:`str`
            The name of the asset to map from

        toAsset: :class:`str`
            The name of the asset to map to

        version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
            The game version to be searched :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will assume we want the latest version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fromCache: :class:`bool`
            Whether to use the result from the cache

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            The name for the particular asset is not found

        Returns
        -------
        `packaging.version.Version`_
            The latest game version from the assets that corresponds to the desired version 
        """
        try:
            self._versions[fromAsset][toAsset]
        except KeyError as e:
            raise KeyError(f"Asset mapping from '{fromAsset}' to '{toAsset}' not found in the available versions") from e

        result = self._versions[fromAsset][toAsset].findClosest(version, fromCache = fromCache)
        if (result is None):
            KeyError("No available versions for the asset mapping")

        return result
    
    def get(self, fromAsset: str, toAsset: str, version: Optional[float] = None) -> str:
        """
        Retrieves the corresponding vertex group remap

        Parameters
        ----------
        fromAsset: :class:`str`
            The name of the asset to map from

        toAsset: :class:`str`
            The name of the asset to map to

        version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
            The game version we want the remap to come from :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will retrieve the asset of the latest version. :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            If the corresponding asset based on the search parameters is not found
            
        Returns
        -------
        :class:`str`
            The found asset
        """

        closestVersion = self.findClosestVersion(fromAsset, toAsset, version = version)
        versionAssets = self._getVersionAssets(closestVersion, self._repo)
        result = versionAssets[fromAsset][toAsset]
        return result

    def _updateVersions(self, assets: Dict[float, Dict[str, Dict[str, VGRemap]]]):
        assetNamesToUpdate = self.fixFrom.union(self.fixTo)

        for version, versionAssets in assets.items():
            for fromAssetName in versionAssets:
                if (fromAssetName not in assetNamesToUpdate):
                    continue

                fromAssets = versionAssets[fromAssetName]
                for toAssetName in fromAssets:
                    if (toAssetName not in assetNamesToUpdate):
                        continue

                    self._addVersion(fromAssetName, toAssetName, version)


class VGRemaps(ModDoubleDictAssets[VGRemap]):
    """
    This class inherits from :class:`ModMappedAssets`

    Class to handle Vertex Group Remaps fsor a mod

    Parameters
    ----------
    repo: Optional[Dict[Union[:class:`str`, :class:`float`, `packaging.version.Version`_], Dict[:class:`str`, Dict[:class:`str`, :class:`VGRemap`]]]]
        The original source for the vertex group remaps :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The second outer key is the name of the asset to fix from
        * The inner key is the name of the asset to fix to
        * The inner value contains the vertex group remap :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, will use the default vertex group remaps provided by the software :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the assets to fix from to the assets to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Optional[Dict[Union[str, float, VersionType], Dict[str, Dict[str, VGRemap]]]] = None, map: Optional[Dict[str, Set[str]]] = None):
        if (repo is None):
            repo = VGRemapData

        super().__init__(repo, map = map)


class BufDataTypeNames(Enum):
    """
    The names of the data types within a .buf file
    """

    Float16 = "Float16"
    """
    `Half precision floating point`_ number
    """

    Float32 = "Float32"
    """
    `floating point`_ number
    """

    Int32 = "SignedInt32"
    """
    Signed integer
    """

    UInt32 = "UnsignedInt32"
    """
    Unsigned integer
    """

    UNorm8 = "UNORM8"
    """
    An 8-bit `unsigned normalized integer`_
    """


class BufElementNames(Enum):
    """
    Usual names for the elements within a .buf file
    """

    Position = "POSITION"
    """
    The coordinate of some vertex of a mod
    """

    Normal = "NORMAL"
    """
    The normal vector of some vertex of a mod
    """

    Tangent = "TANGENT"
    """
    The tangent vector of some vertex of a mod
    """

    BlendWeight = "BLENDWEIGHT"
    """
    The distribution of how much a vertex belongs to a certain vertex group
    """

    BlendIndices = "BLENDINDICES"
    """
    The vertex groups that a vertex belongs to
    """

    Colour = "COLOR"
    """
    The colour at the vertex
    """

    TextureCoordinate = "TEXCOORD"
    """
    The coordinate of the texture file that the vertex is associated with
    """


class BufFileNotRecognized(FileException):
    """
    This Class inherits from :class:`FileException`

    Exception when a Blend.buf file cannot be read

    Parameters
    ----------
    filePath: :class:`str`
        The file path to the .buf file

    fileType: :class:`str`
        The name for the type of .buf file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``Buffer``
    """
    def __init__(self, filePath: str, fileType: str = "Buffer"):
        super().__init__(f"{fileType} file format not recognized for {os.path.basename(filePath)}", path = os.path.dirname(filePath))


class BadBufData(Error):
    """
    This Class inherits from :class:`Error`

    Exception when certain bytes do not correspond to the format defined for a .buf file

    Parameters
    ----------
    fileType: :class:`str`
        The name for the type of .buf file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``Buffer``
    """

    def __init__(self, fileType: str = "Buffer"):
        super().__init__(f"Bytes do not corresponding to the defined format for a {fileType} file")


# our model objects in MVC
class Model():
    """
    Generic class used for any data models in the fix

    Parameters
    ----------
    logger: Optional[:class:`Logger`]
        The logger used to print messages to the console :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    logger: Optional[:class:`Logger`]
        The logger used to print messages to the console
    """
    def __init__(self, logger: Optional["Logger"] = None):
        self.logger = logger

    def print(self, funcName: str, *args, **kwargs):
        r"""
        Prints out output

        Parameters
        ----------
        funcName: :class:`str`
            The name of the function in the logger for printing out the output

        \*args: List[:class:`str`]
            Arguments to pass to the function in the logger

        \*\*kwargs: Dict[:class:`str`, Any]
            Keyword arguments to pass to the function in the logger

        Returns
        -------
        :class:`Any`
            The return value from running the corresponding function in the logger 
        """

        if (self.logger is not None):
            func = getattr(self.logger, funcName)
            return func(*args, **kwargs)


class File(Model):
    """
    Base class for a file
    """

    def read(self) -> Any:
        """
        Reads the data within a file        
        """
        pass


class BinaryFile(File):
    """
    This class inherits from :class:`File`

    A class to handle binary files

    Parameters
    ----------
    src: Union[:class:`str`, :class:`bytes`]
        The source file or bytes for the .buf file

    Attributes
    ----------
    src: Union[:class:`str`, :class:`bytes`]
        The source file or bytes for the .buf file
    """

    def __init__(self, src: Union[str, bytes]):
        self.src = src
        self._data = b""

    @property
    def data(self):
        """
        The bytes read in from the source

        :getter: Returns the bytes that were read
        :type: :class:`bytes`
        """

        return self._data

    def read(self) -> bytes:
        self._data = FileService.readBinary(self.src)
        return self._data


class BufType():
    """
    The base class for a type in a .buf file

    Parameters
    ----------
    name: :class:`str`
        The name of the element

    Attributes
    ----------
    name: :class:`str`
        The name of the element
    """

    def __init__(self, name: str):
        self.name = name

    def decode(self, src: bytes) -> Any:
        """
        Decode the raw bytes to the required format for the type

        .. warning::
            Please make sure the number of bytes passed into 'src' matches the size of the type

        Parameters
        ----------
        src: :class:`bytes`
            The raw bytes to decode

        Returns 
        -------
        Any
            The decoded format for the type
        """

        pass

    def encode(self, src: Any) -> bytes:
        """
        Encodes the format of the type back to raw bytes

        .. warning::
            Please make sure 'src' is within the acceptable range for the type

        Parameters
        ----------
        src: Any
            The decoded format for the type

        Returns 
        -------
        :class:`bytes`
            The encoded raw bytes
        """

        pass


class BufDataType(BufType):
    """
    This class inherits from :class:`BufType`

    The type definition for an elementary data type within a .buf file

    Parameters
    ----------
    name: :class:`str`
        The name of the element

    size: :class:`int`
        The byte size for the data type

    isBigEndian: :class:`bool`
        Whether the type is in big endian mode :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    Attributes
    ----------
    size: :class:`int`
        The byte size for the data type
    """

    def __init__(self, name: str, size: int, isBigEndian: bool = False):
        super().__init__(name)
        self.size = size
        self._endianSymbol = ""
        self.isBigEndian = isBigEndian

    @property
    def isBigEndian(self) -> bool:
        """
        The `endianness`_ for the data type

        :getter: Retrieves whether the data type is in big endian mode
        :setter: Sets the new `endianness`_ for the data type
        :type: :class:`bool`
        """

        return self._isBigEndian
    
    @isBigEndian.setter
    def isBigEndian(self, newIsBigEndian: bool):
        self._isBigEndian = newIsBigEndian
        self._endianSymbol = ">" if (self._isBigEndian) else "<"


class BufElementType(BufType):
    """
    This class inherits from :class:`BufType`

    The type definition for an element within a .buf file

    Parameters
    ----------
    name: :class:`str`
        The name of the element

    formatName: :class:`str`
        The name of the type format according to 3dmigoto

    dataTypes: List[:class:`BufDataType`]
        The data types composed within the element

    Attributes
    ----------
    formatName: :class:`str`
        The name of the type format according to 3dmigoto
    """

    def __init__(self, name: str, formatName: str, dataTypes: List[BufDataType]):
        super().__init__(name)
        self.formatName = formatName
        self.dataTypes = dataTypes

    @property
    def dataTypes(self) -> List[BufDataType]:
        """
        The data types composed within the element

        :getter: Retrieves the data types within the element
        :setter: Sets the new data types for the element
        :type: List[:class:`BufDataType`]
        """

        return self._dataTypes
    
    @dataTypes.setter
    def dataTypes(self, newDataTypes: List[BufDataType]):
        self._dataTypes = newDataTypes
        self._size = 0

        for dataType in self._dataTypes:
            self._size += dataType.size

    @property
    def size(self):
        """
        The byte size for the element

        :getter: The size of the element
        :type: :class:`int`
        """

        return self._size

    def decode(self, src: bytes) -> List[Any]:
        result = []
        byteStart = 0
        byteEnd = 0

        for dataType in self.dataTypes:
            byteEnd += dataType.size
            result.append(dataType.decode(src[byteStart: byteEnd]))
            byteStart = byteEnd

        return result
    
    def encode(self, src: List[Any]) -> bytes:
        result = b""
        minLen = min(len(self.dataTypes), len(src))

        for i in range(minLen):
            dataType = self.dataTypes[i]
            result += dataType.encode(src[i])

        return result


class BufFile(BinaryFile):
    """
    This class inherits from :class:`BinaryFile`

    A class to handle .buf files

    Parameters
    ----------
    src: Union[:class:`str`, :class:`bytes`]
        The source file or bytes for the .buf file

    elements: List[:class:`BufElementType`]
        The sequence of elements within the .buf file

    fileType: :class:`str`
        The name for the type of .buf file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``Buffer``

    Attributes
    ----------
    fileType: :class:`str`
        The name for the type of .buf file

    bytesPerLine: :class:`int`
        The number of bytes per line in the .buf file
    """

    def __init__(self, src: Union[str, bytes], elements: List[BufElementType], fileType: str = "Buffer"):
        super().__init__(src)
        self._elementsInd: Dict[str, int] = {}
        self._elementsDict: Dict[str, int] = {}
        self._bytesPerLine = 0
        self.elements = elements
        self.fileType = fileType

        self.read()

    @property
    def elements(self) -> List[BufElementType]:
        """
        The sequence of elements within the .buf file

        :getter: Retrieves the elements
        :setter: Sets the elements for the .buf file
        :type: List[:class:`BufElementType`]
        """

        return self._elements
    
    @elements.setter
    def elements(self, newElements: List[BufElementType]):
        self._elements = newElements
        self._elementsInd.clear()
        self._elementsDict.clear()
        self._bytesPerLine = 0

        elementsLen = len(self._elements)
        for i in range(elementsLen):
            element = self._elements[i]
            elementName = element.name
            elementInd = ""

            if (elementName not in self._elementsInd):
                self._elementsInd[elementName] = 0
            else:
                self._elementsInd[elementName] += 1
                elementInd = f"{self._elementsInd[elementName]}"

            self._elementsDict[f"{elementName}{elementInd}"] = i
            self._bytesPerLine += element.size

    @property
    def bytesPerLine(self):
        """
        The number of bytes per line (per vertex)

        :getter: Retrieves the number of bytes per line
        :type: :class:`int`
        """

        return self._bytesPerLine

    def isValid(self) -> bool:
        """
        Whether the size of the data is divisible by the # of bytes per line

        Returns
        -------
        :class:`bool`
            Whether the provided data for the .buf file is valid
        """

        if (len(self._data) % self.bytesPerLine != 0):
            return False
        return True

    def read(self) -> bytes:
        """
        Reads the bytes in the .buf file

        Returns
        -------
        :class:`bytes`
            The read bytes
        """

        """
        Reads the bytes in the blend.buf file

        Returns
        -------
        :class:`bytes`
            The read bytes
        """

        self._data = FileService.readBinary(self.src)
        isValid = self.isValid()

        if (not isValid and isinstance(self.src, str)):
            raise BufFileNotRecognized(self.src, fileType = self.fileType)
        elif (not isValid):
            raise BadBufData(fileType = self.fileType)

        return self._data
    
    def decodeLine(self, src: bytes) -> Dict[str, List[Any]]:
        """
        Decodes a line (a vertex) within the .buf file

        Parameters
        ----------
        src: :class:`bytes`
            The source bytes to decode

        Returns 
        -------
        Dict[:class:`str`, List[Any]]
            The decoded values for the line :raw-html:`<br />` :raw-html:`<br />`

            The keys are the names to the elements and the values are what is decoded
        """

        result = {}
        startInd = 0
        endInd = 0

        for elementName in self._elementsDict:
            elementInd = self._elementsDict[elementName]
            element = self._elements[elementInd]

            elementSize = element.size
            endInd += elementSize

            result[elementName] = element.decode(src[startInd: endInd])
            startInd = endInd

        return result
    
    def encodeLine(self, src: Dict[str, List[Any]]) -> bytes:
        """
        Encodes the data about a vertex to their corresponding bytes for the line

        Parameters
        ----------
        src: Dict[:class:`str`, List[Any]]
            The corresponding data for the vertex :raw-html:`<br />` :raw-html:`<br />`

            The keys are the names for the elements and the values are the data for the elements

        Returns 
        -------
        :class:`bytes`
            The encoded bytes for the line
        """

        result = b""

        for elementName in self._elementsDict:
            elementInd = self._elementsDict[elementName]
            element = self._elements[elementInd]

            currentSrc = src[elementName]
            result += element.encode(currentSrc)

        return result

    def fix(self, fixedFile: Optional[str] = None, filters: Optional[List[Callable[[Dict[str, List[Any]], int, int, int], Dict[str, List[Any]]]]] = None) -> Union[Optional[str], bytearray]:
        """
        Fixes the .buf file

        Parameters
        ----------
        fixedFile: Optional[:class:`str`]
            The file path for the fixed .buf file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        filters: Optional[List[Callable[[Dict[:class:`str`, List[Any]], :class:`int`, :class:`int`, :class:`int`], Dict[:class:`str`, List[Any]]]]]
            The filters to process each element :raw-html:`<br />` :raw-html:`<br />`

            The filters take in the following arguments:

            #. The data for a particular line
            #. The starting byte index of the line that is read
            #. The line index being processed
            #. The size of each line :raw-html:`<br />` :raw-html:`<br />`

            The output of the filters is the resultant data that consists where the keys are the names of the elements within a line
            in the .buf file and the values are the resultant data for each element in the line

        Raises
        ------
        :class:`BufFileNotRecognized`
            If the original .buf file provided by the :attr:`src` attribute cannot be read

        :class:`BadBufData`
            If the bytes passed into the :attr:`src` attribute do not correspond to the format defined for the .buf file

        Returns
        -------
        Union[Optional[:class:`str`], :class:`bytearray`]
            If the argument ``fixedFile`` is ``None``, then will return an array of bytes for the fixed .buf file :raw-html:`<br />` :raw-html:`<br />`
            Otherwise will return the filename to the fixed .buf file if the provided .buf file got corrected
        """

        result = bytearray()
        dataLen = len(self._data)
        for i in range(0, dataLen, self._bytesPerLine):
            decodedValues = self.decodeLine(self._data[i: i + self._bytesPerLine])
            lineInd = i / self._bytesPerLine

            for filter in filters:
                decodedValues = filter(decodedValues, i, lineInd, self._bytesPerLine)

            result += self.encodeLine(decodedValues)

        if (fixedFile is not None):
            FileService.writeBinary(fixedFile, result)
            return fixedFile

        return result


class BaseBufEditor():
    """
    Base class to edit some .buf file
    """

    def fix(self, bufFile: BufFile, fixedBufFile: str) -> Union[Optional[str], bytearray]:
        """
        Edits the binary file

        Parameters
        ----------
        bufFile: :class:`BufFile`
            The binary .buf file to be modified

        fixedBufFile: :class:`str`
            The name of the fixed .buf file

        Returns
        -------
        Union[Optional[:class:`str`], :class:`bytearray`]
            If the argument ``fixedBufFile`` is ``None``, then will return an array of bytes for the fixed .buf file :raw-html:`<br />` :raw-html:`<br />`
            Otherwise will return the filename to the fixed .buf file if the provided .buf file got corrected
        """
        pass


class BufEditor(BaseBufEditor):
    """
    This class inherits from :class:`BaseBufEditor`

    Class to edit some .buf file

    Parameters
    ----------
    filters: Optional[List[Callable[[Dict[:class:`str`, List[Any]], :class:`int`, :class:`int`, :class:`int`], Dict[:class:`str`, List[Any]]]]]
        The filters used to edit the data for each line in the .buf file :raw-html:`<br />` :raw-html:`<br />`

        The filters take in the following arguments:

        #. The data for a particular line
        #. The starting byte index of the line that is read
        #. The line index being processed
        #. The size of each line :raw-html:`<br />` :raw-html:`<br />`

        The output of the filters is the resultant data that consists where the keys are the names of the elements within a line
        in the .buf file and the values are the resultant data for each element in the line :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, filters: Optional[List[Callable[[Dict[str, List[Any]], int, int, int], Dict[str, List[Any]]]]] = None):
        super().__init__()
        self.filters = [] if (filters is None) else filters

    def fix(self, bufFile: BufFile, fixedBufFile: str) -> Union[Optional[str], bytearray]:
        return bufFile.fix(fixedFile = fixedBufFile, filters = self.filters)


# IniFixBuilderFunc: Class to define how the PositionEditor filters to edit the position.buf
#   for some mod for a particular version
class PositionEditorFuncs():
    @classmethod
    def xiangling_xianglingCheer_5_3(cls, src: Dict[str, List[Any]], startInd: int, lineInd: int, lineSize: int) -> Dict[str, List[Any]]:
        position = src[BufElementNames.Position.value]

        position[1] += 0.7755
        position[2] -= 0.0405
        return src
    
    @classmethod
    def xianglingCheer_xiangling_5_3(cls, src: Dict[str, List[Any]], startInd: int, lineInd: int, lineSize: int) -> Dict[str, List[Any]]:
        position = src[BufElementNames.Position.value]

        position[1] -= 0.7755
        position[2] += 0.0405
        return src


PositionEditorData= {
    4.0: {ModTypeNames.Amber.value: {ModTypeNames.AmberCN.value: None},
          ModTypeNames.AmberCN.value: {ModTypeNames.Amber.value: None},
          ModTypeNames.Ayaka.value: {ModTypeNames.AyakaSpringbloom.value: None},
          ModTypeNames.AyakaSpringbloom.value: {ModTypeNames.Ayaka.value: None},
          ModTypeNames.Barbara.value: {ModTypeNames.BarbaraSummertime.value: None},
          ModTypeNames.BarbaraSummertime.value: {ModTypeNames.Barbara.value: None},
          ModTypeNames.Diluc.value: {ModTypeNames.DilucFlamme.value: None},
          ModTypeNames.DilucFlamme.value: {ModTypeNames.Diluc.value: None},
          ModTypeNames.Fischl.value: {ModTypeNames.FischlHighness.value: None},
          ModTypeNames.FischlHighness.value: {ModTypeNames.Fischl.value: None},
          ModTypeNames.Jean.value: {ModTypeNames.JeanCN.value: None,
                                    ModTypeNames.JeanSea.value: None},
          ModTypeNames.JeanCN.value: {ModTypeNames.Jean.value: None,
                                      ModTypeNames.JeanSea.value: None},
          ModTypeNames.JeanSea.value: {ModTypeNames.Jean.value: None,
                                       ModTypeNames.JeanCN.value: None},
          ModTypeNames.Kaeya.value: {ModTypeNames.KaeyaSailwind.value: None},
          ModTypeNames.KaeyaSailwind.value: {ModTypeNames.Kaeya.value: None},
          ModTypeNames.Keqing.value: {ModTypeNames.KeqingOpulent.value: None},
          ModTypeNames.KeqingOpulent.value: {ModTypeNames.Keqing.value: None},
          ModTypeNames.Klee.value: {ModTypeNames.KleeBlossomingStarlight.value: None},
          ModTypeNames.KleeBlossomingStarlight.value: {ModTypeNames.Klee.value: None},
          ModTypeNames.Lisa.value: {ModTypeNames.LisaStudent.value: None},
          ModTypeNames.LisaStudent.value: {ModTypeNames.Lisa.value: None},
          ModTypeNames.Mona.value: {ModTypeNames.MonaCN.value: None},
          ModTypeNames.MonaCN.value: {ModTypeNames.Mona.value: None},
          ModTypeNames.Ningguang.value: {ModTypeNames.NingguangOrchid.value: None},
          ModTypeNames.NingguangOrchid.value: {ModTypeNames.Ningguang.value: None},
          ModTypeNames.Raiden.value: {ModTypeNames.RaidenBoss.value: None},
          ModTypeNames.RaidenBoss.value: {ModTypeNames.Raiden.value: None},
          ModTypeNames.Rosaria.value: {ModTypeNames.RosariaCN.value: None},
          ModTypeNames.RosariaCN.value: {ModTypeNames.Rosaria.value: None},
          ModTypeNames.Xingqiu.value: {ModTypeNames.XingqiuBamboo.value: None},
          ModTypeNames.XingqiuBamboo.value: {ModTypeNames.Xingqiu.value: None}},

    4.4: {ModTypeNames.Ganyu.value: {ModTypeNames.GanyuTwilight.value: None},
          ModTypeNames.GanyuTwilight.value: {ModTypeNames.Ganyu.value: None},
          ModTypeNames.Shenhe.value: {ModTypeNames.ShenheFrostFlower.value: None},
          ModTypeNames.ShenheFrostFlower.value: {ModTypeNames.Shenhe.value: None}},

    4.6: {ModTypeNames.Arlecchino.value: {ModTypeNames.ArlecchinoBoss.value: None},
          ModTypeNames.ArlecchinoBoss.value: {ModTypeNames.ArlecchinoBoss.value: None}},

    4.8: {ModTypeNames.Kirara.value: {ModTypeNames.KiraraBoots.value: None},
          ModTypeNames.KiraraBoots.value: {ModTypeNames.Kirara.value: None},
          ModTypeNames.Nilou.value: {ModTypeNames.NilouBreeze.value: None},
          ModTypeNames.NilouBreeze.value: {ModTypeNames.Nilou.value: None}},

    5.3: {ModTypeNames.CherryHuTao.value: {ModTypeNames.HuTao.value: None},
          ModTypeNames.HuTao.value: {ModTypeNames.CherryHuTao.value: None},
          ModTypeNames.Xiangling.value: {ModTypeNames.XianglingCheer.value: BufEditor(filters = [PositionEditorFuncs.xiangling_xianglingCheer_5_3])},
          ModTypeNames.XianglingCheer.value: {ModTypeNames.Xiangling.value: BufEditor(filters = [PositionEditorFuncs.xianglingCheer_xiangling_5_3])}}
}


class PositionEditors(ModDoubleDictAssets[Optional[BaseBufEditor]]):
    """
    This class inherits from :class:`ModDictAssets`
    
    Class for managing editors that edit a position.buf file

    Parameters
    ----------
    repo: Optional[Dict[Union[:class:`str`, :class:`float`, `packaging.version.Version`_], Dict[:class:`str`, Dict[:class:`str`, Optional[:class:`BaseBufEditor`]]]]]
        The original source for the vertex group remaps :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The second outer key is the name of the asset to fix from
        * The inner key is the name of the asset to fix to
        * The inner value contains the vertex group remap :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, will use the default vertex group remaps provided by the software :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the assets to fix from to the assets to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Optional[Dict[Union[str, float, VersionType], Dict[str, Dict[str, Optional[BaseBufEditor]]]]] = None, map: Optional[Dict[str, Set[str]]] = None):
        if (repo is None):
            repo = PositionEditorData

        super().__init__(repo, map = map)


class BaseIniParser():
    """
    Base class to parse a .ini file

    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to parse

    Attributes
    ----------
    _modsToFix: Set[:class:`str`]
        The name of the mods that will be fixed to

    _iniFile: :class:`IniFile`
        The .ini file that will be parsed
    """

    def __init__(self, iniFile: "IniFile"):
        self._modsToFix: Set[str] = set()
        self._iniFile = iniFile

    def clear(self):
        """
        Clears any saved data
        """
        self._modsToFix.clear()

    def parse(self):
        """
        Parses the .ini file
        """
        pass


class IniParseBuilder(Builder[BaseIniParser]):
    """
    This class inherits from :class:`Builder`

    A class to help dynamically build a :class:`BaseIniParser`

    Parameters
    ----------
    buildCls: Union[Type[:class:`BaseIniParser`], :class:`IniParseBuilderArgs`]
        Either:
        
        #. The class to construct a :class:`BaseIniFixer` OR
        #. Some provider that gives the required arguments needed for this class

    args: Optional[List[Any]]
        The constant arguments used to build the object

        .. note::
            If the :attr:`buildCls` attribute is not a class of type Type[:class:`BaseIniParser`], then
            this parameter has no effect

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object

        .. note::
            If the :attr:`buildCls` attribute is not a class of type Type[:class:`BaseIniParser`], then
            this parameter has no effect

        **Default**: ``None``

    Attributes
    ----------
    _buildCls: Optional[Type[:class:`BaseIniParser`]]
        The class for the parser, if available

    _builderArgs: Optional[:class:`IniParseBuilderArgs`]
        The provider for the arguments of this class, if available
    """

    def __init__(self, buildCls: Union[Type[BaseIniParser], "IniParseBuilderArgs"], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        super().__init__(buildCls, args, kwargs)
        
        builderArgsProvided = not isinstance(self._buildCls, type)

        self._builderArgs = buildCls if (builderArgsProvided) else None
        if (builderArgsProvided):
            self._buildCls = None

    @lru_cache(maxsize = 64)
    def _getBuilderArgs(self, modName: str, version: Optional[int] = None) -> Callable[[], Tuple[BaseIniParser, List[Any], Dict[str, Any]]]:
        builderArgsGenerator = self._builderArgs.get(modName, version = version)
        return builderArgsGenerator()

    def build(self, iniFile: "IniFile", modName: Optional[str] = None, version: Optional[int] = None) -> BaseIniParser:
        """
        Builds the parser

        Parameters
        ----------
        iniFile: :class:`IniFile`
            The .ini file to parse

        modeName: Optional[:class:`str`]
            The name of the mod to build the parser for :raw-html:`<br />` :raw-html:`<br />`

            If this argument is ``None``, then will use the mod name extracted from :attr:`IniFile.availableType`

            .. warning::
                This argument has no effect if :attr:`_buildCls` is not ``None`` 

            **Default**: ``None``

        version: Optional[:class:`int`]
            The game version to fix the mod to :raw-html:`<br />` :raw-html:`<br />`

            If this argument is ``None``, will build the parser for the latest version of the game

            .. warning::
                This argument has no effect if :attr:`_buildCls` is not ``None`` 

            **Default**: ``None``
        
        Returns
        -------
        :class:`BaseIniParser`
            The built parser
        """

        if (modName is None):
            modName = iniFile.availableType

        if (self._builderArgs is not None):
            self._buildCls, self._args, self._kwargs, = self._getBuilderArgs(modName, version = version)

        return super().build(iniFile)


class DownloadData():
    """
    Download data used by the .ini files

    Parameters
    ----------
    name: :class:`str`
        The name of the download resource in the .ini file

    download: :class:`FileDownload`
        The file download to initiate

    resourceKeys: Optional[Dict[:class:`str`, :class:`str`]]
        Any additional `KVPs`_ to add to the resource `section`_ of the download resource :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Arguments
    ---------
    name: :class:`str`
        The name of the download resource in the .ini file

    download: :class:`FileDownload`
        The file download to initiate

    resourceKeys: Dict[:class:`str`, :class:`str`]
        Any additional `KVPs`_ to add to the resource `section`_ of the download resource
    """

    def __init__(self, name: str, download: FileDownload, resourceKeys: Optional[Dict[str, str]] = None):
        self.name = name
        self.download = download
        self.resourceKeys = {} if (resourceKeys is None) else resourceKeys

    def addToPart(self, part: IfContentPart, key: str, val: str, **kwargs):
        """
        Adds a reference to the download into 'part'

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part to add the reference

        key: :class:`str`
            The key to the download reference `KVP`_

        val: :class:`str`
            The value to the download reference `KVP`_

        **kwargs:
            Any additional keyword arguments for this method
        """

        part.addKVP(key, val)

    def addToSection(self, ifTemplate: IfTemplate, key: str, val: str):
        """
        Adds a reference to the download into the 'ifTemplate'

        Parameters
        ----------
        ifTemplate: :class:`IfTemplate`
            The `section`_ to add the reference

        key: :class:`str`
            The key to the download reference `KVP`_

        val: :class:`str`
            The value to the download reference `KVP`_
        """

        ifTemplateParts = ifTemplate.parts

        if (not ifTemplateParts or not isinstance(ifTemplateParts[0], IfContentPart)):
            ifTemplateParts.insert(0, IfContentPart({key: [(0, val)]}, 0))
        else:
            ifTemplateParts[0].addKVPToFront(key, val)


class BlendDownloadData(DownloadData):
    """
    This class inherits from :class:`DownloadData`

    Blend.buf download data used by the .ini files

    Parameters
    ----------
    name: :class:`str`
        The name of the download resource in the .ini file

    download: :class:`FileDownload`
        The file download to initiate

    resourceKeys: Optional[Dict[:class:`str`, :class:`str`]]
        Any additional `KVPs`_ to add to the resource `section`_ of the download resource :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def addToPart(self, part: IfContentPart, key: str, val: str, vertexCount: int = 0, **kwargs):
        """
        Adds a reference to the download into 'part'

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part to add the reference

        key: :class:`str`
            The key to the download reference `KVP`_

        val: :class:`str`
            The value to the download reference `KVP`_

        vertexCount: :class:`int`
            The number of vertices in the model (.vb file or its .buf counterparts)

            :raw-html:`<br />`

            .. tip::
                From :class:`BlendFile`, we know that a line in a Blend.buf file for a character usually contains 32 bytes.

                Since a line in a ``Blend.buf`` file usually references a single vertex,
                You can calculate the vertex count by doing:

                .. code-block::

                    (# of bytes in the Blend.buf file) / 32 = vertexCount

        **kwargs:
            Any additional keyword arguments for this method
        """

        super().addToPart(part, key, val)
        part.addKVP(IniKeywords.Handling.value, "skip")
        part.addKVP(IniKeywords.Draw.value, f"{vertexCount},0")


class IniResourceModel():
    """
    Contains data for some particular resource in a .ini file

    Parameters
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located

    Attributes
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located
    """

    def __init__(self, iniFolderPath: str):
        self.iniFolderPath = iniFolderPath


# Needed data model to inject into the .ini file
class IniFixResourceModel(IniResourceModel):
    """
    This class inherits from :class:`IniResourceModel`

    Contains data for fixing a particular resource in a .ini file

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: for fixedPath, fixedFullPath, origPath, origFullPath in x

            Iterates over all the fixed paths to some resource within a :class:`IfContentPart`, ``x`` :raw-html:`<br />` :raw-html:`<br />`

            The tuples to iterate over are as follows:
            #. fixedPath: (:class:`str`) The path name of the fixed file
            #. fixedFullPath: (:class:`str`) The full path name to the fixed file 
            #. origPath: (Optional[:class:`str`]) The path to the orignal file, if available
            #. origFullPath: (Optional[:class:`str`]) The full path name to the original file, if available

    Parameters
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located

    fixedPaths: Dict[:class:`int`, Dict[:class:`str`, List[:class:`str`]]]
        The file paths to the fixed files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the resource file appears in the :class:`IfTemplate` for some resource
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the file paths within the :class:`IfContentPart`

    origPaths: Optional[Dict[:class:`int`, List[:class:`str`]]]
        The file paths for the resource :raw-html:`<br />` :raw-html:`<br />`
        
        * The keys are the indices to the :class:`IfContentPart` that the resource file appears in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    fixedPaths: Dict[:class:`int`, Dict[:class:`str`, List[:class:`str`]]]
        The file paths to the fixed files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the resource files appear in the :class:`IfTemplate` for some resource
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the file paths within the :class:`IfContentPart`

    origPaths: Optional[Dict[:class:`int`, List[:class:`str`]]]
        The file paths to the files for the resource :raw-html:`<br />` :raw-html:`<br />`
        
        * The keys are the indices to the :class:`IfContentPart` that the files appear in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`

    fullPaths: Dict[:class:`int`, Dict[:class:`str`, List[:class:`str`]]]
        The absolute paths to the fixed resource files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the files appear in the :class:`IfTemplate` for some resource
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the file paths within the :class:`IfContentPart`

    origFullPaths: Dict[:class:`int`, List[:class:`str`]]
        The absolute paths to the files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` that the resource files appear in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`
    """

    def __init__(self, iniFolderPath: str, fixedPaths: Dict[int, Dict[str, List[str]]], origPaths: Optional[Dict[int, List[str]]] = None):
        super().__init__(iniFolderPath)
        self.fixedPaths = fixedPaths
        self.origPaths = origPaths

        self.fullPaths = {}
        self.origFullPaths = {}

        # retrieve the absolute paths
        for partIndex, partPaths in self.fixedPaths.items():
            try:
                self.fullPaths[partIndex]
            except KeyError:
                self.fullPaths[partIndex] = {}

            for modName, paths in partPaths.items():
                self.fullPaths[partIndex][modName] = list(map(lambda path: FileService.absPathOfRelPath(path, iniFolderPath), paths))

        if (self.origPaths is not None):
            for partIndex in self.origPaths:
                paths = self.origPaths[partIndex]
                self.origFullPaths[partIndex] = list(map(lambda path: FileService.absPathOfRelPath(path, iniFolderPath), paths))


    def __iter__(self):
        for ifTemplateInd in self.fixedPaths:
            modPaths = self.fixedPaths[ifTemplateInd]

            for modName in modPaths:
                partPaths = modPaths[modName]
                partPathsLen = len(partPaths)

                for i in range(partPathsLen):
                    fixedPath = self.fixedPaths[ifTemplateInd][modName][i]
                    fullPath = self.fullPaths[ifTemplateInd][modName][i]
                    origPath = None
                    origFullPath = None

                    if (self.origPaths is not None):
                        try:
                            origPath = self.origPaths[ifTemplateInd][i]
                            origFullPath = self.origFullPaths[ifTemplateInd][i]
                        except KeyError:
                            pass

                    yield (fixedPath, fullPath, origPath, origFullPath)

    def clear(self):
        """
        Clears out all the path data stored
        """

        self.fixedPaths.clear()
        self.fullPaths.clear()
        self.origFullPaths.clear()

        if (self.origPaths is not None):
            self.origPaths.clear()


class GIMIParser(BaseIniParser):
    """
    This class inherits from :class:`BaseIniParser`

    Parses a .ini file used by a GIMI related importer

    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to parse

    bufDownloads: Optional[Dict[:class:`str`, Dict[:class:`str`, :class:`DownloadData`]]]
        The .buf files to download if the mod is missing some required .buf files :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the type of buffer. The available names are: :attr:`IniKeywords.Blend`.value, :attr:`IniKeywords.Position`.value and :attr:`IniKeywords.Texcoord`.value
        * The inner keys are the names of the registers

         :raw-html:`<br />` :raw-html:`<br />`

        eg. :raw-html:`<br />`

        .. code-block::

            {IniKeywords.Position.value: {"vb0": ("Position", FileDownload("someServer.com/Position.buf", "Position.buf", {"type": "buffer", "stride": "40"}))}, 
             IniKeywords.Blend.value: {"vb1": ("Blend", FileDownload("someServer.com/Blender.buf", "Blend.buf", {})), "vb999": ("NonExistantBlend", FileDownload("someServer.com/NonExistentBlend.buf", "fakeBlend.buf", {"type": "fakenews"}))}, 
             IniKeywords.Texcoord.value: {"ps-t0": ("Texcoord", FileDownload("someServer.com/texcoord.buf", "textensor.buf", {"model": "resnet50"}))}} 

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    blendCommandsGraph: :class:`IniSectionGraph`
        All the `sections`_ that are called by the ``[TextureOverride.*Blend.*]`` section.

    blendResourceCommandsGraph: :class:`IniSectionGraph`
        All the related `sections`_ to the ``[Resource.*Blend.*]`` `sections`_ that are used by `sections`_ related to the ``[TextureOverride.*Blend.*]`` sections.
        The keys are the name of the `sections`_.

    positionCommandsGraph: :class:`IniSectionGraph`
        All the `sections`_ called by the ``[TextureOverride.*Position.*]`` section.

    positionResourceCommandsGraph: :class:`IniSectionGraph`
        All the related `sections`_ to the ``[Resource.*Position.*]`` `sections`_ that are used by `sections`_ related to the ``[TextureOverride.*Position.*]`` sections.
        The keys are the name of the `sections`_

    texcoordCommandsGraph: :class:`IniSectionGraph`
        All the `sections`_ that use some ``[Resource.*Texcoord.*]`` section.

    otherHashIndexCommandsGraph: :class:`IniSectionGraph`
        All the `sections`_ that do not belong in the above section graphs and contains the target hashes/indices that need to be replaced

    _sectionRoots: Dict[:class:`str`, List[:class:`str`]]
        The names of the `sections`_ that are the root nodes to a particular group of `sections`_ in the
        `section`_ caller/callee `graph`_  :raw-html:`<br />` :raw-html:`<br />`par

        The keys are the ids for a particular group of `sections`_ and the values are the root `section`_ names for that group

    bufDownloads: Dict[:class:`str`, Dict[:class:`str`, :class:`DownloadData`]]
        The .buf files to download if the mod is missing some required .buf files :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the type of buffer. The available names are: :attr:`IniKeywords.Blend`.value, :attr:`IniKeywords.Position`.value and :attr:`IniKeywords.Texcoord`.value
        * The inner keys are the names of the registers
    """

    TextureOverrideKey = "textureoverride"

    def __init__(self, iniFile: "IniFile", bufDownloads: Optional[Dict[str, Dict[str, DownloadData]]] = None):
        super().__init__(iniFile)
        self.bufDownloads = {} if bufDownloads is None else bufDownloads
        self.blendCommandsGraph = IniSectionGraph(set(), {})
        self.otherHashIndexCommandsGraph = IniSectionGraph(set(), {})
        self.blendResourceCommandsGraph = IniSectionGraph(set(), {})
        self.positionCommandsGraph = IniSectionGraph(set(), {})
        self.positionResourceCommandsGraph = IniSectionGraph(set(), {})
        self.texcoordCommandsGraph = IniSectionGraph(set(), {})
        self.ibCommandsGraph = IniSectionGraph(set(), {})
        self._sectionRoots: Dict[str, List[str]] = {}

        self._positionEditModsToFix: Set[str] = set()
        self._bufDownloadParts: Dict [str, Dict[str, Set[IfContentPart]]] = {}
        self._bufReferencedDownloadNames: Dict[str, Dict[str, str]] = {}
        self._fixIdsWithDownloadsAdded: Set[int] = set()

    def clearParseDownloadSearch(self):
        self._bufDownloadParts.clear()

    def clearParseTempData(self):
        self.clearParseDownloadSearch()

    def clear(self):
        super().clear()
        self.blendCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self.otherHashIndexCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self.blendResourceCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self.positionCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self.positionResourceCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self.texcoordCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self.ibCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self._sectionRoots.clear()

        self._positionEditModsToFix.clear()
        self._downloadsAdded = False
        self._bufReferencedDownloadNames.clear()
        self.clearParseTempData()

    # _getCommonMods(): Retrieves the common mods that need to be fixed between all target graphs
    #   that are used for the fix
    def _getCommonMods(self) -> Set[str]:
        modType = self._iniFile.type
        if (modType is None):
            return set()
        
        result = set()
        hashes = modType.hashes
        indices = modType.indices

        graphs = [self.blendCommandsGraph, self.otherHashIndexCommandsGraph, self.blendResourceCommandsGraph, 
                  self.positionCommandsGraph, self.positionResourceCommandsGraph,
                  self.texcoordCommandsGraph]

        for graph in graphs:
            commonMods = graph.getCommonMods(hashes, indices, version = self._iniFile.version)
            if (not result):
                result = commonMods
            elif (commonMods):
                result = result.intersection(commonMods)

        return result
    
    def _setToFix(self) -> Set[str]:
        """
        Sets the names for the types of mods that will used in the fix

        Returns
        -------
        Set[:class:`str`]
            The names of the mods that will be used in the fix        
        """

        commonMods = self._getCommonMods()
        toFix = commonMods
        iniModsToFix = self._iniFile.modsToFix
        if (iniModsToFix):
            toFix = toFix.intersection(iniModsToFix)

        type = self._iniFile.availableType

        if (not toFix and type is not None):
            self._modsToFix = type.getModsToFix()
        elif (not toFix):
            self._modsToFix = commonMods
        else:
            self._modsToFix = toFix

        return self._modsToFix
    
    # _makeRemapNames(): Makes the required names used for the fix
    def _makeRemapNames(self):
        self.blendCommandsGraph.getRemapNames(self._modsToFix)
        self.positionCommandsGraph.getRemapNames(self._modsToFix)
        self.texcoordCommandsGraph.getRemapNames(self._modsToFix)
        self.otherHashIndexCommandsGraph.getRemapNames(self._modsToFix)
        self.blendResourceCommandsGraph.getRemapNames(self._modsToFix)
        self.ibCommandsGraph.getRemapNames(self._modsToFix)

        if (self._positionEditModsToFix):
            self.positionResourceCommandsGraph.getRemapNames(self._positionEditModsToFix)

    def _makeRemapModels(self, result: Dict[str, IniFixResourceModel], resourceGraph: IniSectionGraph, getFixedFile: Optional[Callable[[str], str]] = None,
                         modsToFix: Optional[Set[str]] = None):
        """
        Creates all the data needed for fixing the ``[Resource.*Blend.*]`` `sections`_ in the .ini file

        Parameters
        ----------
        result: Dict[:class:`str`, :class:`IniResourceModel`]
            The result to store the data for fixing the resource `sections`_ :raw-html:`<br />` :raw-html:`<br />`

            The keys are the original names for the resource `sections`_ and the values are the required data for fixing the `sections`_

        resourceGraph: :class:`IniSectionGraph`
            The graph of `sections`_ for the resources

        getFixedFile: Optional[Callable[[:class:`str`], :class:`str`]]
            The function for transforming the file path of a found .*Blend.buf file into a .*RemapBlend.buf file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :meth:`IniFile.getFixedBlendFile` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        modsToFix: Optional[Set[:class:`str`]]
            The mods to fix :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :attr:`_modsToFix` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (modsToFix is None):
            modsToFix = self._modsToFix

        resourceCommands = resourceGraph.sections
        for resourceKey in resourceCommands:
            resourceIftemplate = resourceCommands[resourceKey]
            remapBlendModel = self._iniFile.makeFixResourceModel(resourceIftemplate, toFix = modsToFix, getFixedFile = getFixedFile)
            result[resourceKey] = remapBlendModel
    
    def _getSectionRoots(self):
        """
        Retrieves the root `sections`_ names that correspond to a either 
        ``TextureOverride.*Blend`` or ``TextureOverride.*Position``
        """

        remapKey = IniKeywords.Remap.value.lower()
        ibKey = IniKeywords.Ib.value.lower()

        if (not GlobalClassifiers.IniModelParts.value.isSetup):
            GlobalClassifiers.IniModelParts.value.setup({
                IniKeywords.Blend.value.lower(): IniKeywords.Blend.value,
                IniKeywords.Position.value.lower(): IniKeywords.Position.value,
                IniKeywords.Texcoord.value.lower(): IniKeywords.Texcoord.value,
                ibKey: IniKeywords.Ib.value,
                remapKey: None
            })

        sectionRootKeys = [IniKeywords.Blend.value, IniKeywords.Position.value, 
                           IniKeywords.Texcoord.value, IniKeywords.Ib.value]
        
        for key in sectionRootKeys:
            if (key not in self._sectionRoots):
                self._sectionRoots[key] = []

        textureOverrideKeyLen = len(self.TextureOverrideKey)
        for sectionName in self._iniFile.sectionIfTemplates:
            cleanedSectionName = sectionName.lower().strip()
            if (not cleanedSectionName.startswith(self.TextureOverrideKey)):
                continue

            cleanedSectionName = cleanedSectionName[textureOverrideKeyLen:]
            sectionKeySearch = GlobalClassifiers.IniModelParts.value.dfa.getAll(cleanedSectionName)

            if (not sectionKeySearch or remapKey in sectionKeySearch):
                continue

            key = DictTools.getFirstValue(sectionKeySearch)
            
            # Since IB is a very short substring, there may be a case where a mod's name contains the substring 'ib' instead
            if (key == IniKeywords.Ib.value and not cleanedSectionName.endswith(ibKey)):
                continue

            self._sectionRoots[key].append(sectionName)

    # _parseElementCommands(roots, commandsGraph): Parses the commands for particular element
    def _parseElementCommands(self, roots: Set[str], commandsGraph: IniSectionGraph):
        commandsGraph.build(newTargetSections = roots, newAllSections = self._iniFile.sectionIfTemplates)

    # _parseElementResources(commandsGraph, resourceGraph, isIfTemplateResource, getIfTemplateResource):
    #   Parses the resources for a particular element
    def _parseElementResources(self, commandsGraph: IniSectionGraph, resourceGraph: IniSectionGraph, isIfTemplateResource: Callable[[IfContentPart], Any], getIfTemplateResource: Callable[[IfContentPart], str]):
        resources = set()
        self._iniFile.getResources(commandsGraph, isIfTemplateResource, getIfTemplateResource, lambda resource, part: resources.update(resource))

        # sort the resources
        resourceCommandLst = list(map(lambda resourceName: (resourceName, self._iniFile.getMergedResourceIndex(resourceName)), resources))
        resourceCommandLst.sort(key = cmp_to_key(self._iniFile.compareResources))
        resourceCommandLst = list(map(lambda resourceTuple: resourceTuple[0], resourceCommandLst))

        # keep track of all the subcommands that the resources call
        resourceGraph.build(newTargetSections = resourceCommandLst, newAllSections = self._iniFile.sectionIfTemplates)

    # _parseBlend(): Parses all the blend command sections
    def _parseBlendCommands(self):
        blendRoots = self._sectionRoots[IniKeywords.Blend.value]
        if (blendRoots):
            self._parseElementCommands(blendRoots, self.blendCommandsGraph)

    # _parsePositionCommands(): Parses the position command sections
    def _parsePositionCommands(self):
        positionRoots = self._sectionRoots[IniKeywords.Position.value]
        if (not positionRoots):
            return
        
        type = self._iniFile.availableType
        positionModsToFix = type.positionEditors.fixTo

        iniModsToFix = self._iniFile.modsToFix
        if (iniModsToFix):
            positionModsToFix = positionModsToFix.intersection(iniModsToFix)

        for modToFix in positionModsToFix:
            positionEditor = type.getPositionEditor(modToFix, version = self._iniFile.version)
            if (positionEditor is not None):
                self._positionEditModsToFix.add(modToFix)

        positionDownloads = self.bufDownloads.get(IniKeywords.Position.value, {})
        if (not self._positionEditModsToFix and not positionDownloads):
            return

        self._parseElementCommands(positionRoots, self.positionCommandsGraph)

    # _parseTexcoordCommands(): Parses the texcoord command sections
    def _parseTexcoordCommands(self):
        texCoordRoots = self._sectionRoots[IniKeywords.Texcoord.value]
        if (not texCoordRoots):
            return
        
        texcoordDownloads = self.bufDownloads.get(IniKeywords.Texcoord.value, {})
        if (not texcoordDownloads):
            return

        self._parseElementCommands(texCoordRoots, self.texcoordCommandsGraph)

    # _parseIbCommands(): Parses the index buffer command sections
    def _parseIbCommands(self):
        ibRoots = self._sectionRoots[IniKeywords.Ib.value]
        if (not ibRoots):
            return
        
        self._parseElementCommands(ibRoots, self.ibCommandsGraph)

    # _getTargetHashAndIndexSections(): Retrieves the sections with target hashes and indices
    def _getTargetHashAndIndexSections(self) -> Dict[str, IfTemplate]:
        notIncludeCommandNames = set()
        graphsToNotInclude = [self.blendCommandsGraph, self.positionCommandsGraph, self.texcoordCommandsGraph, self.ibCommandsGraph]
        
        for graph in graphsToNotInclude:
            notIncludeCommandNames.update(set(graph.sections.keys()))

        return self._iniFile.getTargetHashAndIndexSections(notIncludeCommandNames)

    def parseCommands(self):
        """
        Parses particular command `sections`_ within the mod
        """

        self._parseBlendCommands()
        self._parsePositionCommands()
        self._parseTexcoordCommands()
        self._parseIbCommands()

        # build the DFS forest for the other sections that contain target hashes/indices that are not part of the blend commands
        hashIndexSections = self._getTargetHashAndIndexSections()
        hashIndexSections = list(hashIndexSections.keys())

        self.otherHashIndexCommandsGraph.build(newTargetSections = hashIndexSections, newAllSections= self._iniFile.sectionIfTemplates)

    def parseResources(self):
        """
        Parses particular resource `sections`_ within the mod

        .. note::
            Needs :meth:`parseCommands` to be ran first, otherwise no resources will be parsed
        """

        self._parseElementResources(self.blendCommandsGraph, self.blendResourceCommandsGraph, 
                                    lambda part: IniKeywords.Vb1.value in part, 
                                    lambda part: set(map(lambda resourceData: resourceData[1], part.get(IniKeywords.Vb1.value, set()))))
        
        if (self._positionEditModsToFix):
            self._parseElementResources(self.positionCommandsGraph, self.positionResourceCommandsGraph,
                                        lambda part: IniKeywords.Vb0.value in part,
                                        lambda part: set(map(lambda resourceData: resourceData[1], part.get(IniKeywords.Vb0.value, set()))))

    def makeRemapData(self):
        """
        Creates any required remap internal data required by the fix
        """

        self._setToFix()
        self._makeRemapNames()
        self._makeRemapModels(self._iniFile.remapBlendModels, self.blendResourceCommandsGraph, getFixedFile = self._iniFile.getFixedBlendFile)

        if (self._positionEditModsToFix):
            self._makeRemapModels(self._iniFile.remapPositionModels, self.positionResourceCommandsGraph, getFixedFile = self._iniFile.getFixedPositionFile, modsToFix = self._positionEditModsToFix)

    def parse(self):
        self._getSectionRoots()

        self.blendCommandsGraph.remapNameFunc = self._iniFile.getRemapBlendName
        self.otherHashIndexCommandsGraph.remapNameFunc = self._iniFile.getRemapFixName
        self.blendResourceCommandsGraph.remapNameFunc = self._iniFile.getRemapBlendResourceName
        self.positionCommandsGraph.remapNameFunc = self._iniFile.getRemapPositionName
        self.positionResourceCommandsGraph.remapNameFunc = self._iniFile.getRemapPositionResourceName
        self.texcoordCommandsGraph.remapNameFunc = self._iniFile.getRemapTexcoordName
        self.ibCommandsGraph.remapNameFunc = self._iniFile.getRemapIbName

        self.parseCommands()
        self.setupDownloads(cleanup = False)
        self.parseResources()
        self.makeRemapData()

        self.clearParseTempData()

    def _getBufDownloads(self, sectionGraph: IniSectionGraph, bufKey: str) -> bool:
        downloads = self.bufDownloads.get(bufKey, None)
        if (downloads is None):
            return False
        
        bufDownloadParts = self._bufDownloadParts.get(bufKey)
        if (bufDownloadParts is None):
            bufDownloadParts = {}
            self._bufDownloadParts[bufKey] = bufDownloadParts

        hasDownloadsNeeded = False
        for reg in downloads:
            result = set()
            sectionMissingParts = sectionGraph.targetsGetKeyMissingParts(reg)
            for sectionName in sectionMissingParts:
                result.update(sectionMissingParts[sectionName])

            bufDownloadParts[reg] = result

            if (not hasDownloadsNeeded and result):
                hasDownloadsNeeded = True

        return hasDownloadsNeeded

    # getDownloads(): Retrieve the particular sections or parts of sections that require a file download
    def getDownloads(self, downloadMode: Optional[DownloadMode] = None):
        self._bufDownloadParts.clear()

        if (downloadMode is None):
            downloadMode = self._iniFile.downloadMode

        skippedModes = {DownloadMode.Disabled, DownloadMode.Tex, DownloadMode.AlwaysTex, DownloadMode.HardTexDriven, downloadMode.HardTexDrivenAll}
        alwaysDLModes = {DownloadMode.Always, DownloadMode.AlwaysBuf}

        if (downloadMode in skippedModes):
            return
        elif (downloadMode in alwaysDLModes):
            self.normalizeSections(self.blendCommandsGraph)
            self.normalizeSections(self.positionCommandsGraph)
            self.normalizeSections(self.texcoordCommandsGraph)
            self.normalizeSections(self.ibCommandsGraph)
        
        hasBufDownloads = False
        hasBufDownloads |= self._getBufDownloads(self.blendCommandsGraph, IniKeywords.Blend.value)
        hasBufDownloads |= self._getBufDownloads(self.positionCommandsGraph, IniKeywords.Position.value)
        hasBufDownloads |= self._getBufDownloads(self.texcoordCommandsGraph, IniKeywords.Texcoord.value)

        if (hasBufDownloads):
            sectionMissingParts = self.ibCommandsGraph.targetsGetKeyMissingParts(IniKeywords.Handling.value)

            ibMissingParts = set()
            self._bufDownloadParts[IniKeywords.Ib.value] = {}
            self._bufDownloadParts[IniKeywords.Ib.value][IniKeywords.Handling.value] = ibMissingParts

            for sectionName in sectionMissingParts:
                ibMissingParts.update(sectionMissingParts[sectionName])
    
    # _makeDownloadResourceIfTemplate(downloadname, modName, modObj, downloadFileBaseName, sectionName, downloadKvps): Creates the ifTemplate for a downloaded file
    def _makeDownloadResourceIfTemplate(self, downloadName: str, modName: str, modObj: str, downloadFileBaseName: str, sectionName: Optional[str] = None, downloadKvps: Optional[Dict[str, str]] = None):
        if (sectionName is None):
            sectionName = self._iniFile.getRemapDLResourceName(f"{modObj}{downloadName}", modName = modName)

        contentPart = IfContentPart({}, 0)
        if (downloadKvps is not None):
            for key in downloadKvps:
                val = downloadKvps[key]
                contentPart.addKVP(key, val)

        contentPart.addKVP("filename", downloadFileBaseName)
        return IfTemplate([contentPart], name = sectionName)
    
    def _addBufDownloads(self, bufKey: str, modTypeName: str, modType: Optional["ModType"] = None):
        bufDownloadParts = self._bufDownloadParts.get(bufKey, {})
        bufDownloads = self.bufDownloads.get(bufKey, {})

        if (not bufDownloadParts and not bufDownloads):
            return
        
        bufDownloadNames = None
        vertexCount = -1 if (modType is None) else modType.getVertexCount(version = self._iniFile.version)

        for reg in bufDownloadParts:
            regDownloadParts = bufDownloadParts[reg]
            if (not regDownloadParts):
                continue

            downloadData = bufDownloads[reg]
            sectionName = self._iniFile.getRemapDLResourceName(f"{TextTools.capitalize(modTypeName)}{downloadData.name}")

            ifTemplate = self._makeDownloadResourceIfTemplate(downloadData.name, modTypeName, "", downloadData.download.filename, sectionName = sectionName, downloadKvps = downloadData.resourceKeys)
            self._iniFile.sectionIfTemplates[sectionName] = ifTemplate
            self._iniFile.fileDownloadModels[sectionName] = self._iniFile.makeDLModel(ifTemplate, downloadData.download)

            for part in regDownloadParts:
                downloadData.addToPart(part, reg, sectionName, vertexCount = vertexCount)

            if (bufDownloadNames is None):
                bufDownloadNames = self._bufReferencedDownloadNames.get(bufKey)

            if (bufDownloadNames is None):
                bufDownloadNames = {}
                self._bufReferencedDownloadNames[bufKey] = bufDownloadNames

            bufDownloadNames[reg] = sectionName

    # addDownloads(): Adds the required download resources to the corresponding sections and their parts
    def addDownloads(self):
        modType = self._iniFile.availableType
        modTypeName = "" if (modType is None) else modType.name

        self._addBufDownloads(IniKeywords.Blend.value, modTypeName, modType = modType)
        self._addBufDownloads(IniKeywords.Position.value, modTypeName, modType = modType)
        self._addBufDownloads(IniKeywords.Texcoord.value, modTypeName, modType = modType)

        ibBufDownloadParts = None
        try:
            ibBufDownloadParts = self._bufDownloadParts[IniKeywords.Ib.value][IniKeywords.Handling.value]
        except KeyError:
            return

        for part in ibBufDownloadParts:
            part.addKVP(IniKeywords.Handling.value, "skip")
            part.addKVP(IniKeywords.DrawIndexed.value, "auto")

    def normalizeSections(self, sectionGraph: IniSectionGraph):
        """
        Normalize all the referenced `sections`_ within 'sectionGraph' to follow the branching
        structure described at :class:`IfTemplateNormTree`

        Parameters
        ----------
        sectionGraph: :class:`IniSectionGraph`
            The graph holding all the referenced sections
        """

        sections = sectionGraph.sections
        for sectionName in sections:
            sections[sectionName].normalize()

    def setupDownloads(self, cleanup: bool = True):
        """
        Setup the required downloads resources, if not already setup

        cleanup: :class:`bool`
            Whether to cleanup any temporary results from this method

            **Default**: ``True``
        """

        if (self._iniFile.downloadMode == DownloadMode.Disabled and not self._downloadsAdded):
            self._downloadsAdded = True
            return

        if (not self._downloadsAdded):
            self._downloadsAdded = True
            self.getDownloads()
            self.addDownloads()

            if (cleanup):
                self.clearParseDownloadSearch()

    def hasDownloads(self) -> bool:
        """
        Whether there are required downloads needed to be added

        .. note::
            requires :meth:`setupDownloads` to be ran first

        Returns
        -------
        :class:`bool`
            Whether downloads are needed to be added
        """

        return bool(self._bufReferencedDownloadNames)


class NoModType(Error):
    """
    This Class inherits from :class:`Error`

    Exception when trying to fix a mod of some unidentified mod type

    Parameters
    ----------
    type: :class:`str`
        The name for the type of mod specified 
    """

    def __init__(self):
        super().__init__(f"No mod type specified when fixing the .ini file")


class BaseIniFixer():
    """
    Base class to fix a .ini file

    Parameters
    ----------
    parser: :class:`BaseIniParser`
        The associated parser to retrieve data for the fix

    Attributes
    ----------
    _parser: :class:`BaseIniParser`
        The associated parser to retrieve data for the fix

    _iniFile: :class:`IniFile`
        The .ini file that will be fixed
    """

    def __init__(self, parser: BaseIniParser):
        self._parser = parser
        self._iniFile = parser._iniFile
        self._fixId = 0

    def clear(self):
        """
        Resets any saved states within the fixer
        """

        self._fixId

    # _getAssetReplacement(assset, assetRepoAttName, notFoundStr): Retrieves the replacement for 'asset'
    def _getAssetReplacement(self, asset: str, assetRepoAttName: str, modName: str, notFoundVal: Any = None) -> Union[str, Any]:
        """
        Retrieves the replacement for 'asset'

        Parameters
        ----------
        asset: :class:`str`
            The asset to be replaced

        assetRepoAttName: :class:`str`
            The name of the :class:`ModIdAssets` repo in :meth:`IniFile.availableType`

        modName: :class:`str`
            The name of the mod we want the replacement for

        notFoundVal: Any
            The value to be returns if the replacement is not found :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Union[:class:`str`, Any]
            The found replacement asset or the value from 'notFoundVal' if the replacement was not found
        """

        result = ""
        type = self._iniFile.availableType

        if (type is not None):
            assetRepo = getattr(type, assetRepoAttName)
            result = assetRepo.replace(asset, version = self._iniFile.version, toAssets = modName)
        else:
            raise NoModType()

        if (result is None):
            return notFoundVal
        return result

    def _getAsset(self, assetType: str, assetRepoAttName: str, modName: str, notFoundVal: Any = None) -> Union[str, Any]:
        """
        Retrieves the corresponding asset

        Parameters
        ----------
        assetType: :class:`str`
            The name for the type of asset to retrieve

        assetRepoAttName: :class:`str`
            The name of the :class:`ModIdAssets` repo in :meth:`IniFile.availableType`

        modName: :class:`str`
            The name of the mod we want the asset for

        notFoundVal: Any
            The value to be returned if the replacement is not found :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Union[:class:`str`, Any]
            The found asset or the value from 'notFoundVal' if the asset was not found
        """

        result = ""
        type = self._iniFile.availableType

        if (type is not None):
            assetRepo = getattr(type, assetRepoAttName)

            try:
                result = assetRepo.get(modName, assetType, version = self._iniFile.version)
            except:
                result = notFoundVal
        else:
            raise NoModType()

        return result

    # _getHashReplacement(hash): Retrieves the hash replacement for 'hash'
    def _getHashReplacement(self, hash: str, modName: str) -> str:
        """
        Retrieves the replacement for 'hash'

        Parameters
        ----------
        hash: :class:`str`
            The hash to be replaced

        modName: :class:`str`
            The name of the mod we want the replacement for

        Returns
        -------
        :class:`str`
            The corresponding replacement for the hash or "HashNotFound" if there are not replacements
        """

        return self._getAssetReplacement(hash, "hashes", modName, notFoundVal = IniKeywords.HashNotFound.value)
    
    # _getIndexReplacement(index): Retrieves the index replacement for 'index'
    def _getIndexReplacement(self, index: str, modName: str) -> str:
        """
        Retrieves the replacement for 'index'

        Parameters
        ----------
        index: :class:`str`
            The index to be replaced

        modName: :class:`str`
            The name of the mod we want the replacement for

        Returns
        -------
        :class:`str`
            The corresponding replacement for the index or "IndexNotFound" if there are not replacements
        """

        return self._getAssetReplacement(index, "indices", modName, notFoundVal = IniKeywords.IndexNotFound.value)
    
    def _getHash(self, hashType: str, modName: str) -> str:
        """
        Retrieves the corresponding hash

        Parameters 
        ----------
        hashType: :class:`str`
            The name for the type of hash to retrieve

        modName: :class:`str`
            The name for the type of mod to get the hash from

        Returns
        -------
        :class:`str`
            The found hash or "HashNotFound" if the corresponding hash is not found        
        """

        return self._getAsset(hashType, "hashes", modName, notFoundVal = IniKeywords.HashNotFound.value)
    
    def _getIndex(self, indexType: str, modName: str) -> str:
        """
        Retrieves the corresponding index

        Parameters 
        ----------
        indexType: :class:`str`
            The name for the type of index to retrieve

        modName: :class:`str`
            The name for the type of mod to get the index from

        Returns
        -------
        :class:`str`
            The found index or "IndexNotFound" if the corresponding index is not found     
        """

        return self._getAsset(indexType, "indices", modName, notFoundVal = IniKeywords.IndexNotFound.value)

    # _getRemapName(sectionName, modName, sectionGraph, remapNameFunc): Retrieves the required remap name for the fix
    def _getRemapName(self, sectionName: str, modName: str, sectionGraph: Optional[IniSectionGraph] = None, remapNameFunc: Optional[Callable[[str, str], str]] = None) -> str:
        error = False
        if (sectionGraph is None):
            error = True

        if (not error):
            try:
                return sectionGraph.remapNames[sectionName][modName]
            except KeyError:
                error = True

        if (sectionName not in self._iniFile.sectionIfTemplates):
            return sectionName

        if (remapNameFunc is None):
            remapNameFunc = self._iniFile.getRemapBlendName

        result = remapNameFunc(sectionName, modName)
        try:
            sectionGraph.remapNames[sectionName]
        except KeyError:
            sectionGraph.remapNames[sectionName] = {}

        sectionGraph.remapNames[sectionName][modName] = result
        return result

    # fills the if..else template in the .ini for each section
    def fillIfTemplate(self, modName: str, sectionName: str, ifTemplate: IfTemplate, fillFunc: Callable[[str, str, IfContentPart, int, int, str], str], origSectionName: Optional[str] = None) -> str:
        """
        Creates a new :class:`IfTemplate` for an existing `section`_ in the .ini file

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name of the `section`_

        ifTemplate: :class:`IfTemplate`
            The :class:`IfTemplate` of the orginal `section`_

        fillFunc: Callable[[:class:`str`, :class:`str`, :class:`IfContentPart`, :class:`int`, :class:`str`, :class:`str`], :class:`str`]]
            The function to create a new **content part** for the new :class:`IfTemplate`
            :raw-html:`<br />` :raw-html:`<br />`

            .. tip::
                For more info about an 'IfTemplate', see :class:`IfTemplate`

            :raw-html:`<br />`
            The parameter order for the function is:

            #. The name for the type of mod to fix to
            #. The new section name
            #. The corresponding **content part** in the original :class:`IfTemplate`
            #. The index for the content part in the original :class:`IfTemplate`
            #. The string to prefix every line in the **content part** of the :class:`IfTemplate`
            #. The original name of the section

        origSectionName: Optional[:class:`str`]
            The original name of the section.

            If this argument is set to ``None``, then will assume this argument has the same value as the argument for ``sectionName`` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`str`
            The text for the newly created :class:`IfTemplate`
        """

        addFix = f"[{sectionName}]\n"
        partIndex = 0
        linePrefix = ""

        if (origSectionName is None):
            origSectionName = sectionName

        for part in ifTemplate:
            # adding in the if..else statements
            if (isinstance(part, IfPredPart)):
                addFix += part.pred
                
                linePrefix = re.match(r"^[( |\t)]*", part.pred)
                if (linePrefix):
                    linePrefix = linePrefix.group(0)
                    linePrefixLen = len(linePrefix)

                    linePrefix = part.pred[:linePrefixLen]

                    if (part.type != IfPredPartType.EndIf):
                        linePrefix += "\t"
                partIndex += 1
                continue
            
            # add in the content within the if..else statements
            addFix += fillFunc(modName, sectionName, part, partIndex, linePrefix, origSectionName)

            partIndex += 1
            
        return addFix

    def getFix(self, fixStr: str = "") -> str:
        """
        Retrieves the text to fix the .ini file
        """
        pass

    # _fix(keepBackup, fixOnly, update, hideOrig, withBoilerPlate, withSrc): Internal function to fix the .ini file
    def _fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, hideOrig: bool = False, withBoilerPlate: bool = True, withSrc: bool = True, fixId: int = 0) -> Union[str, List[str]]:
        self._fixId = fixId
        return self._iniFile._fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update, hideOrig = hideOrig, withBoilerPlate = withBoilerPlate, withSrc = withSrc)

    def fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, hideOrig: bool = False) -> Union[str, List[str]]:
        """
        Fixes the .ini file

        Parameters
        ----------
        keepBackup: :class:`bool`
            Whether to keep backups for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether to only fix the .ini file without undoing any fixes :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        update: :class:`bool`
            Whether to also update the source text in the :class:`IniFile` object with the latest fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        hideOrig: :class:`bool`
            Whether to hide the mod for the original character :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        Union[:class:`str`, List[:class:`str`]]
            The new content of the .ini file which includes the fix and the new content of any other newly created .ini files related to fixing the particular .ini file
        """

        self._fixId = 0
        return self._fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update, hideOrig = hideOrig)


class IniFixBuilder(Builder[Callable[[], Tuple[BaseIniFixer, List[Any], Dict[str, Any]]]]):
    """
    This class inherits from :class:`Builder`

    Class to dynamically build a :class:`BaseIniFixer` to fix .ini files

    Parameters
    ----------
    buildCls: Union[Type[:class:`BaseIniFixer`], :class:`IniFixBuilderArgs`]
        Either:

            #. The class to construct a :class:`BaseIniFixer` OR
            #. Some provider that gives the required arguments needed for this class

    args: Optional[List[Any]]
        The constant arguments used to build the object

        .. note::
            If the :attr:`buildCls` attribute is not a class of type Type[:class:`BaseIniFixer`], then
            this parameter has no effect

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object

        .. note::
            If the :attr:`buildCls` attribute is not a class of type Type[:class:`BaseIniFixer`], then
            this parameter has no effect

        **Default**: ``None``

    Attributes
    ----------
    _buildCls: Optional[Type[:class:`BaseIniFixer`]]
        The class for the fixer, if available

    _builderArgs: Optional[:class:`IniFixBuilderArgs`]
        The provider for the arguments of this class, if available
    """

    def __init__(self, buildCls: Union[Type[BaseIniFixer], "IniFixBuilderArgs"], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        super().__init__(buildCls, args, kwargs)

        builderArgsProvided = not isinstance(self._buildCls, type)

        self._builderArgs = buildCls if (builderArgsProvided) else None
        if (builderArgsProvided):
            self._buildCls = None

    @lru_cache(maxsize = 64)
    def _getBuilderArgs(self, modName: str, version: Optional[int] = None) -> Callable[[], Tuple[BaseIniParser, List[Any], Dict[str, Any]]]:
        builderArgsGenerator = self._builderArgs.get(modName, version = version)
        return builderArgsGenerator()

    def build(self, parser: BaseIniParser, modName: Optional[str] = None, version: Optional[int] = None) -> BaseIniFixer:
        """
        Builds the fixer

        Parameters
        ----------
        parser: :class:`BaseIniParser`
            The corresponding parser for the .ini file

        modeName: Optional[:class:`str`]
            The name of the mod to build the fixer for :raw-html:`<br />` :raw-html:`<br />`

            If this argument is ``None``, then will use the mod name extracted from :attr:`IniFile.availableType` of
            :attr:`BaseIniParser._iniFile`

            .. warning::
                This argument has no effect if :attr:`_buildCls` is not ``None`` 

            **Default**: ``None``

        version: Optional[:class:`int`]
            The game version to fix the mod to :raw-html:`<br />` :raw-html:`<br />`

            If this argument is ``None``, will build the fixer for the latest version of the game

            .. warning::
                This argument has no effect if :attr:`_buildCls` is not ``None`` 

            **Default**: ``None``

        Returns
        -------
        :class:`BaseIniFixer`
            The built fixer
        """

        if (modName is None):
            modName = parser._iniFile.availableType

        if (self._builderArgs is not None):
            self._buildCls, self._args, self._kwargs, = self._getBuilderArgs(modName, version = version)

        return super().build(parser)


class BaseRegEditFilter():
    """
    Base class for editting registers within an :class:`IfContentPart`
    """

    def clear(self):
        """
        Clears any saved state within this class
        """

        pass

    def edit(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        """
        Edits the registers for the current :class:`IfContentPart`

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers

        Returns 
        -------
        :class:`IfContentPart`
            The resultant part of the :class:`IfTemplate` that got its registers editted
        """

        self.clear()


class RegEditFilter(BaseRegEditFilter):
    """
    This class inherits from :class:`BaseRegEditFilter`

    class for editting registers within an :class:`IfContentPart`
    """

    def clear(self):
        """
        Clears any saved state within this class
        """

        pass

    def edit(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        """
        Edits the registers for the current :class:`IfContentPart`. Includes boilerplate of clearing all saved states and handling texture adds/edits

        .. note::
            If you are inheriting this class, you probably want to override the :meth:`RegEditFilter._editReg` method instead

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers

        Returns 
        -------
        :class:`IfContentPart`
            The resultant part of the :class:`IfTemplate` that got its registers editted
        """

        self.clear()
        result = self._editReg(part, modType, fixModName, obj, sectionName, fixer)
        self.handleTexAdd(part, modType, fixModName, obj, sectionName, fixer)
        self.handleTexEdit(part, modType, fixModName, obj, sectionName, fixer)
        return result

    def _editReg(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "BaseIniFixer") -> IfContentPart:
        """
        The main function to edit the registers for the current :class:`IfContentPart`

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`BaseIniFixer`
            The fixer that is editting the registers

        Returns 
        -------
        :class:`IfContentPart`
            The resultant part of the :class:`IfTemplate` that got its registers editted
        """

        pass

    def handleTexAdd(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        """
        Does any post-processing on the added textures of the corresponding :class:`GIMIObjReplaceFixer`

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers
        """

        pass

    def handleTexEdit(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        """
        Does any post-processing on the added textures of the corresponding :class:`GIMIObjReplaceFixer`

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers
        """

        pass


class GIMIFixer(BaseIniFixer):
    """
    This class inherits from :class:`BaseIniFixer`

    Fixes a .ini file used by a GIMI related importer

    Parameters
    ----------
    parser: :class:`GIMIParser`
        The associated parser to retrieve data for the fix

    postModelRegEditFilters: Optional[List[:class:`RegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the `sections`_ related to the .VB or .IB of a mod
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    postModelRegEditFilters: List[:class:`RegEditFilter`]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the `sections`_ related to the .VB or .IB of a mod
        Filters are executed based on the order specified in the list.
    """

    def __init__(self, parser: GIMIParser, postModelRegEditFilters: Optional[List[RegEditFilter]] = None):
        super().__init__(parser)
        self.postModelRegEditFilters = [] if (postModelRegEditFilters is None) else postModelRegEditFilters

    def clear(self):
        super().clear()
        self._parser._fixIdsWithDownloadsAdded.clear()

    # _getBufRemapName(sectionName, modName, bufKey, reg, sectionGraph, remapNameFunc): Retrieves the required remap name for the fix, given the original
    #   name may refer to some .buf download
    def _getBufRemapName(self, sectionName: str, modName: str, modsToFix: Set[str], sectionGraph: Optional[IniSectionGraph] = None, remapNameFunc: Optional[Callable[[str, str], str]] = None):
        if (modName in modsToFix):
            return self._getRemapName(sectionName, modName, sectionGraph = sectionGraph, remapNameFunc = remapNameFunc)
        return sectionName
    
    def editModelRegisters(self, modName: str, part: IfContentPart, modelPartName: str, sectionName: str, filters: List[RegEditFilter]):
        """
        Edits the registers for a :class:`IfContentPart` in the .VB or .IB `sections`_

        .. note::
            For details on steps of how the registers are editted, see :class:`GIMIObjReplaceFixer`

        Parameters
        ----------
        modName: :class:`str`
            The name of the mod to fix to

        part: :class:`IfContentPart`
            The part that is being editted

        modelPartName: :class:`str`
            The name of the part within the .VB or .IB `sections`_

        sectionName: :class:`str`
            The name of the `section`_ the part belongs to

        filters: List[:class:`BaseRegEditFilter`]
            The filters used for editting the registers
        """

        modType = self._iniFile.availableType
        if (modType is None):
            return
        
        for filter in filters:
            filter.clear()
            filter._editReg(part, modType, modName, modelPartName, sectionName, self)

    def _fillTextureOverrideRemapBlend(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str) -> str:
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix related to the ``[TextureOverride.*Blend.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverrideBlend] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""
        newPart = copy.deepcopy(part)

        for varName, varValue, keyInd, orderInd in newPart:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommandName = self._getRemapName(varValue, modName, sectionGraph = self._parser.blendCommandsGraph)
                newPart.src[varName][keyInd] = (orderInd, f"{subCommandName}")

            # filling in the hash
            elif (varName == IniKeywords.Hash.value):
                hash = self._getHashReplacement(varValue, modName)
                newPart.src[varName][keyInd] = (orderInd, f"{hash}")

            # filling in the vb1 resource
            elif (varName == IniKeywords.Vb1.value):
                blendName = varValue
                remapBlendName = self._getRemapName(blendName, modName, sectionGraph = self._parser.blendResourceCommandsGraph, remapNameFunc = self._iniFile.getRemapBlendResourceName)
                newPart.src[varName][keyInd] = (orderInd, f"{remapBlendName}")

            # filling in the handling
            elif (varName == IniKeywords.Handling.value):
                newPart.src[varName][keyInd] = (orderInd, f"skip")

            # filling in the indices
            elif (varName == IniKeywords.MatchFirstIndex.value):
                index = self._getIndexReplacement(varValue, modName)
                newPart.src[varName][keyInd] = (orderInd, f"index")

        self.editModelRegisters(modName, newPart, IniKeywords.Blend.value, sectionName, self.postModelRegEditFilters)

        addFix = newPart.toStr(linePrefix = linePrefix)
        if (addFix != ""):
            addFix += "\n"
                
        return addFix
    
    def _fillTextureOverrideRemapPosition(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str) -> str:
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix related to the ``[TextureOverride.*Position.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverridePosition] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""
        newPart = copy.deepcopy(part)

        for varName, varValue, keyInd, orderInd in newPart:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommandName = self._getRemapName(varValue, modName, sectionGraph = self._parser.positionCommandsGraph, remapNameFunc = self._iniFile.getRemapPositionName)
                newPart.src[varName][keyInd] = (orderInd, f"{subCommandName}")

            # filling in the hash
            elif (varName == IniKeywords.Hash.value):
                hash = self._getHashReplacement(varValue, modName)
                newPart.src[varName][keyInd] = (orderInd, f"{hash}")

            # filling in the vb0 resource
            elif (varName == IniKeywords.Vb0.value):
                positionName = varValue
                remapPositionName = self._getBufRemapName(positionName, modName, self._parser._positionEditModsToFix, sectionGraph = self._parser.positionResourceCommandsGraph, remapNameFunc = self._iniFile.getRemapPositionResourceName)
                newPart.src[varName][keyInd] = (orderInd, f"{remapPositionName}")

            # filling in the indices
            elif (varName == IniKeywords.MatchFirstIndex.value):
                index = self._getIndexReplacement(varValue, modName)
                newPart.src[varName][keyInd] = (orderInd, f"{index}")

        self.editModelRegisters(modName, newPart, IniKeywords.Position.value, sectionName, self.postModelRegEditFilters)

        addFix = newPart.toStr(linePrefix = linePrefix)
        if (addFix != ""):
            addFix += "\n"
                
        return addFix
    
    def _fillTextureOverrideRemapTexcoord(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str) -> str:
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix related to the ``[TextureOverride.*Texcoord.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`
        
        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverrideTexcoord] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""
        newPart = copy.deepcopy(part)

        for varName, varValue, keyInd, orderInd in newPart:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommandName = self._getRemapName(varValue, modName, sectionGraph = self._parser.texcoordCommandsGraph, remapNameFunc = self._iniFile.getRemapTexcoordName)
                newPart.src[varName][keyInd] = (orderInd, f"{subCommandName}")

            # filling in the hash
            elif (varName == IniKeywords.Hash.value):
                hash = self._getHashReplacement(varValue, modName)
                newPart.src[varName][keyInd] = (orderInd, f"{hash}")

            # filling in the indices
            elif (varName == IniKeywords.MatchFirstIndex.value):
                index = self._getIndexReplacement(varValue, modName)
                newPart.src[varName][keyInd] = (orderInd, f"{index}")

        self.editModelRegisters(modName, newPart, IniKeywords.Texcoord.value, sectionName, self.postModelRegEditFilters)

        addFix = newPart.toStr(linePrefix = linePrefix)
        if (addFix != ""):
            addFix += "\n"
                
        return addFix
    
    def _fillTextureOverrideRemapIb(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str) -> str:
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix related to the ``[TextureOverride.*Ib.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`
        
        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverrideIb] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""
        newPart = copy.deepcopy(part)

        for varName, varValue, keyInd, orderInd in newPart:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommandName = self._getRemapName(varValue, modName, sectionGraph = self._parser.ibCommandsGraph, remapNameFunc = self._iniFile.getRemapIbName)
                newPart.src[varName][keyInd] = (orderInd, f"{subCommandName}")

            # filling in the hash
            elif (varName == IniKeywords.Hash.value):
                hash = self._getHashReplacement(varValue, modName)
                newPart.src[varName][keyInd] = (orderInd, f"{hash}")

            # filling in the indices
            elif (varName == IniKeywords.MatchFirstIndex.value):
                index = self._getIndexReplacement(varValue, modName)
                newPart.src[varName][keyInd] = (orderInd, f"{index}")

        self.editModelRegisters(modName, newPart, IniKeywords.Ib.value, sectionName, self.postModelRegEditFilters)

        addFix = newPart.toStr(linePrefix = linePrefix)
        if (addFix != ""):
            addFix += "\n"
                
        return addFix
    
    def _fillOtherHashIndexSections(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str) -> str:
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix that are not related to the ``[TextureOverride.*Blend.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverrideBlend] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""

        for varName, varValue, _, _ in part:
            # filling in the hash
            if (varName == IniKeywords.Hash.value):
                newHash = self._getHashReplacement(varValue, modName)
                addFix += f"{linePrefix}{IniKeywords.Hash.value} = {newHash}\n"

            # filling in the subcommand
            elif (varName == IniKeywords.Run.value):
                subCommand = self._getRemapName(varValue, modName, sectionGraph = self._parser.otherHashIndexCommandsGraph, remapNameFunc = self._iniFile.getRemapFixName)
                subCommandStr = f"{IniKeywords.Run.value} = {subCommand}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # filling in the index
            elif (varName == IniKeywords.MatchFirstIndex.value):
                newIndex = self._getIndexReplacement(varValue, modName)
                addFix += f"{linePrefix}{IniKeywords.MatchFirstIndex.value} = {newIndex}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"

        return addFix
    

    # fill the attributes for the sections related to the resources
    def _fillRemapBlendResource(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str):
        """
        Creates the **content part** of an :class:`IfTemplate` for the new `sections`_ created by this fix related to the ``[Resource.*Blend.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the `section`_

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original ``[Resource.*Blend.*]`` `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""

        for varName, varValue, keyInd, _ in part:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommand = self._getRemapName(varValue, modName, sectionGraph = self._parser.blendResourceCommandsGraph, remapNameFunc = self._iniFile.getRemapBlendResourceName)
                subCommandStr = f"{IniKeywords.Run.value} = {subCommand}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # add in the type of file
            elif (varName == "type"):
                addFix += f"{linePrefix}type = Buffer\n"

            # add in the stride for the file
            elif (varName == "stride"):
                addFix += f"{linePrefix}stride = 32\n"

            # add in the file
            elif (varName == "filename"):
                remapModel = self._iniFile.remapBlendModels[origSectionName]
                fixedBlendFile = remapModel.fixedPaths[partIndex][modName][keyInd]
                addFix += f"{linePrefix}filename = {fixedBlendFile}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"

        return addFix

    def _fillRemapPositionResource(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str):
        """
        Creates the **content part** of an :class:`IfTemplate` for the new `sections`_ created by this fix related to the ``[Resource.*Position.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the `section`_

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original ``[Resource.*Position.*]`` `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""

        for varName, varValue, keyInd, _ in part:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommand = self._getRemapName(varValue, modName, sectionGraph = self._parser.positionResourceCommandsGraph, remapNameFunc = self._iniFile.getRemapPositionResourceName)
                subCommandStr = f"{IniKeywords.Run.value} = {subCommand}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # add in the type of file
            elif (varName == "type"):
                addFix += f"{linePrefix}type = Buffer\n"

            # add in the stride for the file
            elif (varName == "stride"):
                addFix += f"{linePrefix}stride = 40\n"

            # add in the file
            elif (varName == "filename"):
                remapModel = self._iniFile.remapPositionModels[origSectionName]
                fixedPositionFile = remapModel.fixedPaths[partIndex][modName][keyInd]
                addFix += f"{linePrefix}filename = {fixedPositionFile}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"

        return addFix
    
    # _fixElementCommands(modName, commandGraph, remapNameFunc, fillFunc, fix, 
    #                     includeEndNewLine, addToRemapSections): Get the fix string for a specific type of element
    def _fixElementCommands(self, modName: str, commandGraph: IniSectionGraph, remapNameFunc: Callable[[str, str], str],
                            fillFunc: Callable[[str, str, IfContentPart, int, int, str], str], fix: str = "", includeEndNewLine: bool = True,
                            addToRemapSections: bool = False):

        commandTuples = commandGraph.runSequence
        commandsLen = len(commandTuples)
        for i in range(commandsLen):
            commandTuple = commandTuples[i]
            section = commandTuple[0]
            ifTemplate = commandTuple[1]

            if (addToRemapSections):
                self._iniFile._remappedSectionNames.add(section)

            resourceName = self._getRemapName(section, modName, sectionGraph = commandGraph, remapNameFunc = remapNameFunc)
            fix += self.fillIfTemplate(modName, resourceName, ifTemplate, fillFunc, origSectionName = section)

            if (includeEndNewLine or i < commandsLen - 1):
                fix += "\n"

        return fix

    # _fixBlendCommands(modName, fix): Get the fix string for all the texture override blend sections
    def _fixBlendCommands(self, modName: str, fix: str = ""):
        return self._fixElementCommands(modName, self._parser.blendCommandsGraph, self._iniFile.getRemapBlendName, 
                                        self._fillTextureOverrideRemapBlend, fix =  fix, addToRemapSections = True, includeEndNewLine = False)
    
    # _fixPositionCommands(modName, fix): Get the fix string for all the texture override position sections
    def _fixPositionCommands(self, modName: str, fix: str = ""):
        return self._fixElementCommands(modName, self._parser.positionCommandsGraph, self._iniFile.getRemapPositionName, 
                                        self._fillTextureOverrideRemapPosition, fix = fix, addToRemapSections = True, includeEndNewLine = False)
    
    # _fixTexcoordCommands(modName, fix): get the fix string for all the texture override texcoord sections
    def _fixTexcoordCommands(self, modName: str, fix: str = ""):
        return self._fixElementCommands(modName, self._parser.texcoordCommandsGraph, self._iniFile.getRemapTexcoordName, 
                                        self._fillTextureOverrideRemapTexcoord, fix = fix, addToRemapSections = True, includeEndNewLine = False)
    
    # _fixIbCommands(modName, fix): get the fix string for all the texture override ib sections
    def _fixIbCommands(self, modName: str, fix: str = ""):
        return self._fixElementCommands(modName, self._parser.ibCommandsGraph, self._iniFile.getRemapIbName,
                                        self._fillTextureOverrideRemapIb, fix = fix, addToRemapSections = True, includeEndNewLine = False)
    
    # _fixOtherHashIndexCommands(modName, fix): get the fix string for the other sections that include some hash/index register
    def _fixOtherHashIndexCommands(self, modName: str, fix: str = ""):
        return self._fixElementCommands(modName, self._parser.otherHashIndexCommandsGraph, self._iniFile.getRemapFixName,
                                        self._fillOtherHashIndexSections, fix = fix, addToRemapSections = True, includeEndNewLine = False)
    
    # _fixBlendResourceCommands(modName, fix, includeEndNewLine): get the fix string for the blend resources
    def _fixBlendResourceCommands(self, modName: str, fix: str = "", includeEndNewLine: bool = True):
        return self._fixElementCommands(modName, self._parser.blendResourceCommandsGraph, 
                                         self._iniFile.getRemapBlendResourceName, self._fillRemapBlendResource, fix = fix, includeEndNewLine = includeEndNewLine)
    
    # _fixPositionResourceCommands(modName, fix): get the fix string for the position resources
    def _fixPositionResourceCommands(self, modName: str, fix: str = ""):
        return self._fixElementCommands(modName, self._parser.positionResourceCommandsGraph, 
                                         self._iniFile.getRemapPositionResourceName, self._fillRemapPositionResource, fix = fix, includeEndNewLine = False)
    
    # _makeDownloadResourceIfTemplate(downloadname, modName, modObj, downloadFileBaseName, sectionName, downloadKvps): Creates the ifTemplate for a downloaded file
    def _makeDownloadResourceIfTemplate(self, downloadName: str, modName: str, modObj: str, downloadFileBaseName: str, sectionName: Optional[str] = None, downloadKvps: Optional[Dict[str, str]] = None):
        if (sectionName is None):
            sectionName = self._iniFile.getRemapDLResourceName(f"{modObj}{downloadName}", modName = modName)

        contentPart = IfContentPart({}, 0)
        if (downloadKvps is not None):
            for key in downloadKvps:
                val = downloadKvps[key]
                contentPart.addKVP(key, val)

        contentPart.addKVP("filename", downloadFileBaseName)
        return IfTemplate([contentPart], name = sectionName)
    
    # _fixDownloadResources(modName, fix): get the fix string for downloaded files
    def _fixDownloadedResources(self, fix: str = "", includeEndNewLine = False):
        downloadAdded = False

        for bufKey in self._parser._bufReferencedDownloadNames:
            if (bufKey not in self._parser.bufDownloads):
                continue

            regDownloadNames = self._parser._bufReferencedDownloadNames[bufKey]
            regDownloads = self._parser.bufDownloads[bufKey]

            for reg in regDownloadNames:
                if (reg not in regDownloads):
                    continue
                
                sectionName = regDownloadNames[reg]
                ifTemplate = self._iniFile.sectionIfTemplates.get(sectionName)
                if (ifTemplate is None):
                    continue

                fix += self.fillIfTemplate("", sectionName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: f"{part.toStr(linePrefix = linePrefix)}\n")
                fix += "\n"

                if (not downloadAdded):
                    downloadAdded = True

        if (not includeEndNewLine and downloadAdded and fix and fix[-1] == "\n"):
            fix = fix[:-1]

        return fix

    def fixMod(self, modName: str, fix: str = "") -> str:
        """
        Generates the newly added code in the .ini file for the fix of a single type of mod

        .. note::
            eg.
                If we are making the fix from ``Jean`` -> ``JeanCN`` and ``JeanSeaBreeze``,
                The code below will only make the fix for ``JeanCN``

            .. code-block::

                fixMod("JeanCN")


        Parameters
        ----------
        modName: :class:`str`
            The name of the mod to fix

        fix: :class:`str`
            Any existing text we want the result of the fix to add onto :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ""

        Returns
        -------
        :class:`str`
            The text for the newly generated code in the .ini file
        """

        hasDownloads = bool(self._fixId not in self._parser._fixIdsWithDownloadsAdded and self._parser.hasDownloads())
        currentFix = ""

        currentFix = self._fixBlendCommands(modName)
        if (currentFix):
            fix += "\n"
        fix += currentFix

        currentFix = self._fixPositionCommands(modName)
        if (currentFix):
            fix += "\n"
        fix += currentFix

        currentFix = self._fixTexcoordCommands(modName)
        if (currentFix):
            fix += "\n"
        fix += currentFix

        currentFix = self._fixIbCommands(modName)
        if (currentFix):
            fix += "\n"
        fix += currentFix

        currentFix = self._fixOtherHashIndexCommands(modName)
        if (currentFix):
            fix += "\n"
        fix += currentFix

        if (hasDownloads):
            fix += "\n"
            fix = self._fixDownloadedResources(fix = fix)
            self._parser._fixIdsWithDownloadsAdded.add(self._fixId)

        currentFix = self._fixBlendResourceCommands(modName, includeEndNewLine = False)
        if (currentFix):
            fix += "\n"
        fix += currentFix
        
        currentFix = ""
        fix = self._fixPositionResourceCommands(modName, fix = fix)
        return fix

    def getFix(self, fixStr: str = ""):
        heading = Heading("", sideLen = 5, sideChar = "*")
        sortedModsToFix = list(self._parser._modsToFix)
        sortedModsToFix.sort()

        for modName in sortedModsToFix:
            heading.title = modName
            currentFix = self.fixMod(modName)

            if (currentFix):
                fixStr += f"\n\n; {heading.open()}{currentFix}\n; {heading.close()}"

        return fixStr


class ModType():
    """
    Class for defining a generic type of mod

    Parameters
    ----------
    name: :class:`str`
        The default name for the type of mod

    hashes: Optional[:class:`Hashes`]
        The hashes related to the mod and its fix :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will create a new, empty :class:`Hashes` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    indices: Optional[:class:`Indices`]
        The indices related to the mod and its fix :raw-html:`<br />` :raw-html:`<br />`

        If this ``None``, then will create a new, emtpy :class:`Indices` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    aliases: Optional[List[:class:`str`]]
        Other alternative names for the type of mod :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    vgRemaps: Optional[:class:`VGRemaps`]
        Maps the blend indices from the vertex group of one mod to another mod :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will create a new, empty :class:`VGRemaps` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    positionEditors: Optional[:class:`PositionEditors`]
        The editors used for fixing position.buf files :raw-html:`<br />` :raw-html:`<br />`

        If this ``None``, then will create a new, emtpy :class:`PositionEditors` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    iniParseBuilder: Optional[:class:`IniParseBuilder`]
        The builder to build the parser used for .ini files :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then by default this attribute will be set to **IniParseBuilder(:class:`GIMIParser`)** :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    iniFixBuilder: Optional[:class:`IniFixBuilder`]
        The builder to build the fixer used for .ini files :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then by default this attribute will be set to **IniFixBuilder(:class:`GIMIFixer`)** :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    iniRemoveBuilder: Optional[:class:`IniRemoveBuilder`]
        The builder to build the remover used for .ini files :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then by default this attribute will be set to **IniRemoveBuilder(:class:`IniRemover`)** :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    name: :class:`str`
        The default name for the type of mod

    hashes: :class:`Hashes`
        The hashes related to the mod and its fix

    indices: :class:`Indices`
        The indices related to the mod and its fix

    vertexCounts: :class:`VertexCounts`
        The vertex counts related to the mod and its fix

    vgRemaps: :class:`VGRemaps`
        The repository that stores the mapping for remapping vertex group blend indices of the mod to the vertex group blend indices of another mod

    positionEditors: :class:`PositionEditors`
        The editors used for fixing position.buf files

    aliases: Optional[List[:class:`str`]]
        Other alternative names for the type of mod

    iniParseBuilder: :class:`IniParseBuilder`
        The builder to build the parser used for .ini files

    iniFixBuilder: :class:`IniFixBuilder`
        the builder to build the fixer used for .ini files

    iniRemoveBuilder: :class:`IniRemoveBuilder`
        the builder to build the remover used for .ini files
    """

    def __init__(self, name: str, hashes: Optional[Hashes] = None, indices: Optional[Indices] = None, vertexCounts: Optional[VertexCounts] = None,
                 aliases: Optional[List[str]] = None, vgRemaps: Optional[VGRemaps] = None, positionEditors: Optional[PositionEditors] = None, 
                 iniParseBuilder: Optional[IniParseBuilder] = None, iniFixBuilder: Optional[IniFixBuilder] = None, iniRemoveBuilder: Optional[IniRemoveBuilder] = None):
        self.name = name
        if (hashes is None):
            hashes = Hashes()

        if (indices is None):
            indices = Indices()

        if (vertexCounts is None):
            vertexCounts = VertexCounts()

        if (positionEditors is None):
            positionEditors = PositionEditors({})

        self.hashes = hashes
        self.indices = indices
        self.vertexCounts = vertexCounts
        
        if (aliases is None):
            aliases = []
        self.aliases = ListTools.getDistinct(aliases)
        
        self._maxVgIndex = None
        if (vgRemaps is None):
            vgRemaps = VGRemaps()

        self.vgRemaps = vgRemaps

        if (iniParseBuilder is None):
            iniParseBuilder = IniParseBuilder(GIMIParser)

        if (iniFixBuilder is None):
            iniFixBuilder = IniFixBuilder(GIMIFixer)

        if (iniRemoveBuilder is None):
            iniRemoveBuilder = GlobalIniRemoveBuilders.RemoveBuilder.value

        self.positionEditors = positionEditors
        self.iniParseBuilder = iniParseBuilder
        self.iniFixBuilder = iniFixBuilder
        self.iniRemoveBuilder = iniRemoveBuilder

    def isName(self, name: str) -> bool:
        """
        Determines whether a certain name matches with the names defined for this type of mod

        Parameters
        ----------
        name: :class:`str`
            The name being searched

        Returns
        -------
        :class:`bool`
            Whether the searched name matches with the names for this type of mod
        """

        name = name.lower()
        if (self.name.lower() == name):
            return True
        
        for alias in self.aliases:
            if (alias.lower() == name):
                return True

        return False

    def getModsToFix(self) -> Set[str]:
        """
        Retrieves the names of the mods this mod type will fix to

        Returns
        -------
        Set[:class:`str`]
            The names of the mods to fix to
        """

        result = set()
        result = result.union(self.hashes.fixTo)
        result = result.union(self.indices.fixTo)
        result = result.union(self.vgRemaps.fixTo)
        result = result.union(self.positionEditors.fixTo)
        return result
    
    def getVertexCount(self, version: Optional[Union[str, float, VersionType]] = None) -> int:
        """
        Retrieves the number of vertices for a mod

        .. attention::
            This function assumes that the specified dictionary :attr:`vertexCounts` (:attr:`VertexCounts.map`) contains :attr:`name` (the name of this mod type) as a mod to get the vertex count for

        Parameters
        ----------
        version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
            The specific game version we want for the vertex count :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will get the latest version of the vertex count :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns 
        -------
        :class:`int`
            The number of vertices for the mod
        """

        return self.vertexCounts.get(self.name, version = version)
    
    def getVGRemap(self, modName: str, version: Optional[Union[str, float, VersionType]] = None) -> VGRemap:
        """
        Retrieves the corresponding Vertex Group Remap

        .. attention::
            This function assumes that the specified map :attr:`vgRemaps` (:attr:`VGRemaps.map`) contains :attr:`name` (the name of this mod type) as a mod to map from

        Parameters
        ----------
        modName: :class:`str`
            The name of the mod to map to

        version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
            The specific game version we want for the remap :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will get the latest version of the remap :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns 
        -------
        :class:`VGRemap`
            The corresponding remap
        """

        return self.vgRemaps.get(self.name, modName, version = version)
    
    def getPositionEditor(self, modName: str, version: Optional[Union[str, float, VersionType]] = None) -> Optional[BaseBufEditor]:
        """
        Retrieves the corresponding position editor for editting position.buf files

        .. attention::
            This function assumes that the specified map :attr:`positionEditors` (:attr:`PositionEditors.map`) contains :attr:`name` (the name of this mod type) as a mod to map from

        Parameters
        ----------
        modName: :class:`str`
            The name of the mod to map to

        version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
            The specific game version we want for the remap :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will get the latest version of the remap :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns 
        -------
        Optional[:class:`BaseBufEditor`]
            The corresponding position editor
        """

        return self.positionEditors.get(self.name, modName, version = version)

    def getHelpStr(self) -> str:
        modTypeHeading = Heading(self.name, 8, "-")

        currentHelpStr = f"{modTypeHeading.open()}"
        currentHelpStr += f"\n\nname: {self.name}"
        
        if (self.aliases):
            sortedAliases = sorted(self.aliases)
            aliasStr = ", ".join(sortedAliases)
            currentHelpStr += f"\naliases: {aliasStr}"

        currentHelpStr += f"\n\n{modTypeHeading.close()}"
        return currentHelpStr
    
    def fixIni(self, iniFile: "IniFile", keepBackup: bool = True, fixOnly: bool = False):
        """
        Fixes the .ini file associated to this type of mod

        Parameters
        ----------
        iniFile: :class:`IniFile`
            The .ini file to fix

        keepBackup: :class:`bool`
            Whether to keep backups for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether to only fix the .ini file without undoing any fixes :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        iniModType = iniFile.availableType
        if (iniModType is not None and iniModType.name == self.name):
            iniFile.fix(keepBackup = keepBackup, fixOnly = fixOnly)


class ColourConsts(Enum):
    """
    Constants about colours
    """

    MinColourValue = 0
    """
    Minimum bound for a colour channel
    """

    MaxColourValue = 255
    """
    Maximum bound for a colour channel
    """

    MinColourDegree = 0
    """
    Minimum degrees for some HSV/HSL images    
    """

    MaxColourDegree = 360
    """
    Maximum degrees for some HSV/HSL images    
    """

    PaintTempIncRedFactor = 0.41
    """
    The parameter for approximately how fast the red channel increases for the temperature increase algorithm from Paint.net
    """

    PaintTempIncBlueFactor = 0.44
    """
    The parameter for approximately how fast the blue channel decreases for the temperature increase algorithm from Paint.net
    """

    PaintTempDecRedFactor = 0.5
    """
    The parameter for approximately how fast the red channel decreases for the temperature decrease algorithm from Paint.net
    """

    PaintTempDecBlueFactor = 2
    """
    The parameter for approximately how fast the blue channel increases for the temperature decrease algorithm from Paint.net
    """

    StandardGamma = 2.2
    """
    The reciprocal of the standard gamma value (1/2.2) used in computer displays, sRGB images, Adobe RGB images. See :class:`CorrectGamma` for more info.
    """

    SRGBGamma = 1 / StandardGamma
    """
    The standard gamma value (1/2.2) typically used in computer displays, sRGB images, Adobe RGB images. See :class:`CorrectGamma` for more info.
    """


class Colour():
    """
    Class to store data for a colour

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: hash(x)

            Retrieves the hash id for the colour based off :meth:`Colour.getId`

    :raw-html:`<br />`

    Parameters
    ----------
    red: :class:`int`
        The red channel for the colour :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``255``

    green: :class:`int`
        The green channel for the colour :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``255``

    blue: :class:`int`
        The blue channel for the colour :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``255``

    alpha: :class:`int`
        The transparency (alpha) channel for the colour with a range from 0-255. 0 = transparent, 255 = opaque :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``255``

    Attributes
    ----------
    red: :class:`int`
        The red channel for the colour

    green: :class:`int`
        The green channel for the colour

    blue: :class:`int`
        The blue channel for the colour

    alpha: :class:`int`
        The transparency (alpha) channel for the colour with a range from 0-255. 0 = transparent, 255 = opaque
    """

    def __init__(self, red: int = ColourConsts.MaxColourValue.value, green: int = ColourConsts.MaxColourValue.value, blue: int = ColourConsts.MaxColourValue.value, alpha: int = ColourConsts.MaxColourValue.value):
        self.red = self.boundColourChannel(red)
        self.green = self.boundColourChannel(green)
        self.blue = self.boundColourChannel(blue)
        self.alpha = self.boundColourChannel(alpha)

    @classmethod
    def boundColourChannel(self, val: int, min: int = ColourConsts.MinColourValue.value, max: int = ColourConsts.MaxColourValue.value):
        """
        Makes a colour channel to be in between the minimum and maximum value

        Parameters
        ----------
        val: :class:`int`
            The value of the channel

        min: :class:`int`
            The minimum bound for the colour channel :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``0``

        max: :class:`int`
            The maximum bound for the colour channel :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``255``
        """

        if (val > max):
            val = max
        elif (val < min):
            val = min
        return val
    
    @classmethod
    def boolToColourChannel(self, val: bool, min: int = ColourConsts.MinColourValue.value, max: int = ColourConsts.MaxColourValue.value) -> int:
        """
        Converts a boolean value to a value for a colour channel

        Parameters
        ----------
        val: :class:`bool`
            The boolean value to convert

        min: :class:`int`
            The minimum bound for the colour channel :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``0``

        max: :class:`int`
            The maximum bound for the colour channel :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``255``
        Returns
        -------
        :class:`int`
            The corresponding value for the colour channel based off the boolean
        """

        return max if (val) else min
    
    def __hash__(self) -> int:
        return hash(self.getId())
    
    def fromTuple(self, colourTuple: Tuple[int, int, int, int]):
        """
        Updates the colour based off 'colourTuple'

        Parameters
        ----------
        colourTuple: Tuple[:class:`int`, :class:`int`, :class:`int`, :class:`int`]
            The raw values for the colour in RGBA format
        """

        self.red = colourTuple[0]
        self.green = colourTuple[1]
        self.blue = colourTuple[2]
        self.alpha = colourTuple[3]
    
    def getTuple(self) -> Tuple[int, int, int, int]:
        """
        Retrieves the tuple representation of the colour in RGBA format

        Returns
        -------
        Tuple[:class:`int`, :class:`int`, :class:`int`, :class:`int`]
            The colour tuple containing the following colour channel values indicated by the order below: :raw-html:`<br />` :raw-html:`<br />`

            #. Red
            #. Green
            #. Blue
            #. Alpha            
        """

        return (self.red, self.green, self.blue, self.alpha)
    
    def getId(self) -> str:
        """
        Retrieves a unique id for the colour

        .. note::
            The id generated will not correspond to any id generated from :meth:`ColourRange.getId`

        Returns
        -------
        :class:`str`
            The id for the colour        
        """

        return f"{self.red}{self.green}{self.blue}{self.alpha}"

    def copy(self, colour, withAlpha: bool = True):
        """
        Copies the colour value from 'colour'

        Parameters
        ----------
        colour: :class:`Colour`
            The colour to copy from

        withAlpha: :class:`bool`
            Whether to also copy the alpha channel :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``
        """

        self.red = colour.red
        self.green = colour.green
        self.blue = colour.blue

        if (withAlpha):
            self.alpha = colour.alpha
    
    def match(self, colour):
        """
        Whether 'colour' matches this colour

        Parameters
        ----------
        colour: :class:`Colour`
            The colour to check

        Returns
        -------
        :class:`bool`
            Whether the colour matches this colour
        """

        return (colour.red == self.red and colour.green == self.green and
                colour.blue == self.blue and colour.alpha == self.alpha)


class ColourRange():
    """
    Class to store data for a colour

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: hash(x)

            Retrieves the hash id for the colour range based off :meth:`ColourRange.getId`

    :raw-html:`<br />`

    Parameters
    ----------
    min: :class:`Colour`
        The minimum range for the RGBA values

    max: :class:`Colour`
        The maximum range for the RGBA values
    """

    def __init__(self, min: Colour, max: Colour):
        self.min = min
        self.max = max

    def __hash__(self) -> int:
        return hash(self.getId())

    def getId(self) -> str:
        """
        Retrieves a unique id for the colour range

        .. note::
            The id generated will not correspond to any id generated from :meth:`Colour.getId`

        Returns
        -------
        :class:`str`
            The id for the colour range
        """

        return f"{self.min.getId()}{self.max.getId()}"
    
    def match(self, colour: Colour) -> bool:
        """
        Whether 'colour' is within the colour range

        Parameters
        ----------
        colour: :class:`Colour`
            The colour to check

        Returns
        -------
        :class:`bool`
            Whether the colour is within the colour range
        """
        
        return (self.min.red <= colour.red and colour.red <= self.max.red and
                self.min.green <= colour.green and colour.green <= self.max.green and
                self.min.blue <= colour.blue and colour.blue <= self.max.blue and
                self.min.alpha <= colour.alpha and colour.alpha <= self.max.alpha)


class Colours(Enum):
    """
    Some common colours used

    Attributes
    ----------
    White: :class:`Colour` (255, 255, 255, 255)
        white

    LightMapGreenMin: :class:`Colour` (0, 125, 0, 0)
        Minimum range for the green colour usually in the LightMap.dds

    LightMapGreenMax: :class:`Colour` (50, 150, 50, 255)
        Maximum range for the green colour usually in the LightMap.dds

    LightMapGreen: :class:`Colour` (0, 128, 0, 255)
        The usual colour for the green in the LightMap.dds

    NormalMapYellow: :class:`Colour` (128, 128, 0, 255)
        The yellow that usually appears in the NormalMap.dds

    NormalMapBlue: :class:`Colour` (128, 128, 255, 255)
        The light blue that usually appears in the NormalMap.dds

    NormalMapPurple1: :class:`Colour` (128, 98, 128, 255)
        The light purple with rgb(128, 98, 128) that appears in the NormalMap.dds

    NormalMapPurple2: :class:`Colour` (128, 114, 128, 255)
        The light purple with rgb(128, 114, 128) that appears in the NormalMap.dds

    NormalMapPurpleMin: :class:`Colour` (128, 0, 128)
        Minimum range for the purple colour usually in NormalMap.dds
    """

    White = Colour(ColourConsts.MaxColourValue.value, ColourConsts.MaxColourValue.value, ColourConsts.MaxColourValue.value)
    LightMapGreenMin = Colour(0, 125, 0, 0)
    LightMapGreenMax = Colour(50, 160, 50, ColourConsts.MaxColourValue.value)
    LightMapGreen = Colour(0, 128, 0, ColourConsts.MaxColourValue.value)
    NormalMapYellow = Colour(128, 128, 0)
    NormalMapBlue = Colour(128, 128, 255)
    NormalMapPurple1 = Colour(128, 98, 128)
    NormalMapPurple2 = Colour(128, 114, 128)
    NormalMapPurpleMin = Colour(128, 0, 128)

class ColourRanges(Enum):
    """
    Some common colour ranges used

    Attributes
    ----------
    LightMapGreen: :class:`ColourRange` (:attr:`Colours.LightMapGreenMin`, :attr:`Colours.LightMapGreenMax`)
        The colour range for the green usually present in LightMap.dds

    NormalMapPurple1: :class:`ColourRange` (:attr:`Colours.NormalMapPurpleMin`, :attr:`Colours.NormalMapPurple1`)
        The colour range for the colour :class:`Colour.NormalMapPurple1` that usually appears in NormalMap.dds
    """
    LightMapGreen = ColourRange(Colours.LightMapGreenMin.value, Colours.LightMapGreenMax.value)
    NormalMapPurple1 = ColourRange(Colours.NormalMapPurpleMin.value, Colours.NormalMapPurple1.value)
    NormalMapPurple2 = ColourRange(Colours.NormalMapPurpleMin.value, Colours.NormalMapPurple2.value)


class TexMetadataNames(Enum):
    """
    Names for the metadata keys in the texture files
    """

    Gamma = "gamma"
    """
    Adjusts the gamma value of the texture file
    """


class IniTexModel(IniFixResourceModel):
    """
    This class inherits from :class:`IniResourceModel`

    Contains data for editting some texture files in a .ini file

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: for fixedPath, fixedFullPath, origPath, origFullPath in x

            Iterates over all the fixed paths to some texture within a :class:`IfContentPart`, ``x`` :raw-html:`<br />` :raw-html:`<br />`

            The tuples to iterate over are as follows:
            #. fixedPath: (:class:`str`) The path name of the fixed file
            #. fixedFullPath: (:class:`str`) The full path name to the fixed file 
            #. origPath: (Optional[:class:`str`]) The path to the orignal file, if available
            #. origFullPath: (Optional[:class:`str`]) The full path name to the original file, if available

    Parameters
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located

    fixedPaths: Dict[:class:`int`, Dict[:class:`str`, List[:class:`str`]]]
        The file paths to the fixed files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the .dds files appears in the :class:`IfTemplate` for some texture
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the file paths within the :class:`IfContentPart`

    texEdits: Dict[:class:`int`, Dict[:class:`str`, List[:class:`BaseTexEditor`]]]
        The texture editors used to edit the texture :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the .dds files appears in the :class:`IfTemplate` for some texture
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the different texture editors used to the .dds files

    origPaths: Optional[Dict[:class:`int`, List[:class:`str`]]]
        The file paths for the resource :raw-html:`<br />` :raw-html:`<br />`
        
        * The keys are the indices to the :class:`IfContentPart` that the .dds files appears in the :class:`IfTemplate` for some texture
        * The values are the file paths within the :class:`IfContentPart`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, iniFolderPath: str, fixedPaths: Dict[int, Dict[str, List[str]]], texEdits: Dict[int, Dict[str, List[BaseTexEditor]]], 
                 origPaths: Optional[Dict[int, List[str]]] = None):
        super().__init__(iniFolderPath, fixedPaths, origPaths = origPaths)
        self.texEdits = texEdits

    def clear(self):
        super().clear()
        self.texEdits.clear()


class GIMIObjParser(GIMIParser):
    """
    This class inherits from :class:`GIMIParser`

    Parses a .ini file used by a GIMI related importer and parses section's related to a specific mod object (head, body, dress, etc...)

    .. note::
        For the specific names of the objects for a particular mod, please refer to `GIMI Assets`_

    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to parse

    objs: Set[:class:`str`]
        The specific mod objects to keep track of

    texEdits: Optional[Dict[:class:`str`, Dict[:class:`str`, Dict[:class:`str`, :class:`BaseTexEditor`]]]]
        texture resource `sections`_ that require to be editted

        * The outer keys ares the name of the mod object the texture resource belongs in
        * The second outer keys are the name of the register the texture resource belongs in
        * The inner keys are the names of the type of texture files that are editted
        * The inner value is the editor for changing the texture files

        .. note::
            The new names of the texture files to be editted should be all unique

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    bufDownloads: Optional[Dict[:class:`str`, Dict[:class:`str`, :class:`DownloadData`]]]
        The .buf files to download if the mod is missing some required .buf files :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the type of buffer. The available names are: :attr:`IniKeywords.Blend`.value, :attr:`IniKeywords.Position`.value and :attr:`IniKeywords.Texcoord`.value
        * The inner keys are the names of the registers

         :raw-html:`<br />` :raw-html:`<br />`

        eg. :raw-html:`<br />`

        .. code-block::

            {IniKeywords.Position.value: {"vb0": ("Position", FileDownload("someServer.com/Position.buf", "Position.buf", {"type": "buffer", "stride": "40"}))}, 
             IniKeywords.Blend.value: {"vb1": ("Blend", FileDownload("someServer.com/Blender.buf", "Blend.buf", {})), "vb999": ("NonExistantBlend", FileDownload("someServer.com/NonExistentBlend.buf", "fakeBlend.buf", {"type": "fakenews"}))}, 
             IniKeywords.Texcoord.value: {"ps-t0": ("Texcoord", FileDownload("someServer.com/texcoord.buf", "textensor.buf", {"model": "resnet50"}))}} 

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    objFileDownloads: Optional[Dict[:class:`str`, Dict[:class:`str`, :class:`DownloadData`]]]
        The files to download for each mod object (eg. .dds, .ib files) if the mod is missing some required files for the mod object :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the mod object the texture belongs to
        * The inner keys are the names of the registers

        :raw-html:`<br />` :raw-html:`<br />`

        eg. :raw-html:`<br />`

        .. code-block::

            {"head": {"ib": ("garry", FileDownload("CorelliLaFolia.com/handel/sarabandeinDminor.ib", "puppetMary.ib", {"flower": "rose"}))}, 
             "body": {"ps-t3": ("ShadowRamp", FileDownload("someServer.com/bodyShadowRamp.dds", "bodyShadowRamp.dds", {})), "ps-t0": ("Diffuse", FileDownload("someServer.com/bodyDiffuse.dds", "bodyDiffuse.dds", {"model", "diffusion"}))}, 
             "dress": {"ps-t0": ("Diffuse", FileDownload("someServer.com/dressDiffuse.dds", "dressDiffuse.dds", {}))}} 

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    objGraphs: Dict[:class:`str`, :class:`IniSectionGraph`]
        The different `sections`_ related to each mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects and the values are the graphs related to each object

    texGraphs: Dict[:class:`str`, Dict[:class:`str`, :class:`IniSectionGraph`]]
        The different `sections`_ related to the textures to be editted :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the name of the mod object
        * The inner keys are the name of the register within the mod object
        * The inner value are the graphs for each register specified

    _objSearchPatterns: Dict[:class:`str`, `Pattern`]
        The Regex patterns used to find the roots of the `sections`_ related to each mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects and the values are the Regex patterns

    _objRootSections: Dict[:class:`str`, Set[:class:`str`]]
        The root `sections`_ for each mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects and the values are the names of the `sections`_

    texEditRegs: Dict[:class:`str`, Tuple[:class:`str`, :class:`str`]]
        The corresponding register for a particular texture resource to be editted :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the names of the type of texture resource to edit
        * The values contains info about the corresponding register for the texture. The tuple contains:
            #. The name of the mod object the texture resource belongs to
            #. The name of the register that holds the texture
    """

    def __init__(self, iniFile: "IniFile", objs: Set[str], texEdits: Optional[Dict[str, Dict[str, Dict[str, BaseTexEditor]]]] = None,
                 bufDownloads: Optional[Dict[str, Dict[str, DownloadData]]] = None, objFileDownloads: Optional[Dict[str, Dict[str, DownloadData]]] = None):
        super().__init__(iniFile, bufDownloads = bufDownloads)
        self.objGraphs: Dict[str, IniSectionGraph] = {}
        self.texGraphs: Dict[str, Dict[str, IniSectionGraph]] = {}
        self._objSearchPatterns: Dict[str, Pattern] = {}
        self._objRootSections: Dict[str, Set[str]] = {}
        self.texEditRegs: Dict[str, Tuple[str, str]] = {}
        self._texEdits = {}
        self._objFileDownloads = {}
        self._objResources: Dict[str, Dict[str, str]] = {}
        self._objReferencedDownloads: Dict[str, Dict[str, Tuple[str, str]]] = {}
        self.objs = objs

        self.texEdits = {} if texEdits is None else texEdits
        self.objFileDownloads = {} if objFileDownloads is None else objFileDownloads

    @property
    def objs(self):
        """
        The specific mod objects to keep track of

        :getter: Returns the names of the mod objects
        :setter: Sets the new names for the mod objects to keep track of
        :type: Set[:class:`str`]
        """

        return self._objs
    
    @objs.setter
    def objs(self, newObjs: Set[str]):
        self._objs = copy.deepcopy(newObjs)
        self._objs.update(set(self.texEdits.keys()), set(self.objFileDownloads.keys()))
        self.clear()

    @property
    def texEdits(self):
        """
        texture resource `sections`_ that require to be editted

        * The outer keys ares the name of the mod object the texture resource belongs in
        * The second outer keys are the name of the register the texture resource belongs in
        * The inner keys are the names of the type of texture files that are editted
        * The inner value is the editor for changing the texture files

        :getter: Returns the specific registers to have their textures editted
        :setter: Sets the new registers to have their textures editted
        :type: Dict[:class:`str`, Dict[:class:`str`, Dict[:class:`str`, :class:`BaseTexEditor`]]]
        """

        return self._texEdits

    def _getTexEditRegs(self, result: Dict[str, Tuple[str, str]], keys: Dict[str, str], values: Dict[str, Union[BaseTexEditor, Dict[str, BaseTexEditor], Dict[str, Dict[str, BaseTexEditor]]]]):
        result[keys["tex"]] = (keys["modObj"], keys["reg"])
    
    @texEdits.setter
    def texEdits(self, newTexEdits: Dict[str, Dict[str, Dict[str, BaseTexEditor]]]):
        oldObjs = set(self.texEdits.keys())

        self._texEdits = newTexEdits
        self.texEditRegs = {}
        DictTools.forDict(self._texEdits, ["modObj", "reg", "tex"], lambda keys, values: self._getTexEditRegs(self.texEditRegs, keys, values))

        self._objs -= oldObjs
        self._objs.update(set(self._texEdits.keys()))
        self.clear()

    @property
    def objFileDownloads(self) -> Dict[str, Dict[str, DownloadData]]:
        """
        The files to download for each mod object (eg. .dds, .ib files) if the mod is missing some required files for the mod object :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the mod object the texture belongs to
        * The inner keys are the names of the registers

        :getter: Returns the required file downloads for the mod objects
        :setter: Sets the new file downloads for the mod objects
        :type: Dict[:class:`str`, Dict[:class:`str`, :class:`DownloadData`]]
        """
        
        return self._objFileDownloads
    
    @objFileDownloads.setter
    def objFileDownloads(self, newObjFileDownloads: Dict[str, Dict[str, DownloadData]]):
        oldObjs = set(self._objFileDownloads.keys())

        self._objFileDownloads = newObjFileDownloads

        self._objs -= oldObjs
        self._objs.update(set(self._objFileDownloads.keys()))
        self.clear()

    def clearParseTempData(self):
        super().clearParseTempData()
        self._objResources.clear()

    def _makeTexModels(self, texName: str, texGraph: IniSectionGraph, texEditor: BaseTexEditor, getFixedFile: Optional[Callable[[str], str]] = None) -> Dict[str, Dict[str, IniTexModel]]:
        """
        Creates all the data needed for fixing the ``[Resource.*]`` `sections`_ related to texture files in the .ini file

        Parameters
        ----------
        texName: :class:`str`
            The name for the type of texture file to edit

        texGraph: :class:`IniSectionGraph`
            The graph of `sections`_ for the particular type of textures

        getFixedFile: Optional[Callable[[:class:`str`], :class:`str`]]
            The function for transforming the file path of a found from the texture .dds file into a .*RemapFix.dds file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :meth:`IniFile.getFixedTexFile` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Dict[:class:`str`, Dict[:class:`str`, :class:`IniTexModel`]]
            The data for fixing the resource `sections`_

            * The outer keys are the names for the particular type of texture files
            * The inner keys are the names for the resrouce `sections`_
            * The values are the required data for fixing the `sections`_
        """

        if (getFixedFile is None):
            getFixedFile = self._iniFile.getFixedTexFile

        texComands = texGraph.sections
        for sectionName in texComands:
            texIfTemplate = texComands[sectionName]
            texModel =  self._iniFile.makeTexModel(texIfTemplate, self._modsToFix, texEditor, getFixedFile = getFixedFile) 

            try:
                self._iniFile.texEditModels[texName]
            except KeyError:
                self._iniFile.texEditModels[texName] = {}

            self._iniFile.texEditModels[texName][sectionName] = texModel

        return self._iniFile.texEditModels
    
    def clearTexGraphs(self):
        """
        Reset all the graphs for the texture edits
        """

        self.texGraphs.clear()
        for obj in self._texEdits:
            objRegs = self._texEdits[obj]
            self.texGraphs[obj] = {}

            for reg in objRegs:
                self.texGraphs[obj][reg] = IniSectionGraph(set(), {})

    def clear(self):
        super().clear()
        self._objReferencedDownloads.clear()

        # reset the search patterns
        self._objSearchPatterns.clear()
        for obj in self._objs:
            cleanedObj = obj.lower()
            objParseStr = f".*{cleanedObj}" if (cleanedObj != "head") else f"((?!face).)*(head)"

            self._objSearchPatterns[obj] = re.compile(r"^textureoverride" + objParseStr + ".*$")

        # reset the graphs for the objects
        self.objGraphs.clear()
        sortedObjs = sorted(self._objs)
        for obj in sortedObjs:
            self.objGraphs[obj] = IniSectionGraph(set(), {})

        # reset the roots of each section
        self._objRootSections.clear()
        for obj in self._objs:
            self._objRootSections[obj] = set()

        # reset the graphs for each texture resource
        self.clearTexGraphs()
    
    # _getCurrentObjResources(part, objRegNames): Retrieves the desired resources from the registers
    #   specified at 'objRegNames' from 'part'
    def _getCurrentObjResources(self, part: IfContentPart, objRegNames: Set[str]) -> Dict[str, str]:
        result = DictTools.filter(part.src, lambda partKey, partVal: partKey in objRegNames)
        for reg in result:
            result[reg] = set(map(lambda valData: valData[1], result[reg]))
        return result
    
    def parseCommands(self):
        super().parseCommands()

        # retrieve the roots for each object
        for section in self._iniFile.sectionIfTemplates:
            for objName in self._objSearchPatterns:
                pattern = self._objSearchPatterns[objName]
                cleanedSectionName = section.lower().strip()

                if (pattern.match(cleanedSectionName)):
                    self._objRootSections[objName].add(section)
                    break

        # get the sections for each object
        for objName in self.objGraphs:
            objGraph = self.objGraphs[objName]
            objGraph.build(newTargetSections = self._objRootSections[objName], newAllSections = self._iniFile.sectionIfTemplates)

    def parseResources(self):
        super().parseResources()
        self._objResources.clear()

        # get the sections for each texture to be editted
        for objName in self._texEdits:
            objRegNames = set(self._texEdits[objName].keys())
            objGraph = self.objGraphs[objName]
            objResources = {}
            self._objResources[objName] = objResources

            self._iniFile.getResources(objGraph, lambda part: set(part.src.keys()).intersection(objRegNames), 
                                       lambda part: self._getCurrentObjResources(part, objRegNames),
                                       lambda resource, part: DictTools.update(objResources, resource, 
                                                                               combineDuplicate = lambda reg, val1, val2: val1.union(val2)))
            
            # build the graphs for each register
            for reg in objResources:
                objResources[reg] = set(objResources[reg])
                texGraph = self.texGraphs[objName][reg]

                newTargetSections = texGraph.targetSections + list(objResources[reg])
                texGraph.build(newTargetSections = newTargetSections, newAllSections = self._iniFile.sectionIfTemplates)

    def makeRemapData(self):
        super().makeRemapData()

        # build the models for each texture type
        for objName in self._texEdits:
            objResources  = self._objResources[objName]

            for reg in objResources:
                texGraph = self.texGraphs[objName][reg]
                texEditors = self._texEdits[objName][reg]
                
                for texName in texEditors:
                    self._makeTexModels(texName, texGraph, texEditors[texName])

    # _getTexItem(texName, texItems): Retrieves the corresponding item from 'texItems' based off 'texName'
    def _getTexItem(self, texName: str, texItems: Dict[str, Dict[str, Any]]) -> Optional[Any]:
        texKeys = None
        try:
            texKeys = self.texEditRegs[texName]
        except KeyError:
            return None
        
        try:
            return texItems[texKeys[0]][texKeys[1]]
        except KeyError:
            return None

    def getTexEditor(self, texName: str) -> Optional[BaseTexEditor]:
        """
        Retrieves the corresponding :class:`BaseTexEditor` based on 'texName'

        Parameters
        ----------
        texName: :class:`str`
            The name to the type of texture file to be editted

        Returns
        -------
        Optional[:class:`BaseTexEditor`]
            The found texture editor
        """

        texEditors = self._getTexItem(texName, self._texEdits)
        if (texEditors is None):
            return None
        
        try:
            return texEditors[texName]
        except KeyError:
            return None

    def getTexGraph(self, texName: str) -> Optional[IniSectionGraph]:
        """
        Retrieves the corresponding :class:`IniSectionGraph` based on 'texName'

        Parameters
        ----------
        texName: :class:`str`
            The name to the type of texture file to be editted

        Returns
        -------
        Optional[:class:`IniSectionGraph`]
            The found section graph
        """

        texGraphKeys = None
        try:
            texGraphKeys = self.texEditRegs[texName]
        except KeyError:
            return None
        
        try:
            return self.texGraphs[texGraphKeys[0]][texGraphKeys[1]]
        except KeyError:
            return None
        
    def getTexGraphs(self, texNames: List[str]) -> List[IniSectionGraph]:
        """
        Retrieves the corresponding `section`_ graphs based on 'texNames'

        Parameters
        ----------
        texNames: List[:class:`str`]
            The names to the type of texture files to be editted

        Returns
        -------
        List[:class:`IniSectionGraph`]
            The found `section`_ graphs
        """

        result = []
        texNames = ListTools.getDistinct(texNames, keepOrder = True)

        for texName in texNames:
            currentResult = self.getTexGraph(texName)
            if (currentResult is not None):
                result.append(currentResult)

        return result
    
    def _getObjSectionsRequiringDownload(self, objName: str, objGraph: IniSectionGraph, result: Dict[str, Dict[str, Tuple[str, str]]]):
        if (objName not in self.objFileDownloads):
            return
        
        modType = self._iniFile.availableType
        modTypeName = "" if (modType is None) else modType.name

        objDownloads = self.objFileDownloads[objName]

        for reg in objDownloads:
            downloadData = objDownloads[reg]
            targetSectionsKeyFullCover = objGraph.targetsAreFullyCovered(reg)

            for sectionName in targetSectionsKeyFullCover:
                isFullCover = targetSectionsKeyFullCover[sectionName]
                if (isFullCover):
                    continue
                
                if (sectionName not in result):
                    result[sectionName] = {}

                downloadResourceName = self._iniFile.getRemapDLResourceName(f"{TextTools.capitalize(modTypeName)}{TextTools.capitalizeOnlyFirstChar(objName)}{downloadData.name}")
                result[sectionName][reg] = (objName, downloadResourceName)

    def _getAllObjSectionsDownload(self, objName: str, objGraph: IniSectionGraph, result: Dict[str, Dict[str, Tuple[str, str]]]):
        if (objName not in self.objFileDownloads):
            return
        
        modType = self._iniFile.availableType
        modTypeName = "" if (modType is None) else modType.name
        objDownloads = self.objFileDownloads[objName]

        for reg in objDownloads:
            downloadData = objDownloads[reg]
            sections = objGraph.targetSections

            for sectionName in sections:
                if (sectionName not in result):
                    result[sectionName] = {}

                downloadResourceName = self._iniFile.getRemapDLResourceName(f"{TextTools.capitalize(modTypeName)}{TextTools.capitalizeOnlyFirstChar(objName)}{downloadData.name}")
                result[sectionName][reg] = (objName, downloadResourceName)

    def _addObjSectionsRequiringDownload(self):
        objGraphs = self.objGraphs
        modType = self._iniFile.availableType

        for sectionName in self._objReferencedDownloads:
            sectionDownloads = self._objReferencedDownloads[sectionName]

            for reg in sectionDownloads:
                objName, downloadResourceName = sectionDownloads[reg]
                if (objName not in objGraphs):
                    continue

                downloadData = None
                try:
                    downloadData = self.objFileDownloads[objName][reg]
                except KeyError:
                    continue

                objGraph = objGraphs[objName]
                ifTemplate = objGraph.getSection(sectionName)

                downloadData.addToSection(ifTemplate, reg, downloadResourceName)

                downloadIfTemplate = self._makeDownloadResourceIfTemplate(downloadData.name, modType.name, objName, downloadData.download.filename, sectionName = downloadResourceName, downloadKvps = downloadData.resourceKeys)
                self._iniFile.sectionIfTemplates[downloadResourceName] = downloadIfTemplate
                self._iniFile.fileDownloadModels[downloadResourceName] = self._iniFile.makeDLModel(downloadIfTemplate, downloadData.download)
    
    def getDownloads(self, downloadMode: Optional[DownloadMode] = None):
        self._objReferencedDownloads.clear()
        if (downloadMode is None):
            downloadMode = self._iniFile.downloadMode

        if (downloadMode == DownloadMode.Disabled):
            super().getDownloads()
            return

        textureDLModes = {DownloadMode.HardTexDriven, DownloadMode.HardTexDrivenAll, DownloadMode.SoftTexDriven, DownloadMode.SoftTexDrivenAll, DownloadMode.Tex}
        alwaysDLTexModes = {DownloadMode.Always, DownloadMode.AlwaysTex}
        alwaysDLBufModes = {DownloadMode.Always, DownloadMode.AlwaysBuf}
        texOnly = {DownloadMode.Tex, DownloadMode.AlwaysTex}

        if (downloadMode in alwaysDLTexModes):
            for objName in self.objGraphs:
                self._getAllObjSectionsDownload(objName, self.objGraphs[objName], self._objReferencedDownloads)
        
        elif (downloadMode in textureDLModes):
            for objName in self.objGraphs:
                self._getObjSectionsRequiringDownload(objName, self.objGraphs[objName], self._objReferencedDownloads)

            if (self._objReferencedDownloads and (downloadMode == DownloadMode.SoftTexDrivenAll or downloadMode == DownloadMode.HardTexDrivenAll)):
                self.normalizeSections(self.blendCommandsGraph)
                self.normalizeSections(self.positionCommandsGraph)
                self.normalizeSections(self.texcoordCommandsGraph)
                self.normalizeSections(self.ibCommandsGraph)

        if (downloadMode in texOnly or (not self._objReferencedDownloads and (downloadMode == DownloadMode.HardTexDriven or downloadMode == DownloadMode.HardTexDrivenAll))):
            downloadMode = DownloadMode.Disabled
        elif (downloadMode not in alwaysDLBufModes):
            downloadMode = DownloadMode.SoftTexDriven
        
        super().getDownloads(downloadMode = downloadMode)

    def addDownloads(self):
        self._addObjSectionsRequiringDownload()
        super().addDownloads()

    def hasDownloads(self):
        return bool(self._objReferencedDownloads) or super().hasDownloads()


class ImgFormats(Enum):
    """
    Different formats for an image
    """

    RGB = "RGB"
    """
    RGB (red, green blue) image
    """

    RGBA = "RGBA"
    """
    RGBA (red, green, blue) image
    """

    HSV = "HSV"
    """
    HSV (hue, saturation, value) image
    """

    Bit = "1"
    """
    Image with a single bit channel that has values of either 0 or 1
    """


class BasePixelTransform():
    """
    Base class for transforming a pixel in a texture file

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(pixel, xCoord, yCoord)

            Calls :meth:`BasePixelTransform.transform` for the :class:`BasePixelTransform`, ``x``
    """

    def __call__(self, pixel: Colour, x: int, y: int):
        self.transform(pixel, x, y)

    def transform(self, pixel: Colour, x: int, y: int):
        """
        Applies a Transformation to 'pixel'

        Parameters
        ----------
        pixel: :class:`Colour`
            The pixel to be editted

        x: :class:`int`
            x-coordinate of the pixel

        y: :class:`int`
            y-coordinate of the pixel
        """

        pass


class CorrectGamma(BasePixelTransform):
    """
    This class inherits from :class:`BasePixelTransform`

    Performs a `Gamma Correction`_ on an individual pixel using the following simple `Gamma Correction Algorithm`_

    Parameters
    ----------
    gamma: :class:`float`
        The luminance parameter for how bright humans perceive the image. Based off the following Power Law Relationship`_:

        .. code-block::

            V_out = V_in ^ gamma

        :raw-html:`<br />`

        Where ``V_out`` is the perceived brightness by human eyes while ``V_in`` is the actual brightness of the image

        :raw-html:`<br />`

        .. note::
            higher gamma values make the image look brighter and less saturated while lower gamma values make the image look darker and more saturated.

    Attributes
    ----------
    gamma: :class:`float`
        The luminance parameter for how bright humans perceive the image.
    """
    def __init__(self, gamma: float):
        self.gamma = gamma

    @classmethod
    def correctGamma(cls, pixelValue: int, gamma: float) -> int:
        """
        The equation for the gamma correction done at every colour channel pixel

        Parameters
        ----------
        pixelValue: :class:`int`
            The value of the pixel for some colour channel

        gamma: :class:`float`
            The luminance parameter for how bright humans perceive the image.

        Returns
        -------
        :class:`int`
            The gamma corrected pixel values 
        """

        return round(Colour.boundColourChannel(pow(pixelValue / ColourConsts.MaxColourValue.value, (1 / gamma)) * ColourConsts.MaxColourValue.value))

    def transform(self, pixel: Colour, x: int, y: int):
        pixel.red = self.correctGamma(pixel.red, self.gamma)
        pixel.green = self.correctGamma(pixel.green, self.gamma)
        pixel.blue = self.correctGamma(pixel.blue, self.gamma)


class BaseTexFilter():
    """
    Base class for transforming a texture file

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(texFile)

            Calls :meth:`transform` for the filters, ``x``
    """

    def __call__(self, texFile: "TextureFile"):
        self.transform(texFile)

    def transform(self, texFile: "TextureFile"):
        """
        Applies a Transformation to 'texFile'

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture to be editted
        """

        pass


class GammaFilter(BaseTexFilter):
    """
    This class inherits from :class:`BaseTexFilter`

    Performs a `Gamma Correction`_ on the texture file. See :class:`CorrectGamma` for more details

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(texFile)

            Calls :meth:`transform` for the filter, ``x``

    Parameters
    ----------
    gamma: :class:`float`
        The luminance parameter for how bright humans perceive the image.

    Attributes
    ----------
    gamma: :class:`float`
        The luminance parameter for how bright humans perceive the image.
    """

    def __init__(self, gamma: float):
        self.gamma = gamma

    def transform(self, texFile: "TextureFile"):
        alphaImg = texFile.img.getchannel('A')

        texFile.img = texFile.img.convert(ImgFormats.RGB.value)
        texFile.img = texFile.img.point(lambda pixel: CorrectGamma.correctGamma(pixel, self.gamma))

        texFile.img = texFile.img.convert(ImgFormats.RGBA.value)
        texFile.img.putalpha(alphaImg)


class TextureFile(File):
    """
    This Class inherits from :class:`File`

    Used for handling .dds files

    Attributes
    ----------
    img: Optional[`PIL.Image`_]
        The associated image file for the texture
    """

    def __init__(self, src: str):
        self.src = src
        self.img = None

    def open(self, format: str = ImgFormats.RGBA.value) -> Image:
        """
        Opens the texture file

        Parameters
        ----------
        format: :class:`str`
            What format the image of the texture file should be opened as :raw-html:`<br />` :raw-html:`<br />`

            **Default**: "RGBA"

        Returns
        -------
        `PIL.Image`
            The image for the texture file
        """

        if (not os.path.exists(self.src)):
            self.img = None
            return None

        Image = GlobalPackageManager.get(PackageModules.PIL_Image.value)

        self.img = Image.open(self.src)
        self.img = self.img.convert(format)
        return self.img

    def read(self, format: str = ImgFormats.RGBA.value, flush: bool = False) -> Optional[List[List[Tuple[int, int, int, int]]]]:
        """
        Reads the pixels of the texture .dds file, if the file exists

        Parameters
        ----------
        format: :class:`str`
            What format to open the texture file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: "RGBA"

        flush: :class:`bool`
            Whether to reopen the texture file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        Optional[`PIL.PixelAccess`_]
            The pixels for the texture file with RGBA channels
        """

        if (flush or self.img is None):
            self.open(format = format)

        if (self.img is None):
            return None

        return self.img.load()
    
    def save(self, img: Optional[Image] = None):
        """
        Saves the pixels defined at 'img' to the texture .dds file

        Parameters
        ----------
        img: Optional[`PIL.Image`]
            the new image to set for the texture file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (img is not None):
            self.img = img

        gamma = None
        try:
            gamma = self.img.info[TexMetadataNames.Gamma.value]
        except KeyError:
            pass
        else:
            filter = GammaFilter(gamma)
            filter(self)

        self.img.save(self.src, 'DDS')


class TexEditor(BaseTexEditor):
    """
    This class inherits from :class:`BaseTexEditor`

    Class for editing a texture file

    Parameters
    ----------
    filters: Optional[List[Union[:class:`BaseTexFilter`, Callable[[:class:`TextureFile`], Any]]]]
        The filters for editting the image :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    filters: List[Union[:class:`BaseTexFilter`, Callable[[:class:`TextureFile`], Any]]]
        The filters for editting the image :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, filters: Optional[List[Union[BaseTexFilter, Callable[[TextureFile], Any]]]] = None):
        super().__init__()
        self.filters = [] if (filters is None) else filters

    def fix(self, texFile: TextureFile, fixedTexFile: str):
        if (not self.filters):
            return

        texFile.open()
        if (texFile.img is None):
            return
        
        for filter in self.filters:
            filter(texFile)

        texFile.src = fixedTexFile
        texFile.save()

    @classmethod
    def adjustBrightness(self, texFile: TextureFile, brightness: float):
        """
        Adjust the brightness of the texture

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture file to be editted

        brightness: :class:`float`
            The brightness to adjust the texture. :raw-html:`<br />` :raw-html:`<br />`

            0 => make the image black
            1 => original brightness of the image
            >1 => make the image brighter
        """

        ImageEnhance = GlobalPackageManager.get(PackageModules.PIL_ImageEnhance.value)
        
        enhancer = ImageEnhance.Brightness(texFile.img)
        texFile.img = enhancer.enhance(brightness)

    @classmethod
    def setTransparency(self, texFile: TextureFile, alpha: int):
        """
        Sets the transparency of the texture

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture file to be editted

        alpha: :class:`int`
            The value for the alpha (transparency) channel of each pixel. Range from 0 - 255. :raw-html:`<br />` :raw-html:`<br />`

            0 => Transparent
            255 => Opaque
        """

        texFile.img.putalpha(alpha)

    @classmethod
    def adjustSaturation(self, texFile: TextureFile, saturation: float):
        """
        Adjust the saturation of the texture

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture file to be editted

        brightness: :class:`float`
            The brightness to adjust the texture. :raw-html:`<br />` :raw-html:`<br />`

            0 => make the image black and white
            1 => original saturation of the image
            >1 => make the image really saturated like a TV
        """

        ImageEnhance = GlobalPackageManager.get(PackageModules.PIL_ImageEnhance.value)

        enhancer = ImageEnhance.Color(texFile.img)
        texFile.img = enhancer.enhance(saturation)


class InvertAlphaFilter(BaseTexFilter):
    """
    This class inherits from :class:`BaseTexFilter`

    Inverts the alpha channel of an image.

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(texFile)

            Calls :meth:`transform` for the filter, ``x``
    """

    def transform(self, texFile: "TextureFile"):
        alphaImg = texFile.img.getchannel('A')
        alphaImg = alphaImg.point(lambda pixel: ColourConsts.MaxColourValue.value - pixel)
        texFile.img.putalpha(alphaImg)


class ColourReplaceFilter(BaseTexFilter):
    """
    This class inherits from :class:`BaseTexFilter`

    Replaces specific colours in the image

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(texFile)

            Calls :meth:`transform` for the filter, ``x``

    Paramaters
    ----------
    replaceColour: :class:`Colour`
        The colour to fill in

    coloursToReplace: Optional[Set[Union[:class:`Colour`, :class:`ColourRange`]]]
        The colours to find to be replaced. If this value is ``None``, then will always replace the colour of the pixel :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    replaceAlpha: :class:`bool`
        Whether to also replace the alpha channel of the original colour :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    Attributes
    ----------
    replaceColour: :class:`Colour`
        The colour to fill in

    coloursToReplace: Optional[Set[Union[:class:`Colour`, :class:`ColourRange`]]]
        The colour to find to be replaced. If this value is ``None``, then will always replace the colour of the pixel

    replaceAlpha: :class:`bool`
        Whether to also replace the alpha channel of the original colour
    """

    def __init__(self, replaceColour: Colour, coloursToReplace: Optional[Set[Union[Colour, ColourRange]]] = None, replaceAlpha: bool = True):
        self.coloursToReplace = coloursToReplace
        self.replaceColour = replaceColour
        self.replaceAlpha = replaceAlpha

    def transform(self, texFile: "TextureFile"):
        imgSize = texFile.img.size
        imgBox = (0, 0, imgSize[0], imgSize[1])

        replaceAllColours = self.coloursToReplace is None

        # replace all colours
        if (replaceAllColours and self.replaceAlpha):
            texFile.img.paste(self.replaceColour.getTuple(), box = imgBox)
            return
        
        ImageChops = GlobalPackageManager.get(PackageModules.PIL_ImageChops.value)
        Image = GlobalPackageManager.get(PackageModules.PIL_Image.value)

        redImg, greenImg, blueImg, alphaImg = texFile.img.split()
        
        # replace all colours, but don't touch alpha
        if (replaceAllColours):
            redImg.paste(self.replaceColour.red, box = imgBox)
            greenImg.paste(self.replaceColour.green, box = imgBox)
            blueImg.paste(self.replaceColour.blue, box = imgBox)
            texFile.img = Image.merge(ImgFormats.RGBA.value, (redImg, greenImg, blueImg, alphaImg))
            return

        replaceColourTuple = self.replaceColour.getTuple()
        newRedImg = newGreenImg = newBlueImg = None

        if (not self.replaceAlpha):
            newRedImg = redImg.copy()
            newGreenImg = greenImg.copy()
            newBlueImg = blueImg.copy()

        i = 0
        mask = None
        
        for colour in self.coloursToReplace:
            if (isinstance(colour, Colour)):
                redMatch = redImg.point(lambda redPixel: Colour.boolToColourChannel(redPixel == colour.red)).convert(ImgFormats.Bit.value)
                greenMatch = greenImg.point(lambda greenPixel: Colour.boolToColourChannel(greenPixel == colour.green)).convert(ImgFormats.Bit.value)
                blueMatch = blueImg.point(lambda bluePixel: Colour.boolToColourChannel(bluePixel == colour.blue)).convert(ImgFormats.Bit.value)
                alphaMatch = alphaImg.point(lambda alphaPixel: Colour.boolToColourChannel(alphaPixel == colour.alpha)).convert(ImgFormats.Bit.value)
            else:
                redMatch = redImg.point(lambda redPixel: Colour.boolToColourChannel(redPixel >= colour.min.red and redPixel <= colour.max.red)).convert(ImgFormats.Bit.value)
                greenMatch = greenImg.point(lambda greenPixel: Colour.boolToColourChannel(greenPixel >= colour.min.green and greenPixel <= colour.max.green)).convert(ImgFormats.Bit.value)
                blueMatch = blueImg.point(lambda bluePixel: Colour.boolToColourChannel(bluePixel >= colour.min.blue and bluePixel <= colour.max.blue)).convert(ImgFormats.Bit.value)
                alphaMatch = alphaImg.point(lambda alphaPixel: Colour.boolToColourChannel(alphaPixel >= colour.min.alpha and alphaPixel <= colour.max.alpha)).convert(ImgFormats.Bit.value)

            if (i > 0):
                mask = ImageChops.invert(mask)
                mask = ImageChops.logical_and(mask, redMatch)
            else:
                mask = redMatch

            mask = ImageChops.logical_and(mask, greenMatch)
            mask = ImageChops.logical_and(mask, blueMatch)
            mask = ImageChops.logical_and(mask, alphaMatch)

            if (self.replaceAlpha):
                texFile.img.paste(replaceColourTuple, mask = mask)
                i += 1
                continue

            newRedImg.paste(self.replaceColour.red, box = imgBox, mask = mask)
            newGreenImg.paste(self.replaceColour.green, box = imgBox, mask = mask)
            newBlueImg.paste(self.replaceColour.blue, box = imgBox, mask = mask)

            i += 1

        if (not self.replaceAlpha):
            texFile.img = Image.merge(ImgFormats.RGBA.value, (newRedImg, newGreenImg, newBlueImg, alphaImg))


class TransparencyAdjustFilter(BaseTexFilter):
    """
    This class inherits from :class:`BaseTexFilter`

    Adjust the trasparency (alpha channel) for an image

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(texFile)

            Calls :meth:`transform` for the filter, ``x``

    Parameters
    ----------
    alphaChange: :class:`int`
        How much to adjust the alpha channel of each pixel. Range from -255 to 255

        .. note::
            The alpha channel for an image is inclusively bounded from 0 to 255

    coloursToFilter: Optional[Set[Union[:class:`Colour`, :class:`ColourRange`]]]
        The specific colours to have their transparency adjusted. If this value is ``None``, then will adjust the transparency for the entire image`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    alphaChange: :class:`int`
        How much to adjust the alpha channel of each pixel. Range from -255 to 255
    """

    def __init__(self, alphaChange: int, coloursToFilter: Optional[Set[Union[Colour, ColourRange]]] = None):
        self.alphaChange = alphaChange
        self.coloursToFilter = coloursToFilter

    def adjustTransparency(self, texFile: "TextureFile"):
        """
        Adjusts the transparency for the entire image

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture to be editted
        """

        alphaImg = texFile.img.getchannel('A')
        alphaImg = alphaImg.point(lambda alphaPixel: Colour.boundColourChannel(alphaPixel + self.alphaChange))
        texFile.img.putalpha(alphaImg)


    def transform(self, texFile: "TextureFile"):
        if (self.coloursToFilter is None):
            self.adjustTransparency(texFile)
            return
        
        imgSize = texFile.img.size
        imgBox = (0, 0, imgSize[0], imgSize[1])
        ImageChops = GlobalPackageManager.get(PackageModules.PIL_ImageChops.value)
        
        redImg, greenImg, blueImg, alphaImg = texFile.img.split()

        newAlpha = alphaImg.copy()
        adjustedAlphaImg = alphaImg.point(lambda alphaPixel: Colour.boundColourChannel(alphaPixel + self.alphaChange))

        i = 0
        mask = None
        
        for colour in self.coloursToFilter:
            if (isinstance(colour, Colour)):
                redMatch = redImg.point(lambda redPixel: Colour.boolToColourChannel(redPixel == colour.red)).convert(ImgFormats.Bit.value)
                greenMatch = greenImg.point(lambda greenPixel: Colour.boolToColourChannel(greenPixel == colour.green)).convert(ImgFormats.Bit.value)
                blueMatch = blueImg.point(lambda bluePixel: Colour.boolToColourChannel(bluePixel == colour.blue)).convert(ImgFormats.Bit.value)
                alphaMatch = alphaImg.point(lambda alphaPixel: Colour.boolToColourChannel(alphaPixel == colour.alpha)).convert(ImgFormats.Bit.value)
            else:
                redMatch = redImg.point(lambda redPixel: Colour.boolToColourChannel(redPixel >= colour.min.red and redPixel <= colour.max.red)).convert(ImgFormats.Bit.value)
                greenMatch = greenImg.point(lambda greenPixel: Colour.boolToColourChannel(greenPixel >= colour.min.green and greenPixel <= colour.max.green)).convert(ImgFormats.Bit.value)
                blueMatch = blueImg.point(lambda bluePixel: Colour.boolToColourChannel(bluePixel >= colour.min.blue and bluePixel <= colour.max.blue)).convert(ImgFormats.Bit.value)
                alphaMatch = alphaImg.point(lambda alphaPixel: Colour.boolToColourChannel(alphaPixel >= colour.min.alpha and alphaPixel <= colour.max.alpha)).convert(ImgFormats.Bit.value)

            if (i > 0):
                mask = ImageChops.invert(mask)
                mask = ImageChops.logical_and(mask, redMatch)
            else:
                mask = redMatch

            mask = ImageChops.logical_and(mask, greenMatch)
            mask = ImageChops.logical_and(mask, blueMatch)
            mask = ImageChops.logical_and(mask, alphaMatch)

            newAlpha.paste(adjustedAlphaImg, box = imgBox, mask = mask)

        texFile.img.putalpha(newAlpha)


class TexMetadataFilter(BaseTexFilter):
    """
    This class inherits from :class:`BaseTexFilter`

    A pseudo-filter used to manipulate the metadata of a texture file (`PIL.Image.Image.info`_)

    .. warning::
        Currently, any metadata won't actually be saved into the texture file due to the image library (`Pillow`_) facing difficulty
        porting the `BCn Encoding Algorithm`_ from C/C# to Python. 

        https://github.com/python-pillow/Pillow/issues/4864

        :raw-html:`<br />`
        
        But the following metadata will affect how this software saves the texture file:

        - gamma

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(texFile)

            Calls :meth:`transform` for the filter, ``x``

    Parameters
    ----------
    edits: Optional[Dict[:class:`str`, Any]]
        The edits to perform on the metadata :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    removes: Optional[Set[:class:`str`]]
        keys to remove from the metadata :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    edits: Dict[:class:`str`, Any]
        The edits to perform on the metadata

    removes: Set[:class:`str`]
        keys to remove from the metadata
    """

    def __init__(self, edits: Optional[Dict[str, Any]] = None, removes: Optional[Set[str]] = None):
        self.removes = set() if (removes is None) else removes
        self.edits = {} if (edits is None) else edits

    def transform(self, texFile: "TextureFile"):
        """
        Changes metadata of the image

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture to be editted
        """

        for remove in self.removes:
            texFile.img.info.pop(remove, None)

        for editKey in self.edits:
            texFile.img.info[editKey] = self.edits[editKey]


TexcoordByteSizeData = {4.0 : {ModTypeNames.Amber.value: 12,
        ModTypeNames.AmberCN.value: 12,
        ModTypeNames.Ayaka.value: 20,
        ModTypeNames.AyakaSpringbloom.value: 20,
        ModTypeNames.Barbara.value: 20,
        ModTypeNames.BarbaraSummertime.value: 20,
        ModTypeNames.Diluc.value: 12,
        ModTypeNames.DilucFlamme.value: 20,
        ModTypeNames.Fischl.value: 20,
        ModTypeNames.FischlHighness.value: 12,
        ModTypeNames.Ganyu.value: 20,
        ModTypeNames.HuTao.value: 12,
        ModTypeNames.Jean.value: 12,
        ModTypeNames.JeanCN.value: 12,
        ModTypeNames.JeanSea.value: 20,
        ModTypeNames.Kaeya.value: 20,
        ModTypeNames.KaeyaSailwind.value: 20,
        ModTypeNames.Keqing.value: 20,
        ModTypeNames.KeqingOpulent.value: 20,
        ModTypeNames.Kirara.value: 20,
        ModTypeNames.Klee.value: 12,
        ModTypeNames.KleeBlossomingStarlight.value: 20,
        ModTypeNames.Lisa.value: 20,
        ModTypeNames.LisaStudent.value: 20,
        ModTypeNames.Mona.value: 12,
        ModTypeNames.MonaCN.value: 12,
        ModTypeNames.Nilou.value: 20,
        ModTypeNames.Ningguang.value: 20,
        ModTypeNames.NingguangOrchid.value: 20,
        ModTypeNames.Raiden.value: 20,
        ModTypeNames.Rosaria.value: 20,
        ModTypeNames.RosariaCN.value: 20,
        ModTypeNames.Shenhe.value: 20,
        ModTypeNames.Xiangling.value: 20,
        ModTypeNames.Xingqiu.value: 12},
        4.4: {ModTypeNames.ShenheFrostFlower.value: 20,
              ModTypeNames.GanyuTwilight.value: 20,
              ModTypeNames.XingqiuBamboo.value: 20},
        4.6: {ModTypeNames.Arlecchino.value: 20},
        4.8: {ModTypeNames.NilouBreeze.value: 20,
              ModTypeNames.KiraraBoots.value: 20},
        5.3: {ModTypeNames.CherryHuTao.value: 28,
              ModTypeNames.XianglingCheer.value: 12}}


GithubDownloadFolder = r"https://github.com/nhok0169/Anime-Game-Remap/raw/nhok0169/Data/Mod%20Downloads"

FileDownloadData = {
    4.0: {ModTypeNames.Amber.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberHeadDiffuse.dds", f"AmberHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberHeadLightMap.dds", f"AmberHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberHead.ib", f"AmberHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberBodyDiffuse.dds", f"AmberBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberBodyLightMap.dds", f"AmberBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberBody.ib", f"AmberBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberBlend.buf", f"AmberBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                     IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberPosition.buf", f"AmberPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                     IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Amber/4_0/AmberTexcoord.buf", f"AmberTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Amber.value]}"})}},
          ModTypeNames.AmberCN.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNHeadDiffuse.dds", f"AmberCNHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNHeadLightMap.dds", f"AmberCNHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNHead.ib", f"AmberCNHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNBodyDiffuse.dds", f"AmberCNBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNBodyLightMap.dds", f"AmberCNBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNBody.ib", f"AmberCNBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                        IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNBlend.buf", f"AmberCNBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                        IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNPosition.buf", f"AmberCNPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                        IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/AmberCN/4_0/AmberCNTexcoord.buf", f"AmberCNTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.AmberCN.value]}"})}},
          ModTypeNames.Ayaka.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaHeadDiffuse.dds", f"AyakaHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaHeadLightMap.dds", f"AyakaHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaHead.ib", f"AyakaHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaBodyDiffuse.dds", f"AyakaBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaBodyLightMap.dds", f"AyakaBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaBody.ib", f"AyakaBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaDressDiffuse.dds", f"AyakaDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaDressLightMap.dds", f"AyakaDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaDress.ib", f"AyakaDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaBlend.buf", f"AyakaBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                     IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaPosition.buf", f"AyakaPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                     IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Ayaka/4_0/AyakaTexcoord.buf", f"AyakaTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Ayaka.value]}"})}},
          ModTypeNames.AyakaSpringbloom.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomHeadDiffuse.dds", f"AyakaSpringBloomHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                         "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomHeadLightMap.dds", f"AyakaSpringBloomHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                         IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomHead.ib", f"AyakaSpringBloomHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                "body": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomBodyDiffuse.dds", f"AyakaSpringBloomBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                         "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomBodyLightMap.dds", f"AyakaSpringBloomBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                         IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomBody.ib", f"AyakaSpringBloomBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomDressDiffuse.dds", f"AyakaSpringBloomDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                          "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomDressLightMap.dds", f"AyakaSpringBloomDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                          IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomDress.ib", f"AyakaSpringBloomDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomBlend.buf", f"AyakaSpringBloomBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                                IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomPosition.buf", f"AyakaSpringBloomPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                                IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomTexcoord.buf", f"AyakaSpringBloomTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.AyakaSpringbloom.value]}"})}},
          ModTypeNames.Barbara.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraHeadDiffuse.dds", f"BarbaraHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraHeadLightMap.dds", f"BarbaraHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraHead.ib", f"BarbaraHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraBodyDiffuse.dds", f"BarbaraBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraBodyLightMap.dds", f"BarbaraBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraBody.ib", f"BarbaraBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraDressDiffuse.dds", f"BarbaraDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                 "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraDressLightMap.dds", f"BarbaraDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                 IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraDress.ib", f"BarbaraDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                        IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraBlend.buf", f"BarbaraBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                        IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraPosition.buf", f"BarbaraPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                        IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Barbara/4_0/BarbaraTexcoord.buf", f"BarbaraTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Barbara.value]}"})}},
          ModTypeNames.BarbaraSummertime.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeHeadDiffuse.dds", f"BarbaraSummertimeHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                          "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeHeadLightMap.dds", f"BarbaraSummertimeHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                          IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeHead.ib", f"BarbaraSummertimeHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                 "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeBodyDiffuse.dds", f"BarbaraSummertimeBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                          "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeBodyLightMap.dds", f"BarbaraSummertimeBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                          IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeBody.ib", f"BarbaraSummertimeBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                 "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeDressDiffuse.dds", f"BarbaraSummertimeDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                           "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeDressLightMap.dds", f"BarbaraSummertimeDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                           IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeDress.ib", f"BarbaraSummertimeDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                 IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeBlend.buf", f"BarbaraSummertimeBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                                 IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimePosition.buf", f"BarbaraSummertimePosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                                 IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/BarbaraSummertime/4_0/BarbaraSummertimeTexcoord.buf", f"BarbaraSummertimeTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.BarbaraSummertime.value]}"})}},                                       
          ModTypeNames.Diluc.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucHeadDiffuse.dds", f"DilucHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucHeadLightMap.dds", f"DilucHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucHead.ib", f"DilucHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucBodyDiffuse.dds", f"DilucBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucBodyLightMap.dds", f"DilucBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucBody.ib", f"DilucBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucBlend.buf", f"DilucBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                     IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucPosition.buf", f"DilucPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                     IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Diluc/4_0/DilucTexcoord.buf", f"DilucTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Diluc.value]}"})}},
          ModTypeNames.DilucFlamme.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeHeadDiffuse.dds", f"DilucFlammeHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeHeadLightMap.dds", f"DilucFlammeHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeHead.ib", f"DilucFlammeHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeBodyDiffuse.dds", f"DilucFlammeBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeBodyLightMap.dds", f"DilucFlammeBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeBody.ib", f"DilucFlammeBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeDressDiffuse.dds", f"DilucFlammeDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                     "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeDressLightMap.dds", f"DilucFlammeDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                     IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeDress.ib", f"DilucFlammeDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeBlend.buf", f"DilucFlammeBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                           IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammePosition.buf", f"DilucFlammePosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                           IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/DilucFlamme/4_0/DilucFlammeTexcoord.buf", f"DilucFlammeTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.DilucFlamme.value]}"})}},
          ModTypeNames.Fischl.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlHeadDiffuse.dds", f"FischlHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlHeadLightMap.dds", f"FischlHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlHead.ib", f"FischlHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlBodyDiffuse.dds", f"FischlBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlBodyLightMap.dds", f"FischlBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlBody.ib", f"FischlBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlDressDiffuse.dds", f"FischlDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlDressLightMap.dds", f"FischlDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlDress.ib", f"FischlDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlBlend.buf", f"FischlBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                      IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlPosition.buf", f"FischlPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                      IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Fischl/4_0/FischlTexcoord.buf", f"FischlTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Fischl.value]}"})}},
          ModTypeNames.FischlHighness.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessHeadDiffuse.dds", f"FischlHighnessHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                       "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessHeadLightMap.dds", f"FischlHighnessHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessHead.ib", f"FischlHighnessHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                              "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessBodyDiffuse.dds", f"FischlHighnessBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                       "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessBodyLightMap.dds", f"FischlHighnessBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessBody.ib", f"FischlHighnessBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                              IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessBlend.buf", f"FischlHighnessBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                              IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessPosition.buf", f"FischlHighnessPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                              IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/FischlHighness/4_0/FischlHighnessTexcoord.buf", f"FischlHighnessTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.FischlHighness.value]}"})}},
          ModTypeNames.Ganyu.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuHeadDiffuse.dds", f"GanyuHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuHeadLightMap.dds", f"GanyuHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuHead.ib", f"GanyuHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuBodyDiffuse.dds", f"GanyuBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuBodyLightMap.dds", f"GanyuBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuBody.ib", f"GanyuBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuDressDiffuse.dds", f"GanyuDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuDressLightMap.dds", f"GanyuDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuDress.ib", f"GanyuDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuBlend.buf", f"GanyuBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                     IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuPosition.buf", f"GanyuPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                     IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Ganyu/4_0/GanyuTexcoord.buf", f"GanyuTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Ganyu.value]}"})}},
          ModTypeNames.HuTao.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoHeadDiffuse.dds", f"HuTaoHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoHeadLightMap.dds", f"HuTaoHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoHead.ib", f"HuTaoHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoBodyDiffuse.dds", f"HuTaoBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoBodyLightMap.dds", f"HuTaoBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoBody.ib", f"HuTaoBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoBlend.buf", f"HuTaoBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                     IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoPosition.buf", f"HuTaoPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                     IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/HuTao/4_0/HuTaoTexcoord.buf", f"HuTaoTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.HuTao.value]}"})}},
          ModTypeNames.Jean.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanHeadDiffuse.dds", f"JeanHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                             "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanHeadLightMap.dds", f"JeanHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                             IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanHead.ib", f"JeanHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanBodyDiffuse.dds", f"JeanBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                             "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanBodyLightMap.dds", f"JeanBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                             IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanBody.ib", f"JeanBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanBlend.buf", f"JeanBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                    IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanPosition.buf", f"JeanPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                    IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Jean/4_0/JeanTexcoord.buf", f"JeanTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Jean.value]}"})}},
          ModTypeNames.JeanCN.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNHeadDiffuse.dds", f"JeanCNHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNHeadLightMap.dds", f"JeanCNHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNHead.ib", f"JeanCNHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNBodyDiffuse.dds", f"JeanCNBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNBodyLightMap.dds", f"JeanCNBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNBody.ib", f"JeanCNBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNBlend.buf", f"JeanCNBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                      IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNPosition.buf", f"JeanCNPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                      IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/JeanCN/4_0/JeanCNTexcoord.buf", f"JeanCNTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.JeanCN.value]}"})}},
          ModTypeNames.JeanSea.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaHeadDiffuse.dds", f"JeanSeaHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaHeadLightMap.dds", f"JeanSeaHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaHead.ib", f"JeanSeaHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaBodyDiffuse.dds", f"JeanSeaBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaBodyLightMap.dds", f"JeanSeaBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaBody.ib", f"JeanSeaBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaDressDiffuse.dds", f"JeanSeaDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                 "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaDressLightMap.dds", f"JeanSeaDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                 IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaDress.ib", f"JeanSeaDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                        IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaBlend.buf", f"JeanSeaBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                        IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaPosition.buf", f"JeanSeaPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                        IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/JeanSea/4_0/JeanSeaTexcoord.buf", f"JeanSeaTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.JeanSea.value]}"})}},
          ModTypeNames.Kaeya.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaHeadDiffuse.dds", f"KaeyaHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaHeadLightMap.dds", f"KaeyaHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaHead.ib", f"KaeyaHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaBodyDiffuse.dds", f"KaeyaBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaBodyLightMap.dds", f"KaeyaBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaBody.ib", f"KaeyaBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaDressDiffuse.dds", f"KaeyaDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaDressLightMap.dds", f"KaeyaDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaDress.ib", f"KaeyaDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaBlend.buf", f"KaeyaBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                     IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaPosition.buf", f"KaeyaPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                     IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Kaeya/4_0/KaeyaTexcoord.buf", f"KaeyaTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Kaeya.value]}"})}},
          ModTypeNames.KaeyaSailwind.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindHeadDiffuse.dds", f"KaeyaSailwindHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindHeadLightMap.dds", f"KaeyaSailwindHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindHead.ib", f"KaeyaSailwindHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindBodyDiffuse.dds", f"KaeyaSailwindBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindBodyLightMap.dds", f"KaeyaSailwindBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindBody.ib", f"KaeyaSailwindBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindDressDiffuse.dds", f"KaeyaSailwindDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                       "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindDressLightMap.dds", f"KaeyaSailwindDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindDress.ib", f"KaeyaSailwindDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindBlend.buf", f"KaeyaSailwindBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                             IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindPosition.buf", f"KaeyaSailwindPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                             IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/KaeyaSailwind/4_0/KaeyaSailwindTexcoord.buf", f"KaeyaSailwindTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.KaeyaSailwind.value]}"})}},
          ModTypeNames.Keqing.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingHeadDiffuse.dds", f"KeqingHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingHeadLightMap.dds", f"KeqingHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingHead.ib", f"KeqingHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingBodyDiffuse.dds", f"KeqingBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingBodyLightMap.dds", f"KeqingBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingBody.ib", f"KeqingBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingDressDiffuse.dds", f"KeqingDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingDressLightMap.dds", f"KeqingDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingDress.ib", f"KeqingDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingBlend.buf", f"KeqingBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                      IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingPosition.buf", f"KeqingPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                      IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Keqing/4_0/KeqingTexcoord.buf", f"KeqingTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Keqing.value]}"})}},
          ModTypeNames.KeqingOpulent.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentHeadDiffuse.dds", f"KeqingOpulentHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentHeadLightMap.dds", f"KeqingOpulentHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentHead.ib", f"KeqingOpulentHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentBodyDiffuse.dds", f"KeqingOpulentBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentBodyLightMap.dds", f"KeqingOpulentBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentBody.ib", f"KeqingOpulentBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentBlend.buf", f"KeqingOpulentBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                             IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentPosition.buf", f"KeqingOpulentPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                             IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/KeqingOpulent/4_0/KeqingOpulentTexcoord.buf", f"KeqingOpulentTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.KeqingOpulent.value]}"})}},
          ModTypeNames.Kirara.value: {"head": {"ps-t0": DownloadData("NormalMap", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraHeadNormalMap.dds", f"KiraraHeadNormalMap{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraHeadDiffuse.dds", f"KiraraHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraHeadLightMap.dds", f"KiraraHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraHead.ib", f"KiraraHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "body": {"ps-t0": DownloadData("NormalMap", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraBodyNormalMap.dds", f"KiraraBodyNormalMap{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraBodyDiffuse.dds", f"KiraraBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraBodyLightMap.dds", f"KiraraBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraBody.ib", f"KiraraBodys{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "dress": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraDressDiffuse.dds", f"KiraraDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraDressLightMap.dds", f"KiraraDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraDress.ib", f"KiraraDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraBlend.buf", f"KiraraBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                      IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraPosition.buf", f"KiraraPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                      IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraTexcoord.buf", f"KiraraTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Kirara.value]}"})}},
          ModTypeNames.Klee.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleeHeadDiffuse.dds", f"KleeHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                             "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleeHeadLightMap.dds", f"KleeHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                             IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleeHead.ib", f"KleeHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleeBodyDiffuse.dds", f"KleeBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                             "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleeBodyLightMap.dds", f"KleeBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                             IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleeBody.ib", f"KleeBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleeBlend.buf", f"KleeBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                    IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleePosition.buf", f"KleePosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                    IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Klee/4_0/KleeTexcoord.buf", f"KleeTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Klee.value]}"})}},
          ModTypeNames.KleeBlossomingStarlight.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightHeadDiffuse.dds", f"KleeBlossomingStarlightHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightHeadLightMap.dds", f"KleeBlossomingStarlightHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightHead.ib", f"KleeBlossomingStarlightHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                       "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightBodyDiffuse.dds", f"KleeBlossomingStarlightBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightBodyLightMap.dds", f"KleeBlossomingStarlightBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightBody.ib", f"KleeBlossomingStarlightBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                       "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightDressDiffuse.dds", f"KleeBlossomingStarlightDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                                 "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightDressLightMap.dds", f"KleeBlossomingStarlightDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                                 IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightDress.ib", f"KleeBlossomingStarlightDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                       IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightBlend.buf", f"KleeBlossomingStarlightBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                                       IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightPosition.buf", f"KleeBlossomingStarlightPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                                       IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/KleeBlossomingStarlight/4_0/KleeBlossomingStarlightTexcoord.buf", f"KleeBlossomingStarlightTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.KleeBlossomingStarlight.value]}"})}},
          ModTypeNames.Lisa.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaHeadDiffuse.dds", f"LisaHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                             "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaHeadLightMap.dds", f"LisaHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                             IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaHead.ib", f"LisaHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaBodyDiffuse.dds", f"LisaBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                             "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaBodyLightMap.dds", f"LisaBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                             IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaBody.ib", f"LisaBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaDressDiffuse.dds", f"LisaDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaDressLightMap.dds", f"LisaDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaDress.ib", f"LisaDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaBlend.buf", f"LisaBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                    IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaPosition.buf", f"LisaPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                    IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Lisa/4_0/LisaTexcoord.buf", f"LisaTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Lisa.value]}"})}},
          ModTypeNames.LisaStudent.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentHeadDiffuse.dds", f"LisaStudentHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentHeadLightMap.dds", f"LisaStudentHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentHead.ib", f"LisaStudentHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "body": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentBodyDiffuse.dds", f"LisaStudentBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentBodyLightMap.dds", f"LisaStudentBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentBody.ib", f"LisaStudentBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentBlend.buf", f"LisaStudentBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                           IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentPosition.buf", f"LisaStudentPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                           IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentTexcoord.buf", f"LisaStudentTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.LisaStudent.value]}"})}},
          ModTypeNames.Mona.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaHeadDiffuse.dds", f"MonaHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                             "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaHeadLightMap.dds", f"MonaHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                             IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaHead.ib", f"MonaHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaBodyDiffuse.dds", f"MonaBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                             "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaBodyLightMap.dds", f"MonaBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                             IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaBody.ib", f"MonaBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                    IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaBlend.buf", f"MonaBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                    IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaPosition.buf", f"MonaPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                    IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Mona/4_0/MonaTexcoord.buf", f"MonaTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Mona.value]}"})}},
          ModTypeNames.MonaCN.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNHeadDiffuse.dds", f"MonaCNHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNHeadLightMap.dds", f"MonaCNHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNHead.ib", f"MonaCNHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNBodyDiffuse.dds", f"MonaCNBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNBodyLightMap.dds", f"MonaCNBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNBody.ib", f"MonaCNBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNBlend.buf", f"MonaCNBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                      IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNPosition.buf", f"MonaCNPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                      IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/MonaCN/4_0/MonaCNTexcoord.buf", f"MonaCNTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.MonaCN.value]}"})}},
          ModTypeNames.Nilou.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouHeadDiffuse.dds", f"NilouHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouHeadLightMap.dds", f"NilouHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouHead.ib", f"NilouHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouBodyDiffuse.dds", f"NilouBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouBodyLightMap.dds", f"NilouBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouBody.ib", f"NilouBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "dress": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouDressDiffuse.dds", f"NilouDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouDressLightMap.dds", f"NilouDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouDress.ib", f"NilouDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouBlend.buf", f"NilouBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                     IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouPosition.buf", f"NilouPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                     IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouTexcoord.buf", f"NilouTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Nilou.value]}"})}},
          ModTypeNames.Ningguang.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangHeadDiffuse.dds", f"NingguangHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                  "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangHeadLightMap.dds", f"NingguangHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                  IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangHead.ib", f"NingguangHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangBodyDiffuse.dds", f"NingguangBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                  "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangBodyLightMap.dds", f"NingguangBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                  IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangBody.ib", f"NingguangBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangDressDiffuse.dds", f"NingguangDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                   "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangDressLightMap.dds", f"NingguangDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                   IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangDress.ib", f"NingguangDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangBlend.buf", f"NingguangBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                         IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangPosition.buf", f"NingguangPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                         IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Ningguang/4_0/NingguangTexcoord.buf", f"NingguangTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Ningguang.value]}"})}},
          ModTypeNames.NingguangOrchid.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidHeadDiffuse.dds", f"NingguangOrchidHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                        "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidHeadLightMap.dds", f"NingguangOrchidHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                        IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidHead.ib", f"NingguangOrchidHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                               "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidBodyDiffuse.dds", f"NingguangOrchidBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                        "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidBodyLightMap.dds", f"NingguangOrchidBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                        IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidBody.ib", f"NingguangOrchidBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                               "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidDressDiffuse.dds", f"NingguangOrchidDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                         "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidDressLightMap.dds", f"NingguangOrchidDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                         IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidDress.ib", f"NingguangOrchidDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidBlend.buf", f"NingguangOrchidBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                                IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidPosition.buf", f"NingguangOrchidPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                                IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/NingguangOrchid/4_0/NingguangOrchidTexcoord.buf", f"NingguangOrchidTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.NingguangOrchid.value]}"})}},
          ModTypeNames.Rosaria.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaHeadDiffuse.dds", f"RosariaHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaHeadLightMap.dds", f"RosariaHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaHead.ib", f"RosariaHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaBodyDiffuse.dds", f"RosariaBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaBodyLightMap.dds", f"RosariaBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaBody.ib", f"RosariaBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaDressDiffuse.dds", f"RosariaDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                 "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaDressLightMap.dds", f"RosariaDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                 IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaDress.ib", f"RosariaDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "extra": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaExtraDiffuse.dds", f"RosariaExtraDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                 "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaExtraLightMap.dds", f"RosariaExtraLightMap{IniKeywords.RemapDL.value}.dds")),
                                                 IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaExtra.ib", f"RosariaExtra{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                        IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaBlend.buf", f"RosariaBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                        IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaPosition.buf", f"RosariaPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                        IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Rosaria/4_0/RosariaTexcoord.buf", f"RosariaTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Rosaria.value]}"})}},
          ModTypeNames.RosariaCN.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNHeadDiffuse.dds", f"RosariaCNHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                  "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNHeadLightMap.dds", f"RosariaCNHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                  IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNHead.ib", f"RosariaCNHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNBodyDiffuse.dds", f"RosariaCNBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                  "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNBodyLightMap.dds", f"RosariaCNBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                  IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNBody.ib", f"RosariaCNBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNDressDiffuse.dds", f"RosariaCNDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                   "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNDressLightMap.dds", f"RosariaCNDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                   IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNDress.ib", f"RosariaCNDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         "extra": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNExtraDiffuse.dds", f"RosariaCNExtraDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                   "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNExtraLightMap.dds", f"RosariaCNExtraLightMap{IniKeywords.RemapDL.value}.dds")),
                                                   IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNExtra.ib", f"RosariaCNExtra{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNBlend.buf", f"RosariaCNBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                         IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNPosition.buf", f"RosariaCNPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                         IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/RosariaCN/4_0/RosariaCNTexcoord.buf", f"RosariaCNTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.RosariaCN.value]}"})}},
          ModTypeNames.Shenhe.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheHeadDiffuse.dds", f"ShenheHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheHeadLightMap.dds", f"ShenheHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheHead.ib", f"ShenheHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheBodyDiffuse.dds", f"ShenheBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheBodyLightMap.dds", f"ShenheBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheBody.ib", f"ShenheBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheDressDiffuse.dds", f"ShenheDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheDressLightMap.dds", f"ShenheDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheDress.ib", f"ShenheDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheBlend.buf", f"ShenheBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                      IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenhePosition.buf", f"ShenhePosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                      IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Shenhe/4_0/ShenheTexcoord.buf", f"ShenheTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Shenhe.value]}"})}},
          ModTypeNames.Xiangling.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingHeadDiffuse.dds", f"XianglingHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                  "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingHeadLightMap.dds", f"XianglingHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                  IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingHead.ib", f"XianglingHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingBodyDiffuse.dds", f"XianglingBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                  "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingBodyLightMap.dds", f"XianglingBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                  IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingBody.ib", f"XianglingBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingDressDiffuse.dds", f"XianglingDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                   "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingDressLightMap.dds", f"XianglingDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                   IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingDress.ib", f"XianglingDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                         IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingBlend.buf", f"XianglingBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                         IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingPosition.buf", f"XianglingPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                         IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Xiangling/4_0/XianglingTexcoord.buf", f"XianglingTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Xiangling.value]}"})}},
          ModTypeNames.Xingqiu.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuHeadDiffuse.dds", f"XingqiuHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuHeadLightMap.dds", f"XingqiuHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuHead.ib", f"XingqiuHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuBodyDiffuse.dds", f"XingqiuBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuBodyLightMap.dds", f"XingqiuBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuBody.ib", f"XingqiuBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                       IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuBlend.buf", f"XingqiuBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                       IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuPosition.buf", f"XingqiuPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                       IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Xingqiu/4_0/XingqiuTexcoord.buf", f"XingqiuTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Xingqiu.value]}"})}}},
    4.4: {ModTypeNames.GanyuTwilight.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightHeadDiffuse.dds", f"GanyuTwilightHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightHeadLightMap.dds", f"GanyuTwilightHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightHead.ib", f"GanyuTwilightHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "body": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightBodyDiffuse.dds", f"GanyuTwilightBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightBodyLightMap.dds", f"GanyuTwilightBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightBody.ib", f"GanyuTwilightBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "dress": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightDressDiffuse.dds", f"GanyuTwilightDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                       "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightDressLightMap.dds", f"GanyuTwilightDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightDress.ib", f"GanyuTwilightDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightBlend.buf", f"GanyuTwilightBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                             IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightPosition.buf", f"GanyuTwilightPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                             IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightTexcoord.buf", f"GanyuTwilightTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.4][ModTypeNames.GanyuTwilight.value]}"})}},
          ModTypeNames.ShenheFrostFlower.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerHeadDiffuse.dds", f"ShenheFrostFlowerHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                          "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerHeadLightMap.dds", f"ShenheFrostFlowerHeasdLightMap{IniKeywords.RemapDL.value}.dds")),
                                                          IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerHead.ib", f"ShenheFrostFlowerHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                 "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerBodyDiffuse.dds", f"ShenheFrostFlowerBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                          "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerBodyLightMap.dds", f"ShenheFrostFlowerBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                          IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerBody.ib", f"ShenheFrostFlowerBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                 "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerDressDiffuse.dds", f"ShenheFrostFlowerDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                           "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerDressLightMap.dds", f"ShenheFrostFlowerDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                           IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerDress.ib", f"ShenheFrostFlowerDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                 "extra": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerExtraDiffuse.dds", f"ShenheFrostFlowerExtraDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                           "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerExtraLightMap.dds", f"ShenheFrostFlowerExtraLightMap{IniKeywords.RemapDL.value}.dds")),
                                                           IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerExtra.ib", f"ShenheFrostFlowerExtra{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                 IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerBlend.buf", f"ShenheFrostFlowerBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                                 IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerPosition.buf", f"ShenheFrostFlowerPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                                 IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/ShenheFrostFlower/4_4/ShenheFrostFlowerTexcoord.buf", f"ShenheFrostFlowerTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.4][ModTypeNames.ShenheFrostFlower.value]}"})}},
          ModTypeNames.XingqiuBamboo.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooHeadDiffuse.dds", f"XingqiuBambooHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooHeadLightMap.dds", f"XingqiuBambooHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooHead.ib", f"XingqiuBambooHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooBodyDiffuse.dds", f"XingqiuBambooBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooBodyLightMap.dds", f"XingqiuBambooBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooBody.ib", f"XingqiuBambooBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooDressDiffuse.dds", f"XingqiuBambooDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                       "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooDressLightMap.dds", f"XingqiuBambooDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooDress.ib", f"XingqiuBambooDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooBlend.buf", f"XingqiuBambooBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                             IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooPosition.buf", f"XingqiuBambooPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                             IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/XingqiuBamboo/4_4/XingqiuBambooTexcoord.buf", f"XingqiuBambooTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.4][ModTypeNames.XingqiuBamboo.value]}"})}}},
    4.8: {ModTypeNames.KiraraBoots.value: {"head": {"ps-t0": DownloadData("NormalMap", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsHeadNormalMap.dds", f"KiraraBootsHeadNormalMap{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsHeadDiffuse.dds", f"KiraraBootsHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsHeadLightMap.dds", f"KiraraBootsHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsHead.ib", f"KiraraBootsHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "body": {"ps-t0": DownloadData("NormalMap", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsBodyNormalMap.dds", f"KiraraBootsBodyNormalMap{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsBodyDiffuse.dds", f"KiraraBootsBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsBodyLightMap.dds", f"KiraraBootsBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsBody.ib", f"KiraraBootsBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "dress": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsDressDiffuse.dds", f"KiraraBootsDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                     "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsDressLightMap.dds", f"KiraraBootsDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                     IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsDress.ib", f"KiraraBootsDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsBlend.buf", f"KiraraBootsBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                           IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsPosition.buf", f"KiraraBootsPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                           IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsTexcoord.buf", f"KiraraBootsTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.8][ModTypeNames.KiraraBoots.value]}"})}},
          ModTypeNames.NilouBreeze.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeHeadDiffuse.dds", f"NilouBreezeHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GGI/NilouBreeze/4_8/NilouBreezeHeadLightMap.dds", f"NilouBreezeHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeHead.ib", f"NilouBreezeHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeBodyDiffuse.dds", f"NilouBreezeBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeBodyLightMap.dds", f"NilouBreezeBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeBody.ib", f"NilouBreezeBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeDressDiffuse.dds", f"NilouBreezeDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                     "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeDressLightMap.dds", f"NilouBreezeDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                     IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeDress.ib", f"NilouBreezeDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeBlend.buf", f"NilouBreezeBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                           IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezePosition.buf", f"NilouBreezePosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                           IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/NilouBreeze/4_8/NilouBreezeTexcoord.buf", f"NilouBreezeTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.8][ModTypeNames.NilouBreeze.value]}"})}}},
    5.3: {ModTypeNames.CherryHuTao.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoHeadDiffuse.dds", f"CherryHuTaoHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoHeadLightMap.dds", f"CherryHuTaoHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoHead.ib", f"CherryHuTaoHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoBodyDiffuse.dds", f"CherryHuTaoBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoBodyLightMap.dds", f"CherryHuTaoBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoBody.ib", f"CherryHuTaoBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "dress": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoDressDiffuse.dds", f"CherryHuTaoDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                     "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoDressLightMap.dds", f"CherryHuTaoDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                     IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoDress.ib", f"CherryHuTaoDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "extra": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoExtraDiffuse.dds", f"CherryHuTaoExtraDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                     IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoExtra.ib", f"CherryHuTaoExtra{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoBlend.buf", f"CherryHuTaoBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                           IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoPosition.buf", f"CherryHuTaoPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                           IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/CherryHuTao/5_3/CherryHuTaoTexcoord.buf", f"CherryHuTaoTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[5.3][ModTypeNames.CherryHuTao.value]}"})}},
          ModTypeNames.XianglingCheer.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerHeadDiffuse.dds", f"XianglingCheerHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                       "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerHeadLightMap.dds", f"XianglingCheerHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerHead.ib", f"XianglingCheerHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                              "body": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerBodyDiffuse.dds", f"XianglingCheerBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                       "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerBodyLightMap.dds", f"XianglingCheerBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerBody.ib", f"XianglingCheerBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                              IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerBlend.buf", f"XianglingCheerBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                              IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerPosition.buf", f"XianglingCheerPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                              IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/XianglingCheer/5_3/XianglingCheerTexcoord.buf", f"XianglingCheerTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[5.3][ModTypeNames.XianglingCheer.value]}"})}}},
    5.4: {ModTypeNames.AyakaSpringbloom.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomHeadDiffuse.dds", f"AyakaSpringBloomHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                         "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomHeadLightMap.dds", f"AyakaSpringBloomHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                         IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomHead.ib", f"AyakaSpringBloomHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                "body": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomBodyDiffuse.dds", f"AyakaSpringBloomBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                         "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomBodyLightMap.dds", f"AyakaSpringBloomBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                         IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomBody.ib", f"AyakaSpringBloomBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomDressDiffuse.dds", f"AyakaSpringBloomDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                          "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomDressLightMap.dds", f"AyakaSpringBloomDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                          IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomDress.ib", f"AyakaSpringBloomDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomBlend.buf", f"AyakaSpringBloomBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                                IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomPosition.buf", f"AyakaSpringBloomPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                                IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/5_4/AyakaSpringBloomTexcoord.buf", f"AyakaSpringBloomTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.AyakaSpringbloom.value]}"})}},
          ModTypeNames.LisaStudent.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentHeadDiffuse.dds", f"LisaStudentHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentHeadLightMap.dds", f"LisaStudentHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentHead.ib", f"LisaStudentHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           "body": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentBodyDiffuse.dds", f"LisaStudentBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                    "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentBodyLightMap.dds", f"LisaStudentBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                    IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentBody.ib", f"LisaStudentBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                           IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentBlend.buf", f"LisaStudentBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                           IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentPosition.buf", f"LisaStudentPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                           IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/5_4/LisaStudentTexcoord.buf", f"LisaStudentTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.LisaStudent.value]}"})}},
          ModTypeNames.Nilou.value: {"head": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouHeadDiffuse.dds", f"NilouHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouHeadLightMap.dds", f"NilouHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouHead.ib", f"NilouHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouBodyDiffuse.dds", f"NilouBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouBodyLightMap.dds", f"NilouBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouBody.ib", f"NilouBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "dress": {"ps-t1": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouDressDiffuse.dds", f"NilouDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t2": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouDressLightMap.dds", f"NilouDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouDress.ib", f"NilouDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     IniKeywords.Blend.value: {IniKeywords.Vb1.value: BlendDownloadData("Blend", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouBlend.buf", f"NilouBlend{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "32"})},
                                     IniKeywords.Position.value: {IniKeywords.Vb0.value: DownloadData("Position", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouPosition.buf", f"NilouPosition{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": "40"})},
                                     IniKeywords.Texcoord.value: {IniKeywords.Vb1.value: DownloadData("Texcoord", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/5_4/NilouTexcoord.buf", f"NilouTexcoord{IniKeywords.RemapDL.value}.buf"), resourceKeys = {"type": "Buffer", "stride": f"{TexcoordByteSizeData[4.0][ModTypeNames.Nilou.value]}"})}}},
    5.7: {ModTypeNames.AyakaSpringbloom.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomHeadDiffuse.dds", f"AyakaSpringBloomHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                         "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomHeadLightMap.dds", f"AyakaSpringBloomHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                         IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomHead.ib", f"AyakaSpringBloomHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                                "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomBodyDiffuse.dds", f"AyakaSpringBloomBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                         "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomBodyLightMap.dds", f"AyakaSpringBloomBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                         IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/AyakaSpringbloom/4_0/AyakaSpringBloomBody.ib", f"AyakaSpringBloomBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})}},
        ModTypeNames.GanyuTwilight.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightHeadDiffuse.dds", f"GanyuTwilightHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightHeadLightMap.dds", f"GanyuTwilightHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightHead.ib", f"GanyuTwilightHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightBodyDiffuse.dds", f"GanyuTwilightBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                      "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightBodyLightMap.dds", f"GanyuTwilightBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                      IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightBody.ib", f"GanyuTwilightBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                             "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightDressDiffuse.dds", f"GanyuTwilightDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                       "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightDressLightMap.dds", f"GanyuTwilightDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                       IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/GanyuTwilight/4_4/GanyuTwilightDress.ib", f"GanyuTwilightDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},},
        ModTypeNames.Kirara.value: {"body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraBodyDiffuse.dds", f"KiraraBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraBodyLightMap.dds", f"KiraraBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraBody.ib", f"KiraraBodys{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                      "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraDressDiffuse.dds", f"KiraraDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraDressLightMap.dds", f"KiraraDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Kirara/4_0/KiraraDress.ib", f"KiraraDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})}},
        ModTypeNames.KiraraBoots.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsHeadDiffuse.dds", f"KiraraBootsHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                  "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsHeadLightMap.dds", f"KiraraBootsHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                        IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsHead.ib", f"KiraraBootsHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                        "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsBodyDiffuse.dds", f"KiraraBootsBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsBodyLightMap.dds", f"KiraraBootsBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/KiraraBoots/4_8/KiraraBootsBody.ib", f"KiraraBootsBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})}},
        ModTypeNames.LisaStudent.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentHeadDiffuse.dds", f"LisaStudentHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                  "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentHeadLightMap.dds", f"LisaStudentHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentHead.ib", f"LisaStudentHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                        "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentBodyDiffuse.dds", f"LisaStudentBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                                "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentBodyLightMap.dds", f"LisaStudentBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                                IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/LisaStudent/4_0/LisaStudentBody.ib", f"LisaStudentBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})}},
          ModTypeNames.Nilou.value: {"head": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouHeadDiffuse.dds", f"NilouHeadDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouHeadLightMap.dds", f"NilouHeadLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouHead.ib", f"NilouHead{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "body": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouBodyDiffuse.dds", f"NilouBodyDiffuse{IniKeywords.RemapDL.value}.dds")),
                                              "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouBodyLightMap.dds", f"NilouBodyLightMap{IniKeywords.RemapDL.value}.dds")),
                                              IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouBody.ib", f"NilouBody{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})},
                                     "dress": {"ps-t0": DownloadData("Diffuse", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouDressDiffuse.dds", f"NilouDressDiffuse{IniKeywords.RemapDL.value}.dds")),
                                               "ps-t1": DownloadData("LightMap", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouDressLightMap.dds", f"NilouDressLightMap{IniKeywords.RemapDL.value}.dds")),
                                               IniKeywords.Ib.value: DownloadData("Ib", FileDownload(f"{GithubDownloadFolder}/GI/Nilou/4_0/NilouDress.ib", f"NilouDress{IniKeywords.RemapDL.value}.ib"), resourceKeys = {"type": "Buffer", "format": "DXGI_FORMAT_R32_UINT"})}}}
}


# IniParseBuilderFunc: Class to define how the IniParseBuilder arguments for some
#   mod is built for a particular game version
class IniParseBuilderFuncs():
    @classmethod
    def giDefault(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIParser, [], {})
    
    @classmethod
    def amber4_0(cls):
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Amber.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Amber.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Amber.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Amber.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Amber.value]["body"]},})
    
    @classmethod
    def amberCN4_0(cls):
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.AmberCN.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.AmberCN.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.AmberCN.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.AmberCN.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.AmberCN.value]["body"]}})

    @classmethod
    def _ayakaEditDressDiffuse(cls, texFile: TextureFile) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        TexEditor.setTransparency(texFile, 177)

    @classmethod
    def _ayakaEditHeadDiffuse(cls, texFile: TextureFile) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        TexEditor.setTransparency(texFile, 1)

    @classmethod
    def ayaka4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}],
                {"texEdits": {"head": {"ps-t0": {"TransparentDiffuse": TexEditor(filters = [TexMetadataFilter(edits = {TexMetadataNames.Gamma.value: 1 / ColourConsts.StandardGamma.value}),
                                                                                            cls._ayakaEditHeadDiffuse])}},
                              "body": {"ps-t1": {"BrightLightMap": TexEditor(filters = [TransparencyAdjustFilter(-78)])}},
                              "dress": {"ps-t0": {"OpaqueDiffuse": TexEditor(filters = [cls._ayakaEditDressDiffuse,
                                                                                        TexMetadataFilter(edits = {TexMetadataNames.Gamma.value: 1 / ColourConsts.StandardGamma.value})])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Ayaka.value][IniKeywords.Blend.value],
                                 IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Ayaka.value][IniKeywords.Position.value],
                                 IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Ayaka.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Ayaka.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Ayaka.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Ayaka.value]["dress"]}})
    
    @classmethod
    def _ayakaSpringbloomEditLightMap5_6(cls, texFile: TextureFile):
        alphaImg = texFile.img.getchannel('A')
        alphaImg = alphaImg.point(lambda alphaPixel: Colour.boundColourChannel(alphaPixel + 200) if (alphaPixel <= 200) else alphaPixel)
        texFile.img.putalpha(alphaImg)

    @classmethod
    def ayakaSpringbloom4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Blend.value],
                                 IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Position.value],
                                 IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value]["dress"]}})
    
    @classmethod
    def ayakaSpringbloom5_6(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {"head": {"ps-t2": {"HeadShadeLightMap": TexEditor(filters = [ColourReplaceFilter(Colour(0, 128, 0, 1), coloursToReplace = {ColourRange(Colour(0, 125, 0, 255), Colour(50, 160, 50, 255))}),
                                                                                           ColourReplaceFilter(Colours.LightMapGreen.value, 
                                                                                                               coloursToReplace = {ColourRange(Colour(0, 125, 0, 100), Colour(50, 160, 50, 254)),
                                                                                                                                   ColourRange(Colour(0, 0, 0, 100), Colour(0, 0, 0, 200))})])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Blend.value],
                                IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Position.value],
                                IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value]["head"],
                                    "body": FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value]["body"],
                                    "dress": FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value]["dress"]}})
    
    @classmethod
    def ayakaSpingbloomEditBodyDiffuse5_7(cls, texFile: TextureFile):
        TexEditor.setTransparency(texFile, 1)
    
    @classmethod
    def ayakaSpringbloom5_7(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        headShadeLightMapTexEditor = TexEditor(filters = [ColourReplaceFilter(Colour(0, 128, 0, 1), coloursToReplace = {ColourRange(Colour(0, 125, 0, 255), Colour(50, 160, 50, 255))}),
                                                                                           ColourReplaceFilter(Colours.LightMapGreen.value, 
                                                                                                               coloursToReplace = {ColourRange(Colour(0, 125, 0, 100), Colour(50, 160, 50, 254)),
                                                                                                                                   ColourRange(Colour(0, 0, 0, 100), Colour(0, 0, 0, 200))})])
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {"head": {"ps-t1": {"HeadAltShadeLightMap": headShadeLightMapTexEditor},
                                       "ps-t2": {"HeadShadeLightMap": headShadeLightMapTexEditor}},
                              "body": {"ps-t1": {"BodyTransparentDiffuse": TexEditor(filters = [cls.ayakaSpingbloomEditBodyDiffuse5_7]),
                                                 "BodyAltOpaqueGreenLightMap": TexEditor(filters = [TransparencyAdjustFilter(255, coloursToFilter = {ColourRanges.LightMapGreen.value})])},
                                       "ps-t0": {"BodyAltTransparentDiffuse": TexEditor(filters = [cls.ayakaSpingbloomEditBodyDiffuse5_7])},
                                       "ps-t2": {"BodyOpaqueGreenLightMap": TexEditor(filters = [TransparencyAdjustFilter(255, coloursToFilter = {ColourRanges.LightMapGreen.value})])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Blend.value],
                                IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Position.value],
                                IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[5.7][ModTypeNames.AyakaSpringbloom.value]["head"],
                                    "body": FileDownloadData[5.7][ModTypeNames.AyakaSpringbloom.value]["body"],
                                    "dress": FileDownloadData[4.0][ModTypeNames.AyakaSpringbloom.value]["dress"]}})

    @classmethod
    def arlecchino5_4(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {
                    "head": {"ps-t0": {"YellowHeadNormal": TexEditor(filters = [ColourReplaceFilter(Colours.NormalMapYellow.value, coloursToReplace = {ColourRanges.NormalMapPurple1.value})])}},
                    "body": {"ps-t0": {"YellowBodyNormal": TexEditor(filters = [ColourReplaceFilter(Colours.NormalMapYellow.value)])}},
                }})
    
    @classmethod
    def barbara4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Barbara.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Barbara.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Barbara.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Barbara.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Barbara.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Barbara.value]["dress"]}})
    
    @classmethod
    def barbaraSummertime4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.BarbaraSummertime.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.BarbaraSummertime.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.BarbaraSummertime.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.BarbaraSummertime.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.BarbaraSummertime.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.BarbaraSummertime.value]["dress"]}})
    
    @classmethod
    def cherryHutao5_3(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress", "extra"}],
                {"texEdits": {"body": {"ps-t0": {"TransparentBodyDiffuse": TexEditor(filters = [InvertAlphaFilter()])},
                                       "ps-t1": {"OpaqueBodyLightMap": TexEditor(filters = [TexMetadataFilter(edits = {TexMetadataNames.Gamma.value: 1}),
                                                                                           ColourReplaceFilter(Colours.LightMapGreen.value, 
                                                                                                               coloursToReplace = {ColourRange(Colour(0, 120, 110, 65), Colour(255, 140, 255, 75)),
                                                                                                                                   ColourRange(Colour(0, 120, 0, 65), Colour(255, 140, 200, 75)),
                                                                                                                                   ColourRange(Colour(0, 0, 200, 65), Colour(30, 30, 255, 75))})])}},
                              "dress": {"ps-t1": {"TransparentyDressDiffuse": TexEditor(filters = [InvertAlphaFilter()])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[5.3][ModTypeNames.CherryHuTao.value][IniKeywords.Blend.value],
                                 IniKeywords.Position.value: FileDownloadData[5.3][ModTypeNames.CherryHuTao.value][IniKeywords.Position.value],
                                 IniKeywords.Texcoord.value: FileDownloadData[5.3][ModTypeNames.CherryHuTao.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[5.3][ModTypeNames.CherryHuTao.value]["head"],
                                     "body": FileDownloadData[5.3][ModTypeNames.CherryHuTao.value]["body"],
                                     "dress": FileDownloadData[5.3][ModTypeNames.CherryHuTao.value]["dress"],
                                     "extra": FileDownloadData[5.3][ModTypeNames.CherryHuTao.value]["extra"]}})
    
    @classmethod
    def diluc4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Diluc.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Diluc.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Diluc.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Diluc.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Diluc.value]["body"]}})
    
    @classmethod
    def dilucFlamme4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}],
                {"texEdits": {"body": {"ps-t0": {"TransparentBodyDiffuse": TexEditor(filters = [InvertAlphaFilter(),
                                                                                                ColourReplaceFilter(Colour(0, 0, 0, 177), 
                                                                                                                    coloursToReplace = {ColourRange(Colour(0, 0, 0, 125), Colour(0, 0, 0, 130))})])}},
                              "dress": {"ps-t0": {"TransparentDressDiffuse": TexEditor(filters = [InvertAlphaFilter()])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.DilucFlamme.value][IniKeywords.Blend.value],
                                 IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.DilucFlamme.value][IniKeywords.Position.value],
                                 IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.DilucFlamme.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.DilucFlamme.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.DilucFlamme.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.DilucFlamme.value]["dress"]}})
    
    @classmethod
    def fischl4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Fischl.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Fischl.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Fischl.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Fischl.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Fischl.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Fischl.value]["dress"]}})
    
    @classmethod
    def fischlHighness4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.FischlHighness.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.FischlHighness.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.FischlHighness.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.FischlHighness.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.FischlHighness.value]["body"]}})
    
    @classmethod
    def _ganyuEditHeadDiffuse(cls, texFile: TextureFile):
        TexEditor.setTransparency(texFile, 0)
    
    @classmethod
    def ganyu4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {"head": {"ps-t0": {"DarkDiffuse": TexEditor(filters = [cls._ganyuEditHeadDiffuse,
                                                                                    TexMetadataFilter(edits = {TexMetadataNames.Gamma.value: 1 / ColourConsts.StandardGamma.value})])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Ganyu.value][IniKeywords.Blend.value],
                                 IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Ganyu.value][IniKeywords.Position.value],
                                 IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Ganyu.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Ganyu.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Ganyu.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Ganyu.value]["dress"]}})
    
    @classmethod
    def ganyuTwilight4_4(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value]["head"],
                                     "body": FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value]["body"],
                                     "dress": FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value]["dress"]}})
    
    @classmethod
    def ganyuTwilight5_7(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.4][ModTypeNames.GanyuTwilight.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[5.7][ModTypeNames.GanyuTwilight.value]["head"],
                                     "body": FileDownloadData[5.7][ModTypeNames.GanyuTwilight.value]["body"],
                                     "dress": FileDownloadData[5.7][ModTypeNames.GanyuTwilight.value]["dress"]}})
    
    @classmethod
    def _hutaoEditHeadDiffuse(cls, texFile: TextureFile):
        TexEditor.setTransparency(texFile, 1)
    
    @classmethod
    def hutao4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}],
                {"texEdits": {"head": {"ps-t0": {"TransparentHeadDiffuse": TexEditor(filters = [cls._hutaoEditHeadDiffuse])}}},
                 "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.HuTao.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.HuTao.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.HuTao.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.HuTao.value]["head"],
                                      "body": FileDownloadData[4.0][ModTypeNames.HuTao.value]["body"]}})
    
    @classmethod
    def jean4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Jean.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Jean.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Jean.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Jean.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Jean.value]["body"]}})
    
    @classmethod
    def jeanCN4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.JeanCN.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.JeanCN.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.JeanCN.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.JeanCN.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.JeanCN.value]["body"]}})
    
    @classmethod
    def jeanSea4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.JeanSea.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.JeanSea.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.JeanSea.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.JeanSea.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.JeanSea.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.JeanSea.value]["dress"]}})
    
    @classmethod
    def _jeanEditBodyLightMap5_5(cls, texFile: TextureFile):
        alphaImg = texFile.img.getchannel('A')
        alphaImg = alphaImg.point(lambda alphaPixel: Colour.boundColourChannel(alphaPixel + 77) if (alphaPixel <= 77) else alphaPixel)
        texFile.img.putalpha(alphaImg)
    
    @classmethod
    def jean5_5(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"texEdits": {"body": {"ps-t1": {"ShadeLightMap": TexEditor(filters = [cls._jeanEditBodyLightMap5_5])}}},
                 "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Jean.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Jean.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Jean.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Jean.value]["head"],
                                      "body": FileDownloadData[4.0][ModTypeNames.Jean.value]["body"]}})
    
    @classmethod
    def jeanCN5_5(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser,
                [{"head", "body"}], 
                {"texEdits": {"body": {"ps-t1": {"ShadeLightMap": TexEditor(filters = [cls._jeanEditBodyLightMap5_5])}}},
                 "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.JeanCN.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.JeanCN.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.JeanCN.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.JeanCN.value]["head"],
                                      "body": FileDownloadData[4.0][ModTypeNames.JeanCN.value]["body"]}})
    
    @classmethod
    def kaeya4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser,
                [{"head", "body", "dress"}],
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Kaeya.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Kaeya.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Kaeya.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Kaeya.value]["head"],
                                      "body": FileDownloadData[4.0][ModTypeNames.Kaeya.value]["body"],
                                      "dress": FileDownloadData[4.0][ModTypeNames.Kaeya.value]["dress"]}})
    
    @classmethod
    def kaeyaSailwind4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser,
                [{"head", "body", "dress"}],
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.KaeyaSailwind.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.KaeyaSailwind.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.KaeyaSailwind.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.KaeyaSailwind.value]["head"],
                                      "body": FileDownloadData[4.0][ModTypeNames.KaeyaSailwind.value]["body"],
                                      "dress": FileDownloadData[4.0][ModTypeNames.KaeyaSailwind.value]["dress"]}})
    
    @classmethod
    def _keqingEditDressDiffuse(cls, texFile: TextureFile):
        TexEditor.setTransparency(texFile, 255)

    @classmethod
    def _keqingEditHeadDiffuse(cls, texFile: TextureFile):
        TexEditor.setTransparency(texFile, 255)
    
    @classmethod
    def keqing4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {"dress": {"ps-t0": {"OpaqueDressDiffuse": TexEditor(filters = [cls._keqingEditDressDiffuse])}},
                              "head": {"ps-t0": {"OpaqueHeadDiffuse": TexEditor(filters = [cls._keqingEditHeadDiffuse])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Keqing.value][IniKeywords.Blend.value],
                                 IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Keqing.value][IniKeywords.Position.value],
                                 IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Keqing.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Keqing.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Keqing.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Keqing.value]["dress"]}})
    
    @classmethod
    def keqingOpulent4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"texEdits": {"head": {"ps-t1": {"NonReflectiveLightMap": TexEditor(filters = [TransparencyAdjustFilter(255, coloursToFilter = {ColourRange(Colour(20, 0, 20, 0), Colour(225, 0, 225, 254)),
                                                                                                                                                ColourRange(Colour(120, 120, 50, 0), Colour(140, 140, 70, 254))})])}}}})
    
    @classmethod
    def kirara4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {"dress": {"ps-t2": {"WhitenLightMap": TexEditor(filters = [ColourReplaceFilter(Colours.White.value, coloursToReplace = {ColourRanges.LightMapGreen.value}, replaceAlpha = False)])}}},
                 "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Kirara.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Kirara.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Kirara.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Kirara.value]["head"],
                                      "body": FileDownloadData[4.0][ModTypeNames.Kirara.value]["body"],
                                      "dress": FileDownloadData[4.0][ModTypeNames.Kirara.value]["dress"]}})
    
    @classmethod
    def kirara5_7(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {
                 "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Kirara.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Kirara.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Kirara.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Kirara.value]["head"],
                                      "body": FileDownloadData[5.7][ModTypeNames.Kirara.value]["body"],
                                      "dress": FileDownloadData[5.7][ModTypeNames.Kirara.value]["dress"]}})

    @classmethod
    def kiraraBoots4_8(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.8][ModTypeNames.KiraraBoots.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.8][ModTypeNames.KiraraBoots.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.8][ModTypeNames.KiraraBoots.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.8][ModTypeNames.KiraraBoots.value]["head"],
                                      "body": FileDownloadData[4.8][ModTypeNames.KiraraBoots.value]["body"],
                                      "dress": FileDownloadData[4.8][ModTypeNames.KiraraBoots.value]["dress"]}})
    
    @classmethod
    def kiraraBoots5_7(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.8][ModTypeNames.KiraraBoots.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.8][ModTypeNames.KiraraBoots.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.8][ModTypeNames.KiraraBoots.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[5.7][ModTypeNames.KiraraBoots.value]["head"],
                                      "body": FileDownloadData[5.7][ModTypeNames.KiraraBoots.value]["body"],
                                      "dress": FileDownloadData[4.8][ModTypeNames.KiraraBoots.value]["dress"]}})
    
    @classmethod
    def klee4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"texEdits": {"body": {"ps-t1": {"GreenLightMap": TexEditor(filters = [ColourReplaceFilter(Colour(0, 128, 0, 177), 
                                                                                                            coloursToReplace = {ColourRange(Colour(0, 0, 0, 250), Colour(0, 0, 0, 255)),
                                                                                                                                ColourRange(Colour(0, 0, 0, 125), Colour(0 ,0 ,0, 130))}, replaceAlpha = True)])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Klee.value][IniKeywords.Blend.value],
                                 IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Klee.value][IniKeywords.Position.value],
                                 IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Klee.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Klee.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Klee.value]["body"]}})

    @classmethod
    def kleeBlossomingStarlight4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {"dress": {"ps-t0": {"TransparentDiffuse": TexEditor(filters = [InvertAlphaFilter()])}}},
                 "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.KleeBlossomingStarlight.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.KleeBlossomingStarlight.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.KleeBlossomingStarlight.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.KleeBlossomingStarlight.value]["head"],
                                      "body": FileDownloadData[4.0][ModTypeNames.KleeBlossomingStarlight.value]["body"],
                                      "dress": FileDownloadData[4.0][ModTypeNames.KleeBlossomingStarlight.value]["dress"]}})
    
    @classmethod
    def lisa4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Lisa.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Lisa.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Lisa.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Lisa.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Lisa.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Lisa.value]["dress"]}})
    
    @classmethod
    def lisaStudent4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.LisaStudent.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.LisaStudent.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.LisaStudent.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.LisaStudent.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.LisaStudent.value]["body"]}})
    
    @classmethod
    def lisaStudent5_7(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.LisaStudent.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.LisaStudent.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.LisaStudent.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[5.7][ModTypeNames.LisaStudent.value]["head"],
                                     "body": FileDownloadData[5.7][ModTypeNames.LisaStudent.value]["body"]}})
    
    @classmethod
    def mona4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Mona.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Mona.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Mona.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Mona.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Mona.value]["body"]}})
    
    @classmethod
    def monaCN4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.MonaCN.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.MonaCN.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.MonaCN.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.MonaCN.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.MonaCN.value]["body"]}})
    
    @classmethod
    def nilou4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Nilou.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Nilou.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Nilou.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Nilou.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Nilou.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Nilou.value]["dress"]}})
    
    @classmethod
    def nilou5_7(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Nilou.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Nilou.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Nilou.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[5.7][ModTypeNames.Nilou.value]["head"],
                                     "body": FileDownloadData[5.7][ModTypeNames.Nilou.value]["body"],
                                     "dress": FileDownloadData[5.7][ModTypeNames.Nilou.value]["dress"]}})
    
    @classmethod
    def nilouBreeze4_8(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.8][ModTypeNames.NilouBreeze.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.8][ModTypeNames.NilouBreeze.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.8][ModTypeNames.NilouBreeze.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.8][ModTypeNames.NilouBreeze.value]["head"],
                                     "body": FileDownloadData[4.8][ModTypeNames.NilouBreeze.value]["body"],
                                     "dress": FileDownloadData[4.8][ModTypeNames.NilouBreeze.value]["dress"]}})
    
    @classmethod
    def _ningguangEditHeadDiffuse(cls, texFile: TextureFile):
        TexEditor.setTransparency(texFile, 0)
    
    @classmethod
    def ningguang4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {"head": {"ps-t0": {"DarkDiffuse": TexEditor(filters = [cls._ningguangEditHeadDiffuse,
                                                                                    TexMetadataFilter(edits = {TexMetadataNames.Gamma.value: 1 / ColourConsts.StandardGamma.value})])}}},
                "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Ningguang.value][IniKeywords.Blend.value],
                                 IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Ningguang.value][IniKeywords.Position.value],
                                 IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Ningguang.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Ningguang.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Ningguang.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Ningguang.value]["dress"]}})

    @classmethod
    def ningguangOrchid4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.NingguangOrchid.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.NingguangOrchid.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.NingguangOrchid.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.NingguangOrchid.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.NingguangOrchid.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.NingguangOrchid.value]["dress"]}})
    
    @classmethod
    def rosaria4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress", "extra"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Rosaria.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Rosaria.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Rosaria.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Rosaria.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Rosaria.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Rosaria.value]["dress"],
                                     "extra": FileDownloadData[4.0][ModTypeNames.Rosaria.value]["extra"]}})
    
    @classmethod
    def rosariaCN4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress", "extra"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.RosariaCN.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.RosariaCN.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.RosariaCN.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.RosariaCN.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.RosariaCN.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.RosariaCN.value]["dress"],
                                     "extra": FileDownloadData[4.0][ModTypeNames.RosariaCN.value]["extra"]}})

    @classmethod
    def shenhe4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Shenhe.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Shenhe.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Shenhe.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Shenhe.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Shenhe.value]["body"],
                                     "dress": FileDownloadData[4.0][ModTypeNames.Shenhe.value]["dress"]}})
    
    @classmethod
    def shenheFrostFlower4_4(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress", "extra"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.4][ModTypeNames.ShenheFrostFlower.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.4][ModTypeNames.ShenheFrostFlower.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.4][ModTypeNames.ShenheFrostFlower.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.4][ModTypeNames.ShenheFrostFlower.value]["head"],
                                     "body": FileDownloadData[4.4][ModTypeNames.ShenheFrostFlower.value]["body"],
                                     "dress": FileDownloadData[4.4][ModTypeNames.ShenheFrostFlower.value]["dress"],
                                     "extra": FileDownloadData[4.4][ModTypeNames.ShenheFrostFlower.value]["extra"]}})
    
    @classmethod
    def _xianlingEditHeadDiffuse_4_0(cls, texFile: TextureFile):
        TexEditor.setTransparency(texFile, 1)
    
    @classmethod
    def xiangling4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"texEdits": {"head": {"ps-t0": {"DarkDiffuse": TexEditor(filters = [cls._xianlingEditHeadDiffuse_4_0])}}},
                 "bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Xiangling.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Xiangling.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Xiangling.value][IniKeywords.Texcoord.value]},
                 "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Xiangling.value]["head"],
                                      "body": FileDownloadData[4.0][ModTypeNames.Xiangling.value]["body"],
                                      "dress": FileDownloadData[4.0][ModTypeNames.Xiangling.value]["dress"]}})
    
    @classmethod
    def xianglingCheer5_3(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
            [{"head", "body"}], 
            {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[5.3][ModTypeNames.XianglingCheer.value][IniKeywords.Blend.value],
                              IniKeywords.Position.value: FileDownloadData[5.3][ModTypeNames.XianglingCheer.value][IniKeywords.Position.value],
                              IniKeywords.Texcoord.value: FileDownloadData[5.3][ModTypeNames.XianglingCheer.value][IniKeywords.Texcoord.value]},
            "objFileDownloads": {"head": FileDownloadData[5.3][ModTypeNames.XianglingCheer.value]["head"],
                                 "body": FileDownloadData[5.3][ModTypeNames.XianglingCheer.value]["body"]}})
    
    @classmethod
    def xingqiu4_0(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.0][ModTypeNames.Xingqiu.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.0][ModTypeNames.Xingqiu.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.0][ModTypeNames.Xingqiu.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.0][ModTypeNames.Xingqiu.value]["head"],
                                     "body": FileDownloadData[4.0][ModTypeNames.Xingqiu.value]["body"]}})
    
    @classmethod
    def xingqiuBamboo4_4(cls) -> Tuple[BaseIniParser, List[Any], Dict[str, Any]]:
        return (GIMIObjParser, 
                [{"head", "body", "dress"}], 
                {"bufDownloads": {IniKeywords.Blend.value: FileDownloadData[4.4][ModTypeNames.XingqiuBamboo.value][IniKeywords.Blend.value],
                                  IniKeywords.Position.value: FileDownloadData[4.4][ModTypeNames.XingqiuBamboo.value][IniKeywords.Position.value],
                                  IniKeywords.Texcoord.value: FileDownloadData[4.4][ModTypeNames.XingqiuBamboo.value][IniKeywords.Texcoord.value]},
                "objFileDownloads": {"head": FileDownloadData[4.4][ModTypeNames.XingqiuBamboo.value]["head"],
                                     "body": FileDownloadData[4.4][ModTypeNames.XingqiuBamboo.value]["body"],
                                     "dress": FileDownloadData[4.4][ModTypeNames.XingqiuBamboo.value]["dress"]}})


IniParseBuilderData = {
    4.0: {ModTypeNames.Amber.value: IniParseBuilderFuncs.amber4_0,
          ModTypeNames.AmberCN.value: IniParseBuilderFuncs.amberCN4_0,
          ModTypeNames.Ayaka.value: IniParseBuilderFuncs.ayaka4_0,
          ModTypeNames.AyakaSpringbloom.value: IniParseBuilderFuncs.ayakaSpringbloom4_0,
          ModTypeNames.Barbara.value: IniParseBuilderFuncs.barbara4_0,
          ModTypeNames.BarbaraSummertime.value: IniParseBuilderFuncs.barbaraSummertime4_0,
          ModTypeNames.Diluc.value: IniParseBuilderFuncs.diluc4_0,
          ModTypeNames.DilucFlamme.value: IniParseBuilderFuncs.dilucFlamme4_0,
          ModTypeNames.Fischl.value: IniParseBuilderFuncs.fischl4_0,
          ModTypeNames.FischlHighness.value: IniParseBuilderFuncs.fischlHighness4_0,
          ModTypeNames.Ganyu.value: IniParseBuilderFuncs.ganyu4_0,
          ModTypeNames.HuTao.value: IniParseBuilderFuncs.hutao4_0,
          ModTypeNames.Jean.value: IniParseBuilderFuncs.jean4_0,
          ModTypeNames.JeanCN.value: IniParseBuilderFuncs.jeanCN4_0,
          ModTypeNames.JeanSea.value: IniParseBuilderFuncs.jeanSea4_0,
          ModTypeNames.Kaeya.value: IniParseBuilderFuncs.kaeya4_0,
          ModTypeNames.KaeyaSailwind.value: IniParseBuilderFuncs.kaeyaSailwind4_0,
          ModTypeNames.Keqing.value: IniParseBuilderFuncs.keqing4_0,
          ModTypeNames.KeqingOpulent.value: IniParseBuilderFuncs.keqingOpulent4_0,
          ModTypeNames.Kirara.value: IniParseBuilderFuncs.kirara4_0,
          ModTypeNames.Klee.value: IniParseBuilderFuncs.klee4_0,
          ModTypeNames.KleeBlossomingStarlight.value:  IniParseBuilderFuncs.kleeBlossomingStarlight4_0,
          ModTypeNames.Lisa.value: IniParseBuilderFuncs.lisa4_0,
          ModTypeNames.LisaStudent.value: IniParseBuilderFuncs.lisaStudent4_0,
          ModTypeNames.Mona.value: IniParseBuilderFuncs.mona4_0,
          ModTypeNames.MonaCN.value: IniParseBuilderFuncs.monaCN4_0,
          ModTypeNames.Nilou.value: IniParseBuilderFuncs.nilou4_0,
          ModTypeNames.Ningguang.value: IniParseBuilderFuncs.ningguang4_0,
          ModTypeNames.NingguangOrchid.value: IniParseBuilderFuncs.ningguangOrchid4_0,
          ModTypeNames.Raiden.value: IniParseBuilderFuncs.giDefault,
          ModTypeNames.Rosaria.value: IniParseBuilderFuncs.rosaria4_0,
          ModTypeNames.RosariaCN.value: IniParseBuilderFuncs.rosariaCN4_0,
          ModTypeNames.Shenhe.value: IniParseBuilderFuncs.shenhe4_0,
          ModTypeNames.Xiangling.value: IniParseBuilderFuncs.xiangling4_0,
          ModTypeNames.Xingqiu.value: IniParseBuilderFuncs.xingqiu4_0},

    4.4: {ModTypeNames.GanyuTwilight.value: IniParseBuilderFuncs.ganyuTwilight4_4,
          ModTypeNames.ShenheFrostFlower.value: IniParseBuilderFuncs.shenheFrostFlower4_4,
          ModTypeNames.XingqiuBamboo.value: IniParseBuilderFuncs.xingqiuBamboo4_4},

    4.6: {ModTypeNames.Arlecchino.value: IniParseBuilderFuncs.giDefault},

    4.8: {ModTypeNames.KiraraBoots.value: IniParseBuilderFuncs.kiraraBoots4_8,
          ModTypeNames.NilouBreeze.value: IniParseBuilderFuncs.nilouBreeze4_8},

    5.3: {ModTypeNames.CherryHuTao.value: IniParseBuilderFuncs.cherryHutao5_3,
          ModTypeNames.XianglingCheer.value: IniParseBuilderFuncs.xianglingCheer5_3},

    5.4: {ModTypeNames.Arlecchino.value: IniParseBuilderFuncs.arlecchino5_4},

    5.5: {ModTypeNames.Jean.value: IniParseBuilderFuncs.jean5_5,
          ModTypeNames.JeanCN.value: IniParseBuilderFuncs.jeanCN5_5},

    5.6: {ModTypeNames.AyakaSpringbloom.value: IniParseBuilderFuncs.ayakaSpringbloom5_6},

    5.7: {ModTypeNames.AyakaSpringbloom.value: IniParseBuilderFuncs.ayakaSpringbloom5_7,
          ModTypeNames.GanyuTwilight.value: IniParseBuilderFuncs.ganyuTwilight5_7,
          ModTypeNames.Kirara.value: IniParseBuilderFuncs.kirara5_7,
          ModTypeNames.KiraraBoots.value: IniParseBuilderFuncs.kiraraBoots5_7,
          ModTypeNames.LisaStudent.value: IniParseBuilderFuncs.lisaStudent5_7,
          ModTypeNames.Nilou.value: IniParseBuilderFuncs.nilou5_7}
}


class IniParseBuilderArgs(ModDictAssets[Callable[[], Tuple[BaseIniParser, List[Any], Dict[str, Any]]]]):
    """
    This class inherits from :class:`ModDictAssets`
    
    Class for managing functions that create the arguments/keyword arguments for an :class:`IniParseBuilder`

    Parameters
    ----------
    repo: Optional[Dict[:class:`str`, Dict[:class:`str`, Callable[[], Tuple[:class:`BaseIniParser` , List[Any], Dict[:class:`str`, Any]]]]]]
        The original source for any the function that create arguments :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value contains the functions that create arguments/keyword arguments for an :class:`IniParseBuilder`  :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, will use the default functions provided by the software :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Optional[Dict[str, Dict[str, Callable[[], Tuple[BaseIniParser, List[Any], Dict[str, Any]]]]]] = None):
        if (repo is None):
            repo = IniParseBuilderData

        super().__init__(repo)


class IntTools():
    """
    Tools for handling integers
    """

    @classmethod
    def toBase(cls, num: int, base: int) -> Tuple[List[int], bool]:
        """
        Converts a base 10 number to an arbitrary base number

        Parameters
        ----------
        num: :class:`int`
            The base 10 number to convert

        base: :class:`int`
            The base to convert to

        Raises
        ------
        :class:`ZeroDivisionError`
            The base is smaller or equal to 1

        Returns
        -------
        Tuple[List[:class:`int`], :class:`bool`]
            Retrieves the following data in the tuple:

            #. The digits in the converted number
            #. Whether the number is negative
        """

        if (base <= 1):
            raise ZeroDivisionError("Base must be greater than 1")

        if num == 0:
            return ([0], False)

        digits = []
        isNegative = num < 0

        if (isNegative):
            num *= -1

        while num:
            digits.append(int(num % base))
            num //= base

        return (digits[::-1], isNegative)
    
    @classmethod
    def toStrBase(cls, num: int, base: int, getDigit: Union[str, List[str], Callable[[int], str]], negativeChar: str) -> str:
        """
        Converts a base 10 number to an arbitrary base number, such that the characters in this arbitrary based number
        are all characters

        Parameters
        ----------
        num: :class:`int`
            The base 10 number to convert

        base: :class:`int`
            The base to convert to

        getDigit: Union[:class:`str`, List[:class:`str`], Callable[[:class:`int`], :class:`str`]]
            how to get the string representation of a digit. :raw-html:`<br />` :raw-html:`<br />`

            If this argument is a string or a list, each element is the string representation of the digit at the particular index of the string/list.

        negativeChar: :class:`str`
            The character representation for the negative symbol

        Returns
        -------
        :class:`str`
            The converted string representation of the arbitrary base number
        """

        digits, isNegative = cls.toBase(num, base)

        tempChars = getDigit
        if (not callable(getDigit)):
            getDigit = lambda digit: tempChars[digit]

        result = "".join(list(map(getDigit, digits)))
        if (isNegative):
            return negativeChar + result
        return result
    
    @classmethod
    def toBase64(cls, num: int, getDigit: Optional[Union[str, List[str], Callable[[int], str]]] = None, negativeChar: str = "-") -> str:
        """
        Converts a base 10 number to a base 64 number

        Parameters
        ----------
        num: :class:`int`
            The base 10 number to convert

        getDigit: Optional[Union[:class:`str`, List[:class:`str`], Callable[[:class:`int`], :class:`str`]]]
            how to get the string representation of a digit. :raw-html:`<br />` :raw-html:`<br />`

            * If this argument is a string or a list, each element is the string representation of the digit at the particular index of the string/list.
            * If this argument is ``None``, then will use the following string for each digit:

              ``ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_``

              This is the same digit representation as the `standard base 64`_ except that the 63rd digit (``/``) is replaced with the ``_`` character :raw-html:`<br />` :raw-html:`<br />`

              **Default**: ``None``

        negativeChar: :class:`str`
            The character representation for the negative symbol :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``"-"``

        Returns
        -------
        :class:`str`
            The converted string representation of the arbitrary base 64 number
        """

        if (getDigit is None):
            getDigit = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_"

        return cls.toStrBase(num, 64, getDigit, negativeChar)


class HashTools():
    """
    Tools for custom hashing
    """

    Base64SmallHashMap = {}
    Base64SmallDeterministicHashMap = {}
    Base64SmallHashMaxVal = 2 ** 16

    @classmethod
    def clear(cls):
        cls.Base64SmallHashMap.clear()
        cls.Base64SmallDeterministicHashMap.clear()

    @classmethod
    def base64Hash(cls, obj: Hashable, hashFunc: Optional[Callable[[Hashable], int]] =None) -> str:
        """
        Converts the hash to base 64

        Parameters
        ----------
        obj: Hashable
            The object to hash

        hashFunc: Optional[Callable[[Hashable], :class:`int`]]
            The base hash function to use. :raw-html:`<br />` :raw-html:`<br />`

            if this value is ``None``, then the hash function will be the `builtin hash`_ :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`str`
            The base 64 hash
        """

        if (hashFunc is None):
            hashFunc = hash

        hashVal = hashFunc(obj)
        return IntTools.toBase64(hashVal)

    @classmethod
    def _genericBase64ShortUniqueHash(cls, obj: Hashable, hashFunc: Callable[[Hashable], int], hashMap: Dict[str, Dict[Hashable, str]]) -> str:
        hashFuncWrapper = lambda objToHash: hashFunc(objToHash) % cls.Base64SmallHashMaxVal
        hashVal = cls.base64Hash(obj, hashFunc = hashFuncWrapper)

        if (hashVal not in hashMap):
            hashMap[hashVal] = {}

        hashVals = hashMap[hashVal]
        hashValsLen = len(hashVals)

        if (obj not in hashVals):
            hashInd = cls.base64Hash(hashValsLen, hashFunc = hashFuncWrapper)
            hashVals[obj] = hashInd
            hashValsLen += 1
        else:
            hashInd = hashVals[obj]

        # collisions
        if (hashValsLen > 1):
            return f"{hashVal},{hashInd}"
        return f"{hashVal}"
    
    @classmethod
    def base64ShortUniqueHash(cls, obj: Hashable) -> str:
        """
        Converts the hash from `builtin hash`_ function to a unique and unique and short base 64 hash

        Parameters
        ----------
        obj: Hashable
            The object to hash

        Returns
        -------
        :class:`str`
            The unique base 64 hash
        """

        return cls._genericBase64ShortUniqueHash(obj, hash, cls.Base64SmallHashMap)
    
    @classmethod
    def _hashLibSerialize(cls, obj: Hashable):
        if isinstance(obj, (int, float, str, bool, type(None))):
            return obj
        if isinstance(obj, (list, tuple)):
            return [cls._hashLibSerialize(item) for item in obj]
        if isinstance(obj, dict):
            return {k: cls._hashLibSerialize(v) for k, v in sorted(obj.items())}
        
        # Handle custom objects
        return {k: cls._hashLibSerialize(v) for k, v in sorted(obj.__dict__.items()) if not k.startswith('_')}
    
    @classmethod
    def hashLibSerialize(cls, obj: Hashable) -> bytes:
        """
        Convert some hashable into bytes used for the `hashlib` library

        Parameters
        ----------
        obj: Hashable
            The object to convert

        Returns
        -------
        :class:`bytes`
            The resultant bytes converted from the object
        """

        serializedData = cls._hashLibSerialize(obj)
        return json.dumps(serializedData, sort_keys=True).encode('utf-8')
    
    @classmethod
    def _base64DeterministicShortUniqueHashFunc(cls, obj: Hashable):
        if (not isinstance(obj, bytes)):
            obj = cls.hashLibSerialize(obj)

        md5Hash = hashlib.md5(obj)
        digestBytes = md5Hash.digest()
        result = int.from_bytes(digestBytes, byteorder='big')
        return result

    @classmethod
    def base64DeterministicShortUniqueHash(cls, obj: Hashable) -> str:
        """
        Converts the hash from a naive hash function that acts as incrementor to a unique and short base 64 hash

        Parameters
        ----------
        obj: Hashable
            The object to hash

        Returns
        -------
        :class:`str`
            The unique base 64 hash
        """

        return cls._genericBase64ShortUniqueHash(obj, cls._base64DeterministicShortUniqueHashFunc, cls.Base64SmallDeterministicHashMap)


class TexCreator(BaseTexEditor):
    """
    This class inherits from :class:`BaseTexEditor`

    Creates a brand new .dds file if the file doe not exist
    """

    def __init__(self, width: int, height: int, colour: Optional[Colour] = None):
        self.width = width
        self.height = height
        self.colour = Colours.White.value if (colour is None) else colour

    def fix(self, texFile: "TextureFile", fixedTexFile: str):
        if (os.path.isfile(texFile.src)):
            return
        
        Image = GlobalPackageManager.get(PackageModules.PIL_Image.value)

        img = Image.new(mode = ImgFormats.RGBA.value, size=(self.width, self.height), color = self.colour.getTuple())
        texFile.src = fixedTexFile
        texFile.save(img = img)


class RegTexAdd(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for adding new texture .dds files to a :class:`IfContentPart`

    Parameters
    ----------
    textures: Optional[Dict[:class:`str`, Dict[:class:`str`, Tuple[:class:`str`, :class:`TexCreator`, :class:`bool`]]]]
        New texture .dds files to be created :raw-html:`<br />` :raw-html:`<br />`

        * The outer key are the names of the mod object
        * The inner keys are the names of the register
        * The inner values contanis:
            #. The name of the type of texture file
            #. The object that will create the new texture file

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ("EmptyNormalMap", :class:`TexCreator`(4096, 1024))}, "body": {"ps-t3": ("NewLightMap", :class:`TexCreator`(1024, 1024, :class:`Colour`(0, 128, 0, 255))), "ps-t0": ("DummyShadowRamp", :class:`Colour`())}}`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    mustAdd: :class:`bool`
        Whether the texture files will still be created for a particular :class:`IfContentPart` even if the corresponding register for the texture file does not exist within that particular :class:`IfContentPart`

    Attributes
    ----------
    textures: Dict[:class:`str`, Dict[:class:`str`, Tuple[:class:`str`, :class:`TexCreator`]]]
        New texture .dds files to be created :raw-html:`<br />` :raw-html:`<br />`

        * The outer key are the names of the mod object
        * The inner keys are the names of the register
        * The inner values contanis:
            #. The name of the type of texture file
            #. The object that will create the new texture file

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ("EmptyNormalMap", :class:`TexCreator`(4096, 1024))}, "body": {"ps-t3": ("NewLightMap", :class:`TexCreator`(1024, 1024, :class:`Colour`(0, 128, 0, 255))), "ps-t0": ("DummySshadowRamp", :class:`Colour`())}}``

    mustAdd: :class:`bool`
        Whether the texture files will still be created for a particular :class:`IfContentPart` even if the corresponding register for the texture file does not exist within that particular :class:`IfContentPart`

    _regAddVals: Optional[Dict[:class:`str`, :class:`str`]]
        The texture additions to do on the current :class:`IfContentPart` being parsed :raw-html:`<br />` :raw-html:`<br />`

        The keys are the name of the registers and the values are the `section`_ names for the textures
    """

    def __init__(self, textures: Optional[Dict[str, Dict[str, Tuple[str, TexCreator]]]] = None, mustAdd: bool = True):
        self.textures = {} if (textures is None) else textures
        self.mustAdd = mustAdd
        self._regAddVals: Optional[Dict[str, str]] = None

    def clear(self):
        self._regAddVals = None
    
    def _editReg(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        texAdds = None
        try:
            texAdds = self.textures[obj]
        except KeyError:
            return part

        self._regAddVals = {}
        for reg in texAdds:
            texAddData = texAdds[reg]
            texTypeName = texAddData[0]

            name = None
            try:
                fixer._texAddRemapNames[texTypeName]
            except KeyError:
                fixer._texAddRemapNames[texTypeName] = {}

            try:
                name = fixer._texAddRemapNames[texTypeName][obj]
            except KeyError:
                name = fixer.getTexResourceRemapFixName(texTypeName, modType.name, fixModName, obj)
                fixer._texAddRemapNames[texTypeName][obj] = name

            self._regAddVals[reg] = name

        part.replaceVals(self._regAddVals, addNewKVPs = self.mustAdd)
        return part
    
    def handleTexAdd(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regAddVals is not None):
            fixer._currentTexAddsRegs.update(set(self._regAddVals.keys()))
    
    def handleTexEdit(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regAddVals is not None):
            fixer._currentTexEditRegs = fixer._currentTexEditRegs.difference(set(self._regAddVals.keys()))


class GIMIObjReplaceFixer(GIMIFixer):
    """
    This class inherits from :class:`GIMIFixer`

    Base class to fix a .ini file used by a GIMI related importer where particular mod objects (head, body, dress, etc...) in the mod to remap are replaced by other mod objectss

    Parameters
    ----------
    parser: :class:`GIMIObjParser`
        The associated parser to retrieve data for the fix

    preRegEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart`. 
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`

        Whether these filters reference the mod objects to be fixed of the new mod objects of the fixed mods 
        is determined by :attr:`GIMIObjReplaceFixer.preRegEditOldObj` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    postRegEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the new mod objects of the fixed mods. 
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`
        
        .. note::
            These filters are preceded by the filters at :attr:`GIMIObjReplaceFixer.preRegEditFilters`

        :raw-html:`<br />`

        **Default**: ``None``

    preRegEditOldObj: :class:`bool`
        Whether the register editting filters at :attr:`GIMIObjReplaceFixer.preRegEditFilters`
        reference the original mod objects of the mod to be fixed or the new mod objects of the fixed mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    postModelRegEditFilters: Optional[List[:class:`RegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the `sections`_ related to the .VB or .IB of a mod
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    preRegEditOldObj: :class:`bool`
        Whether the register editting filters at :attr:`GIMIObjReplaceFixer.preRegEditFilters`
        reference the original mod objects of the mod to be fixed or the new mod objects of the fixed mods

    addedTextures: Dict[:class:`str`, Dict[:class:`str`, Tuple[:class:`str`, :class:`TexCreator`]]]
        The textures to be newly created :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the name of the mod objects
        * The inner keys are the name of the registers
        * The inner values is a tuple that contains:

            # The name of the texture
            # The texture creator for making the new texture

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ("EmptyNormalMap", :class:`TexCreator`(4096, 1024))}, "body": {"ps-t3": ("NewLightMap", :class:`TexCreator`(1024, 1024, :class:`Colour`(0, 128, 0, 255))), "ps-t0": ("DummyShadowRamp", :class:`Colour`())}}``
    """

    def __init__(self, parser: GIMIObjParser, preRegEditFilters: Optional[List[BaseRegEditFilter]] = None, postRegEditFilters: Optional[List[BaseRegEditFilter]] = None,
                 preRegEditOldObj: bool = True, postModelRegEditFilters: Optional[List[RegEditFilter]] = None):
        super().__init__(parser, postModelRegEditFilters = postModelRegEditFilters)
        self._texInds: Dict[str, Dict[str, int]] = {}
        self._texEditRemapNames: Dict[str, Dict[str, str]] = {}
        self._texAddRemapNames: Dict[str, Dict[str, str]] = {}
        self.preRegEditOldObj = preRegEditOldObj

        self.addedTextures: Dict[str, Dict[str, Tuple[str, TexCreator]]] = {}
        self.preRegEditFilters = [] if (preRegEditFilters is None) else preRegEditFilters
        self.postRegEditFilters = [] if (postRegEditFilters is None) else postRegEditFilters

        self._currentTexAddsRegs: Set[str] = set()
        self._currentTexEditRegs: Set[str] = set()
        self._currentRegTexEdits: Dict[str, Tuple[str, str]] = {}

        self._referencedTexEditSections: Dict[str, Set[str]] = {}
        self._referencedTexAdds: Set[str] = set()


    def _combineAddedTextures(self, filters: List[BaseRegEditFilter]):
        for filter in filters:
            if (isinstance(filter, RegTexAdd)):
                self.addedTextures = DictTools.combine(self.addedTextures, copy.deepcopy(filter.textures), 
                                                       lambda modObj, srcObjTextures, currentObjTextures: DictTools.combine(srcObjTextures, currentObjTextures, 
                                                                                                                    lambda reg, srcTexData, currentTexData: currentTexData))

    @property
    def preRegEditFilters(self):
        """
        Filters used to edit the registers of a certain :class:`IfContentPart` for the original mod objects to be fixed. Filters are executed based on the order specified in the list.

        :getter: Retrieves all the sequence of filters
        :setter: Sets the new sequence of filters
        :type: List[:class:`BaseRegEditFilter`]
        """
        
        return self._preRegEditFilters
    
    @preRegEditFilters.setter
    def preRegEditFilters(self, newRegEditFilters: List[BaseRegEditFilter]):
        self._preRegEditFilters = newRegEditFilters
        self._combineAddedTextures(self._preRegEditFilters)
                
    @property
    def postRegEditFilters(self):
        """
        Filters used to edit the registers of a certain :class:`IfContentPart` for the new mod objects of the fixed mods. Filters are executed based on the order specified in the list.

        :getter: Retrieves all the sequence of filters
        :setter: Sets the new sequence of filters
        :type: List[:class:`BaseRegEditFilter`]
        """

        return self._postRegEditFilters
    
    @postRegEditFilters.setter
    def postRegEditFilters(self, newRegEditFilters: List[BaseRegEditFilter]):
        self._postRegEditFilters = newRegEditFilters
        self._combineAddedTextures(self._postRegEditFilters)

    def clear(self):
        """
        Clears all the saved states
        """

        self._texInds = {}
        self._texEditRemapNames = {}
        self._texAddRemapNames = {}

        self._currentTexAddsRegs = set()
        self._currentTexEditRegs = set()
        self._currentRegTexEdits = {}

        self._referencedTexEditSections = {}
        self._referencedTexAdds = set()

    def getObjRemapFixName(self, name: str, modName: str, objName: str, newObjName: str) -> str:
        """
        Retrieves the new name of the `section`_ for a new mod object

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to be fixed

        objName: :class:`str`
            The name of the original mod object for the `section`_

        newObjName: :class:`str`
            The name of the new mod object for the `section`_

        Returns
        -------
        :class:`str`
            The new name for the `section`_
        """

        name = TextTools.reverse(name)
    
        nameParts = re.split(TextTools.reverse(objName), name, flags = re.IGNORECASE, maxsplit = 1)
        name = TextTools.reverse(TextTools.capitalizeOnlyFirstChar(newObjName)).join(nameParts)
    
        name = TextTools.reverse(name)

        return self._iniFile.getRemapFixName(name, modName = modName)
    
    def getTexResourceRemapFixName(self, texTypeName: str, oldModName: str, newModName: str, objName: str, addInd: bool = False) -> str:
        """
        Retrieves the new name of the `section`_ for a texture resource that is created/editted

        Parameters
        ----------
        texTypeName: :class:`str`
            The name of the type of texture file

        oldModName: :class:`str`
            The name of the mod to fix from

        newModName: :class:`str`
            The name of the mod to fix to

        objName: :class:`str`
            The mod object the texture resource refereces

        addInd: :class:`bool`
            Whether to add a unique numbered index to the end of the name to distingusih the name
            from other previously created names of the same texture type :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The new name for the `section`_
        """

        nameParts = [oldModName, objName, texTypeName]
        nameParts = list(map(lambda namePart: TextTools.capitalize(namePart), nameParts))
        nameParts = "".join(nameParts)

        result = self._iniFile.getRemapTexResourceName(nameParts, modName = newModName)

        if (not addInd):
            return result
        
        # retrieve the occurence index of the type of texture resource
        texInd = 0
        try:
            self._texInds[texTypeName]
        except KeyError:
            self._texInds[texTypeName] = {}

        try:
            texInd = self._texInds[texTypeName][objName]
        except KeyError:
            self._texInds[texTypeName][objName] = 0

        self._texInds[texTypeName][objName] += 1
        return f"{result}{texInd}"

    def getObjHashType(self):
        return "ib"
    
    def editTexRegisters(self, modName: str, part: IfContentPart, obj: str, sectionName: str, filters: List[BaseRegEditFilter]):
        """
        Edits the registers for a :class:`IfContentPart` in the texture related `section`_

        .. note::
            For details on steps of how the registers are editted, see :class:`GIMIObjReplaceFixer`

        Parameters
        ----------
        modName: :class:`str`
            The name of the mod to fix to

        part: :class:`IfContentPart`
            The part that is being editted

        obj: :class:`str`
            The name of the mod object for the corresponding part

        sectionName: :class:`str`
            The name of the `section`_ the part belongs to

        filters: List[:class:`BaseRegEditFilter`]
            The filters used for editting the registers
        """

        modType = self._iniFile.availableType
        if (modType is None):
            return
        
        self._currentRegTexEdits = {}
        self._currentTexAddsRegs = set()
        self._currentTexEditRegs = set()

        for filter in filters:
            part = filter.edit(part, modType, modName, obj, sectionName, self)

        texAdds = None
        try:
            texAdds = self.addedTextures[obj]
        except KeyError:
            pass

        # get the referenced texture add resources
        if (texAdds is not None):
            for reg in texAdds:
                if (reg not in self._currentTexAddsRegs):
                    continue
                
                texAddData = texAdds[reg]
                texName = texAddData[0]
                self._referencedTexAdds.add(texName)

        # get the referenced texture edit resources
        for reg in self._currentTexEditRegs:
            texEditData = None
            try:
                texEditData = self._currentRegTexEdits[reg]
            except KeyError:
                continue
            
            texName = texEditData[0]
            texEditSection = texEditData[1]

            texEditSections = None
            try:
                texEditSections = self._referencedTexEditSections[texName]
            except KeyError:
                texEditSections = set()
                self._referencedTexEditSections[texName] = texEditSections

            texEditSections.add(texEditSection)
        
    
    def fillObjOtherHashIndexSection(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str, objName: str, newObjName: str):
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix where the `sections`_ reference some hash or index and the `section`_ is not
        explictely captured by the fixer. The original `sections`_ may come from a different mod object.

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverrideBlend] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        objName: :class:`str`
            The name of the original mod object

        newObjName: :class:`str`
            The name of the mod object to fix to

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""
        preRegEditObj = objName if (self.preRegEditOldObj) else newObjName

        newPart = copy.deepcopy(part)
        self.editTexRegisters(modName, newPart, preRegEditObj, sectionName, self._preRegEditFilters)

        for varName, varValue, keyInd, orderInd in newPart:
            # filling in the hash
            if (varName == IniKeywords.Hash.value):
                hashType = self.getObjHashType()
                newHash = self._getHash(hashType, modName)
                newPart.src[varName][keyInd] = (orderInd, f"{newHash}")

            # filling in the subcommand
            elif (varName == IniKeywords.Run.value and varValue != IniKeywords.ORFixPath.value and not varValue.startswith(IniKeywords.TexFxFolder.value)):
                subCommand = self.getObjRemapFixName(varValue, modName, objName, newObjName)
                newPart.src[varName][keyInd] = (orderInd, f"{subCommand}")

            # filling in the index
            elif (varName == IniKeywords.MatchFirstIndex.value):
                newIndex = self._getIndex(newObjName.lower(), modName)
                newPart.src[varName][keyInd] = (orderInd, f"{newIndex}")

        self.editTexRegisters(modName, newPart, newObjName, sectionName, self._postRegEditFilters)
        
        addFix = newPart.toStr(linePrefix = linePrefix)
        if (addFix != ""):
            addFix += "\n"

        return addFix
    
    # fill the attributes for the sections related to the resources
    def _fillTexResource(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, 
                         origSectionName: str, texName: str, oldModName: str, modObjName: str, texGraph: IniSectionGraph):
        """
        Creates the **content part** of an :class:`IfTemplate` for the new `sections`_ created by this fix related to the ``[Resource.*]`` `sections`_
        of a texture file

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the `section`_

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original ``[Resource.*Blend.*]`` `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        texName: :class:`str`
            The name of the type of texture file

        oldModName: :class:`str`
            The name of the type of mod to fix froms

        modObjName: :class:`str`
            The name of the type of mod object associated to the `section`_

        texGraph: :class:`IniSectionGraph`
            The graph where the `section`_ belongs to

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""

        for varName, varValue, keyInd, _ in part:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommand = self._getRemapName(sectionName, modName, sectionGraph = texGraph, remapNameFunc = lambda sectionName, modName: self.getTexResourceRemapFixName(texName, oldModName, modName, modObjName))
                subCommandStr = f"{IniKeywords.Run.value} = {subCommand}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # add in the file
            elif (varName == "filename"):
                texModel = self._iniFile.texEditModels[texName][origSectionName]
                fixedTexFile = texModel.fixedPaths[partIndex][modName][keyInd]
                addFix += f"{linePrefix}filename = {fixedTexFile}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"

        return addFix
    
    def getTexEditFile(self, file: str, texName: str, modObj: str, modName: str = "") -> str:
        """
        Makes the file path for an editted texture

        Parameters
        ----------
        texFile: :class:`str`
            The file path to the original .dds file

        texName: :class:`str`
            The name for the type of texture

        modObj: :class:`str`
            The name of the mod object the texture file belongs to

        modName: :class:`str`
            The name of the mod to fix to

        Returns
        -------
        :class:`str`
            The file path of the fixed RemapTex.dds file
        """

        basename = os.path.basename(file)
        ind = f"{HashTools.base64DeterministicShortUniqueHash(basename)} {HashTools.base64DeterministicShortUniqueHash(texName)}"

        texFolder = os.path.dirname(file)
        modName = f"{modName}{TextTools.capitalize(modObj)}"
        return os.path.join(texFolder, f"{self._iniFile.getRemapTexName('', modName = modName)}{ind}{FileExt.DDS.value}")
    
    # _fixEdittedTextures(modName, fix): get the fix string for editted textures
    def _fixEdittedTextures(self, modName: str, fix: str = ""):
        self._iniFile.texEditModels.clear()
        self._parser.clearTexGraphs()
        texGraphs = {}

        # rebuild all the models and the section graphs
        for texName in self._referencedTexEditSections:
            texEditor = self._parser.getTexEditor(texName)
            if (texEditor is None):
                continue

            referencedSections = list(self._referencedTexEditSections[texName])
            referencedSections.sort()

            texGraph = IniSectionGraph(set(), {})
            texGraph.build(newTargetSections = referencedSections, newAllSections = self._iniFile.sectionIfTemplates)
            texGraphs[texName] = texGraph
            
            modObjName = self._parser.texEditRegs[texName][0]
            self._parser._makeTexModels(texName, texGraph, texEditor, getFixedFile = lambda file, modName: self.getTexEditFile(file, texName, modObjName, modName = modName))

        texEditInd = 0
        referencedTexEditLen = len(self._referencedTexEditSections)
        modType = self._iniFile.availableType

        # fix the sections
        for texName in self._referencedTexEditSections:
            texGraph = texGraphs[texName]

            texCommandTuples = texGraph.runSequence
            texCommandsLen = len(texCommandTuples)
            modObjName = self._parser.texEditRegs[texName][0]

            for i in range(texCommandsLen):
                commandTuple = texCommandTuples[i]
                section = commandTuple[0]
                ifTemplate = commandTuple[1]

                resourceName = ""
                try:
                    resourceName = self._texEditRemapNames[section][texName]
                except KeyError:
                    resourceName = self._getRemapName(section, modName, sectionGraph = texGraph, remapNameFunc = lambda sectionName, modName: self.getTexResourceRemapFixName(texName, modType.name, modName, modObjName, addInd = True))

                fix += self.fillIfTemplate(modName, resourceName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: self._fillTexResource(modName, sectionName, part, partIndex, linePrefix, origSectionName, texName, modType.name, modObjName, texGraph), origSectionName = section)

                if (i < texCommandsLen - 1):
                    fix += "\n"

            if (texEditInd < referencedTexEditLen - 1):
                fix += "\n"

            texEditInd += 1

        if (fix and fix[-1] == "\n"):
            fix = fix[:-1]

        return fix
    
    # _makeTexAddResourceIfTemplate(texName, modName, oldModName, modObj): Creates the IfTemplate for an added texture
    def _makeTexAddResourceIfTemplate(self, texName: str, modName: str, oldModName: str, modObj: str) -> IfTemplate:
        sectionName = ""
        try: 
            self._texAddRemapNames[texName]
        except KeyError:
            self._texAddRemapNames[texName] = {}

        try:
            sectionName = self._texAddRemapNames[texName][modObj]
        except KeyError:
            sectionName = self.getTexResourceRemapFixName(texName, oldModName, modName, modObj)
            self._texAddRemapNames[texName][modObj] = sectionName

        filePartName = f"{modName}{TextTools.capitalize(modObj)}{TextTools.capitalize(texName)}"
        filename = f"{self._iniFile.getRemapTexName(filePartName)}{FileExt.DDS.value}"

        return IfTemplate([
            IfContentPart({"filename": [(0, filename)]}, 0)
        ], name = sectionName)

    # _fixAddedTextures(modName, fix): get the fix string for added textures
    def _fixAddedTextures(self, modName: str, fix: str = "") -> str:
        modType = self._iniFile.availableType

        # retrieve the added textures
        for modObj in self.addedTextures:
            objAddedTexs = self.addedTextures[modObj]

            fixedAddedTextures = set()

            # create the needed model and add the new resource
            for reg in objAddedTexs:
                texData = objAddedTexs[reg]
                texName = texData[0]
                texEditor = texData[1]

                if (texName in fixedAddedTextures or texName not in self._referencedTexAdds):
                    continue

                ifTemplate = self._makeTexAddResourceIfTemplate(texName, modName, modType.name, modObj)
                sectionName = ifTemplate.name
                texModel = self._iniFile.makeTexModel(ifTemplate, self._parser._modsToFix, texEditor, getFixedFile = lambda file, modName: file)

                try:
                    self._iniFile.texAddModels[texName]
                except KeyError:
                    self._iniFile.texAddModels[texName] = {}

                self._iniFile.texAddModels[texName][modObj] = texModel

                fix += self.fillIfTemplate(modName, sectionName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: f"{part.toStr(linePrefix = linePrefix)}\n")
                fix += "\n"

                fixedAddedTextures.add(texName)

        if (fix and fix[-1] == "\n"):
            fix = fix[:-1]

        return fix
    
    # _fixDownloadResources(fix): get the fix string for downloaded files
    def _fixDownloadedResources(self, fix: str = "", includeEndNewLine = False):
        fix = super()._fixDownloadedResources(fix = fix, includeEndNewLine = True)

        downloadAdded = False
        referencedDownloads = self._parser._objReferencedDownloads

        for section in referencedDownloads:
            registers = referencedDownloads[section]

            for reg in registers:
                modObj, sectionName = registers[reg]

                ifTemplate = self._iniFile.sectionIfTemplates.get(sectionName)
                fix += self.fillIfTemplate("", sectionName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: f"{part.toStr(linePrefix = linePrefix)}\n")
                fix += "\n"

                if (not downloadAdded):
                    downloadAdded = True

        if (not includeEndNewLine and downloadAdded and fix and fix[-1] == "\n"):
            fix = fix[:-1]

        return fix

    def fixMod(self, modName: str, fix: str = "") -> str:
        self._texEditRemapNames = {}
        self._referencedTexEditSections = {}

        fix = super().fixMod(modName, fix = fix)

        if (self._referencedTexAdds):
            fix += "\n"

        fix = self._fixAddedTextures(modName, fix = fix)

        if (not self._referencedTexAdds and self._referencedTexEditSections):
            fix += "\n"

        if (self._referencedTexEditSections):
            fix += "\n"

        fix = self._fixEdittedTextures(modName, fix = fix)

        if (fix and fix[-1] != "\n"):
            fix += "\n"

        return fix


class RegRemap(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for remapping the register keys for some :class:`IfContentPart`

    Parameters
    ----------
    remap: Optional[Dict[:class:`str`, Dict[:class:`str`, Union[:class:`KeyRemapData`, List[Union[:class:`str`, Tuple[:class:`str`, Callable[[:class:`str`, :class:`str`], :class:`bool`]], :class:`RemappedKeyData`]]]]]]
        Defines how the register values in the parts of an :class:`IfTemplate` are mapped to a new register in the remapped mod for particular mod objects :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the name of the mod object to have their registers remapped
        * The inner keys are the names of the registers that hold the register values to be remapped
        * The inner values are the new names of the registers that will hold the register values that contains either:

            * The data for remapping a particular key OR
            * A list containing either:

                * The new names of the keys to remap to OR
                * A tuple containing a new name for the key to remap to and a predicate that takes in the old key and value of whether to remap the key. OR
                * A class that contains all the necessary information for remapping to the new key

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ["new_ps-t2", "new_ps-t3"]}, "body": {"ps-t3": [ps-t0"], "ps-t0": [], "ps-t1": [("ps-t8", lambda reg, val: val.find("NormalMap") != -1)]}}`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    remap: Dict[:class:`str`, Dict[:class:`str`, Union[:class:`KeyRemapData`, List[Union[:class:`str`, Tuple[:class:`str`, Callable[[:class:`str`, :class:`str`], :class:`bool`]], :class:`RemappedKeyData`]]]]]
        Defines how the register values in the parts of an :class:`IfTemplate` are mapped to a new register in the remapped mod for particular mod objects :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the name of the mod object to have their registers remapped
        * The inner keys are the names of the registers that hold the register values to be remapped
        * The inner values are the new names of the registers that will hold the register values that contains either:

            * The data for remapping a particular key OR
            * A list containing either:

                * The new names of the keys to remap to OR
                * A tuple containing a new name for the key to remap to and a predicate that takes in the old key and value of whether to remap the key. OR
                * A class that contains all the necessary information for remapping to the new key

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ["new_ps-t2", "new_ps-t3"]}, "body": {"ps-t3": [ps-t0"], "ps-t0": [], "ps-t1": [("ps-t8", lambda reg, val: val.find("NormalMap") != -1)]}}`` :raw-html:`<br />` :raw-html:`<br />`

    _regRemap: Optional[Dict[:class:`str`, List[:class:`str`]]]
        The register remap to do on the current :class:`IfContentPart` being parsed :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the registers and the values are the newly mapped registers
    """

    def __init__(self, remap: Optional[Dict[str, Dict[str,  Union[KeyRemapData, List[Union[str, Tuple[str, Callable[[str, str], bool]], RemappedKeyData]]]]]] = None):
        self.remap = {} if (remap is None) else remap
        self._regRemap: Optional[Dict[str, List[str]]] = None

    def clear(self):
        self._regRemap = None
    
    def _editReg(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "BaseIniFixer") -> IfContentPart:
        try:
            self._regRemap = self.remap[obj]
        except KeyError:
            return part

        part.remapKeys(self._regRemap)
        return part
    
    def _getRemappedKeyName(self, remappedKeyData: Union[str, Tuple[str, Callable[[str, str], bool]], RemappedKeyData]) -> str:
        if (isinstance(remappedKeyData, RemappedKeyData)):
            return remappedKeyData.key
        elif (isinstance(remappedKeyData, tuple)):
            return remappedKeyData[0]
        return remappedKeyData
    
    def _handleTex(self, currentTexRegs: Set[str], currentTexRegData: Optional[Dict[str, Any]] = None):
        if (self._regRemap is None):
            return

        for reg in self._regRemap:
            if (reg in currentTexRegs):
                currentTexRegs.remove(reg)
                newTexRegs = set(map(self._getRemappedKeyName, self._regRemap[reg]))
                currentTexRegs.update(newTexRegs)

            if (currentTexRegData is None or reg not in currentTexRegData):
                continue

            newRegs = self._regRemap[reg]
            for newRegKey in newRegs:
                newReg = self._getRemappedKeyName(newRegKey)
                currentTexRegData[newReg] = currentTexRegData[reg]
    
    def handleTexAdd(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        addedTextures = None
        try:
            addedTextures = fixer.addedTextures[obj]
        except KeyError:
            pass

        self._handleTex(fixer._currentTexAddsRegs, addedTextures)

    
    def handleTexEdit(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        self._handleTex(fixer._currentTexEditRegs, fixer._currentRegTexEdits)


class RegNewVals(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for assigning new values to specific registers for some :class:`IfContentPart`

    Parameters
    ----------
    vals: Optional[Dict[:class:`str`, Dict[:class:`str`,Union[:class:`str`, Tuple[:class:`str`, Callable[[:class:`str`], :class:`bool`]]]]]]
        Defines which registers will have their values changed :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the new mod objects where the registers are found
        * The inner keys are the new names of the registers to have their values changed
        * The inner values contains either

            * A string representing the new changed values for all instances of the register OR
            * A tuple containing a string and a predicate, representing the new changed values for only certain instances of the registers.
              The predicate takes the old value of the register as the argument.

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": "newVal"}, "body": {"ps-t3": "newVal2", "ps-t0": "newVal3"}, "dress": {"ps-t0": ("newVal4", lambda val: val == "replaceMe")}}`` :raw-html:`<br />` :raw-html:`<br />`


        **Default**: ``None``

    Attributes
    ----------
    vals: Dict[:class:`str`, Dict[:class:`str`,Union[:class:`str`, Tuple[:class:`str`, Callable[[:class:`str`], :class:`bool`]]]]]
       Defines which registers will have their values changed :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the new mod objects where the registers are found
        * The inner keys are the new names of the registers to have their values changed
        * The inner values contains either

            * A string representing the new changed values for all instances of the register OR
            * A tuple containing a string and a predicate, representing the new changed values for only certain instances of the registers.
              The predicate takes the old value of the register as the argument.

    _regUpdates: Optional[Dict[:class:`str`, :class:`str`]]
        The value updates to do on the current :class:`IfContentPart` being parsed :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the registers and the values are the corresponding values to the registers
    """

    def __init__(self, vals: Optional[Dict[str, Dict[str, Union[str, Callable[[str], bool]]]]] = None):
        self.vals = {} if (vals is None) else vals
        self._regUpdates: Optional[Dict[str, str]] = None

    def clear(self):
        self._regUpdates = None
    
    def _editReg(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "BaseIniFixer") -> IfContentPart:
        try:
            self._regUpdates = self.vals[obj]
        except KeyError:
            return part

        part.replaceVals(self._regUpdates, addNewKVPs = False)
        return part
    
    def handleTexAdd(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regUpdates is not None):
            fixer._currentTexAddsRegs = fixer._currentTexAddsRegs.difference(set(self._regUpdates.keys()))

    def handleTexEdit(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regUpdates is not None):
            fixer._currentTexEditRegs = fixer._currentTexEditRegs.difference(set(self._regUpdates.keys()))


class RegRemove(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for removing keys from a :class:`IfContentPart`

    Parameters
    ----------
    remove: Optional[Dict[:class:`str`, Set[Union[:class:`str`, Callable[[Tuple[:class:`int`, :class:`str`]], :class:`bool`]]]]]
        Defines whether some register assignments should be removed from the `sections`_ from the mod objects :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the names of the objects to have their registers removed 
        * the values are the names of the register to be removed. :raw-html:`<br />` :raw-html:`<br />`

          * If given only a string, will remove all instance of the register
          * If given a tuple containing a string and a predicate, will remove instance of the register that satistfy the predicate
            The predicate takes in a tuple that contains:

            #. The order index where the current `KVP`_ of the register resides in the :class:`IfContentPart`
            #. The corresponding value for the current `KVP`_

        :raw-html:`<br />` :raw-html:`<br />`

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1", "ps-t2"}, "body": {"ps-t3", "ps-t0"}}`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    remove: Dict[:class:`str`, Set[Union[:class:`str`, Callable[[Tuple[:class:`int`, :class:`str`]], :class:`bool`]]]]
        Defines whether some register assignments should be removed from the `sections`_ from the mod objects :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the names of the objects to have their registers removed 
        * the values are the names of the register to be removed. :raw-html:`<br />` :raw-html:`<br />`

          * If given only a string, will remove all instance of the register
          * If given a tuple containing a string and a predicate, will remove instance of the register that satistfy the predicate
            The predicate takes in a tuple that contains:

            #. The order index where the current `KVP`_ of the register resides in the :class:`IfContentPart`
            #. The corresponding value for the current `KVP`_

        :raw-html:`<br />` :raw-html:`<br />`

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1", "ps-t2"}, "body": {"ps-t3", "ps-t0"}}``

    _regRemove: Optional[Set[:class:`str`]]
        The register removal to do on the current :class:`IfContentPart` being parsed
    """

    def __init__(self, remove: Optional[Dict[str, Set[Union[str, Tuple[str, Callable[[Tuple[int, str]], bool]]]]]] = None):
        self.remove = {} if (remove is None) else remove
        self._regRemove: Optional[Set[str]] = None

    def clear(self):
        self._regRemove = None
    
    def _editReg(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "BaseIniFixer") -> IfContentPart:
        try:
            self._regRemove = self.remove[obj]
        except KeyError:
            return part

        part.removeKeys(self._regRemove)
        return part
    
    def _handleTex(self, part: IfContentPart, regs: Set[str]) -> Set[str]:
        removedRegs = set()
        for reg in self._regRemove:
            if (reg not in part):
                removedRegs.add(reg)

        return regs.difference(removedRegs)
    
    def handleTexAdd(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regRemove is not None):
            fixer._currentTexAddsRegs = self._handleTex(part, fixer._currentTexAddsRegs)
    
    def handleTexEdit(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regRemove is not None):
            fixer._currentTexEditRegs = self._handleTex(part, fixer._currentTexEditRegs)


class GIMIObjSplitFixer(GIMIObjReplaceFixer):
    """
    This class inherits from :class:`GIMIObjReplaceFixer`

    Fixes a .ini file used by a GIMI related importer where particular mod objects (head, body, dress, etc...) in the mod to remap
    are split into multiple mod objects in remapped mod

        
    eg.

    .. code-block::

        KeqingOpulent's "body" is split into Keqing's "body" and "dress"

        KeqingOpulent             Keqing
       ===============       =================
       *** objects ***       **** objects ****
           body  -------+------>   body
           head         |          head
                        +------>   dress    

    .. note::
        For the order of how the registers are fixed, please see :class:`GIMIObjReplaceFixer`

    Parameters
    ----------
    parser: :class:`GIMIObjParser`
        The associated parser to retrieve data for the fix

    objs: Dict[:class:`str`, List[:class:`str`]]
        The mod objects that will be split into multiple new mod objects :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the mod objects to be split and the values are the names of the new mod objects the original mod object will be split into :raw-html:`<br />` :raw-html:`<br />`

        .. note::
            The dictionary keys should align with the defined object names at :meth:`GIMIObjParser.objs` for your parser

        :raw-html:`<br />`

        .. warning::
            If multiple mod objects split into the same object, then the resultant .ini file will contain duplicate `sections`_ for that particular mod object

            eg. :raw-html:`<br />`
            ``{"body": ["dress", "extra"], "head": ["face", "extra"]}``

    preRegEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart`. 
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`

        Whether these filters reference the mod objects to be fixed of the new mod objects of the fixed mods 
        is determined by :attr:`GIMIObjSplitFixer.preRegEditOldObj` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    postRegEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the new mod objects of the fixed mods. 
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`
        
        .. note::
            These filters are preceded by the filters at :class:`GIMIObjReplaceFixer.preRegEditFilters`

        :raw-html:`<br />`

        **Default**: ``None``

    preRegEditOldObj: :class:`bool`
        Whether the register editting filters at :attr:`GIMIObjReplaceFixer.preRegEditFilters`
        reference the original mod objects of the mod to be fixed or the new mod objects of the fixed mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    postModelRegEditFilters: Optional[List[:class:`RegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the `sections`_ related to the .VB or .IB of a mod
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, parser: GIMIObjParser, objs: Dict[str, List[str]], preRegEditFilters: Optional[List[BaseRegEditFilter]] = None, 
                 postRegEditFilters: Optional[List[BaseRegEditFilter]] = None, preRegEditOldObj: bool = False, postModelRegEditFilters: Optional[List[RegEditFilter]] = None):
        super().__init__(parser, preRegEditFilters = preRegEditFilters, postRegEditFilters = postRegEditFilters, preRegEditOldObj = preRegEditOldObj, postModelRegEditFilters = postModelRegEditFilters)
        self.objs = objs


    @property
    def objs(self) -> Dict[str, List[str]]:
        """
        The mods objects that will be split to multiple other mod objects :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects in the mod to be remapped and the values are the split objects of the remapped mod

        :getter: Retrieves the mods objects
        :setter: Sets the new objects
        :type: Dict[:class:`str`, List[:class:`str`]]
        """

        return self._objs
    
    @objs.setter
    def objs(self, newObjs: Dict[str, List[str]]):
        self._objs = {}
        for toFixObj in newObjs:
            fixedObjs = newObjs[toFixObj]
            newToFixObj = toFixObj.lower()
            self._objs[newToFixObj] = []

            for fixedObj in fixedObjs:
                newFixedObj = fixedObj.lower()
                self._objs[newToFixObj].append(newFixedObj)

            self._objs[newToFixObj] = ListTools.getDistinct(self._objs[newToFixObj], keepOrder = True)

        # add in the objects that will have their registers editted
        regEditObjs = set()
        for filter in self.preRegEditFilters:
            if (isinstance(filter, RegRemap)):
                regEditObjs.update(set(filter.remap.keys()))
            elif (isinstance(filter, RegRemove)):
                regEditObjs.update(set(filter.remove.keys()))
            elif (isinstance(filter, RegNewVals)):
                regEditObjs.update(set(filter.vals.keys()))
            elif (isinstance(filter, RegTexAdd)):
                regEditObjs.update(set(filter.textures.keys()))

        regEditObjs = regEditObjs.difference(set(self._objs.keys()))
        for obj in regEditObjs:
            cleanedObj = obj.lower()
            self._objs[cleanedObj] = [cleanedObj]


    def _fixOtherHashIndexCommands(self, modName: str, fix: str = ""):
        fixerObjsToFix = set(self.objs.keys())
        objsToFix = list(self._parser.objs.intersection(fixerObjsToFix))
        objsToFix.sort()
        sectionsToIgnore = set()

        # get which section to ignore
        for objToFix in objsToFix:
            objGraph = self._parser.objGraphs[objToFix]
            sectionsToIgnore = sectionsToIgnore.union(objGraph.sections)

        nonBlendCommandTuples = self._parser.otherHashIndexCommandsGraph.runSequence

        for commandTuple in nonBlendCommandTuples:
            section = commandTuple[0]
            ifTemplate = commandTuple[1]

            if (section in sectionsToIgnore):
                continue
            
            self._iniFile._remappedSectionNames.add(section)
            commandName = self._getRemapName(section, modName, sectionGraph = self._parser.otherHashIndexCommandsGraph)
            fix += self.fillIfTemplate(modName, commandName, ifTemplate, self._fillOtherHashIndexSections)
            fix += "\n"

        # retrieve the fix for all the split mod objects
        for objToFix in objsToFix:
            fixedObjs = self.objs[objToFix]
            objGraph = self._parser.objGraphs[objToFix]

            if (not objGraph.sections):
                continue
            
            objGraphTuples = objGraph.runSequence
            for commandTuple in objGraphTuples:
                section = commandTuple[0]
                ifTemplate = commandTuple[1]
                self._iniFile._remappedSectionNames.add(section)

                for fixedObj in fixedObjs:
                    commandName = self.getObjRemapFixName(section, modName, objToFix, fixedObj)
                    fix += self.fillIfTemplate(modName, commandName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: self.fillObjOtherHashIndexSection(modName, sectionName, part, partIndex, linePrefix, origSectionName, objToFix, fixedObj))
                    fix += "\n"

        if (fix and fix[-1] == "\n"):
            fix = fix[:-1]

        return fix


class GIMIObjRegEditFixer(GIMIObjSplitFixer):
    """
    This class inherits from :class:`GIMIObjSplitFixer`

    Fixes a .ini file used by a GIMI related importer where particular mod objects (head, body, dress, etc...) in the mod to remap
    needs to have their registers remapped or removed

    .. note::
        For the order of how the registers are fixed, please see :class:`GIMIObjReplaceFixer`

    Parameters
    ----------
    parser: :class:`GIMIObjParser`
        The associated parser to retrieve data for the fix

    preRegEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart`. 
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`

        Whether these filters reference the mod objects to be fixed of the new mod objects of the fixed mods 
        is determined by :attr:`GIMIObjRegEditFixer.preRegEditOldObj` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    postRegEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the new mod objects of the fixed mods. 
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`
        
        .. note::
            These filters are preceded by the filters at :class:`GIMIObjReplaceFixer.preRegEditFilters`

        :raw-html:`<br />`

        **Default**: ``None``

    postModelRegEditFilters: Optional[List[:class:`RegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the `sections`_ related to the .VB or .IB of a mod
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, parser: GIMIObjParser, preRegEditFilters: Optional[List[BaseRegEditFilter]] = None, 
                 postRegEditFilters: Optional[List[BaseRegEditFilter]] = None, postModelRegEditFilters: Optional[List[RegEditFilter]] = None):
        super().__init__(parser, {}, preRegEditFilters = preRegEditFilters, postRegEditFilters = postRegEditFilters, postModelRegEditFilters = postModelRegEditFilters)

        parserObjs = sorted(self._parser.objs)
        for obj in parserObjs:
            if (obj not in self.objs):
                self.objs[obj] = [obj] 


class FileSuffixes(Enum):
    RemapFixCopy = "RemapFix"


class GIMIObjMergeFixer(GIMIObjReplaceFixer):
    """
    This class inherits from :class:`GIMIObjReplaceFixer`

    Fixes a .ini file used by a GIMI related importer where particular mod objects (head, body, dress, etc...) in the mod to remap are merged to a single mod object

    eg. 

    .. code-block::

        Keqing's "body" and "dress" are merged into KeqingOpulent's "body"

           Keqing             KeqingOpulent
       ===============       =================
       *** objects ***       **** objects ****
           body      -----+---->   body
           head           |        head
           dress     -----+  

    .. note::
        This class takes advantage of GIMI's bug/feature of overlapping mods from loading multiple mods of the same character by creating different variations of the original .ini file

    Parameters
    ----------
    parser: :class:`GIMIObjParser`
        The associated parser to retrieve data for the fix

    objs: Dict[:class:`str`, List[:class:`str`]]
        The mod objects to be merged to a single mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the merged objects and the values are the names of the mod objects to be merged :raw-html:`<br />` :raw-html:`<br />`

        .. note::
            The dictionary values should align with the defined object names at :meth:`GIMIObjParser.objs` for your parser

    copyPreamble: :class:`str`
        Any text we want to put before the text of the newly generated .ini file variations :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``""``

    preRegEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart`. 
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`

        Whether these filters reference the mod objects to be fixed of the new mod objects of the fixed mods 
        is determined by :attr:`GIMIObjMergeFixer.preRegEditOldObj` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    postRegEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the new mod objects of the fixed mods. 
        Filters are executed based on the order specified in the list. :raw-html:`<br />` :raw-html:`<br />`
        
        .. note::
            These filters are preceded by the filters at :class:`GIMIObjReplaceFixer.preRegEditFilters`

        :raw-html:`<br />`

        **Default**: ``None``

    iniPostModelRegEditFilters: Optional[List[List[:class:`RegEditFilter`]]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the `sections`_ related to the .VB or .IB of a mod for each .ini file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    _targetObjs: Dict[:class:`str`, :class:`str`]
        Which original mod objects to show for each merged mod object in the current .ini file :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the original mod objects to display on the current .ini file and the values are the names of the merged objects.

    copyPreamble: :class:`str`
        Any text we want to put before the text of the newly generated .ini file variations

    iniPostModelRegEditFilters: List[List[:class:`RegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart` for the `sections`_ related to the .VB or .IB of a mod for each .ini file

    postModelRegEditFilters: List[:class:`RegEditFilter`]
        The filters used to edit the registers of a certain :class:`IfContentPart` for the `sections`_ related to the .VB or .IB of a mod for the current .ini file being generated
    """

    def __init__(self, parser: GIMIObjParser, objs: Dict[str, List[str]], copyPreamble: str = "", 
                 preRegEditFilters: Optional[List[BaseRegEditFilter]] = None, postRegEditFilters: Optional[List[BaseRegEditFilter]] = None,
                 iniPostModelRegEditFilters: Optional[List[List[RegEditFilter]]] = None):

        self.iniPostModelRegEditFilters = [] if (iniPostModelRegEditFilters is None) else iniPostModelRegEditFilters

        super().__init__(parser, preRegEditFilters = preRegEditFilters, postRegEditFilters = postRegEditFilters)
        self._targetObjs: List[Tuple[str, str]]
        self._maxObjsToMergeLen = 0
        self._sectionsToIgnore: Set[str] = set()
        self.objs = objs

        self.copyPreamble = copyPreamble

    @property
    def objs(self):
        """
        The mod objects to be merged to a single mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the merged objects and the values are the names of the mod objects to be merged

        :getter: Retrieves the mod objects to be merged
        :setter: Set the new mod objects to be merged
        :type: Dict[:class:`str`, List[:class:`str`]]
        """

        return self._objs
    
    @objs.setter
    def objs(self, newObjs: Dict[str, List[str]]):
        self._objs = {}

        for mergedObj in newObjs:
            objsToMerge = newObjs[mergedObj]
            self._objs[mergedObj] = objsToMerge
            self._maxObjsToMergeLen = max(self._maxObjsToMergeLen, len(objsToMerge))


    def _fixOtherHashIndexCommands(self, modName: str, fix: str = ""):
        nonBlendCommandTuples = self._parser.otherHashIndexCommandsGraph.runSequence

        for commandTuple in nonBlendCommandTuples:
            section = commandTuple[0]
            ifTemplate = commandTuple[1]

            if (section in self._sectionsToIgnore):
                continue
            
            self._iniFile._remappedSectionNames.add(section)
            commandName = self._getRemapName(section, modName, sectionGraph = self._parser.otherHashIndexCommandsGraph)
            fix += self.fillIfTemplate(modName, commandName, ifTemplate, self._fillOtherHashIndexSections)
            fix += "\n"

        # retrieve the fix for all the merged mod objects
        for objToFix, fixedObj in self._targetObjs:
            objGraph = self._parser.objGraphs[objToFix]

            if (not objGraph.sections):
                continue
            
            objGraphTuples = objGraph.runSequence
            for commandTuple in objGraphTuples:
                section = commandTuple[0]
                ifTemplate = commandTuple[1]
                commandName = self.getObjRemapFixName(section, modName, objToFix, fixedObj)
                self._iniFile._remappedSectionNames.add(section)
                fix += self.fillIfTemplate(modName, commandName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: self.fillObjOtherHashIndexSection(modName, sectionName, part, partIndex, linePrefix, origSectionName, objToFix, fixedObj))
                fix += "\n"

        if (fix and fix[-1] == "\n"):
            fix = fix[:-1]

        return fix

    
    # _getCurrentTargetObjs(ind): Retrieves the current mod objects to show in the current .ini file for each merged mod object
    def _getCurrentTargetObjs(self, ind: int):
        self._targetObjs = []
        for mergedObj in self._objs:
            objsToMerge = self._objs[mergedObj]
            if (ind <= len(objsToMerge) - 1):
                objToMerge = objsToMerge[ind]
                self._targetObjs.append((objToMerge, mergedObj))

    # _getCurrentModelRegEditFilters(ind): Retrieves the current register editting filters to edit the sections to the .ib/.vb of the mod
    def _getCurrentModelRegEditFilters(self, ind: int):
        if (len(self.iniPostModelRegEditFilters) <= ind):
            self.postModelRegEditFilters = []
            return
        
        self.postModelRegEditFilters = self.iniPostModelRegEditFilters[ind]

    # _getIgnoredSections(): Retrieves which sections to ignore when performing the normal part of the fix
    def _getIgnoredSections(self):
        objsToFix = copy.deepcopy(self._parser.objs)
        ignoredObjs = set()
        self._sectionsToIgnore = set()

        # get which section to ignore
        for mergedObj in self._objs:
            objsToFix = self._objs[mergedObj]

            for objToFix in objsToFix:
                if (objToFix in ignoredObjs):
                    continue

                ignoredObjs.add(objToFix)
                objGraph = None
                try:
                    objGraph = self._parser.objGraphs[objToFix]
                except:
                    continue

                self._sectionsToIgnore = self._sectionsToIgnore.union(objGraph.sections)


    def _fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, hideOrig: bool = False, withBoilerPlate: bool = True, withSrc: bool = True, fixId: int = 0) -> Union[str, List[str]]:
        result = []
        iniFilePath = self._iniFile.filePath
        iniBaseName = iniFilePath.baseName
        self._getIgnoredSections()
        self._iniFile._remappedSectionNames.update(self._sectionsToIgnore)

        texEditModels = {}
        for i in range(self._maxObjsToMergeLen):
            self._getCurrentTargetObjs(i)
            self._getCurrentModelRegEditFilters(i)

            if (i > 0 and iniFilePath is not None):
                iniFilePath.baseName = f"{iniBaseName}{FileSuffixes.RemapFixCopy.value}{i}"

            currentResult = super()._fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update, hideOrig = hideOrig, withBoilerPlate = withBoilerPlate, withSrc = withSrc, fixId = fixId + i)
            currentTexEditModels = DictTools.update(texEditModels, self._iniFile.texEditModels, lambda modelName, resModels, curResModels: DictTools.combine(resModels, curResModels, lambda sectionName, model, curModel: curModel))

            if (i > 0 and withSrc and self.copyPreamble != ""):
                currentResult = f"{self.copyPreamble}\n\n{currentResult}"

            self._iniFile.write(txt = currentResult)
            result.append(currentResult)

        self._iniFile.texEditModels = currentTexEditModels
        iniFilePath.baseName = iniBaseName
        if (len(result) == 1):
            result = result[0]

        return result


class MultiModFixer(BaseIniFixer):
    """
    This class inherits from :class:`BaseIniFixer`

    Fixes a .ini file where each mod to fix requires a different :class:`BaseIniFixer` strategy

    Parameters
    ----------
    parser: :class:`BaseIniParser`
        The associated parser to retrieve data for the fix

    fixBuilders: Dict[:class:`str`, :class:`IniFixBuilder`]
        The different builders to dynamcally construct the :class:`BaseIniFixer` used for each mod to fix :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the mods to fix and the values are the different :class:`IniFixBuilder` used to construct the :class:`BaseIniFixer` to fix the mod

    Attributes
    ----------
    _fixBuilders: Dict[:class:`str`, :class:`IniFixBuilder`]
        The different builders to dynamcally construct the :class:`BaseIniFixer` used for each mod to fix :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the mods to fix and the values are the different :class:`IniFixBuilder` used to construct the :class:`BaseIniFixer` to fix the mod

    _fixers: Dict[:class:`str`, :class:`BaseIniFixer`]
        The different fixers to fix each type of mod :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the mods to fix and the values are the fixers to fix the mod
    """

    def __init__(self, parser: BaseIniParser, fixBuilders: Dict[str, "IniFixBuilder"]):
        super().__init__(parser)
        self._fixBuilders = fixBuilders
        self._fixers: Dict[str, BaseIniFixer] = {}
        self.buildFixers()

    def buildFixers(self):
        """
        Rebuilds the :class:`BaseIniFixer` used for each mod
        """

        self._fixers = {}
        for modToFix in self._fixBuilders:
            self._fixers[modToFix] = self._fixBuilders[modToFix].build(self._parser)

    # _mergeFix(resultFix, currentFix): Merges the current fix results into the resultant fix
    def _mergeFix(self, resultFix: List[str], currentFix: List[str]):
        resultFixLen = len(resultFix)
        currentFixLen = len(currentFix)
        minFixLen = min(resultFixLen, currentFixLen)

        for i in range(minFixLen):
            resultFix[i] += currentFix[i]

        if (currentFixLen > resultFixLen):
            resultFix.append(currentFix[i])

    def _fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, hideOrig: bool = False, withBoilerPlate: bool = True, fixId: int = 0) -> Union[str, List[str]]:
        modsToFix = self._parser._modsToFix.intersection(set(self._fixers.keys()))
        sortedModsToFix = list(modsToFix)
        sortedModsToFix.sort()

        result = [""]

        # retrieve the results for each fixer
        for modToFix in sortedModsToFix:
            self._parser._modsToFix = {modToFix}
            fixer = self._fixers[modToFix]
            self._iniFile._iniFixer = fixer
            currentResult = fixer._fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update, hideOrig = hideOrig, withBoilerPlate = False, withSrc = False, fixId = fixId)
            self._iniFile._isFixed = False

            if (isinstance(currentResult, str)):
                result[0] += currentResult
            else:
                self._mergeFix(result, currentResult)

        self._parser._modsToFix = modsToFix

        resultLen = len(result)
        iniFilePath = self._iniFile.filePath
        iniBaseName = iniFilePath.baseName

        if (hideOrig):
            self._iniFile.hideOriginalSections()

        # add the boilerplate
        for i in range(resultLen):
            if (withBoilerPlate):
                result[i] = f"\n\n{self._iniFile.addFixBoilerPlate(fix = result[i])}"

            if (iniFilePath is not None and i > 0):
                iniFilePath.baseName = f"{iniBaseName}{FileSuffixes.RemapFixCopy.value}{i}"

            result[i] = self._iniFile.injectAddition(result[i], beforeOriginal = False, keepBackup = keepBackup, fixOnly = fixOnly, update = update)
            self._iniFile._isFixed = False

        self._iniFile._isFixed = True
        iniFilePath.baseName = iniBaseName
        if (resultLen == 1):
            result = result[0]
        
        return result


class RegTexEdit(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for editting texture .dds files to a :class:`IfContentPart`

    Parameters
    ----------
    textures: Optional[Dict[:class:`str`, List[Union[:class:`str`, Tuple[:class:`str`, Callable[[:class:`str`, :class:`str`], :class:`bool`]]]]]]
        Texture .dds files to be editted from existing textures files :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the name of the type of texture files of the mod object
        * The values are either:
        
            * the name of the registers to hold the editted textures
            * a tuple containing the name of the register to hold the editted texture and a predicate, will edit the texture to the corresponding register only if the predicate returns ``True`` for the register value

              The predicate takes in:

              #. The old register key of the texture to be editted
              #. The correspondnig value for the old register key

        eg. :raw-html:`<br />`
        ``{"NormalMap": ["ps-t1", "r13", "ps-t0", lambda key, val: val.find("NormalMap") != -1], "ShinyMetalMap": ["ps-t2"]}`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    _regEditVals: Optional[Dict[:class:`str`, :class:`str`]]
        The texture edits to do on the current :class:`IfContentPart` being parsed :raw-html:`<br />` :raw-html:`<br />`

        The keys are the name of the registers and the values are the `section`_ names for the textures
    """

    def __init__(self, textures: Optional[Dict[str, List[Union[str, Tuple[str, Callable[[str, str], bool]]]]]] = None):
        self.textures = {} if (textures is None) else textures
        self._regEditVals: Dict[str, str] = None

    @property
    def textures(self) -> Dict[str, List[str]]:
        """
        Texture .dds files to be editted from existing textures files :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the name of the type of texture files of the mod object
        * The values are the name of the registers to hold the editted textures

        eg. :raw-html:`<br />`
        ``{"NormalMap": ["ps-t1", "r13", "ps-t0"], "ShinyMetalMap": ["ps-t2"]}``

        :getter: Retrieves the texture .dds files to be editted by register
        :setter: Sets the textures to be editted
        :type: Dict[:class:`str`, List[:class:`str`]]
        """

        return self._textures
    
    @textures.setter
    def textures(self, newTextures: Dict[str, List[str]]):
        self._textures = {}

        for texName in newTextures:
            self._textures[texName] = ListTools.getDistinct(newTextures[texName], keepOrder = True)

    def clear(self):
        self._regEditVals = None

    # _addTexEditCalledResources(part, result, regTexEditResult, oldSection, objName, reg, texTypeName, oldModName, newModeName, fixer): 
    #   Adds in the new editted resources section name into 'result'
    def _addTexEditCalledResources(self, part: IfContentPart, result: Dict[str, str], objName: str, reg: str, texTypeName: str, 
                                   oldModName: str, newModName: str, fixer: "GIMIObjReplaceFixer"):
        if (reg not in part):
            return

        # get the new registers for the editted resource
        texNewRegs = None
        try:
            texNewRegs = self.textures[texTypeName]
        except KeyError:
            return
        
        # get the current referenced resource by the editted texture
        currentRegVals = ListTools.getDistinct(part.getVals(reg), keepOrder = True)
        if (not currentRegVals):
            return
        currentRegResource = currentRegVals[-1]
        
        # get the name for the editted texture resource section
        texRemapFixName = None
        try:
            fixer._texEditRemapNames[currentRegResource]
        except KeyError:
            fixer._texEditRemapNames[currentRegResource] = {}

        try:
            texRemapFixName = fixer._texEditRemapNames[currentRegResource][texTypeName]
        except KeyError:
            texRemapFixName = fixer.getTexResourceRemapFixName(texTypeName, oldModName, newModName, objName, addInd = True)
            fixer._texEditRemapNames[currentRegResource][texTypeName] = texRemapFixName

        for newRegKey in texNewRegs:
            newReg = newRegKey
            if (not isinstance(newRegKey, str) and not newRegKey[1](reg, currentRegResource)):
                continue
            elif (not isinstance(newRegKey, str)):
                newReg = newRegKey[0]

            result[newReg] = texRemapFixName
            fixer._currentRegTexEdits[newReg] = (texTypeName, currentRegResource)
    
    def _editReg(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        texEdits = None
        try:
            texEdits = fixer._parser.texEdits[obj]
        except KeyError:
            return part

        self._regEditVals = {}
        DictTools.forDict(texEdits, ["reg", "texName"], 
                          lambda keys, values: self._addTexEditCalledResources(part, self._regEditVals, obj, keys["reg"], keys["texName"], modType.name, fixModName, fixer))
        part.replaceVals(self._regEditVals, addNewKVPs = True)
        return part
    
    def handleTexAdd(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        return
    
    def handleTexEdit(self, part: IfContentPart, modType: "ModType", fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regEditVals is not None):
            fixer._currentTexEditRegs.update(set(self._regEditVals.keys()))


# IniFixBuilderFunc: Class to define how the IniFixBuilder arguments for some
#   mod are built for a particular game version
class IniFixBuilderFuncs():
    def _regIsTexFxWrapper(val: Tuple[int, str]) -> bool:
        return val[1].lower().find(IniKeywords.TexFxFolder.value.lower()) > -1
    
    def _regValIsOrFixWrapper(val: Tuple[int, str]) -> bool:
        return val[1] == IniKeywords.ORFixPath.value
    
    @classmethod
    def _regIsTex(cls, val: Tuple[int, str]) -> bool:
        return cls._regIsTexFxWrapper(val)
    
    @classmethod
    def _regValIsOrFix(cls, val: Tuple[int, str]) -> bool:
        return cls._regValIsOrFixWrapper(val)

    TexFxRemove = {("run", _regIsTexFxWrapper)}
    TexFxTempReg = "tempTexFx"
    TexFxTempRegRemap = {"ps-t69": ["ps-t69", TexFxTempReg], "ps-t70": ["ps-t70", TexFxTempReg]}
    TexFXTempToRun = {TexFxTempReg: ["run"]}
    TexFXToNormalValRename4_0 = {TexFxTempReg: IniKeywords.TexFxShortTransparency1.value}
    TexFXToNormalValRename5_0 = {TexFxTempReg: IniKeywords.TexFxShortTransparency1Natlan.value}
    TexFxNoNormalValRename4_0 = {TexFxTempReg: IniKeywords.TexFxShortTransparency0.value}
    TexFxNoNormalValRename5_0 = {TexFxTempReg: IniKeywords.TexFxShortTransparency0Natlan.value}
    
    ORFixRemove = {("run", _regValIsOrFixWrapper)}
    ReflectionHeadRemove = {"ResourceRefHeadDiffuse", "ResourceRefHeadLightMap", "$CharacterIB", *ORFixRemove}
    ReflectionBodyRemove = {"ResourceRefBodyDiffuse", "ResourceRefBodyLightMap", "$CharacterIB", *ORFixRemove}
    ReflectionDressRemove = {"ResourceRefDressDiffuse", "ResourceRefDressLightMap", "$CharacterIB", *ORFixRemove}
    ReflectionExtraRemove = {"ResourceRefExtraDiffuse", "ResourceRefExtraLightMap", "$CharacterIB", *ORFixRemove}

    ORFixTempReg = "tempORFix"
    ORFixValRename = {ORFixTempReg: IniKeywords.ORFixPath.value}
    ORFixTempToRun = {ORFixTempReg: [RemappedKeyData("run", toInd = -1)]}

    DrawIndexedTempReg = "tempDrawIndexed"
    IbRemappedData = RemappedKeyData(DrawIndexedTempReg, toInd = -1)
    IbRemapData = {"ib": ["ib", IbRemappedData]}
    IbDrawIndexedRename = {DrawIndexedTempReg: "auto"}
    IbTempToDrawIndexed = {DrawIndexedTempReg: [RemappedKeyData("drawindexed", toInd = -1)]}
    IbHashToNull = {IniKeywords.Ib.value: {"hash": "null"}}
    
    @classmethod
    def _isNormalMap(cls, val: str) -> bool:
        return val.lower().find("normalmap") != -1
    
    @classmethod
    def _isDiffuse(cls, val: str) -> bool:
        return val.lower().find("diffuse") != -1
    
    @classmethod
    def _isLightMap(cls, val: str) -> bool:
        return val.lower().find("lightmap") != -1
    
    @classmethod
    def _isMetalMap(cls, val: str) -> bool:
        return val.lower().find("metalmap") != -1
    
    @classmethod
    def _isShadow(cls, val: str) -> bool:
        return val.lower().find("shadow") != -1
    
    @classmethod
    def _remapIsDiffuse(cls, key: str, val: str) -> bool:
        return cls._isDiffuse(val)
    
    @classmethod
    def _remapIsLightMap(cls, key: str, val: str) -> bool:
        return cls._isLightMap(val)
    
    @classmethod
    def _remapIsMetalMap(cls, key: str, val: str) -> bool:
        return cls._isMetalMap(val)
    
    @classmethod
    def _remapIsShadow(cls, key: str, val: str) -> bool:
        return cls._isShadow(val)
    
    @classmethod
    def _removeIsNormalMap(cls, val: Tuple[int, str]) -> bool:
        return cls._isNormalMap(val[1])
    
    # =======================================================

    @classmethod
    def giDefault(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIFixer, [], {})
    
    @classmethod
    def amber4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def amber5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [],
                {"postRegEditFilters": [RegRemap(remap = {"head": cls.IbRemapData,
                                                          "body": cls.IbRemapData}),
                                        RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                                           "body": cls.IbDrawIndexedRename}),
                                        RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                                          "body": cls.IbTempToDrawIndexed})],
                 "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def amberCN4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def amberCN5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [],
                {"postRegEditFilters": [RegRemap(remap = {"head": cls.IbRemapData,
                                                          "body": cls.IbRemapData}),
                                        RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                                           "body": cls.IbDrawIndexedRename}),
                                        RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                                          "body": cls.IbTempToDrawIndexed})],
                 "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def ayaka4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                       RegRemove(remove = {"head": {"ps-t2", *cls.TexFxRemove},
                                           "body": {"ps-t3", *cls.TexFxRemove}}),
                       RegTexEdit({"BrightLightMap": ["ps-t1"], "OpaqueDiffuse": ["ps-t0"], "TransparentDiffuse": ["ps-t0"]}),
                       RegRemap(remap = {"head": {"ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t0": ["ps-t0", "ps-t1"], **cls.TexFxTempRegRemap},
                                         "body": {"ps-t2": ["ps-t3"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t0": ["ps-t0", "ps-t1"], **cls.TexFxTempRegRemap}}),
                       RegTexAdd(textures = {"head": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))},
                                             "body": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}}, mustAdd = False),
                       RegNewVals({"head": {**cls.ORFixValRename, **cls.TexFXToNormalValRename4_0},
                                   "body": {**cls.ORFixValRename, **cls.TexFXToNormalValRename4_0}}),
                       RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                         "body": {**cls.TexFXTempToRun}}),
                       RegRemap(remap = {"head": {**cls.ORFixTempToRun},
                                         "body": {**cls.ORFixTempToRun}})
                ]})
    
    @classmethod
    def ayaka5_4(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                       RegRemove(remove = {"head": {"ps-t2", *cls.TexFxRemove},
                                           "body": {"ps-t3", *cls.TexFxRemove}}),
                       RegTexEdit({"BrightLightMap": ["ps-t1"], "OpaqueDiffuse": ["ps-t0"], "TransparentDiffuse": ["ps-t0"]}),
                       RegRemap(remap = {"head": {"ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t0": ["ps-t0", "ps-t1"], **cls.TexFxTempRegRemap},
                                         "body": {"ps-t2": ["ps-t3"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t0": ["ps-t0", "ps-t1"], **cls.TexFxTempRegRemap}}),
                       RegTexAdd(textures = {"head": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple1.value))},
                                             "body": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple1.value))}}, mustAdd = False),
                       RegNewVals({"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename5_0},
                                   "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename5_0}}),
                       RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                         "body": {**cls.TexFXTempToRun}}),
                       RegRemap(remap = {"head": {**cls.ORFixTempToRun},
                                         "body": {**cls.ORFixTempToRun}})
                ]})
    
    @classmethod
    def ayaka5_6(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                       RegRemove(remove = {"head": {"ps-t2", *cls.TexFxRemove},
                                           "body": {"ps-t3", *cls.TexFxRemove}}),
                       RegTexEdit({"BrightLightMap": ["ps-t1"], "OpaqueDiffuse": ["ps-t0"], "TransparentDiffuse": ["ps-t0"]}),
                       RegRemap(remap = {"head": {"ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t0": ["ps-t0", "ps-t1"], **cls.IbRemapData, **cls.TexFxTempRegRemap},
                                         "body": {"ps-t2": ["ps-t3"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t0": ["ps-t0", "ps-t1"], **cls.IbRemapData, **cls.TexFxTempRegRemap},
                                         "dress": cls.IbRemapData}),
                       RegTexAdd(textures = {"head": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple1.value))},
                                             "body": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple1.value))}}, mustAdd = False),
                       RegNewVals({"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.IbDrawIndexedRename, **cls.TexFXToNormalValRename5_0},
                                   "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.IbDrawIndexedRename, **cls.TexFXToNormalValRename5_0},
                                   "dress": cls.IbDrawIndexedRename}),
                       RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                         "body": {**cls.TexFXTempToRun}}),
                       RegRemap(remap = {"head": {**cls.ORFixTempToRun},
                                         "body": {**cls.ORFixTempToRun}}),
                       RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                         "body": cls.IbTempToDrawIndexed,
                                         "dress": cls.IbTempToDrawIndexed})
                ],
                "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def ayaka5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                       RegRemove(remove = {"head": {"ps-t2"},
                                           "body": {"ps-t3"}}),
                       RegTexEdit({"BrightLightMap": ["ps-t1"], "OpaqueDiffuse": ["ps-t0"], "TransparentDiffuse": ["ps-t0"]}),
                       RegRemap(remap = {"head": {"ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t0": ["ps-t0", "ps-t1"], **cls.IbRemapData},
                                         "body": {"ps-t2": ["ps-t3"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t0": ["ps-t0", "ps-t1"], **cls.IbRemapData},
                                         "dress": cls.IbRemapData}),
                       RegTexAdd(textures = {"head": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple1.value))},
                                             "body": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple1.value))}}, mustAdd = False),
                       RegNewVals({"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.IbDrawIndexedRename},
                                   "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.IbDrawIndexedRename},
                                   "dress": cls.IbDrawIndexedRename}),
                       RegRemap(remap = {"head": {**cls.ORFixTempToRun},
                                         "body": {**cls.ORFixTempToRun}}),
                       RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                         "body": cls.IbTempToDrawIndexed,
                                         "dress": cls.IbTempToDrawIndexed})
                ],
                "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def ayakaSpringbloom4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t0", "ps-t3", *cls.ReflectionHeadRemove, *cls.TexFxRemove},
                                        "body": {"ps-t0", "ResourceRefBodyDiffuse", *cls.ReflectionBodyRemove, *cls.TexFxRemove},
                                        "dress": {"ps-t3", "ResourceRefDressDiffuse", *cls.ReflectionDressRemove, *cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], **cls.TexFxTempRegRemap},
                                      "body": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], "ps-t3": ["ps-t2"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {**cls.TexFxNoNormalValRename4_0},
                                       "body": {**cls.TexFxNoNormalValRename4_0}}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "body": {**cls.TexFXTempToRun}})
                ]})

    @classmethod
    def ayakaSpringbloom5_6(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["body", "body"], "body": ["head", "body"], "dress": ["dress", "dress"]}], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t0", "ps-t3", *cls.ReflectionHeadRemove, *cls.TexFxRemove},
                                        "body": {"ps-t0", *cls.ReflectionBodyRemove, *cls.TexFxRemove},
                                        "dress": {"ps-t3", *cls.ReflectionDressRemove}}),
                    RegTexEdit(textures = {"HeadShadeLightMap": ["ps-t2"]}),
                    RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], **cls.TexFxTempRegRemap, **cls.IbRemapData},
                                      "body": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], "ps-t3": ["ps-t2"], **cls.TexFxTempRegRemap, **cls.IbRemapData},
                                      "dress": cls.IbRemapData}),
                    RegNewVals(vals = {"head": {**cls.TexFxNoNormalValRename5_0, **cls.IbDrawIndexedRename},
                                       "body": {**cls.TexFxNoNormalValRename5_0, **cls.IbDrawIndexedRename},
                                       "dress": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "body": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed,
                                      "dress": cls.IbTempToDrawIndexed})
                ],
                "postRegEditFilters": [RegNewVals({"head": {"ib": "null"}})],
                "copyPreamble": IniComments.GIMIObjMergerPreamble.value,
                "iniPostModelRegEditFilters": [[RegNewVals(vals = cls.IbHashToNull)], [RegNewVals(vals = cls.IbHashToNull)]]})
    
    @classmethod
    def ayakaSpringbloom5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["body", "body"], "body": ["head", "body"], "dress": ["dress", "dress"]}], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t3", *cls.ReflectionHeadRemove},
                                        "body": {*cls.ReflectionBodyRemove},
                                        "dress": {"ps-t3", *cls.ReflectionDressRemove}}),
                    RegRemap(remap = {"head": {"ps-t2": ["ps-t2", (cls.ORFixTempReg, cls._remapIsShadow)], **cls.IbRemapData},
                                      "body": {"ps-t2": ["ps-t2", (cls.ORFixTempReg, cls._remapIsShadow)], **cls.IbRemapData},
                                      "dress": cls.IbRemapData}),
                    RegTexEdit(textures = {"HeadShadeLightMap": [("ps-t2", cls._remapIsShadow)], 
                                           "HeadAltShadeLightMap": [("ps-t1", cls._remapIsShadow)],
                                           "BodyTransparentDiffuse": [("ps-t1", cls._remapIsLightMap)],
                                           "BodyAltTransparentDiffuse": [("ps-t0", cls._remapIsLightMap)],
                                           "BodyOpaqueGreenLightMap": [("ps-t2", cls._remapIsShadow)],  
                                           "BodyAltOpaqueGreenLightMap": [("ps-t1", cls._remapIsShadow)]}),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.IbDrawIndexedRename},
                                       "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.IbDrawIndexedRename},
                                       "dress": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": {**cls.ORFixTempToRun},
                                      "body": {**cls.ORFixTempToRun}}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed,
                                      "dress": cls.IbTempToDrawIndexed})
                ],
                "postRegEditFilters": [RegNewVals({"head": {"ib": "null"}})],
                "copyPreamble": IniComments.GIMIObjMergerPreamble.value,
                "iniPostModelRegEditFilters": [[RegNewVals(vals = cls.IbHashToNull)], [RegNewVals(vals = cls.IbHashToNull)]]})

    
    @classmethod
    def arlecchino5_4(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {"preRegEditFilters": [RegTexEdit({"YellowHeadNormal": ["ps-t0"], "YellowBodyNormal": ["ps-t0"]})]})
    
    @classmethod
    def arlecchino5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer,
                [],
                {"preRegEditFilters": [
                    RegRemove(remove = {"head": cls.ReflectionHeadRemove,
                                        "body": cls.ReflectionBodyRemove,
                                        "dress": cls.ReflectionDressRemove}),
                    RegRemap(remap = {"head": cls.IbRemapData,
                                      "body": cls.IbRemapData,
                                      "dress": cls.IbRemapData}),
                    RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                       "body": cls.IbDrawIndexedRename,
                                       "dress": cls.IbDrawIndexedRename}),
                    RegTexEdit({"YellowHeadNormal": ["ps-t0"], "YellowBodyNormal": ["ps-t0"]}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed,
                                      "dress": cls.IbTempToDrawIndexed})
                ],
                 "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def barbara4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def barbara5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer,
                [],
                {"postRegEditFilters": [
                    RegRemap(remap = {"head": cls.IbRemapData,
                                      "body": cls.IbRemapData,
                                      "dress": cls.IbRemapData}),
                    RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                       "body": cls.IbDrawIndexedRename,
                                       "dress": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed,
                                      "dress": cls.IbTempToDrawIndexed})
                ],
                 "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def barbaraSummertime4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def barbaraSummertime5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer,
                [],
                {"postRegEditFilters": [
                    RegRemap(remap = {"head": cls.IbRemapData,
                                      "body": cls.IbRemapData,
                                      "dress": cls.IbRemapData}),
                    RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                       "body": cls.IbDrawIndexedRename,
                                       "dress": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed,
                                      "dress": cls.IbTempToDrawIndexed})
                ],
                 "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})

    @classmethod
    def cherryHuTao5_3(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["head", "extra"], "body": ["body", "dress"]}], 
                {
                 "preRegEditFilters": [
                         RegRemove(remove = {"head": {*cls.ReflectionHeadRemove, *cls.TexFxRemove},
                                             "body": {*cls.ReflectionBodyRemove},
                                             "dress": {*cls.ReflectionDressRemove, *cls.TexFxRemove},
                                             "extra": {*cls.ReflectionExtraRemove}}),
                         RegTexEdit(textures = {"TransparentBodyDiffuse": ["ps-t0"],
                                                "TransparentyDressDiffuse": ["ps-t1"],
                                                "OpaqueBodyLightMap": ["ps-t1"]}),
                         RegRemove(remove = {"head": {"ps-t0"},
                                             "dress": {"ps-t0"}}),
                         RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], **cls.TexFxTempRegRemap},
                                           "dress": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], **cls.TexFxTempRegRemap}}),
                         RegNewVals(vals = {"head": {**cls.TexFxNoNormalValRename5_0},
                                            "dress": {**cls.TexFxNoNormalValRename5_0}}),
                         RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                           "dress": {**cls.TexFXTempToRun}})
                ],
                "copyPreamble": IniComments.GIMIObjMergerPreamble.value})
    
    @classmethod
    def diluc4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"body": ["body", "dress"]}], 
                {})
    
    @classmethod
    def diluc5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer,
                [{"body": ["body", "dress"]}],
                {"preRegEditOldObj": True,
                 "preRegEditFilters": [
                    RegRemap(remap = {"head": cls.IbRemapData,
                                      "body": cls.IbRemapData}),
                    RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                       "body": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed})
                ],
                 "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def dilucFlamme4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"body": ["body", "dress"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value, 
                 "preRegEditFilters": [
                    RegTexEdit({"TransparentBodyDiffuse": ["ps-t0"], "TransparentDressDiffuse": ["ps-t0"]})
                ]})
    
    @classmethod
    def dilucFlamme5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["head", "head"], "body": ["body", "dress"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value, 
                 "preRegEditFilters": [
                    RegTexEdit({"TransparentBodyDiffuse": ["ps-t0"], "TransparentDressDiffuse": ["ps-t0"]})
                 ],
                 "postRegEditFilters":  [
                    RegRemap(remap = {"head": cls.IbRemapData,
                                      "body": cls.IbRemapData}),
                    RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                       "body": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed})
                 ],
                 "iniPostModelRegEditFilters": [[RegNewVals(vals = cls.IbHashToNull)], [RegNewVals(vals = cls.IbHashToNull)]]})
    
    @classmethod
    def fischl4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"body": ["body", "dress"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value})
    
    @classmethod
    def fischl5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["head", "head"], "body": ["body", "dress"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value,
                 "postRegEditFilters": [
                    RegRemap(remap = {"head": cls.IbRemapData,
                                      "body": cls.IbRemapData}),
                    RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                       "body": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed})
                 ],
                 "iniPostModelRegEditFilters": [[RegNewVals(vals = cls.IbHashToNull)], [RegNewVals(vals = cls.IbHashToNull)]]})

    
    @classmethod
    def fischlHighness4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"body": ["body", "dress"]}], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t2"}}),
                    RegRemap(remap = {"head": {"ps-t3": ["ps-t2"]}})
                ]})
    
    @classmethod
    def fischlHighness5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"body": ["body", "dress"]}], 
                {
                 "preRegEditOldObj": True,
                 "preRegEditFilters": [
                    RegRemap(remap = {"head": cls.IbRemapData,
                                      "body": cls.IbRemapData}),
                    RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                       "body": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed})
                 ],
                 "postRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t2"}}),
                    RegRemap(remap = {"head": {"ps-t3": ["ps-t2"]}}),
                    RegNewVals({"dress": {"ib": "null"}})
                ],
                "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})

    
    @classmethod
    def ganyu4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [],
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], **cls.TexFxTempRegRemap}}),
                    RegTexEdit(textures = {"DarkDiffuse": ["ps-t1"]}),
                    RegTexAdd(textures = {"head": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}}),
                    RegNewVals(vals = {"head": {**cls.TexFXToNormalValRename4_0}}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun}})
                ]})
    
    @classmethod
    def ganyu5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer,
                [],
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], **cls.TexFxTempRegRemap, **cls.IbRemapData},
                                      "body": cls.IbRemapData,
                                      "dress": cls.IbRemapData}),
                    RegTexEdit(textures = {"DarkDiffuse": ["ps-t1"]}),
                    RegTexAdd(textures = {"head": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}}),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename5_0, **cls.IbDrawIndexedRename},
                                       "body": cls.IbDrawIndexedRename,
                                       "dress": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"head": cls.ORFixTempToRun}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed,
                                      "dress": cls.IbTempToDrawIndexed})
                ],
                "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def ganyuTwilight4_4(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t0", *cls.ReflectionHeadRemove, *cls.TexFxRemove},
                                        "body": {*cls.ReflectionBodyRemove},
                                        "dress": {*cls.ReflectionDressRemove}}),
                    RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {**cls.TexFxNoNormalValRename4_0}}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun}})
                ]})
    
    @classmethod
    def ganyuTwilight5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t0", *cls.ReflectionHeadRemove, *cls.TexFxRemove},
                                        "body": {*cls.ReflectionBodyRemove},
                                        "dress": {*cls.ReflectionDressRemove}}),
                    RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], **cls.TexFxTempRegRemap, **cls.IbRemapData},
                                      "body": cls.IbRemapData,
                                      "dress": cls.IbRemapData}),
                    RegNewVals(vals = {"head": {**cls.TexFxNoNormalValRename5_0, **cls.IbDrawIndexedRename},
                                       "body": cls.IbDrawIndexedRename,
                                       "dress": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed,
                                      "dress": cls.IbTempToDrawIndexed})
                ],
                "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def hutao4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"head": ["head", "extra"], "body": ["body", "dress"]}], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t2"},
                                        "body": {"ps-t2", "ps-t3"}})
                ],
                "postRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.TexFxRemove},
                                        "dress": {*cls.TexFxRemove},
                                        "extra": {"ps-t0", "ps-t1"}}),
                    RegNewVals(vals = {"extra": {IniKeywords.Ib.value: "null"}, 
                                       "dress": {IniKeywords.Ib.value: "null"}}),
                    RegTexEdit(textures = {"TransparentHeadDiffuse": ["ps-t0"]}),
                    RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], **cls.TexFxTempRegRemap},
                                      "dress": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {"ps-t0": "null", **cls.TexFXToNormalValRename4_0},
                                       "dress": {**cls.TexFXToNormalValRename4_0}}),
                    RegTexAdd(textures = {"dress": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapBlue.value))}}, mustAdd = False),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "dress": {**cls.TexFXTempToRun}})
                ]})
    
    @classmethod
    def hutao5_6(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"head": ["head", "extra"], "body": ["body", "dress"]}],
                {
                 "preRegEditOldObj": True,
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t2"},
                                        "body": {"ps-t2", "ps-t3"}}),
                    RegRemap(remap = {"head": cls.IbRemapData,
                                      "body": cls.IbRemapData}),
                    RegNewVals(vals = {"head": cls.IbDrawIndexedRename,
                                       "body": cls.IbDrawIndexedRename}),
                    RegRemap(remap = {"head": cls.IbTempToDrawIndexed,
                                      "body": cls.IbTempToDrawIndexed})
                ],
                "postRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.TexFxRemove},
                                        "dress": {*cls.TexFxRemove},
                                        "extra": {"ps-t0", "ps-t1"}}),
                    RegNewVals(vals = {"extra": {IniKeywords.Ib.value: "null"}, 
                                       "dress": {IniKeywords.Ib.value: "null"}}),
                    RegTexEdit(textures = {"TransparentHeadDiffuse": ["ps-t0"]}),
                    RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], **cls.TexFxTempRegRemap},
                                      "dress": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {"ps-t0": "null", **cls.TexFXToNormalValRename5_0},
                                       "dress": {**cls.TexFXToNormalValRename5_0}}),
                    RegTexAdd(textures = {"dress": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapBlue.value))}}, mustAdd = False),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "dress": {**cls.TexFXTempToRun}})
                ],
                "postModelRegEditFilters": [RegNewVals(vals = cls.IbHashToNull)]})
    
    @classmethod
    def jean4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (MultiModFixer, 
                [{ModTypeNames.JeanCN.value: IniFixBuilder(GIMIObjRegEditFixer), 
                  ModTypeNames.JeanSea.value: IniFixBuilder(GIMIObjSplitFixer, args = [{"body": ["body", "dress"]}])}],
                {})
    
    @classmethod
    def jeanCN4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (MultiModFixer, 
                [{ModTypeNames.Jean.value: IniFixBuilder(GIMIObjRegEditFixer), 
                  ModTypeNames.JeanSea.value: IniFixBuilder(GIMIObjSplitFixer, args = [{"body": ["body", "dress"]}])}],
                {})
    
    @classmethod
    def jean5_5(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (MultiModFixer, 
                [{ModTypeNames.JeanCN.value: IniFixBuilder(GIMIObjRegEditFixer, kwargs = {}), 
                  ModTypeNames.JeanSea.value: IniFixBuilder(GIMIObjSplitFixer, 
                                                            args = [{"body": ["body", "dress"]}],
                                                            kwargs = {
                                                                
                                                                "postRegEditFilters": [
                                                                    RegNewVals(vals = {"dress": {"ib": "null"}}),
                                                                    RegTexEdit(textures = {"ShadeLightMap": ["ps-t1"]})
                                                                ]
                                                            })}],
                {})
    
    @classmethod
    def jeanCN5_5(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (MultiModFixer, 
                [{ModTypeNames.Jean.value: IniFixBuilder(GIMIObjRegEditFixer, kwargs = {}), 
                  ModTypeNames.JeanSea.value: IniFixBuilder(GIMIObjSplitFixer, 
                                                            args = [{"body": ["body", "dress"]}],
                                                            kwargs = {
                                                                
                                                                "postRegEditFilters": [
                                                                    RegNewVals(vals = {"dress": {"ib": "null"}}),
                                                                    RegTexEdit(textures = {"ShadeLightMap": ["ps-t1"]})
                                                                ]
                                                            })}],
                {})
    
    @classmethod
    def jeanSea4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"body": ["body", "dress"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value})
    
    @classmethod
    def kaeya4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer,
                [],
                {"postRegEditFilters": [
                    RegRemove(remove = {"body": {*cls.TexFxRemove}}),
                    RegRemap(remap = {"body": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap}}),
                    RegTexAdd(textures = {"body": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}}, mustAdd = False),
                    RegNewVals(vals = {"body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename4_0}}),
                    RegRemap(remap = {"body": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"body": cls.ORFixTempToRun})
                ]})
    
    @classmethod
    def kaeya5_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer,
                [],
                {"postRegEditFilters": [
                    RegRemove(remove = {"body": {*cls.TexFxRemove}}),
                    RegRemap(remap = {"body": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap}}),
                    RegTexAdd(textures = {"body": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}}, mustAdd = False),
                    RegNewVals(vals = {"body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename5_0}}),
                    RegRemap(remap = {"body": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"body": cls.ORFixTempToRun})
                ]})
    
    @classmethod
    def kaeyaSailwind4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer,
                [{"head": ["head"], "body": ["body"], "dress": ["dress", "extra"]}],
                {"preRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.ReflectionHeadRemove},
                                        "body": {"ps-t0", *cls.ReflectionBodyRemove, *cls.TexFxRemove},
                                        "dress": {*cls.ReflectionDressRemove}}),
                    RegRemap(remap = {"body": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], "ps-t3": ["ps-t2"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"body": {**cls.TexFxNoNormalValRename4_0}}),
                    RegRemap(remap = {"body": {**cls.TexFXTempToRun}})
                ]})

    @classmethod
    def kaeyaSailwind5_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer,
                [{"head": ["head"], "body": ["body"], "dress": ["dress", "extra"]}],
                {"preRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.ReflectionHeadRemove},
                                        "body": {*cls.ReflectionBodyRemove, *cls.TexFxRemove},
                                        "dress": {*cls.ReflectionDressRemove}}),
                    RegRemap(remap = {"body": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], "ps-t3": ["ps-t2"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"body": {**cls.TexFxNoNormalValRename5_0}}),
                    RegRemap(remap = {"body": {**cls.TexFXTempToRun}})
                ]})
    
    @classmethod
    def keqing4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["dress", "head"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value, "preRegEditFilters": [
                    RegTexEdit({"OpaqueDressDiffuse": ["ps-t0"], "OpaqueHeadDiffuse": ["ps-t0"]})
                ]})
    
    @classmethod
    def keqingOpulent4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"head": ["head"], "body": ["body", "dress"]}], 
                {"preRegEditFilters": [
                    RegTexEdit(textures = {"NonReflectiveLightMap": ["ps-t1"]})
                ]})
    
    @classmethod
    def kirara4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [],
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"dress": {"ps-t0"}}),
                    RegRemap(remap = {"dress": {"ps-t1": ["ps-t0", "ps-t1"]}}),
                    RegTexEdit(textures = {"WhitenLightMap": ["ps-t2"]})
                ]})
    
    @classmethod
    def kirara5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [],
                {
                    "preRegEditFilters": [
                    RegRemove(remove = {
                        "head": {*cls.ReflectionHeadRemove, *cls.TexFxRemove}, 
                        "body": {*cls.ReflectionBodyRemove, *cls.TexFxRemove}, 
                        "dress": {("ps-t0", cls._removeIsNormalMap), *cls.ReflectionDressRemove, *cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t2": ["ps-t2", cls.ORFixTempReg], **cls.TexFxTempRegRemap},
                                      "body": {"ps-t2": KeyRemapData.build([("ps-t2", cls._remapIsLightMap), (cls.ORFixTempReg, cls._remapIsLightMap)], keepKeyWithoutRemap = True), 
                                               **cls.TexFxTempRegRemap},
                                      "dress": {"ps-t1": KeyRemapData.build([("ps-t0", cls._remapIsDiffuse)], keepKeyWithoutRemap = True), 
                                                "ps-t2": KeyRemapData.build([("ps-t1", cls._remapIsLightMap)], keepKeyWithoutRemap = True), 
                                                **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFxNoNormalValRename5_0},
                                       "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFxNoNormalValRename5_0},
                                       "dress": {**cls.TexFxNoNormalValRename5_0}}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "body": {**cls.TexFXTempToRun},
                                      "dress": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"head": cls.ORFixTempToRun,
                                      "body": cls.ORFixTempToRun})
                ]})
    
    @classmethod
    def kiraraBoots4_8(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemap(remap = {"dress": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"]}}),
                    RegTexAdd(textures = {"dress": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}}, mustAdd = False)
                ]})
    
    @classmethod
    def kiraraBoots5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.ReflectionHeadRemove, *cls.TexFxRemove},
                                        "body": {*cls.ReflectionBodyRemove, *cls.TexFxRemove},
                                        "dress": {("run", cls._regValIsOrFix), "ps-t2"}}),
                    RegRemap(remap = {"head": {"ps-t0": KeyRemapData.build([("tempNorm", cls._remapIsDiffuse), ("ps-t1", cls._remapIsDiffuse)], keepKeyWithoutRemap = True), 
                                               "ps-t1": KeyRemapData.build([("ps-t2", cls._remapIsLightMap), (cls.ORFixTempReg, cls._remapIsLightMap)], keepKeyWithoutRemap = True), 
                                               "ps-t2": KeyRemapData.build([("ps-t2", cls._remapIsLightMap), (cls.ORFixTempReg, cls._remapIsLightMap)], keepKeyWithoutRemap = True),
                                               **cls.TexFxTempRegRemap},
                                      "body": {"ps-t2": KeyRemapData.build([("ps-t2", cls._remapIsLightMap), (cls.ORFixTempReg, cls._remapIsLightMap)], keepKeyWithoutRemap = True),
                                               **cls.TexFxTempRegRemap}}),
                    RegTexAdd(textures = {"head": {"tempNorm": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}}, mustAdd = False),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFxNoNormalValRename5_0},
                                       "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFxNoNormalValRename5_0}}),
                    RegRemap(remap = {"head": {"tempNorm": ["ps-t0"], **cls.TexFXTempToRun},
                                      "body": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"head": cls.ORFixTempToRun,
                                      "body": cls.ORFixTempToRun})
                ]})
    
    @classmethod
    def klee4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"body": ["body", "dress"]}], 
                {
                 "preRegEditFilters": [
                    RegTexEdit(textures = {"GreenLightMap": ["ps-t1"]}),
                    RegRemap(remap = {"head": {"ps-t2": ["ps-t3"]}})
                ]})
    
    @classmethod
    def kleeBlossomingStarlight4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"body": ["body", "dress"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value, "preRegEditFilters": [
                    RegTexEdit(textures = {"TransparentDiffuse": ["ps-t0"]}),
                    RegRemove(remove = {"head": {"ps-t2"}}),
                    RegRemap(remap = {"head": {"ps-t3": ["ps-t2"]}})
                ]})
    
    @classmethod
    def lisa4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer,
                [{"head": ["head"], "body": ["body", "dress"]}],
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value, "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t2"},
                                        "body": {"ps-t3"},
                                        "dress": {"ps-t2"}})
                ],
                "postRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.TexFxRemove},
                                        "body": {*cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], **cls.TexFxTempRegRemap},
                                      "body": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap}}),
                    RegTexAdd(textures = {"head": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value), False)},
                                          "body": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value), False)}}, mustAdd = False),
                    RegNewVals(vals = {"head": {**cls.TexFXToNormalValRename4_0},
                                       "body": {**cls.TexFXToNormalValRename4_0}}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "body": {**cls.TexFXTempToRun}})
                ]})
    
    @classmethod
    def lisa5_4(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer,
                [{"head": ["head"], "body": ["body", "dress"]}],
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value, "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t2"},
                                        "body": {"ps-t3"},
                                        "dress": {"ps-t2"}})
                ],
                "postRegEditFilters": [
                    RegRemove(remove = {"head": {*cls.TexFxRemove},
                                        "body": {*cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], **cls.TexFxTempRegRemap},
                                      "body": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap}}),
                    RegTexAdd(textures = {"head": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple1.value), False)},
                                          "body": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple1.value), False)}}, mustAdd = False),
                    RegNewVals(vals = {"head": {**cls.TexFXToNormalValRename5_0},
                                       "body": {**cls.TexFXToNormalValRename5_0}}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "body": {**cls.TexFXTempToRun}})
                ]})
    
    @classmethod
    def lisa5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer,
                [{"head": ["head"], "body": ["body", "dress"]}],
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value, "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t2"},
                                        "body": {"ps-t3"},
                                        "dress": {"ps-t2"}})
                ]})
    
    @classmethod
    def lisaStudent4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer,
                [{"body": ["body", "dress"]}],
                {
                 "preRegEditOldObj": True,
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t0", "ps-t3", *cls.TexFxRemove}, 
                                        "body": {"ps-t0", "ps-t3", *cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], **cls.TexFxTempRegRemap},
                                      "body": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {**cls.TexFxNoNormalValRename4_0},
                                       "body": {**cls.TexFxNoNormalValRename4_0}}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "body": {**cls.TexFXTempToRun}})
                ],
                "postRegEditFilters": [
                    RegRemap(remap = {"body": {"ps-t3": ["ps-t2"]}})
                ]})
    
    @classmethod
    def mona4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def monaCN4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def nilou4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t0", *cls.ReflectionHeadRemove, *cls.TexFxRemove}, 
                                        "body": {"ps-t0", *cls.ReflectionBodyRemove, *cls.TexFxRemove}, 
                                        "dress": {"ps-t0", *cls.ReflectionDressRemove, *cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1", cls.ORFixTempReg], "ps-t3": ["ps-t2"], **cls.TexFxTempRegRemap},
                                        "body": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1", cls.ORFixTempReg], "ps-t3": ["ps-t2"], **cls.TexFxTempRegRemap},
                                        "dress": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1", cls.ORFixTempReg], "ps-t3": ["ps-t2"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFxNoNormalValRename4_0},
                                       "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFxNoNormalValRename4_0},
                                       "dress": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFxNoNormalValRename4_0}}),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                      "body": {**cls.TexFXTempToRun},
                                      "dress": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"head": cls.ORFixTempToRun,
                                      "body": cls.ORFixTempToRun,
                                      "dress": cls.ORFixTempToRun})
                ]})
    
    @classmethod
    def nilou5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {("ps-t0", cls._removeIsNormalMap), cls.ReflectionHeadRemove}, 
                                        "body": {("ps-t0", cls._removeIsNormalMap), cls.ReflectionDressRemove}, 
                                        "dress": {("ps-t0", cls._removeIsNormalMap), cls.ReflectionDressRemoves}}),
                    RegRemap(remap = {"head": {"ps-t2": KeyRemapData.build([("ps-t2", cls._remapIsLightMap), (cls.ORFixTempReg, cls._remapIsLightMap)], keepKeyWithoutRemap = True)},
                                        "body": {"ps-t2": KeyRemapData.build([("ps-t2", cls._remapIsLightMap), (cls.ORFixTempReg, cls._remapIsLightMap)], keepKeyWithoutRemap = True)},
                                        "dress": {"ps-t2": KeyRemapData.build([("ps-t2", cls._remapIsLightMap), (cls.ORFixTempReg, cls._remapIsLightMap)], keepKeyWithoutRemap = True)}}),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value},
                                       "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value},
                                       "dress": {cls.ORFixTempReg: IniKeywords.ORFixPath.value}}),
                    RegRemap(remap = {"head": {**cls.ORFixTempToRun},
                                      "body": {**cls.ORFixTempToRun},
                                      "dress": {**cls.ORFixTempToRun}})
                ]})
    
    @classmethod
    def nilouBreeze4_8(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t3", *cls.TexFxRemove},
                                        "dress": {"ps-t3", *cls.TexFxRemove},
                                        "body": {"ps-t3", *cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap},
                                        "dress": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap},
                                        "body": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename4_0},
                                        "dress": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename4_0},
                                        "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename4_0}}),
                    RegTexAdd(textures = {"head": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value), False)},
                                            "body": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value), False)},
                                            "dress": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value), False)}}, mustAdd = False),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                        "dress": {**cls.TexFXTempToRun},
                                        "body": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"head": cls.ORFixTempToRun,
                                      "body": cls.ORFixTempToRun,
                                      "dress": cls.ORFixTempToRun})
                ]})
    
    @classmethod
    def nilouBreeze5_4(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t3", *cls.TexFxRemove},
                                        "dress": {"ps-t3", *cls.TexFxRemove},
                                        "body": {"ps-t3", *cls.TexFxRemove}}),
                    RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap},
                                        "dress": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap},
                                        "body": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", cls.ORFixTempReg], "ps-t2": ["ps-t3"], **cls.TexFxTempRegRemap}}),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename5_0},
                                        "dress": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename5_0},
                                        "body": {cls.ORFixTempReg: IniKeywords.ORFixPath.value, **cls.TexFXToNormalValRename5_0}}),
                    RegTexAdd(textures = {"head": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple2.value), False)},
                                            "body": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple2.value), False)},
                                            "dress": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapPurple2.value), False)}}, mustAdd = False),
                    RegRemap(remap = {"head": {**cls.TexFXTempToRun},
                                        "dress": {**cls.TexFXTempToRun},
                                        "body": {**cls.TexFXTempToRun}}),
                    RegRemap(remap = {"head": cls.ORFixTempToRun,
                                      "body": cls.ORFixTempToRun,
                                      "dress": cls.ORFixTempToRun})
                ]})
    
    @classmethod
    def nilouBreeze5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t3"},
                                        "dress": {"ps-t3"},
                                        "body": {"ps-t3"}})
                ]})
    
    @classmethod
    def ningguang4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, 
                [],
                {
                 "preRegEditFilters": [
                    RegTexEdit({"DarkDiffuse": ["ps-t0"]})
                ]})
    
    @classmethod
    def ningguangOrchid4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def rosaria4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def rosariaCN4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjRegEditFixer, [], {})
    
    @classmethod
    def shenhe4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"dress": ["dress", "extra"]}], 
                {
                 "preRegEditFilters": [
                    RegRemove(remove = {"dress": ["ps-t2"]}),
                    RegRemap(remap = {"dress": {"ps-t3": ["ps-t2"]}})
                ]})
    
    @classmethod
    def shenheFrostFlower4_4(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"body": ["body", "extra"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value})
    
    @classmethod
    def shenheFrostFlower5_7(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["head", "head", "head"], "body": ["head", "body", "extra"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value,
                 "postRegEditFilters": [
                     RegNewVals(vals = {"head": {"ib": "null"}})
                 ]})
    
    @classmethod
    def xiangling4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["head", "body", "dress"], "body": ["body"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value,
                 "preRegEditFilters": [
                    RegTexEdit({"DarkDiffuse": ["ps-t0"]}),
                    RegRemove(remove = {"head": {"ps-t2"},
                                        "body": {"ps-t2", "ps-t3"},
                                        "dress": {"ps-t2"}}),
                    RegRemap(remap = {"head": {"ps-t1": ["ps-t2"], "ps-t0": ["ps-t0", "ps-t1"]},
                                      "body": {"ps-t1": ["ps-t2"], "ps-t0": ["ps-t0", "ps-t1"]},
                                      "dress": {"ps-t1": ["ps-t2"], "ps-t0": ["ps-t0", "ps-t1"]}}),
                    RegTexAdd(textures = {"head": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapBlue.value))},
                                          "body": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapBlue.value))},
                                          "dress": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapBlue.value))}}, mustAdd = False),
                ],
                "postRegEditFilters": [
                    RegNewVals(vals = {"body": {IniKeywords.Ib.value: "null"}}),
                    RegRemap(remap = {"head": {"ps-t2": ["ps-t2", cls.ORFixTempReg]}}),
                    RegNewVals(vals = {"head": {cls.ORFixTempReg: IniKeywords.ORFixPath.value}}),
                    RegRemap(remap = {"head": {**cls.ORFixTempToRun}})
                ]})
    
    @classmethod
    def xianglingCheer5_3(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer,
                [{"head": ["head", "dress"], "body": ["body"]}], 
                {
                 "preRegEditOldObj": True,
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t0", *cls.ReflectionHeadRemove}, 
                                        "body": {"ps-t0", *cls.ReflectionBodyRemove}}),
                    RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"]},
                                      "body": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"]}})
                ],
                "postRegEditFilters": [
                    RegNewVals(vals = {"head": {IniKeywords.Ib.value: "null"}})
                ]})
    
    @classmethod
    def xingqiu4_0(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjSplitFixer, 
                [{"head": ["head", "dress"]}], 
                {
                 "postRegEditFilters": [
                    RegRemap(remap = {"head": {"ps-t2": ["ps-t3"]}})
                ]})
    
    @classmethod
    def xingqiuBamboo4_4(cls) -> Tuple[BaseIniFixer, List[Any], Dict[str, Any]]:
        return (GIMIObjMergeFixer, 
                [{"head": ["head", "dress"]}], 
                {
                 "copyPreamble": IniComments.GIMIObjMergerPreamble.value,
                 "preRegEditFilters": [
                    RegRemove(remove = {"head": {"ps-t2"}}),
                    RegRemap(remap = {"head": {"ps-t3": ["ps-t2"]}})
                ]})


IniFixBuilderData = {
    4.0: {
        ModTypeNames.Amber.value: IniFixBuilderFuncs.amber4_0,
        ModTypeNames.AmberCN.value: IniFixBuilderFuncs.amberCN4_0,
        ModTypeNames.Ayaka.value: IniFixBuilderFuncs.ayaka4_0,
        ModTypeNames.AyakaSpringbloom.value: IniFixBuilderFuncs.ayakaSpringbloom4_0,
        ModTypeNames.Barbara.value: IniFixBuilderFuncs.barbara4_0,
        ModTypeNames.BarbaraSummertime.value: IniFixBuilderFuncs.barbaraSummertime4_0,
        ModTypeNames.Diluc.value: IniFixBuilderFuncs.diluc4_0,
        ModTypeNames.DilucFlamme.value: IniFixBuilderFuncs.dilucFlamme4_0,
        ModTypeNames.Fischl.value: IniFixBuilderFuncs.fischl4_0,
        ModTypeNames.FischlHighness.value: IniFixBuilderFuncs.fischlHighness4_0,
        ModTypeNames.Ganyu.value: IniFixBuilderFuncs.ganyu4_0,
        ModTypeNames.HuTao.value: IniFixBuilderFuncs.hutao4_0,
        ModTypeNames.Jean.value: IniFixBuilderFuncs.jean4_0,
        ModTypeNames.JeanCN.value: IniFixBuilderFuncs.jeanCN4_0,
        ModTypeNames.JeanSea.value: IniFixBuilderFuncs.jeanSea4_0,
        ModTypeNames.Kaeya.value: IniFixBuilderFuncs.kaeya4_0,
        ModTypeNames.KaeyaSailwind.value: IniFixBuilderFuncs.kaeyaSailwind4_0,
        ModTypeNames.Keqing.value: IniFixBuilderFuncs.keqing4_0,
        ModTypeNames.KeqingOpulent.value: IniFixBuilderFuncs.keqingOpulent4_0,
        ModTypeNames.Kirara.value: IniFixBuilderFuncs.kirara4_0,
        ModTypeNames.Klee.value: IniFixBuilderFuncs.klee4_0,
        ModTypeNames.KleeBlossomingStarlight.value: IniFixBuilderFuncs.kleeBlossomingStarlight4_0,
        ModTypeNames.Lisa.value: IniFixBuilderFuncs.lisa4_0,
        ModTypeNames.LisaStudent.value: IniFixBuilderFuncs.lisaStudent4_0,
        ModTypeNames.Mona.value: IniFixBuilderFuncs.mona4_0,
        ModTypeNames.MonaCN.value: IniFixBuilderFuncs.monaCN4_0,
        ModTypeNames.Nilou.value: IniFixBuilderFuncs.nilou4_0,
        ModTypeNames.Ningguang.value: IniFixBuilderFuncs.ningguang4_0,
        ModTypeNames.NingguangOrchid.value: IniFixBuilderFuncs.ningguangOrchid4_0,
        ModTypeNames.Raiden.value: IniFixBuilderFuncs.giDefault,
        ModTypeNames.Rosaria.value: IniFixBuilderFuncs.rosaria4_0,
        ModTypeNames.RosariaCN.value: IniFixBuilderFuncs.rosariaCN4_0,
        ModTypeNames.Shenhe.value: IniFixBuilderFuncs.shenhe4_0,
        ModTypeNames.Xiangling.value: IniFixBuilderFuncs.xiangling4_0,
        ModTypeNames.Xingqiu.value: IniFixBuilderFuncs.xingqiu4_0
    },

    4.4: {
        ModTypeNames.GanyuTwilight.value: IniFixBuilderFuncs.ganyuTwilight4_4,
        ModTypeNames.ShenheFrostFlower.value: IniFixBuilderFuncs.shenheFrostFlower4_4,
        ModTypeNames.XingqiuBamboo.value: IniFixBuilderFuncs.xingqiuBamboo4_4
    },

    4.6: {ModTypeNames.Arlecchino.value: IniFixBuilderFuncs.giDefault},

    4.8: {
        ModTypeNames.KiraraBoots.value: IniFixBuilderFuncs.kiraraBoots4_8,
        ModTypeNames.NilouBreeze.value: IniFixBuilderFuncs.nilouBreeze4_8
    },

    5.0: {
        ModTypeNames.Kaeya.value: IniFixBuilderFuncs.kaeya5_0,
        ModTypeNames.KaeyaSailwind.value: IniFixBuilderFuncs.kaeyaSailwind5_0
    },

    5.3: {
        ModTypeNames.CherryHuTao.value: IniFixBuilderFuncs.cherryHuTao5_3,
        ModTypeNames.XianglingCheer.value: IniFixBuilderFuncs.xianglingCheer5_3
    },

    5.4: {
        ModTypeNames.Ayaka.value: IniFixBuilderFuncs.ayaka5_4,
        ModTypeNames.Arlecchino.value: IniFixBuilderFuncs.arlecchino5_4,
        ModTypeNames.NilouBreeze.value: IniFixBuilderFuncs.nilouBreeze5_4,
        ModTypeNames.Lisa.value: IniFixBuilderFuncs.lisa5_4,
    },
    
    5.5: {
        ModTypeNames.Jean.value: IniFixBuilderFuncs.jean5_5,
        ModTypeNames.JeanCN.value: IniFixBuilderFuncs.jeanCN5_5
    },

    5.6: {
        ModTypeNames.HuTao.value: IniFixBuilderFuncs.hutao5_6,
        ModTypeNames.Ayaka.value: IniFixBuilderFuncs.ayaka5_6,
        ModTypeNames.AyakaSpringbloom.value: IniFixBuilderFuncs.ayakaSpringbloom5_6
    },

    5.7: {
        ModTypeNames.Amber.value: IniFixBuilderFuncs.amber5_7,
        ModTypeNames.AmberCN.value: IniFixBuilderFuncs.amberCN5_7,
        ModTypeNames.Ayaka.value: IniFixBuilderFuncs.ayaka5_7,
        ModTypeNames.AyakaSpringbloom.value: IniFixBuilderFuncs.ayakaSpringbloom5_7,
        ModTypeNames.Arlecchino.value: IniFixBuilderFuncs.arlecchino5_7,
        ModTypeNames.Barbara.value: IniFixBuilderFuncs.barbara5_7,
        ModTypeNames.BarbaraSummertime.value: IniFixBuilderFuncs.barbaraSummertime5_7,
        ModTypeNames.Diluc.value: IniFixBuilderFuncs.diluc5_7,
        ModTypeNames.DilucFlamme.value: IniFixBuilderFuncs.dilucFlamme5_7,
        ModTypeNames.Fischl.value: IniFixBuilderFuncs.fischl5_7,
        ModTypeNames.FischlHighness.value: IniFixBuilderFuncs.fischlHighness5_7,
        ModTypeNames.Ganyu.value: IniFixBuilderFuncs.ganyu5_7,
        ModTypeNames.GanyuTwilight.value: IniFixBuilderFuncs.ganyuTwilight5_7,
        ModTypeNames.Kirara.value: IniFixBuilderFuncs.kirara5_7,
        ModTypeNames.KiraraBoots.value: IniFixBuilderFuncs.kiraraBoots5_7,
        ModTypeNames.Lisa.value: IniFixBuilderFuncs.lisa5_7,
        ModTypeNames.Nilou.value: IniFixBuilderFuncs.nilou5_7,
        ModTypeNames.NilouBreeze.value: IniFixBuilderFuncs.nilouBreeze5_7,
        ModTypeNames.ShenheFrostFlower.value: IniFixBuilderFuncs.shenheFrostFlower5_7
    }
}


class IniFixBuilderArgs(ModDictAssets[Callable[[], Tuple[BaseIniFixer, List[Any], Dict[str, Any]]]]):
    """
    This class inherits from :class:`ModDictAssets`
    
    Class for managing functions that create arguments/keyword arguments for an :class:`IniFixBuilder`

    Parameters
    ----------
    repo: Optional[Dict[:class:`str`, Dict[:class:`str`, Callable[[], Tuple[:class:`BaseIniFixer`, List[Any], Dict[:class:`str`, Any]]]]]]
        The original source for any the function that create arguments :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value contains the functions that create arguments/keyword arguments for an :class:`IniFixBuilder` :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, will use the default functions provided by the software :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Optional[Dict[str, Dict[str, Callable[[], Tuple[BaseIniFixer, List[Any], Dict[str, Any]]]]]] = None):
        if (repo is None):
            repo = IniFixBuilderData

        super().__init__(repo)


class ModDataAssets(Enum):
    """
    Refined data used by the software, grouped by version of the game

    .. danger::
        Modifying these data may change how the software fixes mods. If you do
        not want this side-effect, please make a deep-copy of the data before
        editting the data

    :raw-html:`<br />`

    Attributes
    ----------
    IniParseBuilderArgs: :class:`IniParseBuilderArgs`
        The functions that create the arguments/keyword arguments for :class:`IniParseBuilder` to build the correct .ini parser

    IniFixBuilderArgs: :class:`IniFixBuilderArgs`
        The functions that create the arguments/keyword arguments for :class:`IniFixBuilder` to build the correct .ini fixer

    VertexCounts: :class:`VertexCounts`
        The total # of vertices for each mod
    """

    IniParseBuilderArgs = IniParseBuilderArgs()
    IniFixBuilderArgs = IniFixBuilderArgs()
    VertexCounts = VertexCounts()


class GIBuilder(ModTypeBuilder):
    """
    This Class inherits from :class:`ModTypeBuilder`

    Creates new :class:`ModType` objects for some anime game
    """

    @classmethod
    def _regValIsOrFix(cls, val: str) -> bool:
        return val[1] == IniKeywords.ORFixPath.value

    @classmethod
    def amber(cls) -> ModType:
        """
        Creates the :class:`ModType` for Amber

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Amber.value, 
                    Hashes(map = {ModTypeNames.Amber.value: {ModTypeNames.AmberCN.value}}),Indices(map = {ModTypeNames.Amber.value: {ModTypeNames.AmberCN.value}}),
                    aliases = ["BaronBunny", "ColleisBestie"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Amber.value: {ModTypeNames.AmberCN.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Amber.value: {ModTypeNames.AmberCN.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    @classmethod
    def amberCN(cls) -> ModType:
        """
        Creates the :class:`ModType` for AmberCN

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.AmberCN.value, 
                    Hashes(map = {ModTypeNames.AmberCN.value: {ModTypeNames.Amber.value}}),Indices(map = {ModTypeNames.AmberCN.value: {ModTypeNames.Amber.value}}),
                    aliases = ["BaronBunnyCN", "ColleisBestieCN"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.AmberCN.value: {ModTypeNames.Amber.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.AmberCN.value: {ModTypeNames.Amber.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    @classmethod
    def ayaka(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ayaka

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Ayaka.value,
                    Hashes(map = {ModTypeNames.Ayaka.value: {ModTypeNames.AyakaSpringbloom.value}}),Indices(map = {ModTypeNames.Ayaka.value: {ModTypeNames.AyakaSpringbloom.value}}),
                    aliases = ["Ayaya", "Yandere", "NewArchonOfEternity"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Ayaka.value: {ModTypeNames.AyakaSpringbloom.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Ayaka.value: {ModTypeNames.AyakaSpringbloom.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def ayakaSpringBloom(cls) -> ModType:
        """
        Creates the :class:`ModType` for AyakaSpringBloom

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.AyakaSpringbloom.value,
                    Hashes(map = {ModTypeNames.AyakaSpringbloom.value: {ModTypeNames.Ayaka.value}}),Indices(map = {ModTypeNames.AyakaSpringbloom.value: {ModTypeNames.Ayaka.value}}),
                    aliases = ["AyayaFontaine", "YandereFontaine", "NewArchonOfEternityFontaine",
                               "FontaineAyaya", "FontaineYandere", "NewFontaineArchonOfEternity",
                               "MusketeerAyaka", "AyakaMusketeer", "AyayaMusketeer"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.AyakaSpringbloom.value: {ModTypeNames.Ayaka.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.AyakaSpringbloom.value: {ModTypeNames.Ayaka.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    @classmethod
    def arlecchino(cls) -> ModType:
        """
        Creates the :class:`ModType` for Arlecchino

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Arlecchino.value,
                    Hashes(map = {ModTypeNames.Arlecchino.value: {ModTypeNames.ArlecchinoBoss.value}}), Indices(map = {ModTypeNames.Arlecchino.value: {ModTypeNames.ArlecchinoBoss.value}}),
                    aliases = ["Father", "Knave", "Perrie", "Peruere", "Harlequin"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Arlecchino.value: {ModTypeNames.ArlecchinoBoss.value}}),
                    vertexCounts= ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Arlecchino.value: {ModTypeNames.ArlecchinoBoss.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def barbara(cls) -> ModType:
        """
        Creates the :class:`ModType` for Barbara

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Barbara.value,
                    Hashes(map = {ModTypeNames.Barbara.value: {ModTypeNames.BarbaraSummertime.value}}),Indices(map = {ModTypeNames.Barbara.value: {ModTypeNames.BarbaraSummertime.value}}),
                    aliases = ["Idol", "Healer"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Barbara.value: {ModTypeNames.BarbaraSummertime.value}}),
                    vertexCounts= ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Barbara.value: {ModTypeNames.BarbaraSummertime.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def barbaraSummerTime(cls) -> ModType:
        """
        Creates the :class:`ModType` for BarbaraSummerTime

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.BarbaraSummertime.value, 
                    Hashes(map = {ModTypeNames.BarbaraSummertime.value: {ModTypeNames.Barbara.value}}),Indices(map = {ModTypeNames.BarbaraSummertime.value: {ModTypeNames.Barbara.value}}),
                    aliases = ["IdolSummertime", "HealerSummertime", "BarbaraBikini"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.BarbaraSummertime.value: {ModTypeNames.Barbara.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.BarbaraSummertime.value: {ModTypeNames.Barbara.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def cherryHutao(cls) -> ModType:
        """
        Creates the :class:`ModType` for CherryHuTao

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.CherryHuTao.value, 
                     Hashes(map = {ModTypeNames.CherryHuTao.value: {ModTypeNames.HuTao.value}}), Indices(map = {ModTypeNames.CherryHuTao.value: {ModTypeNames.HuTao.value}}),
                     aliases = ["HutaoCherry", "HutaoSnowLaden", "SnowLadenHutao",
                                "LanternRiteHutao", "HutaoLanternRite",
                                "Cherry77thDirectoroftheWangshengFuneralParlor", "CherryQiqiKidnapper",
                                "77thDirectoroftheWangshengFuneralParlorCherry", "QiqiKidnapperCherry",
                                "LanternRite77thDirectoroftheWangshengFuneralParlor", "LanternRiteQiqiKidnapper",
                                "77thDirectoroftheWangshengFuneralParlorLanternRite", "QiqiKidnapperLanternRite",],
                     vgRemaps = VGRemaps(map = {ModTypeNames.CherryHuTao.value: {ModTypeNames.HuTao.value}}),
                     vertexCounts = ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.CherryHuTao.value: {ModTypeNames.HuTao.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def diluc(cls) -> ModType:
        """
        Creates the :class:`ModType` for Diluc

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Diluc.value,
                    Hashes(map = {ModTypeNames.Diluc.value: {ModTypeNames.DilucFlamme.value}}),Indices(map = {ModTypeNames.Diluc.value: {ModTypeNames.DilucFlamme.value}}),
                    aliases = ["KaeyasBrother", "DawnWineryMaster", "AngelShareOwner", "DarkNightBlaze"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Diluc.value: {ModTypeNames.DilucFlamme.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Diluc.value: {ModTypeNames.DilucFlamme.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def dilucFlamme(cls) -> ModType:
        """
        Creates the :class:`ModType` for DilucFlamme

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.DilucFlamme.value,
                    Hashes(map = {ModTypeNames.DilucFlamme.value: {ModTypeNames.Diluc.value}}),Indices(map = {ModTypeNames.DilucFlamme.value: {ModTypeNames.Diluc.value}}),
                    aliases = ["RedDeadOfTheNight", "DarkNightHero"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.DilucFlamme.value: {ModTypeNames.Diluc.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.DilucFlamme.value: {ModTypeNames.Diluc.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def fischl(cls) -> ModType:
        """
        Creates the :class:`ModType` for Fischl

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Fischl.value,
                    Hashes(map = {ModTypeNames.Fischl.value: {ModTypeNames.FischlHighness.value}}),Indices(map = {ModTypeNames.Fischl.value: {ModTypeNames.FischlHighness.value}}),
                    aliases = ["Amy", "Chunibyo", "8thGraderSyndrome", "Delusional", "PrinzessinderVerurteilung", "MeinFraulein", " FischlvonLuftschlossNarfidort", "PrincessofCondemnation", "TheCondemedPrincess", "OzsMiss"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Fischl.value: {ModTypeNames.FischlHighness.value}}),
                    vertexCounts= ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Fischl.value: {ModTypeNames.FischlHighness.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def fischlHighness(cls) -> ModType:
        """
        Creates the :class:`ModType` for FischlHighness

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.FischlHighness.value,
                    Hashes(map = {ModTypeNames.FischlHighness.value: {ModTypeNames.Fischl.value}}),Indices(map = {ModTypeNames.FischlHighness.value: {ModTypeNames.Fischl.value}}),
                    aliases = ["PrincessAmy", "RealPrinzessinderVerurteilung", "Prinzessin", "PrincessFischlvonLuftschlossNarfidort", "PrinzessinFischlvonLuftschlossNarfidort", "ImmernachtreichPrincess", 
                               "PrinzessinderImmernachtreich", "PrincessoftheEverlastingNight", "OzsPrincess"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.FischlHighness.value: {ModTypeNames.Fischl.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.FischlHighness.value: {ModTypeNames.Fischl.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def ganyu(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ganyu

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """

        return ModType(ModTypeNames.Ganyu.value,
                    Hashes(map = {ModTypeNames.Ganyu.value: {ModTypeNames.GanyuTwilight.value}}),Indices(map = {ModTypeNames.Ganyu.value: {ModTypeNames.GanyuTwilight.value}}),
                    aliases = ["Cocogoat"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Ganyu.value: {ModTypeNames.GanyuTwilight.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Ganyu.value: {ModTypeNames.GanyuTwilight.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def ganyuTwilight(cls) -> ModType:
        """
        Creates the :class:`ModType` for GanyuTwilight

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.GanyuTwilight.value,
                    Hashes(map = {ModTypeNames.GanyuTwilight.value: {ModTypeNames.Ganyu.value}}),Indices(map = {ModTypeNames.GanyuTwilight.value: {ModTypeNames.Ganyu.value}}),
                    aliases = ["GanyuLanternRite", "LanternRiteGanyu", "CocogoatTwilight", "CocogoatLanternRite", "LanternRiteCocogoat"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.GanyuTwilight.value: {ModTypeNames.Ganyu.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.GanyuTwilight.value: {ModTypeNames.Ganyu.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def huTao(cls) -> ModType:
        """
        Creates the :class:`ModType` for HuTao

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.HuTao.value, 
                     Hashes(map = {ModTypeNames.HuTao.value: {ModTypeNames.CherryHuTao.value}}), Indices(map = {ModTypeNames.HuTao.value: {ModTypeNames.CherryHuTao.value}}),
                     aliases = ["77thDirectoroftheWangshengFuneralParlor", "QiqiKidnapper"],
                     vgRemaps = VGRemaps(map = {ModTypeNames.HuTao.value: {ModTypeNames.CherryHuTao.value}}),
                     vertexCounts= ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.HuTao.value: {ModTypeNames.CherryHuTao.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    @classmethod
    def jean(cls) -> ModType:
        """
        Creates the :class:`ModType` for Jean

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Jean.value,
                   Hashes(map = {ModTypeNames.Jean.value: {ModTypeNames.JeanCN.value, ModTypeNames.JeanSea.value}}), Indices(map = {ModTypeNames.Jean.value: {ModTypeNames.JeanCN.value, ModTypeNames.JeanSea.value}}),
                   aliases = ["ActingGrandMaster", "KleesBabySitter"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.Jean.value: {ModTypeNames.JeanCN.value, ModTypeNames.JeanSea.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.Jean.value: {ModTypeNames.JeanCN.value, ModTypeNames.JeanSea.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def jeanCN(cls) -> ModType:
        """
        Creates the :class:`ModType` for JeanCN

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.JeanCN.value,
                   Hashes(map = {ModTypeNames.JeanCN.value: {ModTypeNames.Jean.value, ModTypeNames.JeanSea.value}}), Indices(map = {ModTypeNames.JeanCN.value: {ModTypeNames.Jean.value, ModTypeNames.JeanSea.value}}),
                   aliases = ["ActingGrandMasterCN", "KleesBabySitterCN"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.JeanCN.value: {ModTypeNames.Jean.value, ModTypeNames.JeanSea.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.JeanCN.value: {ModTypeNames.Jean.value, ModTypeNames.JeanSea.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def jeanSea(cls) -> ModType:
        """
        Creates the :class:`ModType` for JeanSea

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.JeanSea.value,
                   Hashes(map = {ModTypeNames.JeanSea.value: {ModTypeNames.Jean.value, ModTypeNames.JeanCN.value}}), Indices(map = {ModTypeNames.JeanSea.value: {ModTypeNames.Jean.value, ModTypeNames.JeanCN.value}}),
                   aliases = ["ActingGrandMasterSea", "KleesBabySitterSea"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.JeanSea.value: {ModTypeNames.Jean.value, ModTypeNames.JeanCN.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.JeanSea.value: {ModTypeNames.Jean.value, ModTypeNames.JeanCN.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def kaeya(cls) -> ModType:
        """
        Creates the :class:`ModType` for Kaeya

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Kaeya.value,
                   Hashes(map = {ModTypeNames.Kaeya.value: {ModTypeNames.KaeyaSailwind.value}}),Indices(map = {ModTypeNames.Kaeya.value: {ModTypeNames.KaeyaSailwind.value}}),
                   aliases = ["DilucsBrother", "CavalryCaptain"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.Kaeya.value: {ModTypeNames.KaeyaSailwind.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.Kaeya.value: {ModTypeNames.KaeyaSailwind.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def kaeyaSailwind(cls) -> ModType:
        """
        Creates the :class:`ModType` for KaeyaSailwind

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.KaeyaSailwind.value,
                   Hashes(map = {ModTypeNames.KaeyaSailwind.value: {ModTypeNames.Kaeya.value}}),Indices(map = {ModTypeNames.KaeyaSailwind.value: {ModTypeNames.Kaeya.value}}),
                   aliases = ["DilucsBrotherSailwind", "CavalryCaptainSailwind", "TheftKaeya", "TheftDilucsBrother", "TheftCavalryCaptain", 
                              "KaeyaTheft", "DilucsBrotherTheft", "CavalryCaptainTheft"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.KaeyaSailwind.value: {ModTypeNames.Kaeya.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.KaeyaSailwind.value: {ModTypeNames.Kaeya.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def keqing(cls) -> ModType:
        """
        Creates the :class:`ModType` for Keqing

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Keqing.value,
                   Hashes(map = {ModTypeNames.Keqing.value: {ModTypeNames.KeqingOpulent.value}}),Indices(map = {ModTypeNames.Keqing.value: {ModTypeNames.KeqingOpulent.value}}),
                   aliases = ["Kequeen", "ZhongliSimp", "MoraxSimp"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.Keqing.value: {ModTypeNames.KeqingOpulent.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.Keqing.value: {ModTypeNames.KeqingOpulent.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def keqingOpulent(cls) -> ModType:
        """
        Creates the :class:`ModType` for KeqingOpulent

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.KeqingOpulent.value,
            Hashes(map = {ModTypeNames.KeqingOpulent.value: {ModTypeNames.Keqing.value}}),Indices(map = {ModTypeNames.KeqingOpulent.value: {ModTypeNames.Keqing.value}}),
            aliases = ["LanternRiteKeqing", "KeqingLaternRite", "CuterKequeen", "LanternRiteKequeen", "KequeenLanternRite", "KequeenOpulent", "CuterKeqing", 
                       "ZhongliSimpOpulent", "MoraxSimpOpulent", "ZhongliSimpLaternRite", "MoraxSimpLaternRite", "LaternRiteZhongliSimp", "LaternRiteMoraxSimp"],
            vgRemaps = VGRemaps(map = {ModTypeNames.KeqingOpulent.value: {ModTypeNames.Keqing.value}}), 
            vertexCounts = ModDataAssets.VertexCounts.value,
            positionEditors = PositionEditors(map = {ModTypeNames.KeqingOpulent.value: {ModTypeNames.Keqing.value}}),
            iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
            iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def kirara(cls) -> ModType:
        """
        Creates the :class:`ModType` for Kirara

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Kirara.value,
                    Hashes(map = {ModTypeNames.Kirara.value: {ModTypeNames.KiraraBoots.value}}),Indices(map = {ModTypeNames.Kirara.value: {ModTypeNames.KiraraBoots.value}}),
                    aliases = ["Nekomata", "KonomiyaExpress", "CatBox"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Kirara.value: {ModTypeNames.KiraraBoots.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Kirara.value: {ModTypeNames.KiraraBoots.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def kiraraBoots(cls) -> ModType:
        """
        Creates the :class:`ModType` for KiraraBoots

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.KiraraBoots.value,
                    Hashes(map = {ModTypeNames.KiraraBoots.value: {ModTypeNames.Kirara.value}}),Indices(map = {ModTypeNames.KiraraBoots.value: {ModTypeNames.Kirara.value}}),
                    aliases = ["NekomataInBoots", "KonomiyaExpressInBoots", "CatBoxWithBoots", "PussInBoots"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.KiraraBoots.value: {ModTypeNames.Kirara.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.KiraraBoots.value: {ModTypeNames.Kirara.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def klee(cls) -> ModType:
        """
        Creates the :class:`ModType` for Klee

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Klee.value,
                    Hashes(map = {ModTypeNames.Klee.value: {ModTypeNames.KleeBlossomingStarlight.value}}),Indices(map = {ModTypeNames.Klee.value: {ModTypeNames.KleeBlossomingStarlight.value}}),
                    aliases = ["SparkKnight", "DodocoBuddy", "DestroyerofWorlds"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Klee.value: {ModTypeNames.KleeBlossomingStarlight.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Klee.value: {ModTypeNames.KleeBlossomingStarlight.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    @classmethod
    def kleeBlossomingStarlight(cls) -> ModType:
        """
        Creates the :class:`ModType` for KleeBlossomingStarlight

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.KleeBlossomingStarlight.value,
                    Hashes(map = {ModTypeNames.KleeBlossomingStarlight.value: {ModTypeNames.Klee.value}}),Indices(map = {ModTypeNames.KleeBlossomingStarlight.value: {ModTypeNames.Klee.value}}),
                    aliases = ["RedVelvetMage", "DodocoLittleWitchBuddy", "MagicDestroyerofWorlds", "FlandreScarlet", "ScarletFlandre"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.KleeBlossomingStarlight.value: {ModTypeNames.Klee.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.KleeBlossomingStarlight.value: {ModTypeNames.Klee.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def lisa(cls) -> ModType:
        """
        Creates the :class:`ModType` for Lisa

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Lisa.value,
                    Hashes(map = {ModTypeNames.Lisa.value: {ModTypeNames.LisaStudent.value}}),Indices(map = {ModTypeNames.Lisa.value: {ModTypeNames.LisaStudent.value}}),
                    aliases = ["CutieLibrarian"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.Lisa.value: {ModTypeNames.LisaStudent.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.Lisa.value: {ModTypeNames.LisaStudent.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def lisaStudent(cls) -> ModType:
        """
        Creates the :class:`ModType` for LisaStudent

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.LisaStudent.value,
                    Hashes(map = {ModTypeNames.LisaStudent.value: {ModTypeNames.Lisa.value}}),Indices(map = {ModTypeNames.LisaStudent.value: {ModTypeNames.Lisa.value}}),
                    aliases = ["LisaSumeru", "SumeruLisa", "AkademiyaLisa", "LisaAkademiya"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.LisaStudent.value: {ModTypeNames.Lisa.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.LisaStudent.value: {ModTypeNames.Lisa.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    @classmethod
    def mona(cls) -> ModType:
        """
        Creates the :class:`ModType` for Mona

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Mona.value,
                   Hashes(map = {ModTypeNames.Mona.value: {ModTypeNames.MonaCN.value}}),Indices(map = {ModTypeNames.Mona.value: {ModTypeNames.MonaCN.value}}),
                   aliases = ["NoMora", "BigHat"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.Mona.value: {ModTypeNames.MonaCN.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.Mona.value: {ModTypeNames.MonaCN.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def monaCN(cls) -> ModType:
        """
        Creates the :class:`ModType` for MonaCN

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.MonaCN.value,
                   Hashes(map = {ModTypeNames.MonaCN.value: {ModTypeNames.Mona.value}}),Indices(map = {ModTypeNames.MonaCN.value: {ModTypeNames.Mona.value}}),
                   aliases = ["NoMoraCN", "BigHatCN"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.MonaCN.value: {ModTypeNames.Mona.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.MonaCN.value: {ModTypeNames.Mona.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def nilou(cls) -> ModType:
        """
        Creates the :class:`ModType` for Nilou

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Nilou.value,
                   Hashes(map = {ModTypeNames.Nilou.value: {ModTypeNames.NilouBreeze.value}}),Indices(map = {ModTypeNames.Nilou.value: {ModTypeNames.NilouBreeze.value}}),
                   aliases = ["Dancer", "Morgiana", "BloomGirl"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.Nilou.value: {ModTypeNames.NilouBreeze.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.Nilou.value: {ModTypeNames.NilouBreeze.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    @classmethod
    def nilouBreeze(cls) -> ModType:
        """
        Creates the :class:`ModType` for NilouBreeze

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """ 
        return ModType(ModTypeNames.NilouBreeze.value, 
                   Hashes(map = {ModTypeNames.NilouBreeze.value: {ModTypeNames.Nilou.value}}),Indices(map = {ModTypeNames.NilouBreeze.value: {ModTypeNames.Nilou.value}}),
                   aliases = ["ForestFairy", "NilouFairy", "DancerBreeze", "MorgianaBreeze", "BloomGirlBreeze",
                              "DancerFairy", "MorgianaFairy", "BloomGirlFairy", "FairyNilou", "FairyDancer", "FairyMorgiana", "FairyBloomGirl"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.NilouBreeze.value: {ModTypeNames.Nilou.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.NilouBreeze.value: {ModTypeNames.Nilou.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    @classmethod
    def ningguang(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ningguang

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """

        return ModType(ModTypeNames.Ningguang.value,
                   Hashes(map = {ModTypeNames.Ningguang.value: {ModTypeNames.NingguangOrchid.value}}),Indices(map = {ModTypeNames.Ningguang.value: {ModTypeNames.NingguangOrchid.value}}),
                   aliases = ["GeoMommy", "SugarMommy"],
                   vgRemaps = VGRemaps(map = {ModTypeNames.Ningguang.value: {ModTypeNames.NingguangOrchid.value}}),
                   vertexCounts = ModDataAssets.VertexCounts.value,
                   positionEditors = PositionEditors(map = {ModTypeNames.Ningguang.value: {ModTypeNames.NingguangOrchid.value}}),
                   iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                   iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def ningguangOrchid(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ningguang

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.NingguangOrchid.value,
                    Hashes(map = {ModTypeNames.NingguangOrchid.value: {ModTypeNames.Ningguang.value}}),Indices(map = {ModTypeNames.NingguangOrchid.value: {ModTypeNames.Ningguang.value}}),
                    aliases = ["NingguangLanternRite", "LanternRiteNingguang", "GeoMommyOrchid", "SugarMommyOrchid", "GeoMommyLaternRite", "SugarMommyLanternRite",
                               "LaternRiteGeoMommy", "LanternRiteSugarMommy"],
                    vgRemaps = VGRemaps(map = {ModTypeNames.NingguangOrchid.value: {ModTypeNames.Ningguang.value}}),
                    vertexCounts = ModDataAssets.VertexCounts.value,
                    positionEditors = PositionEditors(map = {ModTypeNames.NingguangOrchid.value: {ModTypeNames.Ningguang.value}}),
                    iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                    iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def raiden(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ei

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Raiden.value,
                     hashes = Hashes(map = {ModTypeNames.Raiden.value: {ModTypeNames.RaidenBoss.value}}), indices = Indices(),
                     aliases = ["Ei", "RaidenEi", "Shogun", "RaidenShogun", "RaidenShotgun", "Shotgun", "CrydenShogun", "Cryden", "SmolEi"], 
                     vgRemaps = VGRemaps(map = {ModTypeNames.Raiden.value: {ModTypeNames.RaidenBoss.value}}),
                     vertexCounts = ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.Raiden.value: {ModTypeNames.RaidenBoss.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def rosaria(cls) -> ModType:
        """
        Creates the :class:`ModType` for Rosaria

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Rosaria.value,
                      Hashes(map = {ModTypeNames.Rosaria.value: {ModTypeNames.RosariaCN.value}}), Indices(map = {ModTypeNames.Rosaria.value: {ModTypeNames.RosariaCN.value}}),
                      aliases = ["GothGirl"],
                      vgRemaps = VGRemaps(map = {ModTypeNames.Rosaria.value: {ModTypeNames.RosariaCN.value}}),
                      vertexCounts = ModDataAssets.VertexCounts.value,
                      positionEditors = PositionEditors(map = {ModTypeNames.Rosaria.value: {ModTypeNames.RosariaCN.value}}),
                      iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                      iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def rosariaCN(cls) -> ModType:
        """
        Creates the :class:`ModType` for RosariaCN

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.RosariaCN.value,
                      Hashes(map = {ModTypeNames.RosariaCN.value: {ModTypeNames.Rosaria.value}}), Indices(map = {ModTypeNames.RosariaCN.value: {ModTypeNames.Rosaria.value}}),
                      aliases = ["GothGirlCN"],
                      vgRemaps = VGRemaps(map = {ModTypeNames.RosariaCN.value: {ModTypeNames.Rosaria.value}}),
                      vertexCounts = ModDataAssets.VertexCounts.value,
                      positionEditors = PositionEditors(map = {ModTypeNames.RosariaCN.value: {ModTypeNames.Rosaria.value}}),
                      iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                      iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def shenhe(cls) -> ModType:
        """
        Creates the :class:`ModType` for Shenhe

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Shenhe.value,
                     Hashes(map = {ModTypeNames.Shenhe.value: {ModTypeNames.ShenheFrostFlower.value}}), Indices(map = {ModTypeNames.Shenhe.value: {ModTypeNames.ShenheFrostFlower.value}}),
                     aliases = ["YelansBestie", "RedRopes"],
                     vgRemaps = VGRemaps(map = {ModTypeNames.Shenhe.value: {ModTypeNames.ShenheFrostFlower.value}}),
                     vertexCounts = ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.Shenhe.value: {ModTypeNames.ShenheFrostFlower.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def shenheFrostFlower(cls) -> ModType:
        """
        Creates the :class:`ModType` for ShenheFrostFlower

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.ShenheFrostFlower.value,
                     Hashes(map = {ModTypeNames.ShenheFrostFlower.value: {ModTypeNames.Shenhe.value}}), Indices(map = {ModTypeNames.ShenheFrostFlower.value: {ModTypeNames.Shenhe.value}}),
                     aliases = ["ShenheLanternRite", "LanternRiteShenhe", "YelansBestieFrostFlower", "YelansBestieLanternRite", "LanternRiteYelansBestie",
                                "RedRopesFrostFlower", "RedRopesLanternRite", "LanternRiteRedRopes"],
                     vgRemaps = VGRemaps(map = {ModTypeNames.ShenheFrostFlower.value: {ModTypeNames.Shenhe.value}}),
                     vertexCounts = ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.ShenheFrostFlower.value: {ModTypeNames.Shenhe.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def xiangling(cls) -> ModType:
        """
        Creates the :class:`ModType` for Xiangling

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Xiangling.value,
                     Hashes(map = {ModTypeNames.Xiangling.value: {ModTypeNames.XianglingCheer.value}}), Indices(map = {ModTypeNames.Xiangling.value: {ModTypeNames.XianglingCheer.value}}),
                     aliases = ["CookingFanatic", "HeadChefoftheWanminRestaurant", "ChefMaosDaughter", "GuobasBuddy"],
                     vgRemaps = VGRemaps(map = {ModTypeNames.Xiangling.value: {ModTypeNames.XianglingCheer.value}}),
                     vertexCounts = ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.Xiangling.value: {ModTypeNames.XianglingCheer.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def xianglingCheer(cls) -> ModType:
        """
        Creates the :class:`ModType` for XianglingCheer

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """

        return ModType(ModTypeNames.XianglingCheer.value,
                     Hashes(map = {ModTypeNames.XianglingCheer.value: {ModTypeNames.Xiangling.value}}), Indices(map = {ModTypeNames.XianglingCheer.value: {ModTypeNames.Xiangling.value}}),
                     aliases = ["XianglingLanternRite", "LanternRiteXiangling", 
                                "CookingFanaticLanternRite", "HeadChefoftheWanminRestaurantLanternRite", "ChefMaosDaughterLanternRite", "GuobasBuddyLanternRite",
                                "LanternRiteCookingFanatic", "LanternRiteHeadChefoftheWanminRestaurant", "LanternRiteChefMaosDaughter", "LanternRiteGuobasBuddy"],
                     vgRemaps = VGRemaps(map = {ModTypeNames.XianglingCheer.value: {ModTypeNames.Xiangling.value}}),
                     vertexCounts = ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.XianglingCheer.value: {ModTypeNames.Xiangling.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))

    
    @classmethod
    def xingqiu(cls) -> ModType:
        """
        Creates the :class:`ModType` for Xingqiu

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.Xingqiu.value,
                     Hashes(map = {ModTypeNames.Xingqiu.value: {ModTypeNames.XingqiuBamboo.value}}), Indices(map = {ModTypeNames.Xingqiu.value: {ModTypeNames.XingqiuBamboo.value}}),
                     aliases = ["GuhuaGeek", "Bookworm", "SecondSonofTheFeiyunCommerceGuild", "ChongyunsBestie"],
                     vgRemaps = VGRemaps(map = {ModTypeNames.Xingqiu.value: {ModTypeNames.XingqiuBamboo.value}}),
                     vertexCounts = ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.Xingqiu.value: {ModTypeNames.XingqiuBamboo.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))
    
    @classmethod
    def xingqiuBamboo(cls) -> ModType:
        """
        Creates the :class:`ModType` for XingqiuBamboo

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType(ModTypeNames.XingqiuBamboo.value,
                     Hashes(map = {ModTypeNames.XingqiuBamboo.value: {ModTypeNames.Xingqiu.value}}), Indices(map = {ModTypeNames.XingqiuBamboo.value: {ModTypeNames.Xingqiu.value}}),
                     aliases = ["XingqiuLanternRite", "GuhuaGeekLanternRite", "BookwormLanternRite", "SecondSonofTheFeiyunCommerceGuildLanternRite", "ChongyunsBestieLanternRite",
                                "LanternRiteXingqiu", "LanternRiteGuhuaGeek", "LanternRiteBookworm", "LanternRiteSecondSonofTheFeiyunCommerceGuild", "LanternRiteChongyunsBestie",
                                "GuhuaGeekBamboo", "BookwormBamboo", "SecondSonofTheFeiyunCommerceGuildBamboo", "ChongyunsBestieBamboo"],
                     vgRemaps = VGRemaps(map = {ModTypeNames.XingqiuBamboo.value: {ModTypeNames.Xingqiu.value}}),
                     vertexCounts = ModDataAssets.VertexCounts.value,
                     positionEditors = PositionEditors(map = {ModTypeNames.XingqiuBamboo.value: {ModTypeNames.Xingqiu.value}}),
                     iniParseBuilder = IniParseBuilder(ModDataAssets.IniParseBuilderArgs.value),
                     iniFixBuilder = IniFixBuilder(ModDataAssets.IniFixBuilderArgs.value))


ModTypesSearchDFA = GlobalClassifiers.ModTypes.value


class ModTypes(Enum):
    r"""
    The supported types of mods that can be fixed :raw-html:`<br />`

    .. caution::
        The different :class:`ModType` objects in this enum are used by the software to help fix specific types of mods.

        Modifying the objects within this enum will also modify the behaviour of how this software fixes a particular mod.
        If this side effect is not your intention, then you can construct a brand new :class:`ModType` object from the :class:`GIBuilder` class

    :raw-html:`<br />`

    .. tip::
        Before parsing the regexes below, the text is normalized by being converted to all lowercase

    :raw-html:`<br />`

    Attributes
    ----------
    Amber: :class:`ModType`
        **Amber mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(amber)((?!cn).)*\]``

    AmberCN: :class:`ModType`
        **Amber Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(ambercn).*\]``

    Ayaka: :class:`ModType`
        **Ayaka mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(ayaka)((?!(springbloom)).)*\]``

    AyakaSpringBloom: :class:`ModType`
        **Ayaka Fontaine mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(ayakaspringbloom).*\]``

    Arlecchino: :class:`ModType`
        **Arlecchino mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(arlecchino).*\]``

    Barbara: :class:`ModType`
        **Barabara mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(barbara)((?!summertime).)*\]``

    BarbaraSummertime: :class:`ModType`
        **Barabara Summer mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(barbarasummertime).*\]``

    CherryHuTao: :class:`ModType`
        **Hu Tao Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(cherryhutao|hutaocherry).*\]``

    Diluc: :class:`ModType`
        **Diluc mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(diluc)((?!flamme).)*\]``

    DilucFlamme: :class:`ModType`
        **Diluc Red Dead of the Night mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(dilucflamme).*\]``

    Fischl: :class:`ModType`
        **Fischl mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(fischl)((?!highness).)*\]``

    FischlHighness: :class:`ModType`
        **Fischl Summer mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(fischlhighness).*\]``

    Ganyu: :class:`ModType`
        **Ganyu mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(ganyu)((?!(twilight)).)*\]``

    GanyuTwilight: :class:`ModType`
        **Ganyu Latern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(ganyutwilight).*\]``

    HuTao: :class:`ModType`
        **Hu Tao mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride((?!cherry).)*(hutao)((?!cherry).)*\]``

    Jean: :class:`ModType`
        **Jean mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(jean)((?!(cn|sea)).)*\]``

    JeanCN: :class:`ModType`
        **Jean Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(jeancn)((?!sea).)*\]``

    JeanSea: :class:`ModType`
        **Jean Summertime mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(jeansea)((?!cn).)*\]``

    Kaeya: :class:`ModType`
        **Kaeya mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(kaeya)((?!(sailwind)).)*\]``

    KaeyaSailwind: :class:`ModType`'
        **Kaeya Summertime mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(kaeyasailwind).*\]``

    Keqing: :class:`ModType`
        **Keqing mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(keqing)((?!(opulent)).)*\]``

    KeqingOpulent: :class:`ModType`
        **Keqing Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(keqingopulent).*\]``

    Kirara: :class:`ModType`
        **Kirara mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(kirara)((?!boots).)*\]``

    KiraraBoots: :class:`ModType`
        **Kirara in Boots mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(kiraraboots).*\]``

    Klee: :class:`ModType`
        **Klee mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(klee)((?!blossomingstarlight).)*\]``

    KleeBlossomingStarlight: :class:`ModType`
        **Klee Summertime mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(kleeblossomingstarlight).*\]``

    Lisa: :class:`ModType`
        **Lisa mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(lisa)((?!student).)*\]``

    LisaStudent: :class:`ModType`
        **Lisa Sumeru mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(lisastudent).*\]``

    Mona: :class:`ModType`
        **Mona mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(mona)((?!(cn)).)*\]``

    MonaCN: :class:`ModType`
        **Mona Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(monacn).*\]``

    Nilou: :class:`ModType`
        **Nilou mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(nilou)((?!(breeze)).)*\]``

    NilouBreeze: :class:`ModType`
        **Nilou Forest Fairy mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(niloubreeze).*\]``

    Ningguang: :class:`ModType`
        **Ningguang Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(ningguang)((?!(orchid)).)*\]``

    NingguangOrchid: :class:`ModType`
        **Ningguang Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(ningguangorchid).*\]``

    Raiden: :class:`ModType`
        **Raiden mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(raiden|shogun).*\]``

    Rosaria: :class:`ModType`
        **Rosaria mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(rosaria)((?!(cn)).)*\]``

    RosariaCN: :class:`ModType`
        **Rosaria Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(rosariacn).*\]``

    Shenhe: :class:`ModType`
        **Shenhe mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(shenhe)((?!frostflower).)*\]``

    ShenheFrostFlower: :class:`ModType`
        **Shenhe Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(shenhefrostflower).*\]``

    Xiangling: :class:`ModType`
        **Xiangling mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(xiangling)((?!cheer).)*\]``

    XianglingCheer: :class:`ModType`
        **Xiangling Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(xiangling(cheer|newyear)).*\]``

    Xingqiu: :class:`ModType`
        **Xingqiu mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(xingqiu)((?!bamboo).)*\]``

    XingqiuBamboo: :class:`ModType`
        **Xingqiu Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*textureoverride.*(xingqiubamboo).*\]``
    """

    Amber = GIBuilder.amber()
    AmberCN = GIBuilder.amberCN()
    Ayaka = GIBuilder.ayaka()
    AyakaSpringBloom = GIBuilder.ayakaSpringBloom()
    Arlecchino = GIBuilder.arlecchino()
    Barbara = GIBuilder.barbara()
    BarbaraSummertime = GIBuilder.barbaraSummerTime()
    CherryHuTao = GIBuilder.cherryHutao()
    Diluc = GIBuilder.diluc()
    DilucFlamme = GIBuilder.dilucFlamme()
    Fischl = GIBuilder.fischl()
    FischlHighness = GIBuilder.fischlHighness()
    Ganyu = GIBuilder.ganyu()
    GanyuTwilight = GIBuilder.ganyuTwilight()
    HuTao = GIBuilder.huTao()
    Jean = GIBuilder.jean()
    JeanCN = GIBuilder.jeanCN()
    JeanSea = GIBuilder.jeanSea()
    Kaeya = GIBuilder.kaeya()
    KaeyaSailwind = GIBuilder.kaeyaSailwind()
    Keqing = GIBuilder.keqing()
    KeqingOpulent = GIBuilder.keqingOpulent()
    Kirara = GIBuilder.kirara()
    KiraraBoots = GIBuilder.kiraraBoots()
    Klee = GIBuilder.klee()
    KleeBlossomingStarlight = GIBuilder.kleeBlossomingStarlight()
    Lisa = GIBuilder.lisa()
    LisaStudent = GIBuilder.lisaStudent()
    Mona = GIBuilder.mona()
    MonaCN = GIBuilder.monaCN()
    Nilou = GIBuilder.nilou()
    NilouBreeze = GIBuilder.nilouBreeze()
    Ningguang = GIBuilder.ningguang()
    NingguangOrchid = GIBuilder.ningguangOrchid()
    Raiden = GIBuilder.raiden()
    Rosaria = GIBuilder.rosaria()
    RosariaCN = GIBuilder.rosariaCN()
    Shenhe = GIBuilder.shenhe()
    ShenheFrostFlower = GIBuilder.shenheFrostFlower()
    Xiangling = GIBuilder.xiangling()
    XianglingCheer = GIBuilder.xianglingCheer()
    Xingqiu = GIBuilder.xingqiu()
    XingqiuBamboo = GIBuilder.xingqiuBamboo()
    
    @classmethod
    def getAll(cls) -> Set["ModType"]:
        """
        Retrieves a set of all the mod types available

        Returns
        -------
        Set[:class:`ModType`]
            All the available mod types
        """

        result = set()
        for modTypeEnum in cls:
            result.add(modTypeEnum.value)
        return result
    
    @classmethod
    def setupSearch(cls):
        if (ModTypesSearchDFA.isSetup):
            return
        
        data = {}
        for modTypeEnum in cls:
            modType = modTypeEnum.value
            data[modType.name.lower()] = modType

            for nickname in modType.aliases:
                data[nickname.lower()] = modType

        ModTypesSearchDFA.setup(data)
    
    @classmethod
    def search(cls, name: str):
        """
        Searches a mod type based off the provided name

        Parameters
        ----------
        name: :class:`str`
            The name of the mod to search for

        Returns
        -------
        Optional[:class:`ModType`]
            The found mod type based off the provided name
        """

        cls.setupSearch()
        keyword, modType = ModTypesSearchDFA.dfa.getMaximal(name.lower().strip(), errorOnNotFound = False)
        return modType
    
    @classmethod
    def getHelpStr(cls, showFullMods: bool = False) -> str:
        result = ""
        helpHeading = Heading("supported types of mods", 15)
        result += f"{helpHeading.open()}\n\nThe names/aliases for the mod types are not case sensitive\n\n"

        if (not showFullMods):
            result += "Below contains a condensed list of all the supported mods, for more details, please visit:\nhttps://github.com/nhok0169/Anime-Game-Remap/tree/nhok0169/Anime%20Game%20Remap%20(for%20all%20users)/api#mod-types\n\n"

        modTypeHelpTxt = []
        for modTypeEnum in cls:
            modType = modTypeEnum.value
            
            if (showFullMods):
                currentHelpStr = modType.getHelpStr()
            else:
                currentHelpStr = f"- {modType.name}"

            modTypeHelpTxt.append(currentHelpStr)

        modTypeHelpTxt = "\n".join(modTypeHelpTxt)
        
        result += f"{modTypeHelpTxt}\n\n{helpHeading.close()}"
        return result


class InvalidModType(Error):
    """
    This Class inherits from :class:`Error`

    Exception when the type of mod specified to fix is not found

    Parameters
    ----------
    type: :class:`str`
        The name for the type of mod specified
    """
    def __init__(self, type: str):
        super().__init__(f"Unable to find the type of mod by the search string, '{type}'")


class InvalidDownloadMode(Error):
    """
    This Class inherits from :class:`Error`

    Exception when the download mode to activate is not found

    Parameters
    ----------
    mode: :class:`str`
        The name for the download mode specified
    """
    def __init__(self, mode: str):
        super().__init__(f"Unable to find the download mode by the string, '{mode}'")


class ConflictingOptions(Error):
    """
    This Class inherits from :class:`Error`

    Exception when the script or :class:`RemapService` is ran with options that cannot be used together

    Parameters
    ----------
    options: List[:class:`str`]
        The options that cannot be used together
    """
    def __init__(self, options: List[str]):
        optionsStr = ", ".join(options)
        super().__init__(f"The following options cannot be used toghether: {optionsStr}")


class Logger():
    """
    Class for pretty printing output to display on the console

    Parameters
    ----------
    prefix: :class:`str`
        line that is printed before any message is printed out :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ""

    logTxt: :class:`bool`
        Whether to log all the printed messages into a .txt file once the fix is done :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    verbose: :class:`bool`
        Whether to print out output :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    Attributes
    ----------
    includePrefix: :class:`bool`
        Whether to include the prefix string when printing out a message

    verbose: :class:`bool`
        Whether to print out output

    logTxt: :class:`bool`
        Whether to log all the printed messages into a .txt file once the fix is done

    _prefix: :class:`str`
        line that is printed before any message is printed out

    _headings: Deque[:class:`Heading`]
        A stack of headings that have been opened (by calling :meth:`Heading.open`), but have not been closed yet (have not called :meth:`Heading.close` yet)

    _loggedTxt: :class:`str`
        The text that will be logged into a .txt file
    """

    DefaultHeadingSideLen = 2
    DefaultHeadingChar = "="

    def __init__(self, prefix: str = "", logTxt: bool = False, verbose: bool = True):
        self._prefix = prefix
        self.includePrefix = True
        self.verbose = verbose
        self.logTxt = logTxt
        self._loggedTxt = ""
        self._headings = deque()
        self._currentPrefixTxt = ""

        self._setDefaultHeadingAtts()

    @property
    def prefix(self):
        """
        The line of text that is printed before any message is printed out

        :getter: Returns such a prefix
        :setter: Sets up such a prefix for the logger
        :type: :class:`str`
        """
        return self._prefix
    
    @prefix.setter
    def prefix(self, newPrefix):
        self._prefix = newPrefix
        self._currentPrefixTxt = ""

    @property
    def loggedTxt(self):
        """
        The text to be logged into a .txt file

        :getter: Returns such a prefix
        :type: :class:`str`
        """
        return self._loggedTxt

    def clear(self):
        """
        Clears out any saved text from the logger
        """

        self._loggedTxt = ""

    def _setDefaultHeadingAtts(self):
        """
        Sets the default attributes for printing out a header line
        """

        self._headingTxtLen = 0
        self._headingSideLen = self.DefaultHeadingSideLen
        self._headingChar = self.DefaultHeadingChar

    def _addLogTxt(self, txt: str):
        """
        Appends the text to the logged output to be printed to a .txt file

        Parameters
        ----------
        txt: :class:`str`
            The text to be added onto the logged output
        """

        if (self.logTxt):
            self._loggedTxt += f"{txt}\n"

    def getStr(self, message: str):
        """
        Retrieves the string to be printed out by the logger

        Parameters
        ----------
        message: :class:`str`
            The message we want to print out

        Returns
        -------
        :class:`str`
            The transformed text that the logger prints out
        """

        return f"# {self._prefix} --> {message}"

    def log(self, message: str):
        """
        Regularly prints text onto the console

        Parameters
        ----------
        message: :class:`str`
            The message we want to print out
        """

        if (self.includePrefix):
            message = self.getStr(message)

        self._addLogTxt(message)
        self._currentPrefixTxt += f"{message}\n"

        if (self.verbose):
            print(message)

    def split(self):
        """
        Prints out a new line
        """

        if (self._currentPrefixTxt):
            self.log("\n")

    def space(self):
        """
        Prints out a space
        """
        self.log("")

    def openHeading(self, txt: str, sideLen: int = DefaultHeadingSideLen, headingChar = DefaultHeadingChar):
        """
        Prints out an opening heading

        Parameters
        ----------
        txt: :class:`str`
            The message we want to print out

        sideLen: :class:`int`
            How many characters we want for the side border of the heading :raw-html:`<br />`
            (see line 1 of the example at :class:`Heading`) :raw-html:`<br />` :raw-html:`<br />`

            **Default**: 2

        headingChar: :class:`str`
            The type of character used to print the side border of the heading :raw-html:`<br />`
            (see line 3 of the example at :class:`Heading`) :raw-html:`<br />` :raw-html:`<br />`

            **Default**: "="
        """

        heading = Heading(title = txt, sideLen = sideLen, sideChar = headingChar)
        self._headings.append(heading)
        self.log(heading.open())

    def closeHeading(self):
        """
        Prints out a closing heading that corresponds to a previous opening heading printed (see line 3 of the example at :class:`Heading`)
        """

        if (not self._headings):
            return

        heading = self._headings.pop()
        self.log(heading.close())

    @classmethod
    def getBulletStr(self, txt: str) -> str:
        """
        Creates the string for an item in an unordered list

        Parameters
        ----------
        txt: :class:`str`
            The message we want to print out

        Returns
        -------
        :class:`str`
            The text formatted as an item in an unordered list
        """
        return f"- {txt}"
    
    @classmethod
    def getNumberedStr(self, txt: str, num: int) -> str:
        """
        Creates the string for an ordered list

        Parameters
        ----------
        txt: :class:`str`
            The message we want to print out

        num: :class:`str`
            The number we want to print out before the text for the ordered list

        Returns
        -------
        :class:`str`
            The text formatted as an item in an ordered list
        """
        return f"{num}. {txt}"

    def bulletPoint(self, txt: str):
        """
        Prints out an item in an unordered list

        Parameters
        ----------
        txt: :class:`str`
            The message we want to print out
        """
        self.log(self.getBulletStr(txt))

    def list(self, lst: List[str], transform: Optional[Callable[[str], str]] = None):
        """
        Prints out an ordered list

        Parameters
        ----------
        lst: List[:class:`str`]
            The list of messages we want to print out

        transform: Optional[Callable[[:class:`str`], :class:`str`]]
            A function used to do any processing on each message in the list of messages

            If this parameter is ``None``, then the list of message will not go through any type of processing :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (transform is None):
            transform = lambda txt: txt

        lstLen = len(lst)
        for i in range(lstLen):
            newTxt = transform(lst[i])
            self.log(self.getNumberedStr(newTxt, i + 1))

    def box(self, message: str, header: str):
        """
        Prints the message to be sandwiched by the text defined in the argument, ``header``

        Parameters
        ----------
        message: :class:`str`
            The message we want to print out

        header: :class:`str`
            The string that we want to sandwich our message against
        """

        self.log(header)

        messageList = message.split("\n")
        for messagePart in messageList:
            self.log(messagePart)

        self.log(header)

    def error(self, message: str):
        """
        Prints an error message

        Parameters
        ----------
        message: :class:`str`
            The message we want to print out
        """

        prevVerbose = self.verbose
        if (not self.logTxt):
            self.verbose = True

        self.space()

        self.box(message, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        self.space()
        self.verbose = prevVerbose

    def handleException(self, exception: Exception):
        """
        Prints the message for an error

        Parameters
        ----------
        exception: :class:`Exception`
            The error we want to handle
        """

        message = f"\n{type(exception).__name__}: {exception}\n\n{traceback.format_exc()}"
        self.error(message)

    def input(self, desc: str) -> str:
        """
        Handles user input from the console

        Parameters
        ----------
        desc: :class:`str`
            The question/description being asked to the user for input

        Returns
        -------
        :class:`str`
            The resultant input the user entered
        """

        if (self.includePrefix):
            desc = self.getStr(desc)

        self._addLogTxt(desc)
        result = input(desc)
        self._addLogTxt(f"Input: {result}")

        return result

    def waitExit(self):
        """
        Prints the message used when the script finishes running
        """

        prevIncludePrefix = self.includePrefix
        self.includePrefix = False
        self.input("\n== Press ENTER to exit ==")
        self.includePrefix = prevIncludePrefix 


class RemapMissingBlendFile(FileException):
    """
    This Class inherits from :class:`FileException`

    Exception when a RemapBlend.buf file is missing its corresponding Blend.buf file

    Parameters
    ----------
    remapBlend: :class:`str`
        The path to the RemapBlend.buf file
    """

    def __init__(self, remapBlend: str):
        super().__init__(f"Missing the corresponding Blend.buf file for the RemapBlend.buf", path = remapBlend)


class BufFormatNames(Enum):
    """
    Names for the different 3dmigoto types for the elements within a .buf file :raw-html:`<br />` :raw-html:`<br />`

    For more info on the types, please see the type definitions here:
    https://learn.microsoft.com/en-us/windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-data-conversion
    """

    Float32RG = "R32G32_FLOAT"
    """
    A type with 2 channels of `floating point`_ numbers
    """

    Float32RGB = "R32G32B32_FLOAT"
    """
    A type with 3 channels of `floating point`_ numbers
    """

    Float32RGBA = "R32G32B32A32_FLOAT"
    """
    A type with 4 channels of `floating point`_ numbers
    """

    Int32RGBA = "R32G32B32A32_SINT"
    """
    A type with 4 channels of signed integers
    """

    UNORM8RGBA = "R8G8B8A8_UNORM"
    """
    A type with 4 channels of `unsigned normalized integers`_ with 8 bits per integer
    """


class ByteSize(Enum):
    """
    Different byte sizes for particular elements in the binary files of mods
    """

    Int32 = 4
    """
    Number of bytes in a `signed integer`_
    """

    UInt32 = 4
    """
    Number of bytes in an `unsigned integer`_
    """

    Float16 = 2
    """
    Number of bytes in a `half precision floating point`_
    """

    Float32 = 4
    """
    Number of bytes in a `floating point`_
    """

    UNorm8 = 1
    """
    Number of bytes in an 8-bit `unsigned normalized integer`_
    """


class BufBaseInt(BufDataType):
    """
    This class inherits from :class:`BufDataType`

    The type definition for some generic integer type within a .buf file

    Parameters
    ----------
    name: :class:`str`
        The name of the element

    size: :class:`int`
        The byte size for the data type

    isBigEndian: :class:`bool`
        Whether the type is in big endian mode :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    isSigned: :class:`bool`
        Whether the type is signed :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``
    """

    def __init__(self, name: str, size: int, isBigEndian: bool = False, isSigned: bool = True):
        super().__init__(name, size, isBigEndian = isBigEndian)
        self._endianSymbolLong = "big" if (isBigEndian) else "little"
        self._isSigned = isSigned

    @property
    def isSigned(self) -> bool:
        """
        Whether the data type is signed

        :getter: Retrieves whether the data type is signed
        :type: :class:`bool`
        """

        return self._isSigned

    def decode(self, src: bytes) -> int:
        """
        Decode the raw bytes to an integer

        .. warning::
            Please make sure the number of bytes passed into 'src' matches the size of the type

        Parameters
        ----------
        src: :class:`bytes`
            The raw bytes to decode

        Returns 
        -------
        :class:`int`
            The decoded signed integer
        """

        return int.from_bytes(src, byteorder = self._endianSymbolLong, signed = self._isSigned)

    def encode(self, src: int) -> bytes:
        """
        Encodes an integer back to raw bytes

        .. warning::
            Please make sure 'src' is within the acceptable range for the type

        Parameters
        ----------
        src: :class:`int`
            The integer to encode

        Returns 
        -------
        :class:`bytes`
            The encoded raw bytes
        """

        return (src).to_bytes(self.size, byteorder = self._endianSymbolLong, signed = self._isSigned)
    

class BufSignedInt(BufBaseInt):
    """
    This class inherits from :class:`BufBaseInt`

    The type definition for some signed integer type within a .buf file

    Parameters
    ----------
    name: :class:`str`
        The name of the element :raw-html:`<br />` :raw-html:`<br />`

        **Default**: :attr:`BufDataTypeNames.Int32`.value

    size: :class:`int`
        The byte size for the data type :raw-html:`<br />` :raw-html:`<br />`

        **Default**: :attr:`ByteSize.Int32`.value

    isBigEndian: :class:`bool`
        Whether the type is in big endian mode :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``
    """

    def __init__(self, name: str = BufDataTypeNames.Int32.value, size: int = ByteSize.Int32.value, isBigEndian: bool  = False):
        super().__init__(name, size, isBigEndian = isBigEndian)


class BufUnSignedInt(BufBaseInt):
    """
    This class inherits from :class:`BufBaseInt`

    The type definition for some signed integer type within a .buf file

    Parameters
    ----------
    name: :class:`str`
        The name of the element :raw-html:`<br />` :raw-html:`<br />`

        **Default**: :attr:`BufDataTypeNames.UInt32`.value

    size: :class:`int`
        The byte size for the data type :raw-html:`<br />` :raw-html:`<br />`

        **Default**: :attr:`ByteSize.UInt32`.value

    isBigEndian: :class:`bool`
        Whether the type is in big endian mode :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``
    """

    def __init__(self, name: str = BufDataTypeNames.UInt32.value, size: int = ByteSize.UInt32.value, isBigEndian: bool = False):
        super().__init__(name, size, isBigEndian = isBigEndian, isSigned = False)


class BufBaseFloat(BufDataType):
    """
    This class inherits from :class:`BufDataType`

    The type definition for a generic `floating point`_ number within a .buf file

    Parameters
    ----------
    name: :class:`str`
        The name of the element

    size: :class:`int`
        The byte size for the data type

    isBigEndian: :class:`bool`
        Whether the type is in big endian mode :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``
    """

    def __init__(self, name: str, size: int, isBigEndian: bool  = False):
        super().__init__(name, size, isBigEndian = isBigEndian)

    def decode(self, src: bytes) -> int:
        """
        Decode the raw bytes to a `floating point`_ number

        .. warning::
            Please make sure the number of bytes passed into 'src' matches the size of the type

        Parameters
        ----------
        src: :class:`bytes`
            The raw bytes to decode

        Returns 
        -------
        :class:`float`
            The decoded `floating point`_
        """

        return struct.unpack(f"{self._endianSymbol}f", src)[0]

    def encode(self, src: Any) -> bytes:
        """
        Encodes the `floating point`_ back to raw bytes

        .. warning::
            Please make sure 'src' is within the acceptable range for the type

        Parameters
        ----------
        src: :class:`float`
            The `floating point`_ to encode

        Returns 
        -------
        :class:`bytes`
            The encoded raw bytes
        """

        return struct.pack(f"{self._endianSymbol}f", src)
    

class BufFloat(BufBaseFloat):
    """
    This class inherits from :class:`BufBaseFloat`

    The type definition for a 32-bit `floating point`_ number within a .buf file

    Parameters
    ----------
    isBigEndian: :class:`bool`
        Whether the type is in big endian mode :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``
    """

    def __init__(self, isBigEndian: bool  = False):
        super().__init__(BufDataTypeNames.Float32.value, ByteSize.Float32.value, isBigEndian = isBigEndian)


class BufFloat16(BufBaseFloat):
    """
    This class inherits from :class:`BufBaseFloat`

    The type definition for a 16-bit `half precision floating point`_ number within a .buf file

    Parameters
    ----------
    isBigEndian: :class:`bool`
        Whether the type is in big endian mode :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``
    """

    def __init__(self, isBigEndian: bool  = False):
        super().__init__(BufDataTypeNames.Float16.value, ByteSize.Float16.value, isBigEndian = isBigEndian)

    def decode(self, src: bytes) -> int:
        return struct.unpack(f"{self._endianSymbol}e", src)[0]
    
    def encode(self, src: Any) -> bytes:
        return struct.pack(f"{self._endianSymbol}e", src)


class BufUnorm(BufBaseInt):
    """
    This class inherits from :class:`BufBaseInt`

    The type definition for an `unsigned normalized integer`_ number within a .buf file

    Parameters
    ----------
    name: :class:`str`
        The name of the element

    size: :class:`int`
        The byte size for the data type

    isBigEndian: :class:`bool`
        Whether the type is in big endian mode
    """

    def __init__(self, name: str, size: int, isBigEndian: bool  = False):
        super().__init__(name, size, isBigEndian = isBigEndian, isSigned = False)
        self._maxValue = pow(2, size * 8) - 1

    def decode(self, src: bytes) -> float:
        """
        Decode the raw bytes to the `floating point`_ value for the `unsigned normalized integer`_
 
        .. warning::
            Please make sure the number of bytes passed into 'src' matches the size of the type

        Parameters
        ----------
        src: :class:`bytes`
            The raw bytes to decode

        Returns 
        -------
        :class:`float`
            The decoded `floating point`_
        """

        numerator = super().decode(src)
        return numerator / self._maxValue

    def encode(self, src: float) -> bytes:
        """
        Encodes the `floating point`_ back to raw bytes

        .. warning::
            Please make sure 'src' is within the acceptable range for the type

        Parameters
        ----------
        src: :class:`float`
            The `floating point`_ to encode

        Returns 
        -------
        :class:`bytes`
            The encoded raw bytes
        """

        result = int(src * self._maxValue)
        return super().encode(result)


class BufDataTypes(Enum):
    """
    Different elementary data types within a .buf file
    """

    Float32 = BufFloat()
    """
    `Floating point`_ number
    """

    Int32 = BufSignedInt()
    """
    A signed integer
    """

    UInt32 = BufUnSignedInt()
    """
    An unsigned integer
    """

    UNorm8 = BufUnorm(BufDataTypeNames.UNorm8.value, ByteSize.UNorm8.value)
    """
    An `unsigned normalized integer`_
    """


class BufElementTypes(Enum):
    """
    Different types for the elements within a .buf file

    Attributes
    ----------
    PositionFloatRGB: :class:`BufElementType`
        The position for the vertex of a mod within an R3 vector space

    NormalFloatRGB: :class:`BufElementType`
        The normal vector for the vertex of a mod

    TangentFloatRGBA: :class:`BufElementType`
        The tangent vector for the vertex of a mod

    BlendWeightFloatRGBA: :class:`BufElementType`
        The distribution for the vertex groups for a particular vertex in a mod

    BlendIndicesIntRGBA: :class:`BufElementType`
        The vertex groups a vertex from a mod belongs to

    ColourRGBA: :class:`BufElementType`
        The colour for a vertex in a mod

    TextureCoordinateRG: :class:`BufElementType`
        The corresponding R2 vector space coordinate from a texture file that is associated to the vertex in a mod
    """

    PositionFloatRGB = BufElementType(BufElementNames.Position.value, BufFormatNames.Float32RGB.value, [BufDataTypes.Float32.value] * 3)
    NormalFloatRGB = BufElementType(BufElementNames.Normal.value, BufFormatNames.Float32RGB.value, [BufDataTypes.Float32.value] * 3)
    TangentFloatRGBA = BufElementType(BufElementNames.Tangent.value, BufFormatNames.Float32RGBA.value, [BufDataTypes.Float32.value] * 4)
    BlendWeightFloatRGBA = BufElementType(BufElementNames.BlendWeight.value, BufFormatNames.Float32RGBA.value, [BufDataTypes.Float32.value] * 4)
    BlendIndicesIntRGBA = BufElementType(BufElementNames.BlendIndices.value, BufFormatNames.Int32RGBA.value, [BufDataTypes.Int32.value] * 4)
    ColourRGBA = BufElementType(BufElementNames.Colour.value, BufFormatNames.UNORM8RGBA.value, [BufDataTypes.UNorm8.value] * 4)
    TextureCoordinateRG = BufElementType(BufElementNames.TextureCoordinate.value, BufFormatNames.Float32RG.value, [BufDataTypes.Float32.value] * 2)


class BlendFile(BufFile):
    """
    This Class inherits from :class:`BufFile`

    Used for handling blend.buf files

    .. note::
        We observe that a Blend.buf file is a binary file defined as:

        * a line corresponds to the data for a particular vertex in the mod
        * each line contains 32 bytes (256 bits)
        * each line uses little-endian mode (MSB is to the right while LSB is to the left)
        * the first 16 bytes of a line are for the blend weights, each weight is 4 bytes or 32 bits (4 weights/line)
        * the last 16 bytes of a line are for the corresponding indices for the blend weights, each index is 4 bytes or 32 bits (4 indices/line)
        * the blend weights are floating points while the blend indices are unsigned integers

    Parameters
    ----------
    src: Union[:class:`str`, :class:`bytes`]
        The source file or bytes for the blend file
    """

    def __init__(self, src: Union[str, bytes]):
        super().__init__(src, [BufElementTypes.BlendWeightFloatRGBA.value, BufElementTypes.BlendIndicesIntRGBA.value], fileType = "Blend.buf")

    @classmethod
    def getMissingIndicesRemap(cls, src: Dict[str, Union[List[int], List[float]]], vgRemap: VGRemap) -> Dict[int, int]:
        """
        Retrives the temporary remap for any missing blend indices not included in 'vgRemap'

        Parameters
        ----------
        src: Dict[:class:`str`, Union[List[:class:`int`, List[:class:`float`]]]]
            The data for the blend weights and the blend indices for a particular vertex

        vgRemap: :class:`VGRemap`
            The vertex group remap for correcting the Blend.buf file

        Returns
        -------
        Dict[:class:`int`, :class:`int`]
            The temporary remap for the missing indices. :raw-html:`<br />` :raw-html:`<br />`

            The keys are the missing indices found and the values are the temporary remapped values for these missing indices
        """

        blendWeights = src[BufElementNames.BlendWeight.value]
        blendIndices = src[BufElementNames.BlendIndices.value]
        minBlendLen = min(len(blendWeights), len(blendIndices))

        result = {}
        for i in range(minBlendLen):
            index = blendIndices[i]
            if (index not in vgRemap.remap):
                result[index] = -abs(index) - 1

        return result

    @classmethod
    def remapIndices(cls, src: Dict[str, Union[List[int], List[float]]], vgRemap: VGRemap, remapMissingIndices: bool = True) -> Dict[str, Union[List[int], List[float]]]:
        """
        Remaps the vertex group indices for a particular line (vertex)

        Parameters
        ----------
        src: Dict[:class:`str`, Union[List[:class:`int`, List[:class:`float`]]]]
            The data for the blend weights and the blend indices for a particular vertex

        vgRemap: :class:`VGRemap`
            The vertex group remap for correcting the Blend.buf file

        remapMissingIndices: :class:`bool`
            Whether to deactivate any missing blend indices that cannot be identified :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns 
        -------
        Dict[:class:`str`, Union[List[:class:`int`, List[:class:`float`]]]]
            The new data for the blend weights/blend indices, with the blend indices remapped
        """

        # Remapping missing indices to some blatantly non-existent index (eg. negative indices)
        # deactivates the weight on these indices
        tempMissingIndexRemap = {} if (not remapMissingIndices) else cls.getMissingIndicesRemap(src, vgRemap)

        blendWeights = src[BufElementNames.BlendWeight.value]
        blendIndices = src[BufElementNames.BlendIndices.value]

        minBlendLen = min(len(blendWeights), len(blendIndices))
        for i in range(minBlendLen):
            weight = blendWeights[i]
            index = blendIndices[i]

            if (weight == 0):
                continue

            if (index in vgRemap.remap):
                blendIndices[i] = int(vgRemap.remap[index])
            elif (index in tempMissingIndexRemap):
                blendIndices[i] = tempMissingIndexRemap[index]

        return src

    def remap(self, vgRemap: VGRemap, fixedBlendFile: Optional[str] = None, remapMissingIndices: bool = True) -> Union[Optional[str], bytearray]:
        """
        Remaps the blend indices in a Blend.buf file

        Parameters
        ----------
        vgRemap: :class:`VGRemap`
            The vertex group remap for correcting the Blend.buf file

        fixedBlendFile: Optional[:class:`str`]
            The file path for the fixed Blend.buf file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        remapMissingIndices: :class:`bool`
            Whether to deactivate any missing blend indices that cannot be identified :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Raises
        ------
        :class:`BlendFileNotRecognized`
            If the original Blend.buf file provided by the parameter ``blendFile`` cannot be read

        :class:`BadBlendData`
            If the bytes passed into this function do not correspond to the format defined for a Blend.buf file

        Returns
        -------
        Union[Optional[:class:`str`], :class:`bytearray`]
            If the argument ``fixedBlendFile`` is ``None``, then will return an array of bytes for the fixed Blend.buf file :raw-html:`<br />` :raw-html:`<br />`
            Otherwise will return the filename to the fixed RemapBlend.buf file if the provided Blend.buf file got corrected
        """

        # if no correction is needed to be done
        blendFile = self.src
        blendIsFile = isinstance(blendFile, str)
        if (not vgRemap.remap and blendIsFile):
            return None
        elif (not vgRemap.remap):
            return bytearray(blendFile)

        filters = [lambda data, startInd, lineInd, lineSize: self.remapIndices(data, vgRemap, remapMissingIndices = remapMissingIndices)]
        return self.fix(fixedBlendFile, filters = filters)


class PositionFile(BufFile):
    """
    This class inherits from :class:`BufFile`

    Used for handling position.buf files

    .. note::
        We observe that a Position.buf file is a binary file defined as:

        * a line corresponds to the data for a particular vertex in the mod
        * each line contains 40 bytes (320 bits)
        * each line uses little-endian mode (MSB is to the right while LSB is to the left)
        * the first 12 bytes of a line are the coordinate position of a vertex in an R3 vector space, each scaler value in the coordinate is 4 bytes or 32 bits (3 scalar values/line)
        * the next 12 bytes of a line corresponds to the normal vector of a vertex, each scalar value in the vector is 4 bytes or 32 bits (3 scalar values/line)
        * the last 16 bytes of a line corresponds to the tangent vector of a vertex, each scalar value in the vector is 4 bytes or 32 bits (4 scalar values/line)
        * all scalar values in the file are `floating point`_ values

    Parameters
    ----------
    src: Union[:class:`str`, :class:`bytes`]
        The source file or bytes for the .buf file
    """

    def __init__(self, src: Union[str, bytes]):
        super().__init__(src, [BufElementTypes.PositionFloatRGB.value, BufElementTypes.NormalFloatRGB.value, BufElementTypes.TangentFloatRGBA.value], fileType = "Position.buf")


class DFA():
    """
    Class for a `DFA (Deterministic Finite Automaton)`_

    Attributes
    ----------
    _states: Dict[Hashable, :class:`Node`]
        The states in the `DFA`_ :raw-html:`<br />` :raw-html:`<br />`

        The keys are the ids of the states and values are the nodes for the states

    _neighbours: Dict[Hashable, Dict[Hashable, Hashable]]
        The out-neighbour nodes of a state :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the ids of the states
        * The inner keys are the transition from one state to another
        * The inner values are the ids of the neighbour states

    _accept: Set[Hashable]
        The ids of the states that are considered as accepting states

    _startId: Hashable
        The id for the start state

    _currentStateId: Hashable
        The id for the current state
    """

    def __init__(self, nodeCls: Type[Node] = Node):
        self._states: Dict[Hashable, Node] = {}
        self._neighbours: Dict[Hashable, Dict[Hashable, Hashable]] = {}
        self._accept: Set[Hashable] = set()

        self._nodeCls = nodeCls

        self._startId: Hashable = []
        self._currentStateId: Hashable = []

    @property
    def startId(self) -> Hashable:
        """
        The id to the start state

        .. warning::
            The setter may raise a :class:`KeyError` if the newly given start id does not correspond
            to any state within the `DFA`_

        :getter: Retrieves the start id
        :setter: Sets the new start id
        :type: Hashable
        """
        
        return self._startId
    
    @startId.setter
    def startId(self, newStartId: Hashable):
        if (newStartId not in self._states):
            raise KeyError(f"The id, '{newStartId}' cannot be set as the new start state since the id does not correspond to a valid state in the DFA")

        self._startId = newStartId

    @property
    def currentStateId(self) -> Hashable:
        """
        The id of the state the `DFA`_ is currently at

        .. warning::
            The setter may raise a :class:`KeyError` if the newly current id does not correspond
            to any state within the `DFA`_

        :getter: Retrieves the id of the current state
        :setter: Sets the new id of the current state the `DFA`_ is on
        :type: Hashable
        """

        return self._currentStateId
    
    @currentStateId.setter
    def currentStateId(self, newCurrentId: Hashable):
        if (newCurrentId not in self._states):
            raise KeyError(f"The id, '{newCurrentId}' cannot be set as the new current state since the id does not correspond to a valid state in the DFA")

        self._currentStateId = newCurrentId

    def clear(self):
        """
        Clears the `DFA`_
        """

        self._transition.cache_clear()
        self._states = {}
        self._neighbours = {}
        self._accept = set()

        self._startId = []
        self._currentStateId = []

    def _constructNode(self, id: Hashable, *args, **kwargs) -> Node:
        """
        Constructs a node for the `DFA`_

        Parameters
        ----------
        id: Hashable
            The id for the node

        *args:
            Any extra arguments used to construct the node

        **kwargs:
            Any extra keyword arguments used to construct the node

        Returns
        -------
        :class:`Node`
            The contructed node
        """

        return self._nodeCls(id, *args, **kwargs)

    def addState(self, id: Hashable, isAccept: bool = False, isStart: bool = False) -> Tuple[Node, bool]:
        """
        Add a new state to the `DFA`

        Parameters
        ----------
        id: Hashable
            The id for the state

        isAccept: :class:`bool`
            Whether the state is an accepting state

        isStart: :class:`bool`
            Whether to set the state as the new starting state

            .. warning::
                A `DFA`_ can only have 1 start state

            .. warning::
                If the `DFA`_ is empty and you add a new state, will set this state as the start state

        Returns
        -------
        Tuple[:class:`Node`, :class:`bool`]
            Retrieves the data about the newly added state, including:

            #. The corresponding state
            #. Whether the state was newly added
        """

        isEmpty = not bool(self._states)
        if (isEmpty):
            isStart = True

        state = self._states.get(id)
        isNewlyAdded = state is None

        if (isNewlyAdded):
            state = self._constructNode(id)
            self._states[id] = state

        if (not isAccept and id in self._accept):
            self._accept.remove(id)
        elif (isAccept):
            self._accept.add(id)
        
        if (isStart):
            self._startId = id

        if (isEmpty):
            self._currentStateId = id

        self._transition.cache_clear()
        return (state, isNewlyAdded)
    
    def addTransition(self, srcId: Hashable, keyword: Hashable, destId: Hashable):
        """
        Adds a transition to the `DFA`_

        Parameters
        ----------
        srcId: Hashable
            The id of the source state for the transition

            .. caution::
                The id to the source state must refer to an existing state to the `DFA`_

        keyword: Hashable
            The keyword that will trigger a transition from the source state to the destination state

            .. warning::
                If the source state already has such a transition, then will overwrite the destination state for this transition

        destId: Hashable
            The id of the destionation state for the transition

            .. note::
                The id of this state does not need to exist yet in the `DFA`_ . If the id of this state does not exist, then
                will create a new state in the `DFA`_
        """

        if (srcId not in self._states):
            raise KeyError(f"The id, '{srcId}' cannot be set as the source state of a new transition since the id does not correspond to a valid state in the DFA")
        
        neighbours = self._neighbours.get(srcId)
        if (neighbours is None):
            neighbours = {}
            self._neighbours[srcId] = neighbours

        destState = self._states.get(destId)
        if (destState is None):
            destState, _ = self.addState(destId, isAccept = False, isStart = False)

        neighbours[keyword] = destId
        self._transition.cache_clear()

    def reset(self):
        """
        Resets the `DFA`_ to return back to its starting state
        """

        self._currentStateId = self._startId

    @lru_cache(maxsize = 256)
    def _transition(self, currentStateId: Hashable, keyword: Hashable):
        resultStateId = currentStateId
        isAccept = currentStateId in self._accept
        transitionTaken = False

        neighbours = self._neighbours.get(currentStateId)
        if (neighbours is None):
            return (resultStateId, isAccept, transitionTaken)
        
        resultStateId = neighbours.get(keyword, [])
        if (isinstance(resultStateId, list)):
            return (currentStateId, isAccept, transitionTaken)
        
        self._currentStateId = resultStateId
        isAccept = resultStateId in self._accept
        transitionTaken = True
        
        return (resultStateId, isAccept, transitionTaken)

    def transition(self, keyword: Hashable) -> Tuple[Hashable, bool, bool]:
        """
        Transitions to a new state

        Parameters
        ----------
        keyword: Hashable
            The keyword to trigger the transition to the new state

        Returns
        -------
        Tuple[Hashable, :class:`bool`, :class:`bool`]
            Resultant data regarding the new transitioned state, which includes:

            #. The id of the new state
            #. Whether the new state is an accepting state
            #. Whether a transition was taken 
        """

        result = self._transition(self._currentStateId, keyword)
        self._currentStateId = result[0]
        return result


class IniClassifyStats():
    """
    A class that stores the statistics about the classification result of a .ini file

    Parameters
    ----------
    modType: Optional[:class:`ModType`]
        The type of mod found

    isMod: :class:`bool`
        Whether the .ini file belongs to a mod

    isFixed: :class:`bool`
        Whether the .ini file is fixed

    Attributes
    ----------
    modType: Optional[:class:`ModType`]
        The type of mod found

    isMod: :class:`bool`
        Whether the .ini file belongs to a mod

    isFixed: :class:`bool`
        Whether the .ini file is fixed
    """

    def __init__(self, modType: Optional["ModType"] = None, isMod: bool = False, isFixed: bool = False):
        self.modType = modType
        self.isMod = isMod
        self.isFixed = isFixed


class BaseIniClassifier():
    """
    Base class to help classify the type of mod given the mod's .ini files
    """

    def classify(self, iniTxt: Union[str, List[str]], checkIsMod: bool = True, checkIsFixed: bool = True) -> IniClassifyStats:
        """
        Determines the type of mod given the text from the mod's .ini file

        Parameters
        ----------
        iniTxt: Union[:class:`str`, List[:class:`str`]]
            The text of the .ini file to read from, given as either:
            
            * the full text OR 
            * lines of text with each line ending with a newline character

        checkIsMod: :class:`bool`
            Whether to fully check the .ini file belongs to a mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        checkIsFixed: :class:`bool`
            Whether to fully check the .ini file has been fixed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns 
        -------
        :class:`IniClassifyStats`
            The stats about the classification of the .ini file
        """

        pass


class BaseIniClassifierBuilder():
    """
    Base class to help build/customize a :class:`IniClassifier`
    """

    def build(self, classifier: "IniClassifier") -> "IniClassifier":
        """
        Builds/customize a :class:`IniClassifier`

        Parameters
        ----------
        classifier: :class:`IniClassifier`
            The classifier to build

        Returns
        -------
        :class:`IniClassifier`
            The classifier that has been built
        """

        pass


class IniClsActionArgs():
    """
    Class to store the arguments for a :class:`IniClsAction`

    Parameters
    ----------
    classifier: :class:`IniClassifier`
        The classifier to identify a mod given a .ini file

    stats: :class:`IniClassiyStats`
        The resultant stats about the classification of the .ini file

    line: :class:`str`
        The current line being read from the .ini file

    keyword: :class:`str`
        The keyword found from the current line read from the .ini file

    keywordInd: :class:`int`
        The start index where the keyword was found

    keywordEndInd: :class:`int`
        The end index of the keyword

    prevStateId: `Hashable`_
        The id of the previous state the classifier was on

    currentStateId: `Hashable`_
        The id of the current state the classifier is on

    isAccept: :class:`bool` 
        Whether the current state is an accepting state

    transitionMade: :class:`bool`
        Whether a transition was made from the prevous state to the current state

    Attributes
    ----------
    classifier: :class:`IniClassifier`
        The classifier to identify a mod given a .ini file

    stats: :class:`IniClassiyStats`
        The resultant stats about the classification of the .ini file

    line: :class:`str`
        The current line being read from the .ini file

    keyword: :class:`str`
        The keyword found from the current line read from the .ini file

    keywordInd: :class:`int`
        The start index where the keyword was found

    keywordEndInd: :class:`int`
        The end index of the keyword

    prevStateId: `Hashable`_
        The id of the previous state the classifier was on

    currentStateId: `Hashable`_
        The id of the current state the classifier is on

    isAccept: :class:`bool` 
        Whether the current state is an accepting state

    transitionMade: :class:`bool`
        Whether a transition was made from the prevous state to the current state
    """

    def __init__(self, classifier: "IniClassifier", stats: IniClassifyStats, line: str, keyword: str, keywordInd: int, 
                 keywordEndInd: int, prevStateId: Hashable, currentStateId: Hashable, isAccept: bool, transitionMade: bool):
        self.classifier = classifier
        self.stats = stats
        self.line = line
        self.keyword = keyword
        self.keywordInd = keywordInd
        self.keywordEndInd = keywordEndInd
        self.prevStateId = prevStateId
        self.currentStateId = currentStateId
        self.isAccept = isAccept
        self.transitionMade = transitionMade


class IniClsAction():
    """
    Base class to handle any post-processing action to run after the :class:`IniClassifier` transitions 
    to a new state when a keyword is found in a line

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(args)

            Runs the action ``x`` on the passed in arguments from :class:`IniClsActionArgs`
    """

    def __call__(self, args: IniClsActionArgs):
        pass


class IniClsTransitionVals(UserDict):
    """
    This class inherits from `UserDict`_

    Stores the values corresponding to the keyword transitions of :class:`IniClassifier`
    """

    pass


class IniClassifier(BaseIniClassifier):
    """
    This class inherits from :class:`BaseIniClassifier`

    Class to help classify the type of mod given the mod's .ini files :raw-html:`<br />` :raw-html:`<br />`

    This classifier will read each line in the .ini file, and performs the following:

    * Keywords in a line are first quickly identified and filtered using `Aho-Corasick`_ . 
      The large majority of the lines in a .ini file will be identified through this method.
    * State information between different lines in a .ini file are stored in a `DFA`_
    * If there are any further ambiguity that keyword searching cannot solve, will perform any needed post-processing on the line (eg. regex matching). 
      Very little to no lines in a .ini file will need to resort to such method.

    Parameters
    ----------
    builder: Optional[:class:`BaseIniClassifierBuilder`]
        The builder used to build the data within the classifier :raw-html:`<br />` :raw-html:`<br />`

        If this argument is ``None``, the constructor will not automatically build the data in the classifier and the
        user must call :meth:`build` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    ahoCorasickCls: Optional[Type[:class:BaseAhoCorasickDFA`]]
        The class implementation of `Aho-Corasick` to use :raw-html:`<br />` :raw-html:`<br />`

        If this parameter is ``None``, then will try to :class:`FastAhoCorasickDFA` if possible, otherwise
        will fall back to :class:`AhoCorasickDFA` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    builder: Optional[:class:`BaseIniClassifierBuilder`]
        The builder used to build the data within the classifier, if available

    _keywordDFA: :class:`BaseAhoCorasickDFA`
        The `DFA`_ that will use `Aho-Corasick`_ to quickly search/filter keywords in a line in the .ini file

    _stateDFA: :class:`DFA`
        The `DFA`_ that will store state information
    """

    IsFixedPattern = re.compile(r"\s*\[.*" + f"{IniKeywords.Remap.value}({IniKeywords.Blend.value}|{IniKeywords.Position.value}|{IniKeywords.Ib.value}|dl|tex|fix".lower() + r").*\]")
    IsModPattern = re.compile(r"\s*\[.*(" + f"{IniKeywords.Blend.value}|{IniKeywords.Position.value}".lower() + r").*\]")
    IsModOrIsFixedPattern = re.compile(r"(" + f"{IniKeywords.Blend.value}|{IniKeywords.Position.value}|{IniKeywords.Remap.value}(fix|tex|{IniKeywords.Ib.value})".lower() + r")")
    RemapFixSuffixPattern = re.compile(IniKeywords.RemapFix.value.lower() + r".*\]")

    IsFixedKeywords = {IniKeywords.RemapBlend.value.lower(), IniKeywords.RemapFix.value.lower(), IniKeywords.RemapPosition.value.lower(),
                       IniKeywords.RemapTex.value.lower(), IniKeywords.RemapDL.value.lower(), IniKeywords.RemapIb.value.lower(), IniKeywords.RemapTexcoord.value.lower()}
    IsModKeywords = {IniKeywords.Blend.value.lower(), IniKeywords.Position.value.lower()}

    def __init__(self, builder: Optional[BaseIniClassifierBuilder] = None, ahoCorasickCls: Optional[Type[BaseAhoCorasickDFA]] = None):
        self.builder = builder
        self._keywordDFA = AhoCorasickBuilder(buildCls = ahoCorasickCls, kwargs = {"handleDuplicate": self._handleDuplicate}).build()
        self._stateDFA = DFA()

        if (builder is not None):
            self.build(builder)

    # _handleDuplicate(keyword, oldVal, newVal): How to handle duplicate values within the keyword DFA
    def _handleDuplicate(self, keyword: str, oldVal: IniClsTransitionVals, newVal: IniClsTransitionVals) -> IniClsTransitionVals:
        oldVal.update(newVal)
        return oldVal
    
    def clear(self):
        """
        Clears all the saved data in the classifier
        """

        self._keywordDFA.clear()
        self._stateDFA.clear()

    def build(self, builder: BaseIniClassifierBuilder):
        """
        Rebuilds the classifier

        Parameters
        ----------
        builder: :class:`BaseIniClassifierBuilder`
            The builder to help build the classifier
        """

        self.clear()
        self.builder = builder
        builder.build(self)

    def reset(self):
        """
        Resets the state the classifier is at
        """

        self._stateDFA.reset()

    def classify(self, iniTxt: Union[str, List[str]], checkIsMod: bool = True, checkIsFixed: bool = True) -> IniClassifyStats:
        self._stateDFA.reset()
        if (isinstance(iniTxt, str)):
            iniTxt = TextTools.getTextLines(iniTxt)

        stats = IniClassifyStats()

        isMod = not checkIsMod
        isFixed = not checkIsFixed
        modFound = False

        for line in iniTxt:
            cleanedLine = line.replace(IniKeywords.HideOriginalComment.value, "").lower()

            if (not modFound):
                self.readLine(cleanedLine, stats)
            else:
                self.checkOnlyIsFixedOrisMod(cleanedLine, stats)

            if (not modFound and isinstance(stats.modType, ModType)):
                modFound = True

            if (not isMod and stats.isMod):
                isMod = True

            if (not isFixed and stats.isFixed):
                isFixed = True

            if (modFound and isFixed and isMod):
                return stats

        return stats

    @classmethod
    def getSectionName(cls, line: str) -> str:
        """
        Retrieves the name of a `section`_ from a line in the .ini file

        Parameters
        ----------
        line: :class:`str`
            The line from the .ini file to retrieve the section name from

        Returns
        -------
        :class:`str`
            The retrieved name
        """

        currentSectionName = line
        rightPos = currentSectionName.rfind("]")
        leftPos = currentSectionName.find("[")

        if (rightPos > -1 and leftPos > -1):
            currentSectionName = currentSectionName[leftPos + 1:rightPos]
        elif (rightPos > -1):
            currentSectionName = currentSectionName[:rightPos]
        elif (leftPos > -1):
            currentSectionName = currentSectionName[leftPos + 1:]

        return currentSectionName.strip()
    
    def checkOnlyIsFixedOrisMod(self, line: str, stats: IniClassifyStats):
        """
        Reads a line in the .ini file and checks whether the line contains
        keywords for:

        #. Whether the .ini file belongs to a mod OR
        #. Whether the .ini file is fixed

        Parameters
        ----------
        line: :class:`str`
            The line from the .ini file to read

        stats: :class:`IniClassifyStats`
            The resultant stats to store the classification result of the .ini file
        """

        if (not stats.isFixed and re.match(self.IsFixedPattern, line)):
            stats.isFixed = True

        if (not stats.isMod and re.match(self.IsModPattern, line)):
            stats.isMod = True
    
    def _addTransition(self, srcStateId: Hashable, transition: str, destStateId: Hashable, transitionVal: Union[Optional[ModType], IniClsAction, Callable[[IniClsActionArgs], Any]]):
        """
        Convenience function to add a transition to the classifier

        Parameters
        ----------
        srcStateId: `Hashable`_
            The id of the source state

        transition: :class:`str`
            The keyword to trigger the transition

        destStateId: `Hashable`_
            The id of the destionation state

            .. note::
                If this state is created from this function, the state will not be an accepting state

        transitionVal: Union[Optional[:class:`ModType`], :class:`IniClsAction`, Callable[[:class:`IniActionArgs`], Any]]
            The corresponding value to store at the transition
        """

        self._stateDFA.addTransition(srcStateId, transition, destStateId)
        self._keywordDFA.add(transition, IniClsTransitionVals({srcStateId: transitionVal}))

    def _transition(self, stats: IniClassifyStats, line: str, keyword: str, keywordInd: int = -1, keywordEndInd: int = -1, keywordVals: Optional[IniClsTransitionVals] = None):
        """
        Transitions the classifier to another state

        Parameters
        ----------
        stats: :class:`IniClassifyStats`
            The resultant stats to store the classification result of the .ini file

        line: :class:`str`
            The line in the .ini file that was read

        keyword: :class:`str`
            The keyword found from the line of the .ini file read

        keywordInd: :class:`int`
            The index where the keyword was found :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``-1``

        keywordEndInd: :class:`int`
            The ending index of where the keyword was found :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``-1``

        keywordVals: :class:`IniClsTransitionVals`
            The corresponding values for the keyword found :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (keywordVals is None):
            keywordVals = self._keywordDFA.getKeyVal(keyword, errorOnNotFound = False)

        currentStateId = self._stateDFA.currentStateId
        if (currentStateId not in keywordVals):
            self._stateDFA.reset()
            return

        action = keywordVals[currentStateId]

        isModType = isinstance(action, ModType)
        newStateId, isAccept, transitionMade = self._stateDFA.transition(keyword)

        if (action is None or (isModType and not isAccept)):
            return
        elif (isModType and isAccept):
            stats.modType = action
            stats.isMod = True
            self._stateDFA.reset()
            return

        actionArgs = IniClsActionArgs(self, stats, line, keyword, keywordInd, keywordEndInd, currentStateId, newStateId, isAccept, transitionMade)
        action(actionArgs)

        if (isinstance(stats.modType, ModType)):
            self._stateDFA.reset()

    def setIsFixed(self, keyword: str, stats: IniClassifyStats):
        """
        Marks the .ini file to be fixed, after checking 'keyword'

        Parameters
        ----------
        keyword: :class:`str`
            The keyword to trigger the .ini file to be considered as fixed

        stats: :class:`IniClassifyStats`
            The resultant stats to store the classification result of the .ini file
        """

        if (not stats.isFixed and keyword in self.IsFixedKeywords):
            stats.isFixed = True

    def setIsMod(self, keyword: str, stats: IniClassifyStats):
        """
        Marks the .ini file to belong to a mod, based off the 'keyword'

        Parameters
        ----------
        keyword: :class:`str`
            The keyword to trigger the .ini file to be a .ini file that belongs to some mod

        stats: :class:`IniClassifyStats`
            The resultant stats to store the classification result of the .ini file
        """

        if (not stats.isMod and keyword in self.IsModKeywords):
            stats.isMod = True

    def setIsFixedAndIsMod(self, keyword: str, stats: IniClassifyStats):
        """
        Marks the .ini file to belong to a mod and is fixed, based off the 'keyword's

        Parameters
        ----------
        keyword: :class:`str`
            The keyword to trigger the .ini file to be a .ini file that belongs to some mod and
            the .ini file to be fixed

        stats: :class:`IniClassifyStats`
            The resultant stats to store the classification result of the .ini file
        """

        self.setIsFixed(keyword, stats)
        self.setIsMod(keyword, stats)

    def readLine(self, line: str, stats: IniClassifyStats):
        """
        Reads a single line in a .ini file

        .. note::
            If you do not care about what type of mod is returned and only want to know
            whether the .ini file belongs to a mod or has already been fixed, then it is recommended
            to use the :meth:`checkOnlyIsFixedOrisMod` method instead for faster computation

        Parameters
        ----------
        line: :class:`str`
            The line in the .ini file

        stats: :class:`IniClassifyStats`
            The resultant stats to store the classification result of the .ini file
        """

        keyword, keywordInd = self._keywordDFA.findMaximal(line)
        if (keyword is None):
            return
        
        val = self._keywordDFA.getKeyVal(keyword)
        keywordEndInd = keywordInd + len(keyword)

        self._transition(stats, line, keyword, keywordInd, keywordEndInd = keywordEndInd, keywordVals = val)


class IniClsCond(IniClsAction):
    """
    This class inherits from :class:`IniClsAction`

    An action for the :class:`IniClassifier` to handle branching conditions

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: x(classifier, line, keyword, prevStateId, currentStateId, isAccept, transtionMade)

            Calls :meth:`run` for the :class:`IniClsCond`, ``x``

    Parameters
    ----------
    conds: List[Callable[[:class:`IniClsActionArgs`], :class:`bool`]]
        A list of predicates to evaluate. :raw-html:`<br />` :raw-html:`<br />`

        .. tip::
            For a condition at position `i` in `conds` (`conds[i]`), you can assume the set of values that will be evaulated at this condition will be the values that
            do not satisfy the previous conditions (does not satisfy any condition at position `j`, where `j < i`) :raw-html:`<br />` :raw-html:`<br />`

            Simply, the standard `if ... else ...` structure you expect from other programming languages

    actions: List[Union[:class:`IniClsAction`, Callable[[:class:`IniClsActionArgs`], Any]]]
        The actions to run after its corresponding predicate at 'conds' is evaluated to be true

    default:  Union[Optional[:class:`IniClsAction`], Callable[[:class:`IniClsActionArgs`], Any]]
        The default action to run if none of the predicates are satisfied

    Attributes
    ----------
    conds: List[Callable[[:class:`IniClsActionArgs`], :class:`bool`]]
        A list of predicates to evaluate.

    actions: List[Union[:class:`IniClsAction`, Callable[[:class:`IniClsActionArgs`], Any]]]
        The actions to run after its corresponding predicate at 'conds' is evaluated to be true

    default:  Union[Optional[:class:`IniClsAction`], Callable[[:class:`IniClsActionArgs`], Any]]
        The default action to run if none of the predicates are satisfied
    """

    def __init__(self, conds: List[Callable[[IniClsActionArgs], bool]],
                 actions: List[Union[IniClsAction, Callable[[IniClsActionArgs], Any]]],
                 default: Union[Optional[IniClsAction], Callable[[IniClsActionArgs], Any]]):
        self.conds = conds
        self.actions = actions
        self.default = (lambda actionArgs: None) if (default is None) else default

    def __call__(self, args):
        minLen = min(len(self.conds), len(self.actions))

        for i in range(minLen):
            if (self.conds[i](args)):
                self.actions[i](args)
                return
        
        self.default(args)


class IniClassifierLambda():
    def __init__(self, *args):
        self.args = args

    def checkRegex(self, actionArgs: IniClsActionArgs) -> bool:
        return bool(re.search(self.args[0], actionArgs.line))
    
    def checkStr(self, actionArgs: IniClsActionArgs) -> bool:
        return actionArgs.line.find(self.args[0]) > -1
    
    def giAcceptLine(self, args: IniClsActionArgs):
        args.stats.modType = self.args[0]
        if (not args.stats.isMod):
            args.stats.isMod = True

        args.classifier.reset()

        txtSuffix = args.line[args.keywordEndInd:]
        suffixKey, suffixInd = args.classifier._keywordDFA.findMaximal(txtSuffix)

        if (suffixKey is None):
            return
        
        args.classifier.setIsFixedAndIsMod(suffixKey, args.stats)

    def giTransitionToCheck(self, args: IniClsActionArgs):
        args.classifier._transition(args.stats, args.line, self.args[0], keywordInd = args.keywordInd, keywordEndInd = args.keywordEndInd)
        

class IniClassifierBuilder(BaseIniClassifierBuilder):
    """
    This class inherits from :class:`BaseIniClassifierBuilder` :raw-html:`<br />` :raw-html:`<br />`

    Class to help build/customize a :class:`IniClassifier` used for this software

    Attributes
    ----------
    _startStateId: :class:`str`
        The id for the root state

    _textureOverrideId: :class:`str`
        The id for the ``TextureOverride`` state
    """

    def __init__(self):
        self._startStateId = "root"
        self._textureOverrideId = "textureOverride"
        self._sectionPatterns = {}

        sectionKeywords = {IniKeywords.RemapFix.value.lower(), IniKeywords.RemapTex.value.lower(),
                           IniKeywords.Blend.value.lower(), IniKeywords.RemapBlend.value.lower(),
                           IniKeywords.RemapPosition.value.lower()}

        for keyword in sectionKeywords:
            self._sectionPatterns[keyword] = re.compile(r"^\s*\[.*" + keyword + r".*\]")

    def _reset(self, args: IniClsActionArgs):
        args.classifier.reset()

    def _setIsFixed(self, args: IniClsActionArgs):
        args.stats.isFixed = True
        args.classifier.reset()

    def _setIsMod(self, args: IniClsActionArgs):
        args.stats.isMod = True
        args.classifier.reset()

    def _setIsFixedAndIsMod(self, args: IniClsActionArgs):
        args.stats.isFixed = True
        args.stats.isMod = True
        args.classifier.reset()

    def _handlePosition(self, args: IniClsActionArgs):
        args.classifier.reset()
        if (not args.stats.isMod):
            args.stats.isMod = True

        if (args.stats.isFixed):
            return
        
        if (re.search(args.classifier.RemapFixSuffixPattern, args.line[args.keywordEndInd:])):
            args.stats.isFixed = True

    def _transitionTextureOverride(self, args: IniClsActionArgs):
        keywordEndInd = args.keywordEndInd
        txtSuffix, txtSuffixInd = args.classifier._keywordDFA.findMaximal(args.line[keywordEndInd:])
        if (txtSuffix is None):
            return
        
        txtSuffixVals = args.classifier._keywordDFA.getKeyVal(txtSuffix)
        txtSuffixEndInd = txtSuffixInd + len(txtSuffix)
        args.classifier._transition(args.stats, args.line, txtSuffix, txtSuffixInd + keywordEndInd, txtSuffixEndInd + keywordEndInd, txtSuffixVals)

    def _checkSectionKeyword(self, actionArgs: IniClsActionArgs) -> bool:
        return bool(self._sectionPatterns[actionArgs.keyword].search(actionArgs.line))
    
    def _checkOnlyFixedSectionKeyword(self, actionArgs: IniClsActionArgs) -> bool:
        return not actionArgs.stats.isFixed and bool(self._sectionPatterns[actionArgs.keyword].search(actionArgs.line))
    
    def _checkOnlyIsModKeyword(self, actionArgs: IniClsActionArgs) -> bool:
        return not actionArgs.stats.isMod and bool(self._sectionPatterns[actionArgs.keyword].search(actionArgs.line))
    
    def _checkIsFixed(self, args: IniClsActionArgs) -> bool:
        return args.stats.isFixed
    
    def _checkIsMod(self, args: IniClsActionArgs) -> bool:
        return args.stats.isMod

    def build(self, classifier: "IniClassifier"):
        classifier._stateDFA.addState(self._startStateId)

        # Comments
        self._addKeywordGroup(classifier, [";", "#"], self._startStateId, "comment", self._reset)

        # texuture override keyword
        classifier._addTransition(self._startStateId, "textureoverride", self._textureOverrideId, self._transitionTextureOverride)

        # Keywords for whether the .ini file is only fixed
        onlyFixedKeywords = [IniKeywords.RemapFix.value.lower(), IniKeywords.RemapTex.value.lower()]
        onlyFixedCond = IniClsCond([self._checkOnlyFixedSectionKeyword], [self._setIsFixed], self._reset)
        self._addKeywordGroup(classifier, onlyFixedKeywords, self._startStateId, "onlyFixed", onlyFixedCond)
        self._addKeywordGroup(classifier, onlyFixedKeywords, self._textureOverrideId, "texOnlyFixed", onlyFixedCond)

        # Keywords for whether the .ini file is only a mod
        onlyIsModKeywords = [IniKeywords.Blend.value.lower()]
        onlyIsModCond = IniClsCond([self._checkOnlyIsModKeyword], [self._setIsMod], self._reset)
        self._addKeywordGroup(classifier, onlyIsModKeywords, self._startStateId, "onlyIsMod", onlyIsModCond)
        self._addKeywordGroup(classifier, onlyIsModKeywords, self._textureOverrideId, "texOnlyIsMod", onlyIsModCond)
        
        # Keywords for whether the .ini file is both fixed and is a mod
        fixedAndIsModKeywords = [IniKeywords.RemapBlend.value.lower(), IniKeywords.RemapPosition.value.lower()]
        fixedAndIsModCond = IniClsCond([self._checkSectionKeyword], [self._setIsFixedAndIsMod], self._reset)
        self._addKeywordGroup(classifier, fixedAndIsModKeywords, self._startStateId, "fixedAndIsModBlend", fixedAndIsModCond)
        self._addKeywordGroup(classifier, fixedAndIsModKeywords, self._textureOverrideId, "tFixedAndIsModBlend", fixedAndIsModCond)
        
        # Position and Position.*RemapFix keywords
        positionKeywords = [IniKeywords.Position.value.lower()]
        self._addKeywordGroup(classifier, positionKeywords, self._startStateId, "fixedOrIsModPos", self._handlePosition)
        self._addKeywordGroup(classifier, positionKeywords, self._textureOverrideId, "tFixedOrIsModPos", self._handlePosition)

        # ===== GI mods =====

        self.addGIModType(classifier, ModTypes.Amber.value, {"amber": re.compile(r"^\s*\[\s*textureoverride.*(amber)((?!cn).)*\]")})
        self.addGIModType(classifier, ModTypes.AmberCN.value, {"ambercn": re.compile(r"^\s*\[\s*textureoverride.*(ambercn).*\]")})
        self.addGIModType(classifier, ModTypes.Ayaka.value, {"ayaka": re.compile(r"^\s*\[\s*textureoverride.*(ayaka)((?!(springbloom)).)*\]")})
        self.addGIModType(classifier, ModTypes.AyakaSpringBloom.value, {"ayakaspringbloom": re.compile(r"^\s*\[\s*textureoverride.*(ayakaspringbloom).*\]")})
        self.addGIModType(classifier, ModTypes.Arlecchino.value, {"arlecchino": re.compile(r"^\s*\[\s*textureoverride.*(arlecchino).*\]")})
        self.addGIModType(classifier, ModTypes.Barbara.value, {"barbara": re.compile(r"^\s*\[\s*textureoverride.*(barbara)((?!summertime).)*\]")})
        self.addGIModType(classifier, ModTypes.BarbaraSummertime.value, {"barbarasummertime": re.compile(r"^\s*\[\s*textureoverride.*(barbarasummertime).*\]")})
        self.addGIModType(classifier, ModTypes.CherryHuTao.value, {"cherryhutao": re.compile(r"^\s*\[\s*textureoverride.*(cherryhutao).*\]"),
                                                                    "hutaocherry": re.compile(r"^\s*\[\s*textureoverride.*(hutaocherry).*\]")})
        self.addGIModType(classifier, ModTypes.Diluc.value, {"diluc": re.compile(r"^\s*\[\s*textureoverride.*(diluc)((?!flamme).)*\]")})
        self.addGIModType(classifier, ModTypes.DilucFlamme.value, {"dilucflamme": re.compile(r"^\s*\[\s*textureoverride.*(dilucflamme).*\]")})
        self.addGIModType(classifier, ModTypes.Fischl.value, {"fischl": re.compile(r"^\s*\[\s*textureoverride.*(fischl)((?!highness).)*\]")})
        self.addGIModType(classifier, ModTypes.FischlHighness.value, {"fischlhighness": re.compile(r"^\s*\[\s*textureoverride.*(fischlhighness).*\]")})
        self.addGIModType(classifier, ModTypes.Ganyu.value, {"ganyu": re.compile(r"^\s*\[\s*textureoverride.*(ganyu)((?!(twilight)).)*\]")})
        self.addGIModType(classifier, ModTypes.GanyuTwilight.value, {"ganyutwilight": re.compile(r"^\s*\[\s*textureoverride.*(ganyutwilight).*\]")})
        self.addGIModType(classifier, ModTypes.HuTao.value, {"hutao": re.compile(r"^\s*\[\s*textureoverride((?!cherry).)*(hutao)((?!cherry).)*\]")})
        self.addGIModType(classifier, ModTypes.Jean.value, {"jean": re.compile(r"^\s*\[\s*textureoverride.*(jean)((?!(cn|sea)).)*\]")})
        self.addGIModType(classifier, ModTypes.JeanCN.value, {"jeancn": re.compile(r"^\s*\[\s*textureoverride.*(jeancn)((?!sea).)*\]")})
        self.addGIModType(classifier, ModTypes.JeanSea.value, {"jeansea": re.compile(r"^\s*\[\s*textureoverride.*(jeansea)((?!cn).)*\]")})
        self.addGIModType(classifier, ModTypes.Kaeya.value, {"kaeya": re.compile(r"^\s*\[\s*textureoverride.*(kaeya)((?!(sailwind)).)*\]")})
        self.addGIModType(classifier, ModTypes.KaeyaSailwind.value, {"kaeyasailwind": re.compile(r"^\s*\[\s*textureoverride.*(kaeyasailwind).*\]")})
        self.addGIModType(classifier, ModTypes.Keqing.value, {"keqing": re.compile(r"^\s*\[\s*textureoverride.*(keqing)((?!(opulent)).)*\]")})
        self.addGIModType(classifier, ModTypes.KeqingOpulent.value, {"keqingopulent": re.compile(r"^\s*\[\s*textureoverride.*(keqingopulent).*\]")})
        self.addGIModType(classifier, ModTypes.Kirara.value, {"kirara": re.compile(r"^\s*\[\s*textureoverride.*(kirara)((?!boots).)*\]")})
        self.addGIModType(classifier, ModTypes.KiraraBoots.value, {"kiraraboots": re.compile(r"^\s*\[\s*textureoverride.*(kiraraboots).*\]")})
        self.addGIModType(classifier, ModTypes.Klee.value, {"klee": re.compile(r"^\s*\[\s*textureoverride.*(klee)((?!blossomingstarlight).)*\]")})
        self.addGIModType(classifier, ModTypes.KleeBlossomingStarlight.value, {"kleeblossomingstarlight": re.compile(r"^\s*\[\s*textureoverride.*(kleeblossomingstarlight).*\]")})
        self.addGIModType(classifier, ModTypes.Lisa.value, {"lisa": re.compile(r"^\s*\[\s*textureoverride.*(lisa)((?!student).)*\]")})
        self.addGIModType(classifier, ModTypes.LisaStudent.value, {"lisastudent": re.compile(r"^\s*\[\s*textureoverride.*(lisastudent).*\]")})
        self.addGIModType(classifier, ModTypes.Mona.value, {"mona": re.compile(r"^\s*\[\s*textureoverride.*(mona)((?!(cn)).)*\]")})
        self.addGIModType(classifier, ModTypes.MonaCN.value, {"monacn": re.compile(r"^\s*\[\s*textureoverride.*(monacn).*\]")})
        self.addGIModType(classifier, ModTypes.Nilou.value, {"nilou": re.compile(r"^\s*\[\s*textureoverride.*(nilou)((?!(breeze)).)*\]")})
        self.addGIModType(classifier, ModTypes.NilouBreeze.value, {"niloubreeze": re.compile(r"^\s*\[\s*textureoverride.*(niloubreeze).*\]")})
        self.addGIModType(classifier, ModTypes.Ningguang.value, {"ningguang": re.compile(r"^\s*\[\s*textureoverride.*(ningguang)((?!(orchid)).)*\]")})
        self.addGIModType(classifier, ModTypes.NingguangOrchid.value, {"ningguangorchid": re.compile(r"^\s*\[\s*textureoverride.*(ningguangorchid).*\]")})
        self.addGIModType(classifier, ModTypes.Raiden.value, {"raiden": re.compile(r"^\s*\[\s*textureoverride.*(raiden).*\]"),
                                                               "shogun": re.compile(r"^\s*\[\s*textureoverride.*(shogun).*\]")})
        self.addGIModType(classifier, ModTypes.Rosaria.value, {"rosaria": re.compile(r"^\s*\[\s*textureoverride.*(rosaria)((?!(cn)).)*\]")})
        self.addGIModType(classifier, ModTypes.RosariaCN.value, {"rosariacn": re.compile(r"^\s*\[\s*textureoverride.*(rosariacn).*\]")})
        self.addGIModType(classifier, ModTypes.Shenhe.value, {"shenhe": re.compile(r"^\s*\[\s*textureoverride.*(shenhe)((?!frostflower).)*\]")})
        self.addGIModType(classifier, ModTypes.ShenheFrostFlower.value, {"shenhefrostflower": re.compile(r"^\s*\[\s*textureoverride.*(shenhefrostflower).*\]")})
        self.addGIModType(classifier, ModTypes.Xiangling.value, {"xiangling": re.compile(r"^\s*\[\s*textureoverride.*(xiangling)((?!cheer|newyear).)*\]")})
        self.addGIModType(classifier, ModTypes.XianglingCheer.value, {"xianglingcheer": re.compile(r"^\s*\[\s*textureoverride.*(xianglingcheer).*\]"),
                                                                      "xianglingnewyear": re.compile(r"^\s*\[\s*textureoverride.*(xianglingnewyear).*\]")})
        self.addGIModType(classifier, ModTypes.Xingqiu.value, {"xingqiu": re.compile(r"^\s*\[\s*textureoverride.*(xingqiu)((?!bamboo).)*\]")})
        self.addGIModType(classifier, ModTypes.XingqiuBamboo.value, {"xingqiubamboo": re.compile(r"^\s*\[\s*textureoverride.*(xingqiubamboo).*\]")})

        # ===================

    def _addKeywordGroup(self, classifier: "IniClassifier", keywords: List[str], srcStateId: Hashable, keywordsStateId: Hashable, 
                         transitionVal: Union[Optional["ModType"], IniClsAction, Callable[["IniClassifier", IniClassifyStats, str, str, Hashable, Hashable, bool, bool], Any]]):
        """
        Convenience function to add many keywords that transition from the same source state to the same destionation state

        Parameters
        ----------
        classifier: :class:`IniClassifier`
            The classifier to identify mods from .ini files

        keywords: List[:class:`str`]
            The keywords to add

        srcStateId: `Hashable`_
            The id of the source state

        keywordsStateId: `Hashable`_
            The id of the destionation state

            .. note::
                If this function creates the destionation state, the destionation state will not be an accepting state

        transitionVal: Union[Optional[:class:`ModType`], :class:`IniClsAction`, Callable[[:class:`IniClassifier`, :class:`IniClassifyStats`, :class:`str`, :class:`str`, `Hashable`_, `Hashable`_, :class:`bool`, :class:`bool`], Any]]
            The corresponding value to store at the transition :raw-html:`<br />` :raw-html:`<br />`

            If this value is a function, refer to :meth:`IniClsAction.run` for the specifics of what paramters to pass to the function
        """

        for keyword in keywords:
            classifier._addTransition(srcStateId, keyword, keywordsStateId, transitionVal)

    def addGIModType(self, classifier: "IniClassifier", modType: "ModType", keywords: Dict[Optional[str], Union[Optional[str], Pattern, Callable[[IniClsActionArgs], bool]]]):
        """
        Convenience function to add a mod type from the game GI

        Parameters
        ----------
        classifier: :class:`IniClassifier`
            The classifier to identify mods from .ini files

        modType: :class:`ModType`
            The type of mod to register

        keywords: Dict[Optional[:class:`str`, Union[Optional[:class:`str`, `Pattern`_, Callable[[:class:`IniClsActionArgs`], :class:`bool`]]]]]
            The keywords used to identify the mod :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the keywords to identify the type of mod when reading a line from the .ini file
            * The values are any further checks to verify the keyword :raw-html:`<br />` :raw-html:`<br />`

                #. If value is a string, then will check if a line in the .ini file equals to this value
                #. If value is a regex pattern, then will check if a line in the .ini file matches this regex pattern
                #. If this value is a function, then will check if a line in the .ini file will make the function for this value return `True`
        """

        name = modType.name
        acceptStateId = f"accept_{name}"
        middleStateId = f"check_{name}"
        classifier._stateDFA.addState(acceptStateId, isAccept = True)
        acceptFunc = IniClassifierLambda(modType).giAcceptLine

        keywordInd = 0
        for keyword in keywords:
            keywordAction = keywords[keyword]
            transitionKeyword = f"{name}{keywordInd}"
            action = None

            # no action --> directly go to accept state
            if (keywordAction is None):
                classifier._addTransition(self._textureOverrideId, keyword, acceptStateId, acceptFunc)
                keywordInd += 1
                continue
            
            # further checks to verify the keyword need to go through an
            #   intermediate state
            condActions = [IniClassifierLambda(transitionKeyword).giTransitionToCheck]
            defaultAction = self._reset

            if (isinstance(keywordAction, str)):
                action = IniClsCond([IniClassifierLambda(keywordAction).checkStr], condActions, default = defaultAction)
            elif (callable(keywordAction)):
                action = IniClsCond([keywordAction], condActions)
            else:
                action = IniClsCond([IniClassifierLambda(keywordAction).checkRegex], condActions, default = defaultAction)

            classifier._addTransition(self._textureOverrideId, keyword, middleStateId, action)
            classifier._addTransition(middleStateId, transitionKeyword, acceptStateId, acceptFunc)
            keywordInd += 1


class GlobalIniClassifiers(Enum):
    """
    Global modules used by the sofware to help identify what mod belongs to a .ini file

    Attributes
    ----------
    Classifier: :class:`IniClassifier`
        The classifier used to identify whether the .ini file belongs to some mod
    """

    Classifier = IniClassifier(builder = IniClassifierBuilder())


class IniSrcResourceModel(IniResourceModel):
    """
    This class inherits from :class:`IniResourceModel`

    Contains data for a particular resource in the original .ini file

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: for path, fullPath in x

            Iterates over all the paths to some resource within a :class:`IfContentPart`, ``x`` :raw-html:`<br />` :raw-html:`<br />`

            The tuples to iterate over are as follows:
            #. path: (:class:`str`) The path to the file
            #. fullPath: (:class:`str`) The full path to the file

    Parameters
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located

    paths: Dict[:class:`int`, List[:class:`str`]]
        The file paths to the fixed files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` that the resource file appears in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`

    Attributes
    ----------
    paths: Dict[:class:`int`, List[:class:`str`]]
        The file paths to the fixed files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` that the resource file appears in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`

    fullPaths: Dict[:class:`int`, List[:class:`str`]]
        The absolute paths to the fixed resource files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` that the files appear in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`
    """

    def __init__(self, iniFolderPath: str, paths: Dict[int, List[str]]):
        super().__init__(iniFolderPath)
        self.paths = paths

        # retrieve the absolute paths
        self.fullPaths = {}
        for partIndex, partPaths in self.paths.items():
            self.fullPaths[partIndex] = list(map(lambda path: FileService.absPathOfRelPath(path, iniFolderPath), partPaths))

    def __iter__(self):
        for ifTemplateInd in self.paths:
            partPaths = self.paths[ifTemplateInd]
            partPathsLen = len(partPaths)

            for i in range(partPathsLen):
                path = partPaths[i]
                fullPath = self.fullPaths[ifTemplateInd][i]

                yield (path, fullPath)


class IniDownloadModel(IniSrcResourceModel):
    """
    This class inherits from: :class:`IniSrcResourceModel`

    Contains data about a particular resource to download in the original .ini file

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: for path, fullPath in x

            Iterates over all the paths to some resource within a :class:`IfContentPart`, ``x`` :raw-html:`<br />` :raw-html:`<br />`

            The tuples to iterate over are as follows:
            #. path: (:class:`str`) The path to the file
            #. fullPath: (:class:`str`) The full path to the file

    Parameters
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located

    paths: Dict[:class:`int`, List[:class:`str`]]
        The file paths to the download files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` that the resource file appears in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`

    downloads: Dict[:class:`int`, List[:class:`FileDownload`]]
        The downloader associated for each file :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` that the resource file appears in the :class:`IfTemplate` for some resource
        * The values are the downloaders for the files within the :class:`IfContentPart`

    Attributes
    ----------
    downloads: Dict[:class:`int`, List[:class:`FileDownload`]]
        The downloader associated for each file :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` that the resource file appears in the :class:`IfTemplate` for some resource
        * The values are the downloaders for the files within the :class:`IfContentPart`s
    """

    def __init__(self, iniFolderPath: str, paths: Dict[int, List[str]], downloads: Dict[int, List[FileDownload]]):
        super().__init__(iniFolderPath, paths)
        self.downloads = downloads


# KeepFirstDict: Dictionary used to only keep the value of the first instance of a key
class KeepFirstDict(OrderedDict):
    def __setitem__(self, key, value):
        # All values updated into the dictionary of ConfigParser will first updated as a list of values, then
        #    the list of values will be turned into a string
        #
        # eg. the 'value' argument for the __setitem__ method in the case a key has 2 duplicates
        # >> value = ["val1"]           <----------- we only want this list
        # >> value = ["val1", "", "val2"]
        # >> value = ["val1", "", "val2", "", "val3"]
        # >> value = "val1\nval2\nval3"
        #
        # Note:
        #   For the case of duplicate keys, GIMI will only keep the value of the first valid instance of the key.
        #       Since checking for correct syntax and semantics is out of the scope of this program, we only get 
        #        the value of the first instance of the key
        if (key in self and isinstance(self[key], list) and isinstance(value, list)):
            return

        super().__setitem__(key, value)


# KeepAllDict: Dictionary used to keep all instances of a key
class KeepAllDict(OrderedDict):
    def __init__(self):
        super().__init__()
        self._orderInd = 0

    def __setitem__(self, key, value):
        keyExists = key in self
        valueIsList = isinstance(value, list)

        if (keyExists and valueIsList):
            self[key].append(f"{self._orderInd}_{value[0]}")
            self._orderInd += 1
            return
        elif (valueIsList):
            super().__setitem__(key, [f"{self._orderInd}_{value[0]}"])
            self._orderInd += 1
            return

        elif (isinstance(value, str) and keyExists and isinstance(self[key], list)):
            return

        super().__setitem__(key, value)


# IniFile: Class to handle .ini files
class IniFile(File):
    """
    This class inherits from :class:`File`

    Class for handling .ini files

    :raw-html:`<br />`

    .. note::
        We analyse the .ini file using Regex which is **NOT** the right way to do things
        since the modified .ini language that GIMI interprets is a **CFG** (context free grammer) and **NOT** a regular language.
   
        But since we are lazy and don't want make our own compiler with tokenizers, parsing algorithms (eg. SLR(1)), type checking, etc...
        this module should handle regular cases of .ini files generated using existing scripts (assuming the user does not do anything funny...)

    :raw-html:`<br />`

    Parameters
    ----------
    file: Optional[:class:`str`]
        The file path to the .ini file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    logger: Optional[:class:`Logger`]
        The logger to print messages if necessary

    txt: :class:`str`
        Used as the text content of the .ini file if :attr:`IniFile.file` is set to ``None`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ""

    modTypes: Optional[Set[:class:`ModType`]]
        The types of mods that the .ini file should belong to :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    modsToFix: Optional[Set[:class:`str`]]
        The names of the mods we want to fix to :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    defaultModType: Optional[:class:`ModType`]
        The type of mod to use if the .ini file has an unidentified mod type :raw-html:`<br />` :raw-html:`<br />`
        If this value is ``None``, then will skip the .ini file with an unidentified mod type :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    forcedModType: Optional[:class:`ModType`]
        The type of mod to forcibly assume the .ini file to belong to :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
        The game version we want the .ini file to be compatible with :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will retrieve the hashes/indices of the latest version. :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    downloadMode: :class:`DownloadMode`
        The download mode to handle file downloads :raw-html:`<br />` :raw-html:`<br />`

        .. note::
            For more information about the available download modes to specify, see :ref:`Download Modes`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: :attr:`DownloadMode.HardTexDriven`

    iniClassifier: Optional[:class:`IniClassifier`]
        The classifier used to identify what mod belongs to this .ini file :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will use the default classifier used by the software from :attr:`IniModules.Classifier` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    version: Optional[`packaging.version.Version`_]
        The game version we want the .ini file to be compatible with :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will retrieve the hashes/indices of the latest version.

    downloadMode: :class:`DownloadMode`
        The download mode to handle file downloads :raw-html:`<br />`

        .. note::
            For more information about the available download modes to specify, see :ref:`Download Modes`

    _parser: `ConfigParser`_
        Parser used to parse very basic cases in a .ini file

    modTypes: Set[:class:`ModType`]
        The types of mods that the .ini file should belong to

    modsToFix: Set[:class:`str`]
        The names of the mods that we want to fix to

    defaultModType: Optional[:class:`ModType`]
        The type of mod to use if the .ini file has an unidentified mod type

    forcedModType: Optional[:class:`ModType`]
        The type of mod to forcibly assume the .ini file to belong to

    sectionIfTemplates: Dict[:class:`str`, :class:`IfTemplate`]
        All the `sections`_ in the .ini file that can be parsed into an :class:`IfTemplate`

        For more info see :class:`IfTemplate`

        .. attention::
            The modified .ini language that GIMI uses introduces keywords that can be used before the key of a key-value pair :raw-html:`<br />`

            *eg. defining constants*

            .. code-block:: ini
                :linenos:

                [Constants]
                global persist $swapvar = 0
                global persist $swapscarf = 0
                global $active
                global $creditinfo = 0

            :raw-html:`<br />`

            `Sections`_ containing this type of pattern will not be parsed. But generally, these sections are irrelevant to fixing the Raiden Boss

    _resourceBlends: Dict[:class:`str`, :class:`IfTemplate`]
        `Sections`_ that are linked to 1 or more Blend.buf files.

        The keys are the name of the sections.

    _remappedSectionNames: Set[:class:`str`]
        The `section`_ names that were fixed.

    remapBlendModels: Dict[:class:`str`, :class:`IniResourceModel`]
        The data for the ``[Resource.*RemapBlend.*]`` `sections`_ used in the fix :raw-html:`<br />` :raw-html:`<br />`

        The keys are the original names of the resource with the pattern ``[Resource.*Blend.*]``

    remapPositionModels: Dict[:class:`str`, :class:`IniResourceModel`]
        The data for the ``[Resource.*RemapPosition.*]`` `sections`_ used in the fix :raw-html:`<br />` :raw-html:`<br />`

        The keys are the original names of the resource with the pattern ``[Resource.*Position.*]``

    texEditModels: Dict[:class:`str`, Dict[:class:`str`, :class:`IniTexModel`]]
        The data for the ``[Resource.*]`` `sections`_ that belong to some texture file that got editted :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names for the type of texture files *eg. MyBrandNewLightMap*
        * The inner keys are the original names of the resource with the pattern ``[Resource.*]``

    texAddModels: Dict[:class:`str`, Dict[:class:`str`, :class:`IniTexModel`]]
        The data for the ``[Resource.*]`` `sections`_ that belong to some texture file that got added :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names for the type of texture files *eg. MyBrandNewLightMap*
        * The inner keys are the names of the mod object *eg. Head*

    fileDownloadModels: Dict[:class:`str`, :class:`IniDownloadModel`]
        The data for the downloaded files in the fix :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the ``[Resource.*]`` `sections`_ that have some downloaded file
    """

    # -- regex strings ---

    _textureOverrideBlendPatternStr = r"^\s*\[\s*TextureOverride.*" + IniKeywords.Blend.value + r".*\s*\]"
    _fixedTextureOverrideBlendPatternStr = r"^\s*\[\s*TextureOverride.*" + IniKeywords.RemapBlend.value + r".*\s*\]"
    
    # --------------------
    # -- regex objects ---
    _sectionPattern = re.compile(r"^\s*\[.*\]")
    _textureOverrideBlendPattern = re.compile(_textureOverrideBlendPatternStr)
    _fixedTextureOverrideBlendPattern = re.compile(_fixedTextureOverrideBlendPatternStr)

    # -------------------

    _ifStructurePattern = re.compile(r"\s*(" + IfPredPartType.EndIf.value + "|" + IfPredPartType.Else.value +  "|" + IfPredPartType.If.value + "|" + IfPredPartType.Elif.value + ")")

    def __init__(self, file: Optional[str] = None, logger: Optional["Logger"] = None, txt: str = "", modTypes: Optional[Set[ModType]] = None, defaultModType: Optional[ModType] = None, 
                 forcedModType: Optional[ModType] = None, version: Optional[float] = None, modsToFix: Optional[Set[str]] = None, iniClassifier: Optional[IniClassifier] = None,
                 downloadMode: DownloadMode = DownloadMode.HardTexDriven):
        super().__init__(logger = logger)

        self._filePath: Optional[FilePath] = None
        self.file = file
        self.version = Version.getVersion(version)
        self.downloadMode = downloadMode

        self._parserDictType = KeepAllDict
        self._parser = configparser.ConfigParser(dict_type = self._parserDictType, strict = False)
        self._parser.optionxform=str

        self._fileLines = []
        self._fileTxt = ""
        self._fileLinesRead = False
        self._isClassified = False
        self._ifTemplatesRead = False
        self._setupFileLines(fileTxt = txt)

        if (modTypes is None):
            modTypes = set()
        if (modsToFix is None):
            modsToFix = set()

        self.defaultModType = defaultModType
        self.forcedModType = forcedModType
        self.modTypes = modTypes
        self.modsToFix = modsToFix
        self._heading = IniBoilerPlate.DefaultHeading.value.copy()

        self._isFixed = False
        self._setType(None)
        self._isModIni = False
        self._hideOriginalReplaced = False

        self.sectionIfTemplates: Dict[str, IfTemplate] = {}
        self._resourceBlends: Dict[str, IfTemplate] = {}
        self._remappedSectionNames: Set[str] = set()

        self.remapBlendModels: Dict[str, IniFixResourceModel] = {}
        self.remapPositionModels: Dict[str, IniFixResourceModel] = {}
        self.texEditModels: Dict[str, Dict[str, IniTexModel]] = {}
        self.texAddModels: Dict[str, Dict[str, IniTexModel]] = {}
        self.fileDownloadModels: Dict[str, IniDownloadModel] = {}

        self._iniParser: Optional[BaseIniParser] = None
        self._iniFixer: Optional[BaseIniFixer] = None
        self._iniRemover: Optional[BaseIniRemover] = None
        self._iniClassifier = GlobalIniClassifiers.Classifier.value if (iniClassifier is None) else iniClassifier

    @property
    def filePath(self) -> Optional[FilePath]:
        """
        The path to the .ini file

        :getter: Returns the path to the file
        :type: Optional[:class:`FilePath`]
        """
        return self._filePath

    @property
    def file(self) -> Optional[str]:
        """
        The file path to the .ini file

        :getter: Returns the path to the file
        :setter: Sets the new path for the file
        :type: Optional[:class:`str`]
        """

        if (self._filePath is None):
            return None
        return self._filePath.path
    
    @file.setter
    def file(self, newFile: Optional[str]) -> str:
        if (newFile is not None and self._filePath is None):
            self._filePath = FilePath(newFile)
        elif (newFile is not None):
            self._filePath.path = newFile
        elif (self._filePath is not None):
            self._filePath = None

    @property
    def folder(self) -> str:
        """
        The folder where this .ini file resides :raw-html:`<br />` :raw-html:`<br />`

        If :attr:`IniFile.file` is set to ``None``, then will return the folder where this script is ran

        :getter: Retrieves the folder
        :type: :class:`str`
        """

        if (self._filePath is not None):
            return self._filePath.folder
        return FilePathConsts.CurrentDir

    @property
    def isFixed(self) -> bool:
        """
        Whether the .ini file has already been fixed

        :getter: Returns whether the .ini file has already been fixed
        :type: :class:`bool`
        """

        return self._isFixed
    
    @property
    def type(self) -> Optional[ModType]:
        """
        The type of mod the .ini file belongs to

        :getter: Returns the type of mod the .ini file belongs to
        :type: Optional[:class:`ModType`]
        """

        return self._type
    
    def _setType(self, newType: Optional[ModType]):
        self._type = newType
        self._heading.title = None
    
    @property
    def isModIni(self) -> bool:
        """
        Whether the .ini file belongs to a mod

        :getter: Returns whether the .ini file belongs to a mod
        :type: :class:`bool`
        """

        return self._isModIni
    
    @property
    def fileLinesRead(self) -> bool:
        """
        Whether the .ini file has been read

        :getter: Determines whether the .ini file has been read
        :type: :class:`bool`
        """

        return self._fileLinesRead
    
    @property
    def isClassified(self) -> bool:
        """
        Whether the type of mod has already been identified for the .ini file

        :getter: Determines whether the .ini file has already been classified
        :type: :class:`bool`
        """

        return self._isClassified
    
    @property
    def hideOriginalReplaced(self) -> bool:
        """
        Whether the comments created by this fix that is used to hide the original mod has been erased

        :getter: Determines whether the comments are erased
        :type: :class:`bool`
        """

        return self._hideOriginalReplaced
    
    @property
    def fileTxt(self) -> str:
        """
        The text content of the .ini file

        :getter: Returns the content of the .ini file
        :setter: Reads the new value for both the text content of the .ini file and the text lines of the .ini file 
        :type: :class:`str`
        """

        return self._fileTxt
    
    @fileTxt.setter
    def fileTxt(self, newFileTxt: str):
        self._fileTxt = newFileTxt
        self._fileLines = TextTools.getTextLines(self._fileTxt)

        self._fileLinesRead = True
        self._isFixed = False

    @property
    def fileLines(self) -> List[str]:
        """
        The text lines of the .ini file :raw-html:`<br />` :raw-html:`<br />`

        .. note::
            For the setter, each line must end with a newline character (same behaviour as `readLines`_)

        :getter: Returns the text lines of the .ini file
        :setter: Reads the new value for both the text lines of the .ini file and the text content of the .ini file
        :type: List[:class:`str`]
        """

        return self._fileLines
    
    @fileLines.setter
    def fileLines(self, newFileLines: List[str]):
        self._fileLines = newFileLines
        self._fileTxt = "".join(self._fileLines)

        self._fileLinesRead = True
        self._isFixed = False

    def clearRead(self, eraseSourceTxt: bool = False):
        """
        Clears the saved text read in from the .ini file

        .. note::
            If :attr:`IniFile.file` is set to ``None``, then the default run of this function
            with the argument ``eraseSourceTxt`` set to ``False`` will have no effect since the provided text from :attr:`IniFile._fileTxt` is the only source of data for the :class:`IniFile`

            If you also want to clear the above source text data, then run this function with the ``eraseSourceTxt`` argument set to ``True``

        Parameters
        ----------
        eraseSourceTxt: :class:`bool`
            Whether to erase the only data source for this class if :attr:`IniFile.file` is set to ``None``, see the note above for more info :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        if (self._filePath is not None or eraseSourceTxt):
            self._fileLines = []
            self._fileTxt = ""
            self._fileLinesRead = False

            self._isFixed = False
            self._hideOriginalReplaced = False

    def clearModels(self):
        """
        Clears all the internal data models used in the .ini file

        .. note::
            This function will not clear the text data read in from the .ini file
            To clear this data, please see :meth:`clearRead`
        """

        self._resourceBlends.clear()
        self.remapBlendModels.clear()
        self.texEditModels.clear()
        self.texAddModels.clear()
        self.fileDownloadModels.clear()
        self._remappedSectionNames.clear()

    def clear(self, eraseSourceTxt: bool = False):
        """
        Clears all the saved data for the .ini file

        .. note::
            Please see the note at :meth:`IniFile.clearRead`

        Parameters
        ----------
        eraseSourceTxt: :class:`bool`
            Whether to erase the only data source for this class if :attr:`IniFile.file` is set to ``None``, see the note at :meth:`IniFile.clearRead` for more info :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        self.clearRead(eraseSourceTxt = eraseSourceTxt)
        self._heading = IniBoilerPlate.DefaultHeading.value.copy()
        self._setType(None)
        self._isModIni = False
        self._isClassified = False

        self._ifTemplatesRead = False
        self.sectionIfTemplates = {}
        self._resourceBlends = {}

        self._iniParser = None
        self._iniFixer = None

        self.clearModels()


    @property
    def availableType(self) -> Optional[ModType]:
        """
        Retrieves the type of mod identified for this .ini file

        .. note::
            This function is the same as :meth:`IniFile.type`, but will return :attr:`IniFile.defaultModType` if :meth:`IniFile.type` is ``None``

        :getter: Returns the type of mod identified
        :type: Optional[:class:`ModType`]
        """

        if (self._type is not None):
            return self._type
        elif (self.defaultModType is not None):
            return self.defaultModType
        
        return None

    def read(self) -> str:
        """
        Reads the .ini file :raw-html:`<br />` :raw-html:`<br />`

        If :attr:`IniFile.file` is set to ``None``, then will read the existing value from :attr:`IniFile.fileTxt`

        Returns
        -------
        :class:`str`
            The text content of the .ini file
        """

        if (self._filePath is not None):
            self.fileTxt = FileService.read(self._filePath.path, "r", lambda filePtr: filePtr.read())
        return self._fileTxt
    
    def write(self, txt: Optional[str] = None) -> str:
        """
        Writes back into the .ini files based off the content in :attr:`IniFile._fileLines`

        Parameters
        ----------
        txt: Optional[:class:`str`]
            The text to write back into the .ini file :raw-html:`<br />` :raw-html:`<br />`

            If this argument is ``None``, then will use the :attr:`IniFile.fileTxt`

            **Default**: ``none``

        Returns
        -------
        :class:`str`
            The text that is written to the .ini file
        """

        if (self._filePath is None and txt is not None):
            self.fileTxt = txt

        if (self._filePath is None):
            return self._fileTxt
        
        if (txt is None):
            txt = self._fileTxt

        with open(self._filePath.path, "w", encoding = FileEncodings.UTF8.value) as f:
            f.write(txt)

        return txt

    def _setupFileLines(self, fileTxt: str = ""):
        if (self._filePath is None):
            self.fileTxt = fileTxt
            self._fileLinesRead = True

    def readFileLines(self) -> List[str]:
        """
        Reads each line in the .ini file :raw-html:`<br />` :raw-html:`<br />`

        If :attr:`IniFile.file` is set to ``None``, then will read the existing value from :attr:`IniFile.fileLines`

        Returns
        -------
        List[:class:`str`]
            All the lines read from the .ini file
        """

        if (self._filePath is not None):
            self.fileLines = FileService.read(self._filePath.path, "r", lambda filePtr: filePtr.readlines())
        return self._fileLines

    def _readLines(func):
        """
        Decorator to read all the lines in the .ini file first before running a certain function

        All the file lines will be saved in :attr:`IniFile._fileLines`

        Examples
        --------
        .. code-block:: python
            :linenos:

            @_readLines
            def printLines(self):
                for line in self._fileLines:
                    print(f"LINE: {line}")
        """

        @wraps(func)
        def readLinesWrapper(self, *args, **kwargs):
            if (not self._fileLinesRead):
                self.readFileLines()
            return func(self, *args, **kwargs)
        return readLinesWrapper
    
    def getTexEditModels(self) -> List[IniTexModel]:
        """
        Retrieves all the file path data needed for editing a texture .dds file
        (transforms :attr:`IniFile.texEditModels` to a list)

        Returns
        -------
        List[:class:`IniTexModel`]
            The data models needed for editting a texture .dds file
        """

        result = []

        for texName in self.texEditModels:
            texTypeModels = self.texEditModels[texName]
            for section in texTypeModels:
                result.append(texTypeModels[section])

        return result
    
    def getTexAddModels(self) -> List[IniTexModel]:
        """
        Retrieves all the file path data needed for creating new texture .dds file
        (transforms :attr:`IniFile.texAddModels` to a list)

        Returns
        -------
        List[:class:`IniTexModel`]
            The data models needed for editting a texture .dds file
        """

        result = []

        for texName in self.texAddModels:
            texTypeModels = self.texAddModels[texName]
            for modObj in texTypeModels:
                result.append(texTypeModels[modObj])

        return result
    
    def _getReferencedModels(self) -> List[IniFixResourceModel]:
        """
        Retrieves all the resources referenced by the .ini file

        Returns 
        -------
        List[:class:`IniResourceModel`]
            All the resource models referenced
        """

        result = []
        for _, model in self.remapBlendModels.items():
            result.append(model)

        for _, model in self.remapPositionModels.items():
            result.append(model)

        for texName in self.texAddModels:
            texTypeModels = self.texAddModels[texName]
            for modObj in texTypeModels:
                result.append(texTypeModels[modObj])

        for texName in self.texEditModels:
            texTypeModels = self.texEditModels[texName]
            for section in texTypeModels:
                result.append(texTypeModels[section])

        for _, model in self.fileDownloadModels.items():
            result.append(model)

        return result
    
    def getReferencedFiles(self) -> List[str]:
        """
        Retrieves all the files referenced by the .ini file

        Returns
        -------
        List[:class:`str`]
            The absolute paths to all the files
        """

        OrderedSet = GlobalPackageManager.get(PackageModules.OrderedSet.value).OrderedSet

        result = OrderedSet([])
        models = self._getReferencedModels()

        for model in models:
            if (isinstance(model, IniFixResourceModel)):
                for fixedPath, fixedFullPath, origPath, origFullPath in model:
                    result.add(origFullPath)

            elif (isinstance(model, IniSrcResourceModel)):
                for path, fullPath in model:
                    result.add(fullPath)

        return list(result)
    
    def getReferencedFolders(self) -> List[str]:
        """
        Retrieves all the folders referenced by the .ini file

        Returns
        -------
        List[:class:`str`]
            The absolute paths to all the folders
        """

        OrderedSet = GlobalPackageManager.get(PackageModules.OrderedSet.value).OrderedSet

        result = OrderedSet([])
        models = self._getReferencedModels()

        for model in models:
            if (isinstance(model, IniFixResourceModel)):
                for fixedPath, fixedFullPath, origPath, origFullPath in model:
                    result.add(os.path.dirname(origFullPath))
            elif (isinstance(model, IniSrcResourceModel)):
                for path, fullPath in model:
                    result.add(os.path.dirname(fullPath))

        return list(result)

    @_readLines
    def classify(self, flush: bool = False) -> bool:
        """
        Classifies a .ini file by answering the following questions:

        #. Does the .ini file belong to a mod?
        #. What type of mod does the .ini file belong to?
        #. Has the .ini file already been fixed?

        .. note::
            To access the result of the classification, you can call the following attributes:

            * :attr:`isModIni`
            * :attr:`type`
            * :attr:`isFixed`

        Parameters
        ----------
        flush: :class:`bool`
            Whether to flush out any cached data and reclassify the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`bool`
            Whether the .ini file belongs to a mod
        """
        if (not flush and self._isClassified):
            return self._isModIni

        classifyStats = self._iniClassifier.classify(self._fileTxt)

        modType = classifyStats.modType
        hasModType = modType is not None and modType in self.modTypes
        hasForcedModType = self.forcedModType is not None
    
        self._isModIni = False if (self.defaultModType is None and not hasModType and self.modTypes and not hasForcedModType) else classifyStats.isMod
        self._isFixed = classifyStats.isFixed

        if (hasForcedModType):
            modType = self.forcedModType
            hasModType = True

        if (hasModType and self._isModIni):
            self._setType(modType)
        else:
            self._setType(None)

        self._isClassified = True
        return self._isModIni

    def _parseSection(self, sectionName: str, srcTxt: str, save: Optional[Dict[str, Any]] = None) -> Optional[Dict[str, str]]:
        """
        Regularly parses the key-value pairs of a certain `section`_

        The function parses uses `ConfigParser`_ to parse the `section`_.

        Parameters
        ----------
        sectionName: :class:`str`
            The name of the `section`_

        srcTxt: :class:`str`
            The text containing the entire `section`_

        save: Optional[Dict[:class:`str`, Any]]
            Place to save the parsed result for the `section`_  :raw-html:`<br />` :raw-html:`<br />`

            The result for the parsed `section`_ will be saved as a value in the dictionary while section's name will be used in the key for the dictionary :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Optional[Dict[:class:`str`, :class:`str`]]
            The result from parsing the `section`_

            .. note:: 
                If `ConfigParser`_ is unable to parse the section, then ``None`` is returned
        """

        result = None   

        # delete any previously saved sections
        try:
            self._parser[sectionName]
        except KeyError:
            pass
        else:
            del self._parser[sectionName]

        # eliminate all indented tabs/spaces
        srcTxt = re.sub(r"\n([( |\t)]+)", r"\n", srcTxt)

        # parse the section
        try:
            self._parser.read_string(srcTxt)
            result = self._parser[sectionName]
        except:
            return result

        if (self._parserDictType == KeepAllDict):
            sectionOpts = {}
            for varName in result:
                sectionOpts[varName] = self._parser.get(sectionName, varName, raw = True)

            result = sectionOpts
            for key in result:
                currentValues = result[key]
                result[key] = []

                for val in currentValues:
                    if (not val):
                        continue

                    currentValue = val.split("_", 1)
                    currentValue[0] = int(currentValue[0])
                    result[key].append(tuple(currentValue))
        else:
            result = dict(result)

        try:
            save[sectionName] = result
        except TypeError:
            pass

        return result
    
    def _getSectionName(self, line: str) -> str:
        return IniClassifier.getSectionName(line)

    # retrieves the key-value pairs of a section in the .ini file. Manually parsed the file since ConfigParser
    #   errors out on conditional statements in .ini file for mods. Could later inherit from the parser (RawConfigParser) 
    #   to custom deal with conditionals
    @_readLines
    def getSectionOptions(self, section: Union[str, Pattern, Callable[[str], bool]], postProcessor: Optional[Callable[[int, int, List[str], str, str], Any]] = None, 
                          handleDuplicateFunc: Optional[Callable[[List[Any]], Any]] = None, ignoreHideOriginal: bool = False) -> Dict[str, Any]:
        """
        Reads the entire .ini file for a certain type of `section`_

        Parameters
        ----------
        section: Union[:class:`str`, `Pattern`_, Callable[[:class:`str`], :class:`bool`]]
            The type of section to find

            * If this argument is a :class:`str`, then will check if the line in the .ini file exactly matches the argument
            * If this argument is a `Pattern`_, then will check if the line in the .ini file matches the specified Regex pattern
            * If this argument is a function, then will check if the line in the .ini file passed as an argument for the function will make the function return ``True``

        postProcessor: Optional[Callable[[:class:`int`, :class:`int`, List[:class:`str`], :class:`str`, :class:`str`], Any]]
            Post processor used when a type of `section`_ has been found

            The order of arguments passed into the post processor will be:

            #. The starting line index of the `section`_ in the .ini file
            #. The ending line index of the `section`_ in the .ini file
            #. All the file lines read from the .ini file
            #. The name of the `section`_ found
            #. The entire text for the `section`_ :raw-html:`<br />` :raw-html:`<br />`

            **Default**: `None`

        handleDuplicateFunc: Optional[Callable[List[Any], Any]]
            Function to used to handle the case of multiple sections names :raw-html:`<br />` :raw-html:`<br />`

            If this value is set to ``None``, will keep all sections with the same names

            .. note::
                For this case, GIMI only keeps the first instance of all sections with same names

            :raw-html:`<br />`

            **Default**: ``None``

        ignoreHideOriginal: :class:`bool`
            Whether to ignore the special comment created by this fix used to hide the original mod within the .ini txt :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        Dict[:class:`str`, Any]
            The resultant `sections`_ found

            The keys are the names of the `sections`_ found and the values are the content for the `section`_,
        """

        sectionFilter = None
        if (isinstance(section, str)):
            sectionFilter = lambda line: line == section
        elif callable(section):
            sectionFilter = section
        else:
            sectionFilter = lambda line: section.search(line)

        if (postProcessor is None):
            postProcessor = lambda startInd, endInd, fileLines, sectionName, srcTxt: self._parseSection(sectionName, srcTxt)

        result = {}
        currentSectionName = None
        currentSectionToParse = None
        currentSectionStartInd = -1

        fileLinesLen = len(self._fileLines)

        for i in range(fileLinesLen):
            line = self._fileLines[i]
            if (not self._hideOriginalReplaced and ignoreHideOriginal):
                line = line.replace(IniKeywords.HideOriginalComment.value, "")

            # process the resultant section
            if (currentSectionToParse is not None and self._sectionPattern.search(line)):
                currentResult = postProcessor(currentSectionStartInd, i, self._fileLines, currentSectionName, currentSectionToParse)
                if (currentResult is None):
                    continue

                # whether to keep sections with the same name
                sectionResults = result.get(currentSectionName)
                if (sectionResults is None):
                    sectionResults = []
                    result[currentSectionName] = sectionResults

                sectionResults.append(currentResult)

                currentSectionToParse = None
                currentSectionName = None
                currentSectionStartInd = -1

            elif (currentSectionToParse is not None):
                currentSectionToParse += f"{line}"

            # keep track of the found section
            if (sectionFilter(line)):
                currentSectionToParse = f"{line}"
                currentSectionName = self._getSectionName(currentSectionToParse)
                currentSectionStartInd = i

        # get any remainder section
        if (currentSectionToParse is not None):
            currentResult = postProcessor(currentSectionStartInd, fileLinesLen, self._fileLines, currentSectionName, currentSectionToParse)
            try:
                result[currentSectionName]
            except:
                result[currentSectionName] = [currentResult]
            else:
                result[currentSectionName].append(currentResult)

        if (handleDuplicateFunc is None):
            return result

        # handle the duplicate sections with the same names
        for sectionName in result:
            result[sectionName] = handleDuplicateFunc(result[sectionName])

        return result

    def _removeSection(self, startInd: int, endInd: int, fileLines: List[str], sectionName: str, srcTxt: str) -> Tuple[int, int]:
        """
        Retrieves the starting line index and ending line index of where to remove a certain `section`_ from the read lines of the .ini file

        Parameters
        ----------
        startInd: :class:`int`
            The starting line index of the `section`_

        endInd: :class:`int`
            The ending line index of the `section`_

        fileLines: List[:class:`str`]
            All the file lines read from the .ini file

        sectionName: :class:`str`
            The name of the `section`_

        srcTxt: :class:`str`
            The text content of the `section`_

        Returns
        -------
        Tuple[:class:`int`, :class:`int`]
            The starting line index and the ending line index of the `section`_ to remove
        """

        fileLinesLen = len(fileLines)
        if (endInd > fileLinesLen):
            endInd = fileLinesLen

        if (startInd > fileLinesLen):
            startInd = fileLinesLen

        return (startInd, endInd)
    
    def removeSectionOptions(self, section: Union[str, Pattern, Callable[[str], bool]]):
        """
        Removes a certain type of `section`_ from the .ini file

        Parameters
        ----------
        section: Union[:class:`str`, `Pattern`_, Callable[[:class:`str`], :class:`bool`]]
            The type of `section`_ to remove
        """

        rangesToRemove = self.getSectionOptions(section, postProcessor = self._removeSection)
        partIndices = []

        for sectionName, ranges in rangesToRemove.items():
            for range in ranges:
                partIndices.append(range)

        self.fileLines = TextTools.removeLines(self._fileLines, partIndices)

    def _commentSection(self, startInd: int, endInd: int, fileLines: List[str], comment: str = ";"):
        """
        Comments out a `section`_

        Parameters
        ----------
        startInd: :class:`int`
            The starting line index of the `section`_

        endInd: :class:`int`
            The ending line index of the `section`_

        fileLines: List[:class:`str`]
            All the file lines read from the .ini file

        comment: :class:`str`
            The comment string used to prefix every line in the `section`_ :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ````

        Returns
        -------
        Tuple[:class:`int`, :class:`int`]
            The starting line index and the ending line index of the `section`_ that was commented
        """

        fileLinesLen = len(fileLines)
        if (endInd > fileLinesLen):
            endInd = fileLinesLen

        if (startInd > fileLinesLen):
            startInd = fileLinesLen

        for i in range(startInd, endInd):
            fileLines[i] = f"{comment}{fileLines[i]}"

        return (startInd, endInd)
    
    def commentSectionOptions(self, section: Union[str, Pattern, Callable[[str], bool]], comment: str = ";"):
        """
        Comments out a certain type of `section`_ from the .ini file

        Parameters
        ----------
        section: Union[:class:`str`, `Pattern`_, Callable[[:class:`str`], :class:`bool`]]
            The type of `section`_ to comment out     

        comment: :class:`str`
            The comment string used to prefix every line in the `section`_ :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ````

        Returns
        -------
        :class:`str`
            The file text with the comments added
        """

        self.getSectionOptions(section, postProcessor = lambda startInd, endInd, fileLines, sectionName, srcTxt: self._commentSection(startInd, endInd, fileLines, comment = comment))
        self.fileLines = self._fileLines
        return self._fileTxt
    
    def hideOriginalSections(self):
        """
        Comments out all the sections referenced by the remap

        .. note::
            The .ini file need to be parsed first using the :meth:`parse` method        
        """

        self.commentSectionOptions(lambda line: self._sectionPattern.search(line) and self._getSectionName(line) in self._remappedSectionNames, comment = IniKeywords.HideOriginalComment.value)

    def _processIfTemplate(self, startInd: int, endInd: int, fileLines: List[str], sectionName: str, srcTxt: str) -> IfTemplate:
        """
        Parses a `section`_ in the .ini file as an :class:`IfTemplate`

        .. note::
            See :class:`IfTemplate` to see how we define an 'IfTemplate'

        Parameters
        ----------
        startInd: :class:`int`
            The starting line index of the `section`_

        endInd: :class:`int`
            The ending line index of the `section`_

        fileLines: List[:class:`str`]
            All the file lines read from the .ini file

        sectionName: :class:`str`
            The name of the `section`_

        srcTxt: :class:`str`
            The text content of the `section`_

        Returns
        -------
        :class:`IfTemplate`
            The generated :class:`IfTemplate` from the `section`_
        """

        ifTemplate = []
        dummySectionName = "dummySection"
        currentDummySectionName = f"{dummySectionName}"
        replaceSection = ""
        atReplaceSection = False

        for i in range(startInd + 1, endInd):
            line = fileLines[i]
            isConditional = bool(self._ifStructurePattern.match(line))

            if (isConditional and atReplaceSection):
                currentDummySectionName = f"{dummySectionName}{i}"
                replaceSection = f"[{currentDummySectionName}]\n{replaceSection}"

                currentPart = self._parseSection(currentDummySectionName, replaceSection)
                if (currentPart is None):
                    currentPart = {}

                ifTemplate.append(currentPart)
                replaceSection = ""

            if (isConditional):
                ifTemplate.append(line)
                atReplaceSection = False
                continue
            
            replaceSection += line
            atReplaceSection = True

        # get any remainder replacements in the if..else template
        if (replaceSection != ""):
            currentDummySectionName = f"{dummySectionName}END{endInd}"
            replaceSection = f"[{currentDummySectionName}]\n{replaceSection}"
            currentPart = self._parseSection(currentDummySectionName, replaceSection)
            if (currentPart is None):
                currentPart = {}

            if (currentPart):
                ifTemplate.append(currentPart)

        # create the if template
        result = IfTemplate.build(ifTemplate, name = sectionName)
        return result
    

    def getIfTemplates(self, flush: bool = False) -> Dict[str, IfTemplate]:
        """
        Retrieves all the :class:`IfTemplate`s for the .ini file

        .. note::
            This is the same as :meth:`IniFile.readIfTemplates`, but uses caching

        Parameters
        ----------
        flush: :class:`bool`
            Whether to re-parse the :class:`IfTemplates`s instead of using the saved cached values

        Returns
        -------
        Dict[:class:`str`, :class:`IfTempalte`]
            The parsed :class:`IfTemplate`s :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the name of the :class:`IfTemplate`
            * The values are the corresponding :class:`IfTemplate`
        """

        if (not self._ifTemplatesRead or flush):
            self.readIfTemplates()
        return self.sectionIfTemplates

    def readIfTemplates(self) -> Dict[str, IfTemplate]:
        """
        Parses all the :class:`IfTemplate`s for the .ini file

        Returns
        -------
        Dict[:class:`str`, :class:`IfTempalte`]
            The parsed :class:`IfTemplate`s :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the name of the :class:`IfTemplate`
            * The values are the corresponding :class:`IfTemplate`
        """

        self.sectionIfTemplates = self.getSectionOptions(self._sectionPattern, postProcessor = self._processIfTemplate, 
                                                         handleDuplicateFunc = lambda duplicates: duplicates[0], ignoreHideOriginal = True)
        self._ifTemplatesRead = True
        return self.sectionIfTemplates 
    
    @classmethod
    def getMergedResourceIndex(cls, mergedResourceName: str) -> Optional[int]:
        """
        Retrieves the index number of a resource created by GIMI's ``genshin_merge_mods.py`` script

        Examples
        --------
        >>> IniFile.getMergedResourceIndex("ResourceCuteLittleEiBlend.8")
        8


        >>> IniFile.getMergedResourceIndex("ResourceCuteLittleEiBlend.Score.-100")
        -100


        >>> IniFile.getMergedResourceIndex("ResourceCuteLittleEiBlend.UnitTests")
        None


        >>> IniFile.getMergedResourceIndex("ResourceCuteLittleEiBlend")
        None

        Parameters
        ----------
        mergedResourceName: :class:`str`
            The name of the `section`_

        Returns
        -------
        Optional[:class:`int`]
            The index for the resource `section`_, if found and the index is an integer
        """
        result = None

        try:
            result = int(mergedResourceName.rsplit(".", 1)[-1])
        except:
            pass
            
        return result
    
    @classmethod
    def compareResources(cls, resourceTuple1: Tuple[str, Optional[int]], resourceTuple2: Tuple[str, Optional[int]]) -> int:
        """
        Compare function used for sorting resources :raw-html:`<br />` :raw-html:`<br />`

        The order for sorting is the resources is:
        
        #. Resources that do are not suffixed by an index number
        #. Resource that are suffixed by an index number (see :meth:`IniFile.getMergedResourceIndex` for more info)

        Parameters
        ----------
        resourceTuple1: Tuple[:class:`str`, Optional[:class:`int`]]
            Data for the first resource in the compare function, contains:

            * Name of the resource
            * The index for the resource

        resourceTuple2: Tuple[:class:`str`, Optional[:class:`int`]]
            Data for the second resource in the compare function, contains:

            * Name of the resource
            * The index for the resource

        Returns
        -------
        :class:`int`
            The result for a typical compare function used in sorting

            * returns -1 if ``resourceTuple1`` should come before ``resourceTuple2``
            * returns 1 if ``resourceTuple1`` should come after ``resourceTuple2``
            * returns 0 if ``resourceTuple1`` is equal to ``resourceTuple2`` 
        """

        resourceKey1 = resourceTuple1[1]
        resourceKey2 = resourceTuple2[1]
        resource1MissingIndex = resourceKey1 is None
        resource2MissingIndex = resourceKey2 is None

        if (resource1MissingIndex):
            resourceKey1 = resourceTuple1[0]
        
        if (resource2MissingIndex):
            resourceKey2 = resourceTuple2[0]

        if ((resource1MissingIndex == resource2MissingIndex and resourceKey1 < resourceKey2) or (resource1MissingIndex and not resource2MissingIndex)):
            return -1
        elif ((resource1MissingIndex == resource2MissingIndex and resourceKey1 > resourceKey2) or (not resource1MissingIndex and resource2MissingIndex)):
            return 1
        
        return 0

    # Disabling the OLD ini
    def disIni(self, makeCopy: bool = False):
        """
        Disables the .ini file

        .. note::
            For more info, see :meth:`FileService.disableFile` 

        Parameters
        ----------
        makeCopy: :class:`bool`
            Whether to make a copy of the disabled .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        if (self._filePath is None):
            return

        disabledPath = FileService.disableFile(self._filePath.path)
        if (makeCopy):
            FileService.copyFile(disabledPath, self._filePath.path)

    @classmethod
    def getFixedElementFile(cls, file: str, elementName: str, fileExt: str, modName: str = "") -> str:
        """
        Retrieves the file path for a a fixed element

        Parameters
        ----------
        file: :class:`str`
            The file path to the original file

        elementName: :class:`str`
            The name of the element to fix

        fileExt: :class:`str`
            The file extension for the file path of the fixed element

        modName: :class:`str`
            The name of the mod to fix to

        Returns
        -------
        :class:`str`
            The file path of the fixed file of the element
        """

        folder = os.path.dirname(file)
        baseName = os.path.basename(file)
        baseName = baseName.rsplit(".", 1)[0]
        
        return os.path.join(folder, f"{cls.getRemapElementName(baseName, elementName, modName = modName)}{fileExt}")

    @classmethod
    def getFixedBlendFile(cls, blendFile: str, modName: str = "") -> str:
        """
        Retrieves the file path for the fixed RemapBlend.buf file

        Parameters
        ----------
        blendFile: :class:`str`
            The file path to the original Blend.buf file

        modName: :class:`str`
            The name of the mod to fix to

        Returns
        -------
        :class:`str`
            The file path of the fixed RemapBlend.buf file
        """

        return cls.getFixedElementFile(blendFile, IniKeywords.Blend.value, FileExt.Buf.value, modName = modName)
    
    @classmethod
    def getFixedPositionFile(cls, positionFile: str, modName: str = "") -> str:
        """
        Retrieves the file path for the fixed RemapPosition.buf file

        Parameters
        ----------
        positionFile: :class:`str`
            The file path to the original Position.buf file

        modName: :class:`str`
            The name of the mod to fix to

        Returns
        -------
        :class:`str`
            The file path of the fixed RemapPosition.buf file
        """

        return cls.getFixedElementFile(positionFile, IniKeywords.Position.value, FileExt.Buf.value, modName = modName)
    
    @classmethod
    def getFixedTexFile(cls, texFile: str, modName: str = "") -> str:
        """
        Retrieves the file path for the fixed RemapTex.dds file

        Parameters
        ----------
        texFile: :class:`str`
            The file path to the original .dds file

        modName: :class:`str`
            The name of the mod to fix to

        Returns
        -------
        :class:`str`
            The file path of the fixed RemapTex.dds file
        """

        blendFolder = os.path.dirname(texFile)
        blendBaseName = os.path.basename(texFile)
        blendBaseName = blendBaseName.rsplit(".", 1)[0]

        return os.path.join(blendFolder, f"{cls.getRemapTexName(blendBaseName, modName = modName)}{FileExt.DDS.value}")
    
    def getFixModTypeName(self) -> Optional[str]:
        """
        Retrieves the name of the type of mod corresponding to the .ini file to be used for the comment of the fix

        Returns
        -------
        Optional[:class:`str`]
            The name for the type of mod corresponding to the .ini file
        """
        if (self._type is None):
            return None
        return self._type.name.replace("\n", "").replace("\t", "")
    
    def getFixModTypeHeadingname(self):
        """
        Retrieves the name of the type of mod corresponding to the .ini file to be used in the header/footer divider comment of the fix

        Returns
        -------
        Optional[:class:`str`]
            The name for the type of mod to be displayed in the header/footer divider comment
        """

        modTypeName = self.getFixModTypeName()
        if (modTypeName is None):
            modTypeName = "GI"

        return modTypeName

    def getHeadingName(self):
        """
        Retrieves the title for the header of the divider comment of the fix

        Returns
        -------
        :class:`str`
            The title for the header of the divider comment
        """

        result = self.getFixModTypeHeadingname()
        if (result):
            result += " "

        return f"{result}Remap"

    def getFixHeader(self) -> str:
        """
        Retrieves the header text used to identify a code section has been changed by this fix
        in the .ini file

        Returns
        -------
        :class:`str`
            The header section comment to be used in the .ini file
        """
        
        if (self._heading.title is None):
            self._heading.title = self.getHeadingName()
        return f"; {self._heading.open()}"
    
    def getFixFooter(self) -> str:
        """
        Retrieves the footer text used to identify a code section has been changed by this fix
        in the .ini file

        Returns
        -------
        :class:`str`
            The footer section comment to be used in the .ini file
        """

        if (self._heading.title is None):
            self._heading.title = self.getHeadingName()
        return f"\n\n; {self._heading.close()}"
    
    def getFixCredit(self) -> str:
        """
        Retrieves the credit text for the code generated in the .ini file

        Returns
        -------
        :class:`str`
            The credits to be displayed in the .ini file
        """

        modTypeName = self.getFixModTypeName()
        shortModTypeName = modTypeName

        if (modTypeName is None):
            modTypeName = "Mod"
            shortModTypeName = ""

        if (modTypeName):
            modTypeName += " "
        
        if (shortModTypeName):
            shortModTypeName += " "
        
        return IniBoilerPlate.Credit.value.replace(IniBoilerPlate.ModTypeNameReplaceStr.value, modTypeName).replace(IniBoilerPlate.ShortModTypeNameReplaceStr.value, shortModTypeName)
    
    def addFixBoilerPlate(self, fix: str = "") -> str:
        """
        Adds the boilerplate code to identify the .ini `sections`_ have been changed by this fix

        Parameters
        ----------
        fix: :class:`str`
            The content for the fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The fix with the boilerplate code included
        """

        result = self.getFixHeader()
        result += self.getFixCredit()
        result += fix
        result += self.getFixFooter()
        return result

    def fixBoilerPlate(func):
        """
        Decorator used to add the boilerplate code to identify a code section has been changed by this fix in the .ini file

        Examples
        --------
        .. code-block:: python
            :linenos:

            @fixBoilerPlate
            def helloWorld(self) -> str:
                return "Hello World"
        """

        def addFixBoilerPlateWrapper(self, *args, **kwargs):
            fix = func(self, *args, **kwargs)
            fix = self.addFixBoilerPlate(fix = fix)
            return fix
        return addFixBoilerPlateWrapper
    
    @classmethod
    def getResourceName(cls, name: str) -> str:
        """
        Makes the name of a `section`_ to be used for the resource `sections`_ of a .ini file

        Examples
        --------
        >>> IniFile.getResourceName("CuteLittleEi")
        "ResourceCuteLittleEi"


        >>> IniFile.getResourceName("ResourceCuteLittleEi")
        "ResourceCuteLittleEi"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        Returns
        -------
        :class:`str`
            The name of the `section`_ as a resource in a .ini file
        """

        if (not name.startswith(IniKeywords.Resource.value)):
            name = f"{IniKeywords.Resource.value}{name}"
        return name
    
    @classmethod
    def removeResourceName(cls, name: str) -> str:
        """
        Removes the 'Resource' prefix from a section's name

        Examples
        --------
        >>> IniFile.removeResourceName("ResourceCuteLittleEi")
        "CuteLittleEi"


        >>> IniFile.removeResourceName("LittleMissGanyu")
        "LittleMissGanyu"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the 'Resource' prefix removed
        """

        if (name.startswith(IniKeywords.Resource.value)):
            name = name[len(IniKeywords.Resource.value):]

        return name
    
    @classmethod
    def getRemapElementName(cls, name: str, elementName: str, modName: str = ""):
        """
        Changes a `section`_ name to have the keyword from 'elementName' to identify that the `section`_
        is created by this fix

        Examples
        --------
        >>> IniFile.getRemapElementName("EiTriesToUseBlenderAndFails", "Blend", "Raiden")
        "EiTriesToUseRaidenRemapBlenderAndFails"


        >>> IniFile.getRemapElementName("EiTextsTheTexture", "Tex", "Yae")
        "EiTextsTheYaeRemapTexture"
    

        >>> IniFile.getRemapElementName("ResourceCuteLittleEi", "Position", "Raiden")
        "ResourceCuteLittleEiRaidenRemapPosition"


        >>> IniFile.getRemapElementName("ResourceCuteLittleEiRemapDango", "Dango" "Raiden")
        "ResourceCuteLittleEiRemapRaidenRemapDango"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        elementName: :class:`str`
            The name of the target element

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the keyword of 'elementName', prefixed by the word 'Remap' added
        """

        nameParts = name.rsplit(elementName, 1)
        namePartsLen = len(nameParts)

        remapName = f"{modName}{IniKeywords.Remap.value}{elementName}"
        if (namePartsLen > 1):
            name = remapName.join(nameParts)
        else:
            name += remapName

        return name
    
    @classmethod
    def getRemapBlendName(cls, name: str, modName: str = "") -> str:
        """
        Changes a `section`_ name to have the keyword 'RemapBlend' to identify that the `section`_
        is created by this fix

        .. tip::
            See :meth:`getRemapElementName` for some examples

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapBlend' keyword
        """

        return cls.getRemapElementName(name, elementName = IniKeywords.Blend.value, modName = modName)
    
    @classmethod
    def getRemapPositionName(cls, name: str, modName: str = "") -> str:
        """
        Changes a `section`_ name to have the keyword 'RemapPosition' to identify that the `section`_
        is created by this fix

        .. tip::
            See :meth:`getRemapElementName` for some examples

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapPosition' keyword
        """

        return cls.getRemapElementName(name, elementName = IniKeywords.Position.value, modName = modName)
    
    @classmethod
    def getRemapTexcoordName(cls, name: str, modName: str = "") -> str:
        """
        Changes a `section`_ name to have the keyword 'RemapTexcoord' to identify that the `section`_
        is created by this fix

        .. tip::
            See :meth:`getRemapElementName` for some examples

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapTexcoord' keyword
        """

        return cls.getRemapElementName(name, elementName = IniKeywords.Texcoord.value, modName = modName)
    
    @classmethod
    def getRemapIbName(cls, name: str, modName: str = "") -> str:
        """
        Changes a `section`_ name to have the keyword 'RemapIb' to identify that the `section`_
        is created by this fix

        .. tip::
            See :meth:`getRemapElementName` for some examples

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapIb' keyword
        """

        return cls.getRemapElementName(name, elementName = "IB", modName = modName)
    
    @classmethod
    def getModSuffixedName(cls, name: str, suffix: str = "", modName: str = ""):
        """
        Changes a `section`_ name to have the suffix of 'modName' followed by 'suffix'

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        suffix: :class:`str`
            The name of the suffix to put at the end of the `section`_ :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added suffix keyword
        """

        remapName = f"{modName}{suffix}"
        if (name.endswith(remapName)):
            return name
        elif(name.endswith(suffix)):
            return name[:len(suffix)] + remapName

        return name + remapName
    
    @classmethod
    def getRemapFixName(cls, name: str, modName: str = "") -> str:
        """
        Changes a `section`_ name to have the suffix `RemapFix` to identify that the `section`_
        is created by this fix

        Examples
        --------
        >>> IniFile.getRemapFixName("EiIsDoneWithRemapFix", "Raiden")
        "EiIsDoneWithRaidenRemapFix"

        >>> IniFile.getRemapFixName("EiIsHappy", "Raiden")
        "EiIsHappyRaidenRemapFix"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapFix' keyword
        """

        return cls.getModSuffixedName(name, suffix = IniKeywords.RemapFix.value, modName = modName)
    
    @classmethod
    def getRemapTexName(cls, name: str, modName: str = ""):
        """
        Changes a `section`_ name to have the suffix `RemapFix` to identify that the `section`_
        is created by this fix

        Examples
        --------
        >>> IniFile.getRemapTexName("EiIsDoneWithRemapTex", "Raiden")
        "EiIsDoneWithRaidenRemapTex"

        >>> IniFile.getRemapTexName("EiIsHappy", "Raiden")
        "EiIsHappyRaidenRemapTex"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapFix' keyword
        """

        return cls.getModSuffixedName(name, suffix = IniKeywords.RemapTex.value, modName = modName)
    
    @classmethod
    def getRemapDLName(cls, name: str, modName: str = ""):
        """
        Changes a `section`_ name to have the suffix `RemapDL` to identify that the `section`_
        is created by this fix

        Examples
        --------
        >>> IniFile.getRemapTexName("EiIsDoneWithRemapDL", "Raiden")
        "EiIsDoneWithRaidenRemapDL"

        >>> IniFile.getRemapTexName("EiIsHappy", "Raiden")
        "EiIsHappyRaidenRemapDL"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapDL' keyword
        """

        return cls.getModSuffixedName(name, suffix = IniKeywords.RemapDL.value, modName = modName)

    @classmethod
    def getRemapFixResourceName(cls, name: str, modName: str = ""):
        """
        Changes a `section`_ name to be a new non-blend resource created by this fix

        .. note::
            See :meth:`IniFile.getResourceName` and :meth:`IniFile.getRemapFix` for more info

        Parameters
        ----------
        name: :class:`str`
            The name of the section

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the section with the prefix 'Resource' and the suffix 'RemapFix' added
        """

        name = cls.getRemapFixName(name, modName = modName)
        name = cls.getResourceName(name)
        return name
    
    @classmethod
    def getRemapTexResourceName(cls, name: str, modName: str = ""):
        """
        Changes a `section`_ name to be a texture resource created by this fix

        .. note::
            See :meth:`IniFile.getResourceName` and :meth:`IniFile.getRemapTexName` for more info

        Parameters
        ----------
        name: :class:`str`
            The name of the section

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the section with the prefix 'Resource' and the suffix 'RemapTex' added
        """

        name = cls.getRemapTexName(name, modName = modName)
        name = cls.getResourceName(name)
        return name
    
    @classmethod
    def getRemapDLResourceName(cls, name: str, modName: str = ""):
        """
        Changes a `section`_ name to be a texture resource created by this fix

        .. note::
            See :meth:`IniFile.getResourceName` and :meth:`IniFile.getRemapDLName` for more info

        Parameters
        ----------
        name: :class:`str`
            The name of the section

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the section with the prefix 'Resource' and the suffix 'RemapDL' added
        """

        name = cls.getRemapDLName(name, modName = modName)
        name = cls.getResourceName(name)
        return name

    @classmethod
    def getRemapBlendResourceName(cls, name: str, modName: str = "") -> str:
        """
        Changes the name of a section to be a new blend resource that this fix will create

        .. note::
            See :meth:`getResourceName` and :meth:`getRemapBlendName` for more info

        Parameters
        ----------
        name: :class:`str`
            The name of the section

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the section with the prefix 'Resource' and the keyword 'Remap' added
        """

        name = cls.getRemapBlendName(name, modName = modName)
        name = cls.getResourceName(name)
        return name
    
    @classmethod
    def getRemapPositionResourceName(cls, name: str, modName: str = "") -> str:
        """
        Changes the name of a section to be a new position resource that this fix will create

        .. note::
            See :meth:`getResourceName` and :meth:`getRemapPositionName` for more info

        Parameters
        ----------
        name: :class:`str`
            The name of the section

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the section with the prefix 'Resource' and the keyword 'Remap' added
        """

        name = cls.getRemapPositionName(name, modName = modName)
        name = cls.getResourceName(name)
        return name

    def _isIfTemplateResource(self, ifTemplatePart: Dict[str, Any]) -> bool:
        """
        Whether the content for some part of a `section`_ contains the key 'vb1'

        Parameters
        ----------
        ifTemplatePart: Dict[:class:`str`, Any]
            The key-value pairs for some part in a `section`_

        Returns
        -------
        :class:`bool`
            Whether 'vb1' is contained in the part
        """

        return IniKeywords.Vb1.value in ifTemplatePart
    
    def _isIfTemplateDraw(self, ifTemplatePart: Dict[str, Any]) -> bool:
        """
        Whether the content for some part of a `section`_ contains the key 'draw'

        Parameters
        ----------
        ifTemplatePart: Dict[:class:`str`, Any]
            The key-value pairs for some part in a `section`_

        Returns
        -------
        :class:`bool`
            Whether 'draw' is contained in the part
        """


        return IniKeywords.Draw.value in ifTemplatePart
    
    def _getIfTemplateResourceName(self, ifTemplatePart: Dict[str, Any]) -> Any:
        """
        Retrieves the value from the key, 'vb1', for some part of a `section`_

        Parameters
        ----------
        ifTemplatePart: Dict[:class:`str`, Any]
            The key-value pairs for some part in a `section`_

        Returns
        -------
        Any
            The corresponding value for the key 'vb1'
        """

        return ifTemplatePart[IniKeywords.Vb1.value]
    
    # fills the if..else template in the .ini for each section
    def fillIfTemplate(self, modName: str, sectionName: str, ifTemplate: IfTemplate, fillFunc: Callable[[str, str, Union[str, Dict[str, Any]], int, int, str], str], origSectionName: Optional[str] = None) -> str:
        """
        Creates a new :class:`IfTemplate` for an existing `section`_ in the .ini file

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name of the `section`_

        ifTemplate: :class:`IfTemplate`
            The :class:`IfTemplate` of the orginal `section`_

        fillFunc: Callable[[:class:`str`, :class:`str`, Union[:class:`str`, Dict[:class:`str`, Any], :class:`int`, :class:`str`, :class:`str`], :class:`str`]]
            The function to create a new **content part** for the new :class:`IfTemplate`
            :raw-html:`<br />` :raw-html:`<br />`

            .. tip::
                For more info about an 'IfTemplate', see :class:`IfTemplate`

            :raw-html:`<br />`
            The parameter order for the function is:

            #. The name for the type of mod to fix to
            #. The new section name
            #. The corresponding **content part** in the original :class:`IfTemplate`
            #. The index for the content part in the original :class:`IfTemplate`
            #. The string to prefix every line in the **content part** of the :class:`IfTemplate`
            #. The original name of the section

        origSectionName: Optional[:class:`str`]
            The original name of the section.

            If this argument is set to ``None``, then will assume this argument has the same value as the argument for ``sectionName`` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`str`
            The text for the newly created :class:`IfTemplate`
        """

        addFix = f"[{sectionName}]\n"
        partIndex = 0
        linePrefix = ""

        if (origSectionName is None):
            origSectionName = sectionName

        for part in ifTemplate:
            # adding in the if..else statements
            if (isinstance(part, str)):
                addFix += part
                
                linePrefix = re.match(r"^[( |\t)]*", part)
                if (linePrefix):
                    linePrefix = linePrefix.group(0)
                    linePrefixLen = len(linePrefix)

                    linePrefix = part[:linePrefixLen]
                    lStrippedPart = part[linePrefixLen:]

                    if (lStrippedPart.find("endif") == -1):
                        linePrefix += "\t"
                partIndex += 1
                continue
            
            # add in the content within the if..else statements
            addFix += fillFunc(modName, sectionName, part, partIndex, linePrefix, origSectionName)

            partIndex += 1
            
        return addFix

    # _getRemapName(sectionName, modName, sectionGraph, remapNameFunc): Retrieves the required remap name for the fix
    def _getRemapName(self, sectionName: str, modName: str, sectionGraph: Optional[IniSectionGraph] = None, remapNameFunc: Optional[Callable[[str, str], str]] = None) -> str:
        error = False
        if (sectionGraph is None):
            error = True

        if (not error):
            try:
                return sectionGraph.remapNames[sectionName][modName]
            except KeyError:
                error = True

        if (sectionName not in self.sectionIfTemplates):
            return sectionName

        if (remapNameFunc is None):
            remapNameFunc = self.getRemapBlendName

        return remapNameFunc(sectionName, modName)
    

    def _getFixer(self):
        """
        Retrieves the fixer for fixing the .ini file

        Returns
        -------
        Optional[:class:`BaseIniFixer`]
            The resultant fixer
        """

        availableType = self.availableType
        if (availableType is not None and self._iniParser is not None and self._iniFixer is None):
            self._iniFixer = availableType.iniFixBuilder.build(self._iniParser, modName = self.availableType.name, version = self.version)
        
        return self._iniFixer
    
    # _getFixStr(fix, withBoilerPlate): Internal function to get the needed lines to fix the .ini file
    def _getFixStr(self, fix: str = "", withBoilerPlate: bool = True) -> str:
        fixer = self._getFixer()
        availableType = self.availableType

        if (fixer is None and availableType is not None):
            return fix
        elif (availableType is None):
            raise NoModType()

        result = fixer.getFix(fixStr = fix)

        if (withBoilerPlate):
            return self.addFixBoilerPlate(fix = result)
        return result

    def getFixStr(self, fix: str = "") -> str:
        """
        Generates the newly added code in the .ini file for the fix

        Parameters
        ----------
        fix: :class:`str`
            Any existing text we want the result of the fix to add onto :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ""

        Returns
        -------
        :class:`str`
            The text for the newly generated code in the .ini file
        """

        return self._getFixStr(fix = fix)

    @_readLines
    def injectAddition(self, addition: str, beforeOriginal: bool = True, keepBackup: bool = True, fixOnly: bool = False, update: bool = False) -> str:
        """
        Adds and writes new text to the .ini file

        Parameters
        ----------
        addition: :class:`str`
            The text we want to add to the file

        beforeOriginal: :class:`bool`
            Whether to add the new text before the original text :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        keepBackup: :class:`bool`
            Whether we want to make a backup copy of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether we are only fixing the .ini file without removing any previous changes :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        update: :class:`bool`
            Whether to update the source text within this class to reflect the new addition :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The content of the .ini file with the new text added
        """

        original = self._fileTxt
        if (keepBackup and fixOnly and self._filePath is not None and os.path.exists(self._filePath.path)):
            self.print("log", "Cleaning up and disabling the OLD STINKY ini")
            self.disIni()

        result = ""
        if (beforeOriginal):
            result = f"{addition}\n\n{original}"
        else:
            result = f"{original}\n{addition}"

        # writing the fixed file
        if (self._filePath is not None):
            with open(self._filePath.path, "w", encoding = FileEncodings.UTF8.value) as f:
                f.write(result)

        # update the source text
        if (update):
            self._fileTxt = result
            self._fileLines = TextTools.getTextLines(result)

        self._isFixed = True
        return result

    def _removeFix(self, parse: bool = False, writeBack: bool = True) -> str:
        """
        Removes any previous changes that were probably made by this script :raw-html:`<br />` :raw-html:`<br />`

        For the .ini file will remove:

        #. All code surrounded by the *'---...--- .* Fix ---...----'* header/footer
        #. All `sections`_ containing the keywords ``RemapBlend``

        Parameters
        ----------
        parse: :class:`bool`
            Whether to keep track of the Blend.buf files that also need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        writeBack: :class:`bool`
            Whether to write back the change txt of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file with the changes removed
        """

        self._getRemover()
        return self._iniRemover.remove(parse = parse, writeBack = writeBack)
    
    def _getRemover(self) -> BaseIniRemover:
        """
        Retrieves the remover for removing fixes from the .ini file

        Returns
        -------
        :class:`BaseIniRemover`
            The resultant parser
        """

        availableType = self.availableType

        if (availableType is not None and self._iniRemover is None):
            self._iniRemover = availableType.iniRemoveBuilder.build(self)
            self._iniRemover.iniFile = self
        elif (self._iniRemover is None):
            self._iniRemover = GlobalIniRemoveBuilders.RemoveBuilder.value.build(self)
        
        return self._iniRemover

    @_readLines
    def removeFix(self, keepBackups: bool = True, fixOnly: bool = False, parse: bool = False, writeBack: bool = True) -> str:
        """
        Removes any previous changes that were probably made by this script and creates backup copies of the .ini file

        .. tip::
            For more info about what gets removed from the .ini file, see :meth:`IniFile._removeFix`

        Parameters
        ----------
        keepBackup: :class:`bool`
            Whether we want to make a backup copy of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether we are only fixing the .ini file without removing any previous changes :raw-html:`<br />` :raw-html:`<br />`

            .. note::
                If this value is set to ``True``, then the previous changes made by this script will not be removed

            **Default**: ``False``

        parse: :class:`bool`
            Whether to also parse for the .*RemapBlend.buf files that need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        writeBack: :class:`bool`
            Whether to write back the changed text of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file with the changes removed
        """

        if (keepBackups and not fixOnly and self._filePath is not None):
            self.print("log", f"Creating Backup for {self._filePath.base}")
            self.disIni(makeCopy = True)

        if (fixOnly):
            return self._fileTxt

        if (self._filePath is not None):
            self.print("log", f"Removing any previous changes from this script in {self._filePath.base}")

        result = self._removeFix(parse = parse, writeBack = writeBack)
        return result
    
    def makeFixResourceModel(self, ifTemplate: IfTemplate, toFix: Set[str], getFixedFile: Optional[Callable[[str, str], str]] = None,
                            iniResourceModelCls: Type[IniFixResourceModel] = IniFixResourceModel, 
                            iniResModelArgs: Optional[List[Any]] = None, iniResModelKwargs: Optional[Dict[str, Any]] = None) -> IniFixResourceModel:
        """
        Creates the data needed for fixing a particular ``[Resource.*]`` `section`_ in the .ini file

        Parameters
        ----------
        ifTemplate: :class:`IfTemplate`
            The particular `section`_ to extract data

        toFix: Set[:class:`str`]
            The names of the mods to fix 

        getFixedFile: Optional[Callable[[:class:`str`, :class:`str`], :class:`str`]]
            The function for transforming the file path of a found resource file into a new file path for the fixed resources file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :meth:`IniFile.getFixedBlendFile` :raw-html:`<br />` :raw-html:`<br />`

            The parameters for the function are:

                # The path to the original file
                # The type of mod to fix to

            **Default**: ``None``

        iniResourceModelCls: Type[:class:`IniFixResourceModel`]
            A subclass of :class:`IniFixResourceModel` for constructing the required data

            .. attention::
                The constructor of this subclass must at least have the same arguments and keyword arguments
                as the constructor for :class:`IniFixResourceModel`

             **Default**: :class:`IniFixResourceModel`

        iniResModelArgs: Optional[List[Any]]
            Any arguments to add onto the contructor for creating the subclass of a :class:`IniFixResourceModel` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        iniResModelKwargs: Optional[Dict[:class:`str`, Any]]
            Any keyword arguments to add onto the constructor for creating the subclass of a :class:`IniFixResourceModel` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`IniFixResourceModel`
            The data for fixing the particular resource
        """

        folderPath = self.folder
        if (getFixedFile is None):
            getFixedFile = self.getFixedBlendFile

        origResPaths = {}
        fixedResPaths = {}
        partIndex = 0

        for part in ifTemplate:
            if (isinstance(part, IfPredPart)):
                partIndex += 1
                continue

            currentOrigResPaths = []
            try:
                currentOrigResPaths = part[IniKeywords.Filename.value]
            except KeyError:
                partIndex += 1
                continue
            
            currentOrigResPaths = list(map(lambda pathData: FileService.parseOSPath(pathData[1]), currentOrigResPaths))
            origResPaths[partIndex] = currentOrigResPaths

            for modName in toFix:
                currentFixedResPaths = list(map(lambda origBlendFile: getFixedFile(origBlendFile, modName = modName), currentOrigResPaths))

                try:
                    fixedResPaths[partIndex]
                except KeyError:
                    fixedResPaths[partIndex] = {}

                fixedResPaths[partIndex][modName] = currentFixedResPaths

            partIndex += 1

        if (iniResourceModelCls == IniFixResourceModel): 
            return IniFixResourceModel(folderPath, fixedResPaths, origPaths = origResPaths)

        if (iniResModelKwargs is None):
            iniResModelKwargs = {}

        if (iniResModelArgs is None):
            iniResModelArgs = []

        return iniResourceModelCls(folderPath, fixedResPaths, *iniResModelArgs, origPaths = origResPaths, **iniResModelKwargs)
    
    def makeSrcResourceModel(self, ifTemplate: IfTemplate, iniResourceModelCls: Type[IniFixResourceModel] = IniSrcResourceModel, 
                             iniResModelArgs: Optional[List[Any]] = None, iniResModelKwargs: Optional[Dict[str, Any]] = None) -> IniSrcResourceModel:
        """
        Creates the data needed for a particular ``[Resource.*]`` `section`_ in the original .ini file

        Parameters
        ----------
        ifTemplate: :class:`IfTemplate`
            The particular `section`_ to extract data

        iniResourceModelCls: Type[:class:`IniSrcResourceModel`]
            A subclass of :class:`IniSrcResourceModel` for constructing the required data

            .. attention::
                The constructor of this subclass must at least have the same arguments and keyword arguments
                as the constructor for :class:`IniSrcResourceModel`

             **Default**: :class:`IniSrcResourceModel`

        iniResModelArgs: Optional[List[Any]]
            Any arguments to add onto the contructor for creating the subclass of a :class:`IniSrcResourceModel` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        iniResModelKwargs: Optional[Dict[:class:`str`, Any]]
            Any keyword arguments to add onto the constructor for creating the subclass of a :class:`IniSrcResourceModel` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`IniSrcResourceModel`
            The data for a particular source resource
        """

        folderPath = self.folder

        paths = {}
        partIndex = 0

        for part in ifTemplate:
            if (isinstance(part, IfPredPart)):
                partIndex += 1
                continue
           
            currentPaths = []
            try:
                currentPaths = part[IniKeywords.Filename.value]
            except KeyError:
                partIndex += 1
                continue

            currentPaths = list(map(lambda pathData: FileService.parseOSPath(pathData[1]), currentPaths))
            paths[partIndex] = currentPaths
            partIndex += 1

        if (iniResourceModelCls == IniSrcResourceModel): 
            return IniSrcResourceModel(folderPath, paths)

        if (iniResModelKwargs is None):
            iniResModelKwargs = {}

        if (iniResModelArgs is None):
            iniResModelArgs = []

        return iniResourceModelCls(folderPath, paths, *iniResModelArgs, **iniResModelKwargs)
    
    def makeTexModel(self, ifTemplate: IfTemplate, toFix: Set[str], texEditors: Union[BaseTexEditor, Dict[int, Dict[str, List[BaseTexEditor]]]], 
                     getFixedFile: Optional[Callable[[str, str], str]] = None) -> IniTexModel:
        """
        Creates the data needed for fixing a particular ``[Resource.*]`` `section`_ for some .dds texture file in the .ini file

        Parameters
        ----------
        ifTemplate: :class:`IfTemplate`
            The particular `section`_ to extract data

        toFix: Set[:class:`str`]
            The names of the mods to fix 

        texEditors: Union[:class:`BaseTexEditor`, Dict[:class:`int`, Dict[:class:`str`, List[:class:`BaseTexEditor`]]]]
            The texture editors for editting the found .dds files :raw-html:`<br />` :raw-html:`<br />`

            * If this argument is of type :class:`BaseTexEditor`, then all .dds files encountered within the parsed `section`_ will use the same texture editor
            * If this argument is a dictionary, then the structure of the dictionary follows the same structure as :attr:`IniTexModel.texEdits`

        getFixedFile: Optional[Callable[[:class:`str`, :class:`str`], :class:`str`]]
            The function for transforming the file path of a found .dds file into a new file path to the fixed .dds file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :meth:`IniFile.getFixedBlendFile` :raw-html:`<br />` :raw-html:`<br />`

            The parameters for the function are:

                # The path to the original file
                # The type of mod to fix to

            **Default**: ``None``

        Returns
        -------
        :class:`IniTexModel`
            The data for fixing the particular texture
        """
        
        # get the texture editors
        texEdits = {}
        if (isinstance(texEditors, dict)):
            texEdits = texEditors

        elif (isinstance(texEditors, BaseTexEditor)):
            partIndex = 0
            for part in ifTemplate:
                if (isinstance(part, IfPredPart)):
                    partIndex += 1
                    continue

                currentOrigResPaths = []
                try:
                    currentOrigResPaths = part[IniKeywords.Filename.value]
                except KeyError:
                    partIndex += 1
                    continue

                for modName in toFix:
                    currentEditors = list(map(lambda origTexFile: texEditors, currentOrigResPaths))

                    try:
                        texEdits[partIndex]
                    except KeyError:
                        texEdits[partIndex] = {}

                    texEdits[partIndex][modName] = currentEditors

                partIndex += 1

        return self.makeFixResourceModel(ifTemplate, toFix, getFixedFile, iniResourceModelCls = IniTexModel, iniResModelArgs = [texEdits])
    
    def makeDLModel(self, ifTemplate: IfTemplate, downloads: Union[FileDownload, Dict[int, Dict[str, List[FileDownload]]]]) -> IniDownloadModel:
        """
        Creates the data needed for a particular ``[Resource.*]`` `section`_ for some file download in the .ini file

        Parameters
        ----------
        ifTemplate: :class:`IfTemplate`
            The particular `section`_ to extract data

        downloads: Union[:class:`FileDownload`, Dict[:class:`int`, List[:class:`BaseTexEditor`]]]
            The downloaders for downloading files :raw-html:`<br />` :raw-html:`<br />`

            * If this argument is of type :class:`FileDownload`, then all files encountered within the parsed `section`_ will use the same downloaders
            * If this argument is a dictionary, then the structure of the dictionary follows the same structure as :attr:`IniDownloadModel.downloads`

        Returns
        -------
        :class:`IniDownloadModel`
            The data for downloading a particular resource
        """

        # get the file downloads
        fileDownloads = {}
        if (isinstance(downloads, dict)):
            fileDownloads = downloads

        elif (isinstance(downloads, FileDownload)):
            partIndex = 0
            for part in ifTemplate:
                if (isinstance(part, IfPredPart)):
                    partIndex += 1
                    continue

                currentOrigResPaths = []
                try:
                    currentOrigResPaths = part[IniKeywords.Filename.value]
                except KeyError:
                    partIndex += 1
                    continue

                currentDownloads = list(map(lambda origDownloadFile: downloads, currentOrigResPaths))
                fileDownloads[partIndex] = currentDownloads
                partIndex += 1

        return self.makeSrcResourceModel(ifTemplate, iniResourceModelCls = IniDownloadModel, iniResModelArgs = [fileDownloads])

    def _getSubCommands(self, ifTemplate: IfTemplate, currentSubCommands: Set[str], subCommands: Set[str], subCommandLst: List[str]):
        for partIndex in ifTemplate.calledSubCommands:
            partSubCommands = ifTemplate.calledSubCommands[partIndex]

            for subCommandData in partSubCommands:
                subCommand = subCommandData[1]
                if (subCommand not in subCommands):
                    currentSubCommands.add(subCommand)
                    subCommands.add(subCommand)
                    subCommandLst.append(subCommand)

    def _getCommandIfTemplate(self, sectionName: str, raiseException: bool = True) -> Optional[IfTemplate]:
        """
        Retrieves the :class:`IfTemplate` for a certain `section`_ from `IniFile._sectionIfTemplate`

        Parameters
        ----------
        sectionName: :class:`str`
            The name of the `section`_

        raiseException: :class:`bool`
            Whether to raise an exception when the section's :class:`IfTemplate` is not found

        Raises
        ------
        :class:`KeyError`
            If the :class:`IfTemplate` for the `section`_ is not found and ``raiseException`` is set to `True`

        Returns
        -------
        Optional[:class:`IfTemplate`]
            The corresponding :class:`IfTemplate` for the `section`_
        """
        try:
            ifTemplate = self.sectionIfTemplates[sectionName]
        except Exception as e:
            if (raiseException):
                raise KeyError(f"The section by the name '{sectionName}' does not exist") from e
            else:
                return None
        else:
            return ifTemplate

    @classmethod
    def getResources(cls, commandsGraph: IniSectionGraph, isIfTemplateResource: Callable[[IfContentPart], Any],
                     getIfTemplateResource: Callable[[IfContentPart], str], addResource: Callable[[Any, IfContentPart], Any]):
        """
        Retrieves all the referenced resources that were called by `sections`_ related to the ``[TextureOverride.*Blend.*]`` `sections`_

        Parameters
        ----------
        resources: Set[:class:`str`]
            The result for all the resource `sections`_ that were referenced

        commandsGraph: :class:`IniSectionGraph`
            The subgraph for all the `sections`_ related to the resource

        isIfTemplateResource: Callable[[:class:`IfContentPart`], :class:`bool`]
            Checks whether a part in the :class:`IfTemplate` of a `section`_ contains the key that reference the target resource

        getIfTemplateResource: Callable[[:class:`IfContentPart`], Any]
            Function to retrieve the target resource from a part in the :class:`IfTemplate` of a `section`_

        addResource: Callable[[Any, :class:`IfContentPart`], Any]
            Function to add in the result of the found resource `section`_

            :raw-html:`<br />`
            The parameter order for the function is:

            #. the retrieved resource `section`_
            #. the part in the :class:`IfTemplate` where the resource is found
        """

        sections = commandsGraph.sections
        for sectionName in sections:
            ifTemplate = sections[sectionName]

            for part in ifTemplate:
                if (isinstance(part, IfPredPart)):
                    continue

                if (isIfTemplateResource(part)):
                    resource = getIfTemplateResource(part)
                    addResource(resource, part)

    def _getCommands(self, sectionName: str, subCommands: Set[str], subCommandLst: List[str]):
        """
        Low level function for retrieving all the commands/`sections`_ that are called from a certain `section`_ in the .ini file

        Parameters
        ----------
        sectionName: :class:`str`
            The name of the `section`_ we are starting from

        subCommands: Set[:class:`str`]
            The result for all of the `sections`_ that were called

        subCommandLst: List[:class:`str`]
            The result for all of the `sections`_ that were called while maintaining the order
            the `sections`_ are called in the call stack

        Raises
        ------
        :class:`KeyError`
            If the :class:`IfTemplate` is not found for some `section`_
        """

        currentSubCommands = set()
        ifTemplate = self._getCommandIfTemplate(sectionName)

        # add in the current command if it has not been added yet
        if (sectionName not in subCommands):
            subCommands.add(sectionName)
            subCommandLst.append(sectionName)

        # get all the unvisited subcommand sections to visit
        self._getSubCommands(ifTemplate, currentSubCommands, subCommands, subCommandLst)

        # visit the children subcommands that have not been visited yet
        for sectionName in currentSubCommands:
            self._getCommands(sectionName, subCommands, subCommandLst)


    # getTargetHashAndIndexSections(notIncludeCommandNames): Retrieves the sections with target hashes and indices
    def getTargetHashAndIndexSections(self, notIncludeCommandNames: Set[str]) -> Dict[str, IfTemplate]:
        if (self._type is None and self.defaultModType is None):
            return {}
        
        type = self._type
        if (self._type is None):
            type = self.defaultModType

        result = {}
        hashes = set(type.hashes.fromAssets)
        indices = set(type.indices.fromAssets)
        
        # get the sections with the hashes/indices
        for sectionName in self.sectionIfTemplates:
            ifTemplate = self.sectionIfTemplates[sectionName]
            if (sectionName in notIncludeCommandNames):
                continue

            if (hashes.intersection(ifTemplate.hashes) or indices.intersection(ifTemplate.indices)):
                result[sectionName] = ifTemplate

        return result
    
    def _getParser(self) -> Optional[BaseIniParser]:
        """
        Retrieves the parser for parsing the .ini file

        Returns
        -------
        Optional[:class:`BaseIniParser`]
            The resultant parser
        """

        availableType = self.availableType
        if (availableType is not None and self._iniParser is None):
            self._iniParser = availableType.iniParseBuilder.build(self, modName = self.availableType.name, version = self.version)
        
        return self._iniParser


    def parse(self, flushIfTemplates: bool = True):
        """
        Parses the .ini file

        Parameters
        ----------
        flushIfTemplates: :class:`bool`
             Whether to re-parse the :class:`IfTemplates`s instead of using the saved cached values :raw-html:`<br />` :raw-html:`<br />`
             
            **Default**: ``True``
             
        Raises
        ------
        :class:`KeyError`
            If a certain resource `section`_ is not found :raw-html:`<br />` :raw-html:`<br />`
            
            (either the name of the `section`_ is not found in the .ini file or the `section`_ was skipped due to some error when parsing the `section`_)
        """

        if (not self._isClassified):
            self.classify()

        if (self.availableType is None):
            return

        self.remapBlendModels.clear()
        self.remapPositionModels.clear()
        self.texAddModels.clear()
        self.texEditModels.clear()

        self.getIfTemplates(flush = flushIfTemplates)

        parser = self._getParser()
        if (parser is not None):
            parser.clear()
        else:
            return

        parser.parse()

    # _fix(keepBackup, fixOnly, update, withBoilerPlate, withSrc): Internal function to fix the .ini file
    def _fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, hideOrig: bool = False, withBoilerPlate: bool = True, withSrc: bool = True) -> str:
        fix = ""
        fix += self._getFixStr(fix = fix, withBoilerPlate = withBoilerPlate)

        if (withBoilerPlate):
            fix = f"\n\n{fix}"
        
        if (not withSrc):
            self._isFixed = True
            return fix

        uncommentedTxt = ""
        if (hideOrig):
            uncommentedTxt = self._fileTxt
            self.hideOriginalSections()

        fix = self.injectAddition(fix, beforeOriginal = False, keepBackup = keepBackup, fixOnly = fixOnly, update = update)

        if (hideOrig and not update):
            self.fileTxt = uncommentedTxt

        self._isFixed = True
        return fix

    def fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, hideOrig: bool = False) -> Union[str, List[str]]:
        """
        Fixes the .ini file

        Parameters
        ----------
        keepBackup: :class:`bool`
            Whether we want to make a backup copy of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: `True`

        fixOnly: :class:`bool`
            Whether we are only fixing the .ini file without removing any previous changes :raw-html:`<br />` :raw-html:`<br />`

            **Default**: `False`

        update: :class:`bool`
            Whether to also update the source text of this classs with the fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        hideOrig: :class:`bool`
            Whether to hide the mod for the original character :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        Union[:class:`str`, List[:class:`str`]]
            The new content of the .ini file which includes the fix and the new content of any other newly created .ini files related to fixing the particular .ini file
        """

        fixer = self._getFixer()
        availableType = self.availableType

        if (availableType is None):
            raise NoModType()
        elif (fixer is None):
            return

        fixer.clear()
        return fixer.fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update, hideOrig = hideOrig)


class FileStats():
    """
    Keeps track of different types of files encountered by the program

    Attributes
    ----------
    fixed: Set[:class:`str`]
        The paths to the fixed files

    skipped: Dict[:class:`str`, :class:`Exception`]
        The exceptions to files paths that were skipped due to errors

    skippedByMods: DefaultDict[:class:`str`, Dict[:class:`str`, :class:`Exception`]]
        The exceptions to file paths that were skipped due to errors, grouped for each mod folder paths :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names to the mod folders
        * The inner keys are the names of the file paths
        * The inner values are the errors encountered

    removed: Set[:class:`str`]
        The file paths for files that got removed

    undoed: Set[:class:`str`]
        The file paths for files that got undoed to a previous state before the software was ran

    visitedAtRemoval: Set[:class:`str`]
        The file paths for files that got visited when attempting to remove those files
    """

    def __init__(self):
        self.fixed: Set[str] = set()
        self.skipped: Dict[str, Exception] = {}
        self.skippedByMods: DefaultDict[str, Dict[str, Exception]] = defaultdict(lambda: {})
        self.removed: Set[str] = set()
        self.undoed: Set[str] = set()
        self.visitedAtRemoval: Set[str] = set()

    def clear(self):
        """
        Clears out all saved data about the files
        """

        self.fixed.clear()
        self.skipped.clear()
        self.skippedByMods.clear()
        self.removed.clear()
        self.undoed.clear()
        self.visitedAtRemoval.clear()

    def updateFixed(self, newFixed: Set[str]):
        """
        Updates the fixed file paths

        Parameters
        ----------
        newFixed: Set[:class:`str`]
            The newly added file paths that got fixed      
        """

        self.fixed.update(newFixed)

    def addFixed(self, filePath: str):
        """
        Adds in the file path to the paths of fixed files

        Parameters
        ----------
        filePath: :class:`str`
            the new file path to a fixed file
        """
        
        self.fixed.add(filePath)

    def updateSkipped(self, newSkipped: Dict[str, Exception], modFolder: Optional[str] = None):
        """
        Updates the file paths that got skipped due to errors

        Parameters
        ----------
        newSkipped: Dict[:class:`str`, :class:`Exception`]
            The newly skipped file paths due to errors within a particular mod folder

        modFolder: Optional[:class:`str`]
            The folder where the files got skipped. If this argument is ``None``, will read the folder from
            the provided file pahts in `newSkipped`
        """

        if (modFolder is not None): 
            DictTools.update(self.skipped, newSkipped)
            if (newSkipped):
                DictTools.update(self.skippedByMods[modFolder], newSkipped)
            return
        
        for skippedFile in newSkipped:
            self.addSkipped(skippedFile, newSkipped[skippedFile], modFolder = modFolder)

    def addSkipped(self, filePath: str, error: Exception, modFolder: Optional[str] = None):
        """
        Adds a new file path to the paths of skipped files

        Parameters
        ----------
        filePath: :class:`str`
            the new file path that got skipped

        error: :class:`Exception`
            The exception that caused the file to be skipped

        modFolder: Optional[:class:`str`]
            The mod folder that contains the file path. If this argument is ``None``, will read the folder from
            the provided argument in `filePath` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (modFolder is None):
            modFolder = os.path.dirname(filePath)
        
        self.skipped[filePath] = error
        self.skippedByMods[modFolder][filePath] = error

    def updateRemoved(self, newRemoved: Set[str]):
        """
        Updates the file paths that got removed

        Parameters
        ----------
        newRemoved: Set[:class:`str`]
            The newly updated file paths that got removed
        """

        self.removed.update(newRemoved)

    def addRemoved(self, filePath: str):
        """
        Adds in a new file path that got removed

        Parameters
        ----------
        filePath: :class:`str`
            The file path that got removed
        """

        self.removed.add(filePath)

    def updateUndoed(self, newUndoed: Set[str]):
        """
        Updates the file paths that got contents undoed to a previous state before the software was ran

        Parameters
        ----------
        newRemoved: Set[:class:`str`]
            The newly updated file paths that got contents undoed to a previous state before the software was ran
        """

        self.undoed.update(newUndoed)

    def addUndoed(self, filePath: str):
        """
        Adds in a new file path that got undoeds

        Parameters
        ----------
        filePath: :class:`str`
            The file path that got undoed
        """

        self.undoed.add(filePath)

    def updateVisitedAtRemoval(self, newVisitedAtRemoval: Set[str]):
        """
        Updates the file paths that got visited when the software attempts to remove those files

        Parameters
        ----------
        newVisitedAtRemoved: Set[:class:`str`]
            The newly updated file paths that got visited when the software attempts to remove those files
        """

        self.visitedAtRemoval.update(newVisitedAtRemoval)

    def addVisitedAtRemoval(self, filePath: str):
        """
        Adds in a new file path that got visited when the software attempts to remove the file

        Parameters
        ----------
        filePath: :class:`str`
            The file path that got visited when the software attempts to remove the file
        """

        self.visitedAtRemoval.add(filePath)

    def update(self, modFolder: Optional[str] = None, newFixed: Optional[Set[str]] = None, 
               newSkipped: Optional[Dict[str, Exception]] = None, newRemoved: Optional[Set[str]] = None, 
               newUndoed: Optional[Set[str]] = None, newVisitedAtRemoval: Optional[Set[str]] = None):
        """
        Updates the overall file paths in this class

        .. note::
            See :meth:`FileStats.updateFixed`, :meth:`FileStats.updateSkipped` and :meth:`FileStats.updateRemoved` for more details

        Parameters
        ----------
        modFolder: Optional[:class:`str`]
            The folder where the files got skipped :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newFixed: Optional[Set[:class:`str`]]
            The newly updated file paths that got fixed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newSkipped: Optional[Dict[:class:`str`, :class:`Exception`]]
            The newly skipped file paths due to errors within a particular mod folder :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newRemoved: Optional[Set[:class:`str`]]
            The newly updated file paths that got removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newUndoed: Optional[Set[:class:`str`]]
             The newly updated file paths that got contents undoed to a previous state before the software was ran :raw-html:`<br />` :raw-html:`<br />`

             **Default**: ``None``

        newVisitedAtRemoved: Optional[Set[:class:`str`]]
            The newly updated file paths that got visited when the software attempts to remove those files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (newFixed is not None):
            self.updateFixed(newFixed)

        if (newSkipped is not None):
            self.updateSkipped(newSkipped, modFolder = modFolder)

        if (newRemoved is not None):
            self.updateRemoved(newRemoved)

        if (newUndoed is not None):
            self.updateUndoed(newUndoed)

        if (newVisitedAtRemoval is not None):
            self.updateVisitedAtRemoval(newVisitedAtRemoval)


class CachedFileStats(FileStats):
    """
    Attributes
    ----------
    fixed: Set[:class:`str`]
        The paths to the files retrieved during a cache miss

    hit: Set[:class:`str`]
        The paths to the files retrieved during a cache hit
    """

    def __init__(self):
        super().__init__()
        self.hit: Set[str] = set()

    def clear(self):
        super().clear()
        self.hit.clear()

    def updateHit(self, newHit: Set[str]):
        """
        Updates the file paths that have a cache hit

        Parameters
        ----------
        newHit: Set[:class:`str`]
            The new file paths that got a hit      
        """

        self.hit.update(newHit)

    def addHit(self, filePath: str):
        """
        Adds a new file path to the paths of cache hit files

        Parameters
        ----------
        filePath: :class:`str`
            the new file path to that was hit
        """
        
        self.hit.add(filePath)

    def update(self, modFolder: Optional[str] = None, newFixed: Optional[Set[str]] = None, 
               newSkipped: Optional[Dict[str, Exception]] = None, newRemoved: Optional[Set[str]] = None, 
               newUndoed: Optional[Set[str]] = None, newVisitedAtRemoval: Optional[Set[str]] = None,
               newHit: Optional[Set[str]] = None):
        super().update(modFolder = modFolder, newFixed = newFixed, newSkipped = newSkipped, 
                       newRemoved = newRemoved, newUndoed = newUndoed, newVisitedAtRemoval = newVisitedAtRemoval)

        if (newHit is not None):
            self.updateHit(newHit)


class RemapStats():
    """
    The file stats for the overall remap process at :class:`RemapService`

    Attributes
    ----------
    blend: :class:`FileStats`
        Stats about whether some Blend.buf files got fixed/skipped/removed

        .. note::
            * removed Blend.buf files refer to RemapBlend.buf files that were previously made by this software on a previous run

    position: :class:`FileStats`
        Stats about whether some Position.buf files got fixed/skipped/removed

        .. note::
            * removed Position.buf files refer to RemapPosition.buf files that were previously made by this software on a previous run

    ini: :class:`FileStats`
        Stats about whether some .ini files got fixed/skipped/undoed

        .. note::
            * The skipped .ini files may or may not have been previously fixed. A path to some .ini file in this attribute **DOES NOT** imply that the .ini file previously had a fix

    mod: :class:`FileStats`
        Stats about whether a mod has been fixed/skipped

    texAdd: :class:`FileStats`
        Stats about whether an existing texture file has been editted/removed

    texEdit: :class:`FileStats`
        Stats about whether some brand new texture file created by this software has been created/removed

    download: :class:`CachedFileStats`
        Stats about whether some downloaded mod files have been recently downloaded/removed
    """

    def __init__(self):
        self.blend = FileStats()
        self.position = FileStats()
        self.ini = FileStats()
        self.mod = FileStats()
        self.texEdit = FileStats()
        self.texAdd = FileStats()
        self.download = CachedFileStats()

    def clear(self):
        """
        Clears all the stats for the remap process
        """

        self.blend.clear()
        self.position.clear()
        self.ini.clear()
        self.mod.clear()
        self.texEdit.clear()
        self.texAdd.clear()
        self.download.clear()


class Mod(Model):
    """
    This Class inherits from :class:`Model`

    Used for handling a mod

    .. note::
        We define **a mod** based off the following criteria:

        * A folder that contains at least 1 .ini file
        * At least 1 of the .ini files in the folder contains:

            * a section with the regex ``[TextureOverride.*Blend]`` if :attr:`RemapService.readAllInis` is set to ``True`` or the script is ran with the ``--all`` flag :raw-html:`<br />`  :raw-html:`<br />` **OR** :raw-html:`<br />` :raw-html:`<br />`
            * a section that meets the criteria of one of the mod types defined :attr:`Mod._types` by running the mod types' :meth:`ModType.isType` function

        :raw-html:`<br />`
        See :class:`ModTypes` for some predefined types of mods
        
    Parameters
    ----------
    path: Optional[:class:`str`]
        The file location to the mod folder. :raw-html:`<br />` :raw-html:`<br />`
        
        If this value is set to ``None``, then will use the current directory of where this module is loaded.
        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    files: Optional[List[:class:`str`]]
        The direct children files to the mod folder (does not include files located in a folder within the mod folder). :raw-html:`<br />` :raw-html:`<br />`

        If this parameter is set to ``None``, then the class will search the files for you when the class initializes :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    logger: Optional[:class:`Logger`]
        The logger used to pretty print messages :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    types: Optional[Set[:class:`ModType`]]
        The types of mods this mod should be. :raw-html:`<br />` :raw-html:`<br />` 
        If this argument is empty or is ``None``, then all the .ini files in this mod will be parsed :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    remappedTypes: Optional[Set[:class:`ModType`]]
        The types of mods to the mods specified at :attr:`Mod._types` will be fixed to.

        .. note::
            For more details, see :attr:`RemapService.remappedTypes`

        **Default**: ``None``

    defaultType: Optional[:class:`ModType`]
        The type of mod to use if a mod has an unidentified type :raw-html:`<br />` :raw-html:`<br />`
        If this argument is ``None``, then will skip the mod with an identified type :raw-html:`<br />` :raw-html:`<br />` 

        **Default**: ``None``

    forcedType: Optional[:class:`ModType`]
        The type of mod to forcibly assume for some .ini file :raw-html:`<br />` :raw-html:`<br />` 

        **Default**: ``None``

    version: Optional[Union[:class:`str`, :class:`float`, `packaging.version.Version`_]]
        The game version we want the fixed mod :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will fix the mod to using the latest hashes/indices.

    downloadMode: :class:`DownloadMode`
        The download mode to handle file downloads :raw-html:`<br />` :raw-html:`<br />`

        .. note::
            For more information about the available download modes to specify, see :ref:`Download Modes`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: :attr:`DownloadMode.Normal`

    Attributes
    ----------
    path: Optional[:class:`str`]
        The file location to the mod folder

    version: Optional[`packaging.version.Version`_]
        The game version we want the fixed mod

    downloadMode: :class:`DownloadMode`
        The download mode to handle file downloads :raw-html:`<br />`

        .. note::
            For more information about the available download modes to specify, see :ref:`Download Modes`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: :attr:`DownloadMode.SoftTexDriven`

    _files: List[:class:`str`]
        The direct children files to the mod folder (does not include files located in a folder within the mod folder).

    _types: Set[:class:`ModType`]
        The types of mods this mod should be

    _remappedType: Set[:class:`str`]
        The types of mods to the mods specified at :attr:`Mod.types` will be fixed to.

        .. note::
            For more details, see :attr:`RemapService.remappedTypes`

    _defaultType: Optional[:class:`ModType`]
        The type of mod to use if a mod has an unidentified type

    _forcedType: Optional[:class:`ModType`]
        The type of mod to forcibly assume for some .ini file

    logger: Optional[:class:`Logger`]
        The logger used to pretty print messages

    inis: Dict[:class:`str`, :class:`IniFile`]
        The .ini files found for the mod :raw-html:`<br />` :raw-html:`<br />`

        The keys are the file paths to the .ini file

    remapBlend: List[:class:`str`]
        The RemapBlend.buf files found for the mod

    backupInis: List[:class:`str`]
        The RemapBKUP.txt files found for the mod

    remapCopies: Dict[:class:`str`, :class:`IniFile`]
        The *remapFix*.ini files found for the mod

        The keys are the file paths to the .ini file

    remapTextures: List[:class:`str`]
        The *remapFix*.dds files found for the mod
    """
    def __init__(self, path: Optional[str] = None, files: Optional[List[str]] = None, logger: Optional[Logger] = None, types: Optional[Set[ModType]] = None, 
                 forcedType: Optional[ModType] = None, defaultType: Optional[ModType] = None, version: Optional[Union[str, float, VersionType]] = None, remappedTypes: Optional[Set[str]] = None,
                 downloadMode: DownloadMode = DownloadMode.HardTexDriven):
        super().__init__(logger = logger)
        self.path = FileService.getPath(path)
        self.version = Version.getVersion(version)
        self.downloadMode = downloadMode
        self._files = files

        if (types is None):
            types = set()
        if (remappedTypes is None):
            remappedTypes = set()

        self._types = types
        self._remappedTypes = remappedTypes
        self._defaultType = defaultType
        self._forcedType = forcedType

        self._optFileClassifier = GlobalClassifiers.ModOptFiles.value

        self.inis = []
        self.remapBlend = []
        self.backupInis = []
        self.remapCopies = []
        self.groupedRemapCopies = {}
        self._setupFiles()

    @property
    def files(self):
        """
        The direct children files to the mod folder (does not include files located in a folder within the mod folder).

        :getter: Returns the files to the mod
        :setter: Sets up the files for the mod
        :type: Optional[List[:class:`str`]]
        """

        return self._files

    @files.setter
    def files(self, newFiles: Optional[List[str]] = None):
        self._files = newFiles
        self._setupFiles()

    def createIniFile(self, iniPath: str) -> IniFile:
        """
        Creates a new .ini file given the file path

        Parameters
        ----------
        iniPath: :class:`str`
            The file path to the .ini file

        Returns
        -------
        :class:`IniFile`
            The new object representing the .ini file
        """

        return IniFile(iniPath, logger = self.logger, modTypes = self._types, defaultModType = self._defaultType, 
                       forcedModType = self._forcedType, version = self.version, modsToFix = self._remappedTypes, downloadMode = self.downloadMode)
    
    def getOrigIniPath(self, remapCopyPath: str) -> str:
        """
        Retrieves the file path to the original .ini file for some RemapFix.ini file

        Parameters
        ----------
        remapCopyPath: :class:`str`
            The file path to the RemapFix.ini file

        Returns
        -------
        :class:`str`
            The file path to the corresponding .ini file
        """

        folder = os.path.dirname(remapCopyPath)
        basename = os.path.basename(remapCopyPath)

        remapCopyBaseParts = basename.rsplit(FileSuffixes.RemapFixCopy.value, 1)
        remapCopyBasePartsLen = len(remapCopyBaseParts)

        if (remapCopyBasePartsLen == 1):
            return os.path.join(folder, remapCopyBaseParts[0])
        
        ext = remapCopyBaseParts[-1]
        extPos = ext.find(".")
        if (extPos > 0):
            remapCopyBaseParts[-1] = ext[extPos:]

        basename = "".join(remapCopyBaseParts)
        return os.path.join(folder, basename)

    def _setupFiles(self):
        """
        Searches the direct children files to the mod folder if :attr:`Mod.files` is set to ``None``        
        """

        if (self._files is None):
            self._files = FileService.getFiles(path = self.path)

        self.inis, self.backupInis, self.remapCopies = self.getOptionalFiles()

        iniPaths = self.inis
        self.inis = {}
        for iniPath in iniPaths:
            iniFile = self.createIniFile(iniPath)
            self.inis[iniPath] = iniFile

        iniPaths = self.remapCopies
        self.remapCopies = {}
        for iniPath in iniPaths:
            iniFile = self.createIniFile(iniPath)
            self.remapCopies[iniPath] = iniFile

            origIniFile = self.getOrigIniPath(iniPath)

            remapCopies = self.groupedRemapCopies.get(origIniFile)
            if (remapCopies is None):
                remapCopies = []
                self.groupedRemapCopies[origIniFile] = remapCopies

            remapCopies.append(iniPath)

    @classmethod
    def isIni(cls, file: str) -> bool:
        """
        Determines whether the file is a .ini file which is the file used to control how a mod behaves

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a .ini file
        """

        return file.endswith(FileExt.Ini.value)
    
    @classmethod
    def isSrcIni(cls, file: str) -> bool:
        """
        Determines whether the file is a .ini file that is not created by this fix

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a .ini file not created by this fix
        """

        fileBaseName = os.path.basename(file)
        return (cls.isIni(file) and fileBaseName.find(FileSuffixes.RemapFixCopy.value) == -1)
    
    @classmethod
    def isRemapBlend(cls, file: str) -> bool:
        """
        Determines whether the file is a RemapBlend.buf file which is the fixed Blend.buf file created by this fix

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a RemapBlend.buf file
        """

        baseName = os.path.basename(file)
        if (not baseName.endswith(FileExt.Buf.value)):
            return False

        baseName = baseName.rsplit(".", 1)[0]
        baseNameParts = baseName.rsplit("RemapBlend", 1)

        return (len(baseNameParts) > 1)
    
    @classmethod
    def isBlend(cls, file: str) -> bool:
        """
        Determines whether the file is a Blend.buf file which is the original blend file provided in the mod

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a Blend.buf file
        """

        return bool(file.endswith(FileTypes.Blend.value) and not cls.isRemapBlend(file))
   
    @classmethod
    def isBackupIni(cls, file: str) -> bool:
        """
        Determines whether the file is a RemapBKUP.txt file that is used to make
        backup copies of .ini files

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a RemapBKUP.txt file
        """

        fileBaseName = os.path.basename(file)
        return (fileBaseName.startswith(FilePrefixes.BackupFilePrefix.value) or fileBaseName.startswith(FilePrefixes.OldBackupFilePrefixV3.value) or fileBaseName.startswith(FilePrefixes.OldBackupFilePrefixV4_3.value)) and file.endswith(FileExt.Txt.value)
    
    @classmethod
    def isRemapCopyIni(cls, file: str) -> bool:
        """
        Determines whether the file is *RemapFix*.ini file which are .ini files generated by this fix to remap specific type of mods :raw-html:`<br />` :raw-html:`<br />`

        *eg. mods such as Keqing or Jean that are fixed by :class:`GIMIObjMergeFixer` *

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a *RemapFix*.ini file
        """

        fileBaseName = os.path.basename(file)
        return (cls.isIni(file) and fileBaseName.rfind(FileSuffixes.RemapFixCopy.value) > -1)
    
    @classmethod
    def isRemapTexture(cls, file: str) -> bool:
        """
        Determines whether the file is a *RemapTex*.dds file which are texture .dds files generated by this fix to edit a particular texture file for some specific type of mods :raw-html:`<br />` :raw-html:`<br />`

        *eg. mods such as Kirara or Nilou that are fixed by :class:`GIMIRegEditFixer` *

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a *RemapTex*.dds file
        """

        return bool(file.endswith(FileTypes.RemapTexture.value)) 

    def getOptionalFiles(self) -> List[List[str]]:
        """
        Retrieves a list of each type of files that are not mandatory for the mod

        Returns
        -------
        [ List[:class:`str`], List[:class:`str`], List[:class:`str`]]
            The resultant files found for the following file categories (listed in the same order as the return type):

            #. .ini files not created by this fix
            #. RemapBKUP.txt files
            #. RemapFix.ini files

            .. note::
                See :meth:`Mod.isIni`, :meth:`Mod.isBackupIni`, :meth:`Mod.isRemapCopyIni` for the specifics of each type of file
        """

        resultIni = []
        resultBackup = []
        resultCopy = []

        if (not self._optFileClassifier.isSetup):
            self._optFileClassifier.setup({FileExt.Ini.value: "isIni", 
                                           FileExt.Txt.value: "isTxt", 
                                           FilePrefixes.BackupFilePrefix.value: "isBackup", 
                                           FilePrefixes.OldBackupFilePrefixV3.value: "isBackup",
                                           FilePrefixes.OldBackupFilePrefixV4_3.value: "isBackup",
                                           FileSuffixes.RemapFixCopy.value: "isCopy"})
            
        backupFilePrefixes = {FilePrefixes.BackupFilePrefix.value, FilePrefixes.OldBackupFilePrefixV3.value, FilePrefixes.OldBackupFilePrefixV4_3.value}
            
        for file in self._files:
            basename = os.path.basename(file)
            basenameLen = len(basename)

            searchResult = self._optFileClassifier.dfa.findAll(basename)
            if (not searchResult):
                continue

            searchResultLen = len(searchResult)
            extKey = None

            if (FileExt.Ini.value in searchResult):
                extKey = FileExt.Ini.value
            elif (FileExt.Txt.value in searchResult):
                extKey = FileExt.Txt.value

            if (extKey is None or searchResult[extKey][-1][1] != basenameLen):
                continue

            if (searchResultLen == 1 and extKey == FileExt.Ini.value):
                resultIni.append(file)

            if (searchResultLen == 1):
                continue

            foundBackupFilePrefixes = backupFilePrefixes.intersection(set(searchResult.keys()))

            if (foundBackupFilePrefixes):
                resultBackup.append(file)
            elif (FileSuffixes.RemapFixCopy.value in searchResult):
                resultCopy.append(file)

        return [resultIni, resultBackup, resultCopy]
    
    # _removeFileType(fileTypeAtt, logFunc): Removes all the files for a particular file type for the mod
    def _removeFileType(self, fileTypeAtt: str, logFunc: Callable[[str], str]):
        files = getattr(self, fileTypeAtt)

        for file in files:
            logTxt = logFunc(file)
            self.print("log", logTxt)
            try:
                os.remove(file)
            except FileNotFoundError:
                pass
    
    def removeBackupInis(self):
        """
        Removes all RemapBKUP.txt contained in the mod
        """

        self._removeFileType("backupInis", lambda file: f"Removing the backup ini, {os.path.basename(file)}")

    def _removeIniResources(self, ini: IniFile, result: Set[str], resourceName: str, resourceStats: FileStats, getPathsToRemove: Callable[[IniFile], List[str]]) -> bool:
        """
        Removes a particular type of resource from a .ini file

        Parameters
        ----------
        ini: :class:`IniFile`
            The particular .ini file to be processed

        result: Set[:class:`str`]
            The resultant paths to the resources that got removed

        resourceName: :class:`str`
            The name of the type of resource

        resourceStats: :class:`FileStats`
            The associated statistical data for the resource type

        getPathsToRemove: Callable[[:class:`IniFile`], List[:class:`str`]]
            The function to file paths to remove for a particular type of resource

        Returns
        -------
        :class:`bool`
            Whether there was a file that was attempted to be removed
        """

        paths = getPathsToRemove(ini)
        hasRemovedResource = False

        for path in paths:
            if (path not in resourceStats.fixed and path not in resourceStats.visitedAtRemoval):
                try:
                    os.remove(path)
                except FileNotFoundError as e:
                    self.print("log", f"No Previous {resourceName} found at {path}")
                else:
                    self.print("log", f"Removing previous {resourceName} at {path}")
                    result.add(path)
                
                resourceStats.addVisitedAtRemoval(path)

                if (not hasRemovedResource):
                    hasRemovedResource = True

        return hasRemovedResource

    def _getIniFixResourceFixPaths(self, iniFixResources: List[IniFixResourceModel]) -> List[str]:
        result = set()
        for model in iniFixResources:
            for fixedPath, fixedFullPath, origPath, origFullPath in model:
                result.add(fixedFullPath)

        return list(result)
    
    def _getIniSrcResourcePaths(self, iniSrcResources: List[IniSrcResourceModel]) -> List[str]:
        result = set()
        for model in iniSrcResources:
            for path, fullPath in model:
                result.add(fullPath)

        return list(result)
    
    def _removeIniFix(self, ini: IniFile, remapStats: RemapStats, removedRemapBlends: Set[str], removedRemapPositions: Set[str], 
                      removedTextures: Set[str], removedDownloads: Set[str], undoedInis: Set[str],
                      keepBackups: bool = True, fixOnly: bool = False, readAllInis: bool = False, writeBackInis: bool = True) -> bool:
        iniFilesUndoed = False
        iniFullPath = None
        iniHasErrors = False
        iniStats = remapStats.ini

        if (ini.file is not None):
            iniFullPath = FileService.absPathOfRelPath(ini.file, self.path)

        # remove the fix from the .ini files
        if (iniFullPath is None or (iniFullPath not in iniStats.fixed and iniFullPath not in iniStats.skipped and (ini.isModIni or readAllInis))):
            try:
                ini.removeFix(keepBackups = keepBackups, fixOnly = fixOnly, parse = True, writeBack = writeBackInis)
            except Exception as e:
                iniStats.addSkipped(iniFullPath, e, modFolder = self.path)
                iniHasErrors = True
                self.print("handleException", e)

            if (not iniHasErrors and iniFullPath is not None):
                undoedInis.add(iniFullPath)

            if (not iniFilesUndoed):
                iniFilesUndoed = True

        # remove only the remap blends that have not been recently created
        self._removeIniResources(ini, removedRemapBlends, FileTypes.RemapBlend.value, remapStats.blend, lambda iniFile: self._getIniFixResourceFixPaths(list(iniFile.remapBlendModels.values())))

        # remove only the remap positions that have not been recently created
        self._removeIniResources(ini, removedRemapPositions, FileTypes.Position.value, remapStats.position, lambda iniFile: self._getIniFixResourceFixPaths(list(iniFile.remapPositionModels.values())))

        # remove only the remap texture files that have not been recently created
        self._removeIniResources(ini, removedTextures, FileTypes.RemapTexture.value, remapStats.texAdd, lambda iniFile: self._getIniFixResourceFixPaths(iniFile.getTexAddModels()))

        # remove only the download files that have not been recently created
        downloadsRemoved = self._removeIniResources(ini, removedDownloads, FileTypes.RemapDownload.value, remapStats.download, lambda iniFile: self._getIniSrcResourcePaths(list(iniFile.fileDownloadModels.values())))
        if (downloadsRemoved):
            self.print("space")

        return iniFilesUndoed

    def removeFix(self, remapStats: RemapStats, keepBackups: bool = True, fixOnly: bool = False, readAllInis: bool = False, writeBackInis: bool = True) -> List[Set[str]]:
        """
        Removes any previous changes done by this module's fix

        Parameters
        ----------
        remapStats: :class:`RemapStats`
            The stats for the remap process

        keepBackups: :class:`bool`
            Whether to create or keep RemapBKUP.txt files in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether to not undo any changes created in the .ini files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        readAllInis: :class:`bool`
            Whether to remove the .ini fix from all the .ini files encountered :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        writeBackInis: :class:`bool`
            Whether to write back the changes to the .ini files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        [Set[:class:`str`], Set[:class:`str`], Set[:class:`str`], Set[:class:`str`], Set[:class:`str`]]
            The removed files that have their fix removed, where the types of files for the return value is based on the list below:

            #. .ini files with their fix removed
            #. RemapBlend.buf files that got deleted
            #. RemapPosition.buf files that got deleted
            #. RemapTex.dds files that got deleted
            #. Download files that got deleted
        """

        removedRemapBlends = set()
        removedRemapPositions = set()
        removedTextures = set()
        removedDownloads = set()
        undoedInis = set()
        undoedRemapCopies = set()

        for iniPath in self.inis:
            ini = self.inis[iniPath]

            iniFileUndoed = self._removeIniFix(ini, remapStats, removedRemapBlends, removedRemapPositions, removedTextures, removedDownloads, undoedInis,
                                               keepBackups = keepBackups, fixOnly = fixOnly, readAllInis = readAllInis, writeBackInis = writeBackInis)
            
            if (not iniFileUndoed or iniPath not in self.groupedRemapCopies):
                continue
            
            # remove the remap copies associated to the .ini file
            remapCopiesRemoved = False
            for remapCopyPath in self.groupedRemapCopies[iniPath]:
                remapCopy = self.remapCopies[remapCopyPath]
                remapCopy.classify()

                self._removeIniFix(remapCopy, remapStats, removedRemapBlends, removedRemapPositions, removedTextures, removedDownloads, undoedRemapCopies,
                                   keepBackups = False, fixOnly = fixOnly, readAllInis = readAllInis, writeBackInis = writeBackInis)

                if (remapCopy.file is None):
                    continue

                try:
                    os.remove(remapCopy.file)
                except FileNotFoundError:
                    pass
                else:
                    self.print("log", f"Removing the .ini remap copy, {os.path.basename(remapCopy.file)}")
                    
                    if (not remapCopiesRemoved):
                        remapCopiesRemoved = True

            if (remapCopiesRemoved):
                self.print("space")

        return [undoedInis, removedRemapBlends, removedRemapPositions, removedTextures, removedDownloads]

    @classmethod
    def blendCorrection(cls, blendFile: Union[str, bytes], modType: ModType, modToFix: str, 
                        fixedBlendFile: Optional[str] = None, version: Optional[Union[str, float, VersionType]] = None,
                        remapMissingIndices: bool = True) -> Union[Optional[str], bytearray]:
        """
        Fixes a Blend.buf file

        See :meth:`BlendFile.remap` for more info

        Parameters
        ----------
        blendFile: Union[:class:`str`, :class:`bytes`]
            The file path to the Blend.buf file to fix

        modType: :class:`ModType`
            The type of mod to fix from

        modToFix: :class:`str`
            The name of the mod to fix to

        fixedBlendFile: Optional[:class:`str`]
            The file path for the fixed Blend.buf file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        version: Optional[Union[:class:`str`, :class:`float`, :class:`VersionType`]]
            The game version to fix to :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will fix to the latest game version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        remapMissingIndices: :class:`bool`
            Whether to deactivate any missing blend indices that cannot be identified :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Raises
        ------
        :class:`BufFileNotRecognized`
            If the original Blend.buf file provided by the parameter ``blendFile`` cannot be read

        :class:`BadBufData`
            If the bytes passed into this function do not correspond to the format defined for a Blend.buf file

        Returns
        -------
        Union[Optional[:class:`str`], :class:`bytearray`]
            If the argument ``fixedBlendFile`` is ``None``, then will return an array of bytes for the fixed Blend.buf file :raw-html:`<br />` :raw-html:`<br />`
            Otherwise will return the filename to the fixed RemapBlend.buf file if the provided Blend.buf file got corrected
        """

        blend = BlendFile(blendFile)
        vgRemap = modType.getVGRemap(modToFix, version = version)
        return blend.remap(vgRemap = vgRemap, fixedBlendFile = fixedBlendFile, remapMissingIndices = remapMissingIndices)
    
    @classmethod
    def positionCorrection(cls, positionFile: Union[str, bytes], modType: ModType, modToFix: str,
                           fixedPositionFile: Optional[str] = None, version: Optional[Union[str, float, VersionType]] = None) -> Union[Optional[str], bytearray]:
        """
        Fixes a Position.buf file

        Parameters
        ----------
        positionFile: Union[:class:`str`, :class:`bytes`]
            The file path to the Position.buf file to fix

        modType: :class:`ModType`
            The type of mod to fix from

        modToFix: :class:`str`
            The name of the mod to fix to

        fixedPositionFile: Optional[:class:`str`]
            The file path for the fixed Position.buf file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        version: Optional[Union[:class:`str`, :class:`float`, :class:`VersionType`]]
            The game version to fix to :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will fix to the latest game version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Raises
        ------
        :class:`BufFileNotRecognized`
            If the original Position.buf file provided by the parameter ``positionFile`` cannot be read

        :class:`BadBufData`
            If the bytes passed into this function do not correspond to the format defined for a Position.buf file

        Returns
        -------
        Union[Optional[:class:`str`], :class:`bytearray`]
            If the argument ``fixedPositionFile`` is ``None``, then will return an array of bytes for the fixed Position.buf file :raw-html:`<br />` :raw-html:`<br />`
            Otherwise will return the filename to the fixed RemapPosition.buf file if the provided Position.buf file got corrected
        """

        
        position = PositionFile(positionFile)
        positionEditor = modType.getPositionEditor(modToFix, version = version)
        return positionEditor.fix(position, fixedBufFile = fixedPositionFile)
    
    @classmethod
    def _texCorrection(cls, fixedTexFile: str, modToFix: str, model: IniTexModel, partInd: int, pathInd: int, texFile: Optional[str] = None) -> str:
        texEditor = model.texEdits[partInd][modToFix][pathInd]
        if (texFile is None):
            texFile = fixedTexFile

        result = cls.texCorrection(fixedTexFile, texEditor, texFile = texFile)
        if (result is None):
            raise FileNotFoundError(f"Cannot find texture file at {texFile}")
        
        return result
    
    @classmethod
    def texCorrection(cls, fixedTexFile: str, texEditor: BaseTexEditor, texFile: Optional[str] = None) -> Optional[str]:
        """
        Fixes a .dds file

        Parameters
        ----------
        fixedTexFile: :class:`str`
            The name of the file path to the fixed RemapTex.dds file

        texEditor: :class:`BaseTexEditor`
            The texture editor to change the texture file

        texFile Optional[:class:`str`]
            The file path to the original texture .dds file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use 'fixedTexFile' as the original file path to the texture .dds file 
            (usually this case for creating a brand new .dds file by also passing in object of type :class:`TexCreator` into the 'texEditor' argument) :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Optional[:class:`str`]
            The file path to the fixed texture, if the original texture exists
        """
        if (texFile is None):
            texFile = fixedTexFile

        tex = TextureFile(texFile)
        texEditor.fix(tex, fixedTexFile)

        if (tex.img is None):
            return None
        return fixedTexFile

    def _downloadFile(self, downloadPath: str, model: IniDownloadModel, partInd: int, pathInd: int, downloadStats: CachedFileStats, proxy: Optional[str] = None) -> str:
        download = model.downloads[partInd][pathInd]
        downloadFolder = os.path.dirname(downloadPath)

        rawDownloadFullPath, downloaded, downloadExisted =  download.get(downloadFolder, proxy = proxy)

        if (downloadPath != rawDownloadFullPath):
            shutil.move(rawDownloadFullPath, downloadPath)

        if (downloaded):
            downloadStats.addFixed(downloadPath)
            self.print("log", f"Download successful at {downloadPath}")
        else:
            downloadStats.addHit(downloadPath)
            self.print("log", f"Copied previous download to {downloadPath}")

    def correctResource(self, resourceStats: FileStats, getResourceModels: Callable[[IniFile], List[IniFixResourceModel]], 
                        correctFile: Callable[[str, str, ModType, str, int, int, int, IniFixResourceModel, FileStats], str], 
                        iniPaths: Optional[List[str]] = None, fileTypeName: str = "", 
                        needsSrcFile: bool = True, fixOnly: bool = False,
                        newTranslations: Optional[Dict[str, Callable[[List[str]], Any]]] = None) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Fixes all the files for a particular type of resource referenced by the mod

        Requires all the .ini files in the mod to have ran their :meth:`IniFile.parse` function

        Parameters
        ----------
        resourceStats: :class:`FileStats`
            The stats to keep track of whether the particular resource has been fixed or skipped

        getResourceModels: Callable[[:class:`IniFile`], List[:class:`IniFixResourceModel`]]
            Function to retrieve all of the needed :class:`IniFixResourceModel` from some .ini file

        correctFile: Callable[[:class:`str`, :class:`str`, :class:`ModType`, :class:`str`, :class:`int`, :class:`int`, :class:`int`, :class:`IniFixResourceModel`, :class:`FileStats`], :class:`str`]
            Function to fix up the resource file :raw-html:`<br />` :raw-html:`<br />`

            The parameters for the function are as follows:

            #. The full file path to the original resource
            #. The fixed file path to the resource
            #. The type of mod being fixed within the .ini file
            #. The name of the mod to fix to
            #. The index of the part within the :class:`IfTemplate`
            #. The index of the path within the particular part of the :class:`IfTemplate`
            #. The version of the game to fix to
            #. The current :class:`IniFixResourceModel` being processed
            #. The stats for the particular resource

            :raw-html:`<br />` :raw-html:`<br />`

            The function returns a :class:`str` with the fixed file path to the resource

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have their resources corrected. If this value is ``None``, then will correct all the .ini file in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fileTypeName: :class:`str`
            The name of the file resource

        fixOnly: :class:`bool`
            Whether to not correct some resource file if its corresponding fixed resource file already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        newTranslations: Optional[Dict[:class:`str`, Callable[[...], Any]]]
            Event handlers to print output based on some event. :raw-html:`<br />` :raw-html:`<br />`

            The keys are the names of the events and the values are the handlers.

            The argument supports the following event handlers:

            .. list-table::
                :widths: 20 40 40
                :header-rows: 1

                * - Event Name
                  - Parameters
                  - Description
                * - **missingOrig**
                  - | origFullPath: :class:`str`
                    |   The full path to the source file to fix
                  - When the source file to fix is not found
                * - **origAlreadyError**
                  - | origFullPath: :class:`str`
                    |   The full path to the source file to fix
                  - When the source file to fix had already encountered an error
                * - **fixedAlreadyFixed**
                  - | fixedFullPath: :class:`str`
                    |   The full path to the fixed file
                  - When the file to fix has already been fixed
                * - **fixedAlreadyExists**
                  - | fixedFullPath: :class:`str`
                    |   The full path to the fixed file
                  - When the file to fix has already encountered an error
                * - **noCorrectionNeeded**
                  - | origFullPath: :class:`str`
                    |   The full path to the source file to fix               
                  - When no correction is needed to be done
                * - **correctionDone**
                  - | fixedFullPath: :class:`str`
                    |   The full path to the fixed file
                  - When the correction has been done to the fixed file
                * - **onIniFirstCorrection**
                  - | fixedFullPath: :class:`str`
                    |   The full path to the fixed file
                  - When handling the first file for a particular .ini file
                * - **handleError**
                  - | error: :class:`Exception`
                    |   The error that occured when trying to fix some resource
                  - When an error occurs during the correction of a file
                * - **iniSpace**
                  - | iniPath: :class:`str`
                    |   The path to the .ini file
                  - When printing out a seperator between .ini files

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the fixed resource files that were fixed
            #. The exceptions encountered when trying to fix some fixed resource files :raw-html:`<br />` :raw-html:`<br />`

               The keys are absolute filepath to the fixed resource file and the values are the exception encountered
        """

        if (newTranslations is None):
            newTranslations = {}

        translations =  {"missingOrig": lambda fixedFullPath: self.print("log", f"Missing Original {fileTypeName} for the {fileTypeName} file at {fixedFullPath}"),
                         "origAlreadyError": lambda origFullPath: self.print("log", f"{fileTypeName} has already previously encountered an error at {origFullPath}"),
                         "fixedAlreadyFixed": lambda fixedFullPath: self.print("log", f"{fileTypeName} has already been corrected at {fixedFullPath}"),
                         "fixedAlreadyError": lambda fixedFullPath: self.print("log", f"{fileTypeName} has already previously encountered an error at {fixedFullPath}"),
                         "fixedAlreadyExists": lambda fixedFullPath: self.print("log", f"{fileTypeName} was previously fixed at {fixedFullPath}"),
                         "noCorrectionNeeded": lambda origFullPath: self.print("log", f"{fileTypeName} does not need to be corrected at {origFullPath}"),
                         "correctionDone": lambda fixedFullPath: self.print("log", f'{fileTypeName} correction done at {fixedFullPath}'),
                         "onIniFirstCorrection": lambda iniPath: self.print("log", f"Fixing the {fileTypeName} files for {os.path.basename(iniPath)}..."),
                         "handleError": lambda error: self.print("handleException", error),
                         "iniSpace": lambda iniPath: self.print("space")}
        
        translations.update(newTranslations)

        currentBlendsSkipped = {}
        currentBlendsFixed = set()
        fileTypeName = "file" if (fileTypeName == "") else f"{fileTypeName} file"
        correctionDone = False

        if (iniPaths is None):
            iniPaths = list(self.inis.keys())
        else:
            iniPaths = ListTools.getDistinct(iniPaths, keepOrder = True)

        iniPathsLen = len(iniPaths)
        for iniInd in range(iniPathsLen):
            iniPath = iniPaths[iniInd]
            ini = None
            try:
                ini = self.inis[iniPath]
            except KeyError:
                continue

            if (ini is None):
                continue
            
            modType = ini.availableType
            if (modType is None):
                continue

            resourceModels = getResourceModels(ini)
            iniLogged = False

            for model in resourceModels:
                for partIndex, partFullPaths in model.fullPaths.items():
                    for modName, fixedFullPaths in partFullPaths.items():

                        fixedFullPathsLen = len(fixedFullPaths)
                        for i in range(fixedFullPathsLen):
                            fixedFullPath = fixedFullPaths[i]
                            origFullPath = None

                            if (needsSrcFile):
                                try:
                                    origFullPath = model.origFullPaths[partIndex][i]
                                except KeyError:
                                    if (not correctionDone):
                                        translations["onIniFirstCorrection"](iniPath)
                                        correctionDone = True

                                    translations["missingOrig"](fixedFullPath)
                                    iniLogged = True

                                    if (fixedFullPath not in resourceStats.skipped):
                                        error = RemapMissingBlendFile(fixedFullPath)
                                        currentBlendsSkipped[fixedFullPath] = error
                                        resourceStats.addSkipped(fixedFullPath, error, modFolder = self.path)
                                    break

                            # check if the file was already encountered and did not need to be fixed
                            if (origFullPath is not None and origFullPath in resourceStats.fixed):
                                break

                            if (not correctionDone):
                                translations["onIniFirstCorrection"](iniPath)
                                correctionDone = True

                            if (not iniLogged):
                                iniLogged = True
                            
                            # check if the file that did not need to be fixed already had encountered an error
                            if (origFullPath is not None and origFullPath in resourceStats.skipped):
                                translations["origAlreadyError"](origFullPath)
                                break
                            
                            # check if the file has been fixed
                            if (fixedFullPath in resourceStats.fixed):
                                translations["fixedAlreadyFixed"](fixedFullPath)
                                continue

                            # check if the file already had encountered an error
                            if (fixedFullPath in resourceStats.skipped):
                                translations["fixedAlreadyError"](fixedFullPath)
                                continue

                            # check if the fixed file already exists and we only want to fix mods without removing their previous fixes
                            if (fixOnly and os.path.isfile(fixedFullPath)):
                                translations["fixedAlreadyExists"](fixedFullPath)
                                continue
                            
                            # fix the file resource
                            correctedResourcePath = None
                            try:
                                correctedResourcePath = correctFile(origFullPath, fixedFullPath, modType, modName, partIndex, i, self.version, model, resourceStats)
                            except Exception as e:
                                currentBlendsSkipped[fixedFullPath] = e
                                resourceStats.addSkipped(fixedFullPath, e, modFolder = self.path)
                                translations["handleError"](e)
                            else:
                                pathToAdd = ""
                                if (correctedResourcePath is None):
                                    translations["noCorrectionNeeded"](origFullPath)
                                    pathToAdd = origFullPath
                                else:
                                    translations["correctionDone"](fixedFullPath)
                                    pathToAdd = fixedFullPath

                                currentBlendsFixed.add(pathToAdd)
                                resourceStats.addFixed(pathToAdd)

            if (iniLogged and iniInd < iniPathsLen - 1):
                translations["iniSpace"](iniPath)

        return [currentBlendsFixed, currentBlendsSkipped]
    
    def handleSrcFiles(self, resourceStats: FileStats, getResourceModels: Callable[[IniFile], List[IniSrcResourceModel]], 
                       handleFile: Callable[[str, str, ModType, str, int, int, int, IniFixResourceModel, FileStats], str],
                       iniPaths: Optional[List[str]] = None, fileTypeName: str = "", 
                       fixOnly: bool = False,
                       newTranslations: Optional[Dict[str, Callable[[List[str]], Any]]] = None) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Downloads the required files for the mod

        Parameters
        ----------
        resourceStats: :class:`FileStats`
            The stats to keep track of a particular resource

        getResourceModels: Callable[[:class:`IniFile`], List[:class:`IniSrcResourceModel`]]
            Function to retrieve all of the needed :class:`IniSrcResourceModel` from some .ini file

        handleFile: Callable[[:class:`str`, :class:`ModType`, :class:`int`, :class:`int`, :class:`int`, :class:`IniFixResourceModel`, :class:`FileStats`], :class:`str`]
            Function to handle the resource file :raw-html:`<br />` :raw-html:`<br />`

            The parameters for the function are as follows:

            #. The full file path to the resource
            #. The type of mod being fixed within the .ini files
            #. The index of the part within the :class:`IfTemplate`
            #. The index of the path within the particular part of the :class:`IfTemplate`
            #. The version of the game to fix to
            #. The current :class:`IniSrcResourceModel` being processed
            #. The stats for the particular resource

            :raw-html:`<br />` :raw-html:`<br />`

            The function returns a :class:`str` with the fixed file path to the resource

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have files downloaded. If this value is ``None``, then will download files from all the .ini file in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fileTypeName: :class:`str`
            The name of the file resource

        fixOnly: :class:`bool`
            Whether to not correct some resource file if its corresponding fixed resource file already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        newTranslations: Optional[Dict[:class:`str`, Callable[[...], Any]]]
            Event handlers to print output based on some event. :raw-html:`<br />` :raw-html:`<br />`

            The keys are the names of the events and the values are the handlers.

            The argument supports the following event handlers:

            .. list-table::
                :widths: 20 40 40
                :header-rows: 1

                * - Event Name
                  - Parameters
                  - Description
                * - **alreadyHandled**
                  - | fullPath: :class:`str`
                    |   The full path to the file to handle
                  - When some file has already been handled
                * - **alreadyError**
                  - | fullPath: :class:`str`
                    |   The full path to the file to handle
                  - When some file already encountered an error
                * - **alreadyExists**
                  - | fullPath: :class:`str`
                    |   The full path to the file to handle
                  - When some file already exists
                * - **handled**
                  - | fullPath: :class:`str`
                    |   The full path to the file to handle
                  - When some file has already been handled
                * - **skipped**
                  - | fullPath: :class:`str`
                    |   The full path to the file to handle
                  - When skipping the handling of some file
                * - **correctionDone**
                  - | fullPath: :class:`str`
                    |   The full path to the file to handle
                  - When the correction has been done to the fixed file
                * - **onIniFirstCorrection**
                  - | fullPath: :class:`str`
                    |   The full path to the file to handle
                  - When handling the first file for a particular .ini file
                * - **handleError**
                  - | error: :class:`Exception`
                    |   The error that occured when trying to fix some resource
                  - When an error occurs during the correction of a file
                * - **iniSpace**
                  - | iniPath: :class:`str`
                    |   The path to the .ini file
                  - When printing out a seperator between .ini files

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the files that were handled
            #. The exceptions encountered when trying to handle some file :raw-html:`<br />` :raw-html:`<br />`

               The keys are expected absolute filepath to the downloaded file and the values are the exception encountered
        """

        if (newTranslations is None):
            newTranslations = {}

        translations =  {"alreadyHandled": lambda fullPath: self.print("log", f"{fileTypeName} has already been handled at {fullPath}"),
                         "alreadyError": lambda fullPath: self.print("log", f"{fileTypeName} has already previously encountered an error at {fullPath}"),
                         "alreadyExists": lambda fullPath: self.print("log", f"{fileTypeName} was previously handled at {fullPath}"),
                         "handled": lambda fullPath: self.print("log", f'{fileTypeName} handled at {fullPath}'),
                         "skipped": lambda fullPath: self.print("log", f"{fileTypeName} was skipped at {fullPath}"),
                         "onIniFirstCorrection": lambda iniPath: self.print("log", f"Handling the {fileTypeName} files for {os.path.basename(iniPath)}..."),
                         "handleError": lambda error: self.print("handleException", error),
                         "iniSpace": lambda iniPath: self.print("space")}
        
        translations.update(newTranslations)

        currentResourcesSkipped = {}
        currentResourcesHandled = set()
        handled = False

        if (iniPaths is None):
            iniPaths = list(self.inis.keys())
        else:
            iniPaths = ListTools.getDistinct(iniPaths, keepOrder = True)

        iniPathsLen = len(iniPaths)
        for iniInd in range(iniPathsLen):
            iniPath = iniPaths[iniInd]
            if (iniPath not in self.inis):
                continue

            ini = self.inis[iniPath]
            if (ini is None):
                continue
            
            modType = ini.availableType
            if (modType is None):
                continue

            resourceModels = getResourceModels(ini)

            for model in resourceModels:
                for partIndex, partFullPaths in model.fullPaths.items():

                    partFullPathsLen = len(partFullPaths)
                    for i in range(partFullPathsLen):
                        fullPath = partFullPaths[i]

                        if (not handled):
                            translations["onIniFirstCorrection"](iniPath)
                            handled = True

                        # check if the file was already encountered and did not need to be fixed
                        if (fullPath is not None and fullPath in resourceStats.fixed):
                            translations["alreadyHandled"](fullPath)
                            continue

                        # check if the file that did not need to be fixed already had encountered an error
                        if (fullPath is not None and fullPath in resourceStats.skipped):
                            translations["alreadyError"](fullPath)
                            continue

                        # check if the fixed file already exists and we only want to fix mods without removing their previous fixes
                        if (fixOnly and os.path.isfile(fullPath)):
                            translations["alreadyExists"](fullPath)
                            continue

                        # download the resource 
                        handledResourcePath = None
                        try:
                            handledResourcePath = handleFile(fullPath, modType, partIndex, i, self.version, model, resourceStats)
                        except Exception as e:
                            currentResourcesSkipped[fullPath] = e
                            resourceStats.addSkipped(fullPath, e, modFolder = self.path)
                            translations["handleError"](e)
                        else:
                            if (handledResourcePath is not None):
                                currentResourcesHandled.add(fullPath)
                                resourceStats.addFixed(fullPath)
                                translations["handled"](fullPath)
                            else:
                                translations["skipped"](fullPath)

            if (iniInd < iniPathsLen - 1):
                translations["iniSpace"](iniPath)

        return [currentResourcesHandled, currentResourcesSkipped]
    
    def correctTex(self, texAddStats: FileStats, texEditStats: FileStats, iniPaths: Optional[List[str]] = None, fixOnly: bool = False) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Fixes all the texture .dds files reference by the mods

        Requires all the .ini files in the mod to have ran their :meth:`IniFile.fix` function

        Parameters
        ----------
        texAddStats: :class:`FileStats`
            The stats to keep track of whether the particular .dds file have been newly created or skipped

        texEditStats: :class:`FileStats`
            The stats to keep track of whether the particular .dds file has been editted or skipped

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have their .dds files corrected. If this value is ``None``, then will correct all the .ini file in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fixOnly: :class:`bool`
            Whether to not correct some .dds file if its corresponding RemapTex.dds already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`], Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the .dds files that were added
            #. The exceptions encountered when trying to created some .dds files 
            #. The absolute file paths of the .dds files that were editted
            #. The exceptions encountered when trying to edit some .dds files :raw-html:`<br />` :raw-html:`<br />`

            For the exceptions, the keys are absolute filepath to the .dds file and the values are the exception encountered        
        """

        fixedTexAdds, skippedTexAdds = self.correctResource(texAddStats, lambda iniFile: iniFile.getTexAddModels(), 
                                    lambda origFullPath,  fixedFullPath, modType, modName, partInd, pathInd, version, iniTexModel, resourceStats: self._texCorrection(fixedFullPath, modName, iniTexModel, partInd, pathInd, texFile = origFullPath),
                                    fileTypeName = "Texture", fixOnly = fixOnly, iniPaths = iniPaths,
                                    newTranslations = {"onIniFirstCorrection": lambda iniPath: self.print("log", f"Adding the {FileTypes.Texture.value} files for {os.path.basename(iniPath)}...")})
        
        fixedTexEdits, skippedTexEdits = self.correctResource(texEditStats, lambda iniFile: iniFile.getTexEditModels(), 
                                    lambda origFullPath,  fixedFullPath, modType, modName, partInd, pathInd, version, iniTexModel, resourceStats: self._texCorrection(fixedFullPath, modName, iniTexModel, partInd, pathInd, texFile = origFullPath),
                                    fileTypeName = "Texture", fixOnly = fixOnly, iniPaths = iniPaths,
                                    newTranslations = {"onIniFirstCorrection": lambda iniPath: self.print("log", f"Editting the {FileTypes.Texture.value} files for {os.path.basename(iniPath)}...")})
        
        return fixedTexAdds, skippedTexAdds, fixedTexEdits, skippedTexEdits
    
    def correctBlend(self, blendStats: FileStats, iniPaths: Optional[List[str]] = None, fixOnly: bool = False) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Fixes all the Blend.buf files reference by the mod

        Requires all the .ini files in the mod to have ran their :meth:`IniFile.parse` function

        Parameters
        ----------
        blendStats: :class:`FileStats`
            The stats to keep track of whether the particular the blend.buf files have been fixed or skipped

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have their blend.buf files corrected. If this value is ``None``, then will correct all the .ini file in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fixOnly: :class:`bool`
            Whether to not correct some Blend.buf file if its corresponding RemapBlend.buf already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the RemapBlend.buf files that were fixed
            #. The exceptions encountered when trying to fix some RemapBlend.buf files :raw-html:`<br />` :raw-html:`<br />`

            The keys are absolute filepath to the RemapBlend.buf file and the values are the exception encountered
        """

        return self.correctResource(blendStats, lambda iniFile: iniFile.remapBlendModels.values(), 
                                    lambda origFullPath,  fixedFullPath, modType, modName, partInd, pathInd, version, iniResourceModel, resourceStats: self.blendCorrection(origFullPath, modType, modName, fixedBlendFile = fixedFullPath, version = version),
                                    fileTypeName = "Blend", fixOnly = fixOnly, iniPaths = iniPaths,
                                    newTranslations = {"onIniFirstCorrection": lambda iniPath: self.print("log", f"Fixing the {FileTypes.Blend.value} files for {os.path.basename(iniPath)}...")})
    
    def correctPosition(self, positionStats: FileStats, iniPaths: Optional[List[str]] = None, fixOnly: bool = False) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Fixes all the Position.buf files reference by the mod

        Requires all the .ini files in the mod to have ran their :meth:`IniFile.parse` function

        Parameters
        ----------
        positionStats: :class:`FileStats`
            The stats to keep track of whether the particular the Position.buf files have been fixed or skipped

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have their Position.buf files corrected. If this value is ``None``, then will correct all the .ini file in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fixOnly: :class:`bool`
            Whether to not correct some Position.buf file if its corresponding RemapPosition.buf already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the RemapPosition.buf files that were fixed
            #. The exceptions encountered when trying to fix some RemapPosition.buf files :raw-html:`<br />` :raw-html:`<br />`

            The keys are absolute filepath to the RemapPosition.buf file and the values are the exception encountered
        """

        return self.correctResource(positionStats, lambda iniFile: iniFile.remapPositionModels.values(), 
                            lambda origFullPath,  fixedFullPath, modType, modName, partInd, pathInd, version, iniResourceModel, resourceStats: self.positionCorrection(origFullPath, modType, modName, fixedPositionFile = fixedFullPath, version = version),
                            fileTypeName = "Position", fixOnly = fixOnly, iniPaths = iniPaths,
                            newTranslations = {"onIniFirstCorrection": lambda iniPath: self.print("log", f"Fixing the {FileTypes.Position.value} files for {os.path.basename(iniPath)}...")})
    
    def downloadFiles(self, downloadStats: CachedFileStats, iniPaths: Optional[List[str]] = None, fixOnly: bool = False, proxy: Optional[str] = None) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Downloads the necessary files for a mod

        Requires all the .ini files in the mod to have ran their :meth:`IniFile.parse` function

        Parameters
        ----------
        downloadStats: :class:`CachedFileStats`
            The stats to keep track of the downloads

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have downloads required. If this value is ``None``, then will download files from all the .ini files in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fixOnly: :class:`bool`
            Whether to not download a file if the corresponding downloaded file already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the downloaded files
            #. The exceptions encountered when trying to download some files :raw-html:`<br />` :raw-html:`<br />`

            The keys are absolute filepath to the download file and the values are the exception encountered
        """

        return self.handleSrcFiles(downloadStats, lambda iniFile: iniFile.fileDownloadModels.values(),
                                   lambda fullPath, modType, partInd, pathInd, version, iniResourceModel, resourceStats: self._downloadFile(fullPath, iniResourceModel, partInd, pathInd, resourceStats, proxy = proxy),
                                   iniPaths = iniPaths, fileTypeName = "Download", fixOnly = fixOnly,
                                   newTranslations = {
                                    "alreadyHandled": lambda fullPath: self.print("log", f"Download has already been downloaded at {fullPath}"),
                                    "alreadyError": lambda fullPath: self.print("log", f"Download has already previously encountered an error at {fullPath}"),
                                    "alreadyExists": lambda fullPath: self.print("log", f"Download was previously downloaded at {fullPath}"),
                                    "handled": lambda fullPath: 0,
                                    "skipped": lambda fullPath: 0,
                                    "onIniFirstCorrection": lambda iniPath: self.print("log", f"Downloading the required files for {os.path.basename(iniPath)}...")})


class ConcurrentManager(Generic[T]):
    """
    Base class to manage running many executions

    Paramaters
    ----------
    executionCls: Type[T]
        The class for building the executions

    jobNo: Optional[:class:`int`]
        The number of executions to run at once :raw-html:`<br />` :raw-html:`<br />`

        If this argument is ``None``, will run all the executions at once :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    executionCls: Type[T]
        The class for building the executions

    execution: List[T]
        The executions to run

    jobNo: Optional[:class:`int`]
        The number of threads to run at once
    """

    def __init__(self, executionCls: Type[T], jobNo: Optional[int] = None):
        self.executionCls = executionCls
        self.execs: List[T] = []
        self.jobNo = jobNo

    def clear(self):
        """
        Clears all the executions
        """

        self.execs.clear()

    def add(self, *args, **kwargs):
        """
        Adds an execution

        Parameters
        ----------
        *args:
            The arguments to provide into the class at :attr:`executionCls`

        **kwargs:
            The keyword arguments to provide into :attr:`executionCls`
        """

        self.execs.append(self.executionCls(*args, **kwargs))

    def waitAll(self):
        """
        Runs all the executions at once and waits until all the executions have finished running
        """

        if (self.jobNo is None):
            for exec in self.execs:
                exec.start()

            for exec in self.execs:
                exec.join()
            
            return
        
        numOfCycles, remainingJobs = divmod(len(self.execs), self.jobNo)

        for i in range(numOfCycles):
            for j in range(self.jobNo):
                ind = self.jobNo * i + j
                self.execs[ind].start()

            for j in range(self.jobNo):
                ind = self.jobNo * i + j
                self.execs[ind].join()

        for i in range(remainingJobs):
            ind = self.jobNo * numOfCycles + i
            self.execs[ind].start()

        for i in range(remainingJobs):
            ind = self.jobNo * numOfCycles + i
            self.execs[ind].join()


class ProcessManager(ConcurrentManager[Process]):
    """
    Class to manage running many processes

    .. danger::
        This class is susceptible to keyboard interrupts. However, this vulnerability seem to
        be rooted to a bug in Python itself:
        https://stackoverflow.com/questions/1408356/keyboard-interrupts-with-pythons-multiprocessing-pool

    Paramaters
    ----------
    jobNo: Optional[:class:`int`]
        The number of processes to run at once :raw-html:`<br />` :raw-html:`<br />`

        If this argument is ``None``, will run all the processes at once :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, jobNo: Optional[int] = None):
        super().__init__(Process, jobNo = jobNo)

    def waitAll(self):
        """
        Runs all the processes at once and waits until all the processes have finished running
        """

        if (self.jobNo is None):
            for exec in self.execs:
                exec.start()

            try:
                for exec in self.execs:
                    exec.join()
            except KeyboardInterrupt:
                for exec in self.execs:
                    exec.terminate()
            
            return
        
        numOfCycles, remainingJobs = divmod(len(self.execs), self.jobNo)

        for i in range(numOfCycles):
            try:
                for j in range(self.jobNo):
                    ind = self.jobNo * i + j
                    self.execs[ind].daemon = True
                    self.execs[ind].start()

                for j in range(self.jobNo):
                    ind = self.jobNo * i + j
                    self.execs[ind].join()
            except KeyboardInterrupt:
                for exec in self.execs:
                    exec.terminate()
                    exec.join()

                return

        try:
            for i in range(remainingJobs):
                ind = self.jobNo * numOfCycles + i
                self.execs[ind].daemon = True
                self.execs[ind].start()

            for i in range(remainingJobs):
                ind = self.jobNo * numOfCycles + i
                self.execs[ind].join()
        except KeyboardInterrupt:
            for exec in self.execs:
                exec.terminate()
                exec.join()


class ThreadManager(ConcurrentManager[Thread]):
    """
    Class to manage running many threads

    Paramaters
    ----------
    jobNo: Optional[:class:`int`]
        The number of processes to run at once :raw-html:`<br />` :raw-html:`<br />`

        If this argument is ``None``, will run all the processes at once :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, jobNo: Optional[int] = None):
        super().__init__(Thread, jobNo = jobNo)


class RemapService():
    """
    The overall class for remapping mods

    Parameters
    ----------
    path: Optional[:class:`str`]
        The file location of where to run the fix. :raw-html:`<br />` :raw-html:`<br />`

        If this attribute is set to ``None``, then will run the fix from wherever this class is called :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    keepBackups: :class:`bool`
        Whether to keep backup versions of any .ini files that the script fixes :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    fixOnly: :class:`bool`
        Whether to only fix the mods without removing any previous changes this fix script may have made :raw-html:`<br />` :raw-html:`<br />`

        .. warning::
            if this is set to ``True`` and :attr:`undoOnly` is also set to ``True``, then the fix will not run and will throw a :class:`ConflictingOptions` exception

        :raw-html:`<br />`

        **Default**: ``False``

    undoOnly: :class:`bool`
        Whether to only undo the fixes previously made by the fix :raw-html:`<br />` :raw-html:`<br />`

        .. warning::
            if this is set to ``True`` and :attr:`fixOnly` is also set to ``True``, then the fix will not run and will throw a :class:`ConflictingOptions` exception

        :raw-html:`<br />`

        **Default**: ``True``

    hideOrig: :class:`bool`
        Whether to not show the mod on the original character :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    readAllInis: :class:`bool`
        Whether to read all the .ini files that the fix encounters :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    types: Optional[List[:class:`str`]]
        The names for all the types of mods to fix.  :raw-html:`<br />` :raw-html:`<br />`

        If this argument is an empty list or this argument is ``None``, then will fix all the types of mods supported by this fix :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

        :raw-html:`<br />`

        .. note::
            For more information about the available mod names/aliases to reference, see :ref:`Mod Types`

    remappedTypes: Optional[List[:class:`str`]]
        The names for the types of mods to be remapped based from the types of mods specified at :attr:`RemapService.types`. :raw-html:`<br />` :raw-html:`<br />`

        For a mod specified at :attr:`RemapService.types`, if none of its corresponding mods to remap are specified in this attribute, then will remap the mod specified at :attr:`RemapService.types` to all its corresponding mods to remap.

        If this argument is an empty list or this argument is ``None``, then will fix the mods specified at :attr:`types` to all of their corresponding remapped mods :raw-html:`<br />` :raw-html:`<br />`

        eg.
        if :attr:`RemapService.types` is ``["Kequeen", "jean"]`` and this attribute is ``["jeanSea"]``, then this class will perform the following remaps:
        
        * Keqing --> KeqingOpulent
        * Jean --> JeanSea

        **Note: ** Jean --> JeanCN will not be remapped for the above example :raw-html:`<br />`

        .. note::
            For more information about the available mod names/aliases to reference, see :ref:`Mod Types`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    defaultType: Optional[:class:`str`]
        The name for the type to use if a mod has an unidentified type :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then mods with unidentified types will be skipped :raw-html:`<br />`

        .. note::
            For more information about the available mod names/aliases to reference, see :ref:`Mod Types`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    forcedType: Optional[:class:`str`]
        The mod type to forcibly assume for the parsed .ini files :raw-html:`<br />`

        .. note::
            For more information about the available mod names/aliases to reference, see :ref:`Mod Types`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    log: Optional[:class:`str`]
        The folder location to log the run of the fix into a seperate text file :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will not log the fix :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    verbose: :class:`bool`
        Whether to print the progress for fixing mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    handleExceptions: :class:`bool`
        When an exception is caught, whether to silently stop running the fix :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    version: Optional[:class:`str`]
        The game version we want the fix to be compatible with :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will retrieve the hashes/indices of the latest version. :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    proxy: Optional[:class:`str`]
        The link to the proxy server used for any internet network requests made :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will assume all internet network requests do not require the need to go through a proxy server.

    downloadMode: Optional[:class:`str`]
        The download mode to handle file downloads :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then the software will default to use :attr:`DownloadMode.HardTexDriven` as the download mode :raw-html:`<br />`

        .. note::
            For more information about the available download modes to specify, see :ref:`Download Modes`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    _loggerBasePrefix: :class:`str`
        The prefix string for the logger used when the fix returns back to the original directory that it started to run

    logger: :class:`Logger`
        The logger used to pretty print messages

    _path: :class:`str`
        The file location of where to run the fix.

    keepBackups: :class:`bool`
        Whether to keep backup versions of any .ini files that the script fixes

    fixOnly: :class:`bool`
        Whether to only fix the mods without removing any previous changes this fix script may have made

    undoOnly: :class:`bool`
        Whether to only undo the fixes previously made by the fix

    hideOrig: :class:`bool`
        Whether to not show the mod on the original character

    readAllInis: :class:`bool`
        Whether to read all the .ini files that the fix encounters

    types: Set[:class:`ModType`]
        All the types of mods that will be fixed. :raw-html:`<br />`

        .. note::
            For more information about the available mod names/aliases to reference, see :ref:`Mod Types`

    remappedTypes: Set[:class:`str`]
        The names for the types of mods to be remapped based from the types of mods specified at :attr:`RemapService.types`. :raw-html:`<br />` :raw-html:`<br />`

        For a mod specified at :attr:`RemapService.types`, if none of its corresponding mods to remap are specified in this attribute, then will remap the mod specified at :attr:`RemapService.types` to all its corresponding mods to remap.

        If this argument is an empty list or this argument is ``None``, then will fix the mods specified at :attr:`RemapService.types` to all of their corresponding remapped mods :raw-html:`<br />` :raw-html:`<br />`

        eg.
        if :attr:`RemapService.types` is ``["Kequeen", "jean"]`` and this attribute is ``["jeanSea"]``, then this class will perform the following remaps:
        
        * Keqing --> KeqingOpulent
        * Jean --> JeanSea

        **Note: ** Jean --> JeanCN will not be remapped for the above example :raw-html:`<br />`

        .. note::
            For more information about the available mod names/aliases to reference, see :ref:`Mod Types`

    defaultType: Optional[:class:`ModType`]
        The type to use if a mod has an unidentified type :raw-html:`<br />`

        .. note::
            For more information about the available mod names/aliases to reference, see :ref:`Mod Types`

    forcedType: Optional[:class:`ModType`]
        The mod type to forcibly assume for the parsed .ini files :raw-html:`<br />`

        .. note::
            For more information about the available mod names/aliases to reference, see :ref:`Mod Types`

    version: Optional[`packaging.version.Version`_]
        The game version we want the fix to be compatible with :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will retrieve the hashes/indices of the latest version.

    downloadMode: :class:`DownloadMode`
        The download mode to handle file downloads :raw-html:`<br />`

        .. note::
            For more information about the available download modes to specify, see :ref:`Download Modes`

    handleExceptions: :class:`bool`
        When an exception is caught, whether to silently stop running the fix

    _logFile: :class:`str`
        The file path of where to generate a log .txt file

    _pathIsCWD: :class:`bool`
        Whether the filepath that the program runs from is the current directory where this module is loaded

    stats: :class:`RemapStats`
        The statistics gathered about the fix process
    """

    def __init__(self, path: Optional[str] = None, keepBackups: bool = True, fixOnly: bool = False, undoOnly: bool = False, hideOrig: bool = False,
                 readAllInis: bool = False, types: Optional[List[str]] = None, defaultType: Optional[str] = None, forcedType: Optional[str] = None, 
                 log: Optional[str] = None, verbose: bool = True, handleExceptions: bool = False, version: Optional[str] = None, remappedTypes: Optional[List[str]] = None,
                 proxy: Optional[str] = None, downloadMode: Optional[str] = None):
        self.proxy = proxy
        self.downloadMode = downloadMode

        self._loggerBasePrefix = ""
        self.logger = Logger(logTxt = bool(log), verbose = verbose)
        self.log = log

        self._path = path
        self.keepBackups = keepBackups
        self.fixOnly = fixOnly
        self.undoOnly = undoOnly
        self.hideOrig = hideOrig
        self.readAllInis = readAllInis
        self.types = types
        self.remappedTypes = remappedTypes
        self.defaultType = defaultType
        self.forcedType = forcedType
        self._verbose = verbose
        self.version = version
        self.handleExceptions = handleExceptions
        self._pathIsCwd = False
        self.__errorsBeforeFix = None

        # certain statistics about the fix
        self.stats = RemapStats()

        self._setupModPath()
        self._setupForcedModType()
        self._setupDefaultModType()
        self._setupToFixModTypes()
        self._setupRemappedTypes()
        self._setupVersion()
        self._setupDownloadMode()

        self._iniExecs = ThreadManager(jobNo = 10)

        if (self.__errorsBeforeFix is None):
            self._printModsToFix()

    @property
    def pathIsCwd(self):
        """
        Whether the filepath that the program runs from is the current directory where this module is loaded

        :getter: Returns whether the filepath that the program runs from is the current directory of where the module is loaded
        :type: :class:`bool`
        """

        return self._pathIsCwd
    
    @property
    def path(self) -> str:
        """
        The filepath of where the fix is running from

        :getter: Returns the path of where the fix is running
        :setter: Sets the path for where the fix runs
        :type: :class:`str`
        """

        return self._path
    
    @path.setter
    def path(self, newPath: Optional[str]):
        self._path = newPath
        self._setupModPath()
        self.clear()

    @property
    def log(self) -> str:
        """
        The folder location to log the run of the fix into a seperate text file

        :getter: Returns the file path to the log
        :setter: Sets the path for the log
        :type: :class:`str`
        """

        return self._log
    
    @log.setter
    def log(self, newLog: Optional[str]):
        self._log = newLog
        self._setupLogPath()
        self.logger.logTxt = bool(newLog)

    @property
    def verbose(self) -> bool:
        """
        Whether to print the progress for fixing mods

        :getter: Tells whether progress will be printed when fixing mods
        :setter: Sets the new flag for whether to print progress
        :type: :class:`bool`
        """

        return self._verbose
    
    @verbose.setter
    def verbose(self, newVerbose: bool):
        self._verbose = newVerbose
        self.logger.verbose = newVerbose

    @property
    def proxy(self) -> Optional[str]:
        """
        The link to the proxy server used for any internet network requests made :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will assume all internet network requests do not require the need to go through a proxy server.

        :getter: Retrieves the proxy link
        :setter: Sets the new proxy link
        :type: Optional[:class:`str`]
        """

        return self._proxy
    
    @proxy.setter
    def proxy(self, newProxy: str):
        self._proxy = newProxy
        GlobalPackageManager.Packager.value.proxy = self._proxy

    def clear(self, clearLog: bool = True):
        """
        Clears up all the saved data

        Paramters
        ---------
        clearLog: :class:`bool`
            Whether to also clear out any saved data in the logger
        """

        self.stats.clear()

        if (clearLog):
            self.logger.clear()
    
    def _setupModPath(self):
        """
        Sets the filepath of where the fix will run from
        """

        self._pathIsCwd = False
        if (self._path is None):
            self._path = FilePathConsts.DefaultPath
            self._pathIsCwd = True
            return

        self._path = FileService.parseOSPath(self._path)
        self._path = FileService.parseOSPath(os.path.abspath(self._path))
        self._pathIsCwd = (self._path == FilePathConsts.DefaultPath)

    def _setupLogPath(self):
        """
        Sets the folder path for where the log file will be stored
        """

        if (self._log is not None):
            self._log = FileService.parseOSPath(os.path.join(self._log, FileTypes.Log.value))

    def _setupModTypes(self, attr: str):
        """
        Sets the types of mods that will be fixed / fix to

        Parameters
        ----------
        attr: :class:`str`
            The name of the attribute within this class set the mods for
        """
        attrVal = getattr(self, attr)
        if (isinstance(attrVal, set)):
            return

        modTypes = set()
        if (attrVal is None or not attrVal):
            modTypes = ModTypes.getAll()

        # search for the types of mods to fix
        else:
            for typeStr in attrVal:
                modType = ModTypes.search(typeStr)
                modTypeFound = bool(modType is not None)

                if (modTypeFound):
                    modTypes.add(modType)
                elif (self.__errorsBeforeFix is None):
                    self.__errorsBeforeFix = InvalidModType(typeStr)
                    return

        setattr(self, attr, modTypes)

    def _setupToFixModTypes(self):
        """
        Sets the names for the type of mods that will be fixed
        """

        hasForcedModType = self.forcedType is not None
        if (hasForcedModType and isinstance(self.forcedType, ModType)):
            self.types = {self.forcedType}
            return

        elif (hasForcedModType and isinstance(self.forcedType, str)):
            self.types = [self.forcedType]

        elif (self.readAllInis):
            self.types = ModTypes.getAll()
            return

        self._setupModTypes("types")

    def _setupRemappedTypes(self):
        """
        Sets the names for the types of mods that will be fixed to
        """

        self._setupModTypes("remappedTypes")
        if (self.__errorsBeforeFix is not None):
            return
        
        self.remappedTypes = set(map(lambda remappedType: remappedType.name, self.remappedTypes))

    def _setupVersion(self):
        """
        Sets the game version to fix to
        """

        if (self.version is None):
            return
        
        version = Version.getVersion(self.version)

        if (version is None and self.__errorsBeforeFix is None):
            self.__errorsBeforeFix = ValueError("Please enter a valid version that conforms to PEP 440 for the game version")
        elif (version is not None):
            self.version = version

    def _setupDefaultModType(self):
        """
        Sets the default mod type to be used for an unidentified mod
        """

        if (not self.readAllInis or self.forcedType is not None):
            self.defaultType = None
            return

        elif (self.defaultType is None):
            self.defaultType = ModTypes.Raiden.value
            return

        elif (isinstance(self.defaultType, ModType)):
            return

        foundModType = ModTypes.search(self.defaultType)
        if (foundModType is None and self.__errorsBeforeFix is None):
            self.__errorsBeforeFix = InvalidModType(self.defaultType)
        
        self.defaultType = foundModType

    def _setupForcedModType(self):
        """
        Sets the forced mod type to assume for the .ini files
        """

        if (self.forcedType is None or isinstance(self.forcedType, ModType)):
            return

        foundModType = ModTypes.search(self.forcedType)
        if (foundModType is None and self.__errorsBeforeFix is None):
            self.__errorsBeforeFix = InvalidModType(self.forcedType)
            return
        
        self.forcedType = foundModType

    def _setupDownloadMode(self):
        """
        Sets the download mode the software will use for file downloads
        """

        if (self.downloadMode is None):
            self.downloadMode = DownloadMode.HardTexDriven
            return
        
        foundDownloadMode = DownloadMode.search(self.downloadMode)
        if (foundDownloadMode is None and self.__errorsBeforeFix is None):
            self.__errorsBeforeFix = InvalidDownloadMode(self.downloadMode)
            return

        self.downloadMode = foundDownloadMode

    def _printModsToFix(self):
        """
        Prints out the types of mods that will be fixed
        """

        self.logger.includePrefix = False

        self.logger.openHeading("Types of Mods To Fix", 5)
        self.logger.space()

        if (not self.types):
            self.logger.log("All mods")
        else:
            sortedModNames = list(map(lambda modType: modType.name, self.types))
            sortedModNames.sort()

            for name in sortedModNames:
                self.logger.bulletPoint(f"{name}")
        
        self.logger.space()
        self.logger.closeHeading()
        self.logger.split() 
        self.logger.includePrefix = True
    
    # fixes an ini file in a mod
    def fixIni(self, ini: IniFile, mod: Mod, flushIfTemplates: bool = True) -> bool:
        """
        Fixes an individual .ini file for a particular mod

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`

        Parameters
        ----------
        ini: :class:`IniFile`
            The .ini file to fix

        mod: :class:`Mod`
            The mod being fixed

        flushIfTemplates: :class:`bool`
            Whether to re-parse the :class:`IfTemplates`s in the .ini files instead of using the saved cached values :raw-html:`<br />` :raw-html:`<br />`
             
            **Default**: ``True``

        Returns
        -------
        :class:`bool`
            Whether the particular .ini file has just been fixed
        """

        # check if the .ini is belongs to some mod
        if (ini is None or not ini.isModIni):
            return False

        if (self.undoOnly):
            return True

        fileBaseName = os.path.basename(ini.file)
        iniFullPath = FileService.absPathOfRelPath(ini.file, mod.path)

        if (iniFullPath in self.stats.ini.skipped):
            self.logger.log(f"the ini file, {fileBaseName}, has alreaedy encountered an error")
            return False
        
        if (iniFullPath in self.stats.ini.fixed):
            self.logger.log(f"the ini file, {fileBaseName}, is already fixed")
            return True

        # parse the .ini file
        self.logger.log(f"Parsing {fileBaseName}...")
        ini.parse(flushIfTemplates = flushIfTemplates)

        if (ini.isFixed):
            self.logger.log(f"the ini file, {fileBaseName}, is already fixed")
            return True
        
        # download the required files
        mod.downloadFiles(self.stats.download, iniPaths = [ini.file], fixOnly = self.fixOnly, proxy = self._proxy)

        # fix the blends
        mod.correctBlend(self.stats.blend, fixOnly = self.fixOnly, iniPaths = [ini.file])

        # fix the positions
        mod.correctPosition(self.stats.position, fixOnly = self.fixOnly, iniPaths = [ini.file])

        # writing the fixed file
        self.logger.log(f"Making the fixed ini file for {fileBaseName}")
        ini.fix(keepBackup = self.keepBackups, fixOnly = self.fixOnly, hideOrig = self.hideOrig)
        self.logger.space()

        # fix the textures
        mod.correctTex(self.stats.texAdd, self.stats.texEdit, fixOnly = self.fixOnly, iniPaths = [ini.file])

        return True

    # fixes a mod
    def fixMod(self, mod: Mod, flushIfTemplates: bool = True) -> bool:
        """
        Fixes a particular mod

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`

        Parameters
        ----------
        mod: :class:`Mod`
            The mod being fixed

        flushIfTemplates: :class:`bool`
            Whether to re-parse the :class:`IfTemplates`s in the .ini files instead of using the saved cached values :raw-html:`<br />` :raw-html:`<br />`
             
            **Default**: ``True``

        Returns
        -------
        :class:`bool`
            Whether the particular mod has just been fixed
        """

        # remove any backups
        if (not self.keepBackups):
            mod.removeBackupInis()

        for iniPath in mod.inis:
            ini = mod.inis[iniPath]
            ini.classify()

        # undo any previous fixes
        if (not self.fixOnly):
            undoedInis, removedRemapBlends, removedRemapPositions, removedTextures, removedDownloads = mod.removeFix(self.stats,
                                                                                                                     keepBackups = self.keepBackups, fixOnly = self.fixOnly, 
                                                                                                                     readAllInis = self.readAllInis, writeBackInis = self.undoOnly)
            self.stats.blend.updateRemoved(removedRemapBlends)
            self.stats.position.updateRemoved(removedRemapPositions)
            self.stats.ini.updateUndoed(undoedInis)
            self.stats.texAdd.updateRemoved(removedTextures)
            self.stats.download.updateRemoved(removedDownloads)

        # clear the temporary models only used for undoing the fix
        if (not self.undoOnly):
            for iniPath in mod.inis:
                ini = mod.inis[iniPath]
                ini.clearModels()

        result = False
        firstIniException = None
        inisLen = len(mod.inis)

        i = 0
        for iniPath in mod.inis:
            ini = mod.inis[iniPath]
            iniFullPath = FileService.absPathOfRelPath(ini.file, mod.path)
            iniIsFixed = False

            try:
                iniIsFixed = self.fixIni(ini, mod, flushIfTemplates = True)
            except Exception as e:
                self.logger.handleException(e)
                self.stats.ini.addSkipped(iniFullPath, e)

                if (firstIniException is None):
                    firstIniException = e

            if (firstIniException is None and iniFullPath in self.stats.ini.skipped):
                firstIniException = self.stats.ini.skipped[iniFullPath]

            result = (result or iniIsFixed)

            if (not iniIsFixed):
                i += 1
                continue
            
            if (not self.undoOnly and i < inisLen - 1):
                self.logger.space()

            self.stats.ini.addFixed(iniFullPath)
            i += 1

        if (not result and firstIniException is not None):
            self.stats.mod.addSkipped(mod.path, firstIniException, modFolder = mod.path)

        return result
    
    def addTips(self):
        """
        Prints out any useful tips for the user to know
        """

        self.logger.includePrefix = False

        if (not self.undoOnly or self.keepBackups):
            self.logger.split()
            self.logger.openHeading("Tips", sideLen = 10)

            if (self.keepBackups):
                self.logger.bulletPoint(f'Hate deleting the "{FilePrefixes.BackupFilePrefix.value}" {FileExt.Ini.value}/{FileExt.Txt.value} files yourself after running this script? (cuz I know I do!) Run this script again (on CMD) using the {CommandOpts.DeleteBackup.value} option')

            if (not self.undoOnly):
                self.logger.bulletPoint(f"Want to undo this script's fix? Run this script again (on CMD) using the {CommandOpts.Revert.value} option")

            if (not self.hideOrig):
                self.logger.bulletPoint(f"Want the mod to only show on the remapped character and not the original character? Run this script again (on CMD) using the {CommandOpts.HideOriginal.value} options")

            if (not self.readAllInis):
                self.logger.bulletPoint(f"Were your {FileTypes.Ini.value}s not read? Run this script again (on CMD) using the {CommandOpts.All.value} option")

            self.logger.space()
            self.logger.log("For more info on command options, run this script (on CMD) using the --help option")
            self.logger.closeHeading()

        self.logger.includePrefix = True


    def reportSkippedAsset(self, assetName: str, assetDict: Dict[str, Exception], warnStrFunc: Callable[[str], str]):
        """
        Prints out the exception message for why a particular .ini file or Blend.buf file has been skipped

        Parameters
        ----------
        assetName: :class:`str`
            The name for the type of asset (files, folders, mods, etc...) that was skipped

        assetDict: Dict[:class:`str`, :class:`Exception`]
            Locations of where exceptions have occured for the particular asset :raw-html:`<br />` :raw-html:`<br />`

            The keys are the absolute folder paths to where the exception occured

        wantStrFunc: Callable[[:class:`str`], :class:`str`]
            Function for how we want to print out the warning for each exception :raw-html:`<br />` :raw-html:`<br />`

            Takes in the folder location of where the exception occured as a parameter
        """

        if (assetDict):
            message = f"\nWARNING: The following {assetName} were skipped due to warnings (see log above):\n\n"
            for dir in assetDict:
                message += warnStrFunc(dir)

            self.logger.error(message)
            self.logger.space()

    def warnSkippedIniResource(self, modPath: str, stats: FileStats):
        """
        Prints out all of the resource files from the .ini files that were skipped due to exceptions

        Parameters
        ----------
        modPath: :class:`str`
            The absolute path to a particular folder
        """

        parentFolder = os.path.dirname(self._path)
        relModPath = FileService.getRelPath(modPath, parentFolder)
        modHeading = Heading(f"Mod: {relModPath}", 5)
        message = f"{modHeading.open()}\n\n"
        fileWarnings = stats.skippedByMods[modPath]
        
        for filePath in fileWarnings:
            relBlendPath = FileService.getRelPath(filePath, self._path)
            message += self.logger.getBulletStr(f"{relBlendPath}:\n\t{Heading(type(fileWarnings[filePath]).__name__, 3, '-').open()}\n\t{fileWarnings[filePath]}\n\n")
        
        message += f"{modHeading.close()}\n"
        return message

    def reportSkippedMods(self):
        """
        Prints out all of the mods that were skipped due to exceptions

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`
        """

        self.reportSkippedAsset(f"newly added {FileTypes.Texture.value} files", self.stats.texAdd.skippedByMods, lambda dir: self.warnSkippedIniResource(dir, self.stats.texAdd))
        self.reportSkippedAsset(f"editted {FileTypes.Texture.value} files", self.stats.texEdit.skippedByMods, lambda dir: self.warnSkippedIniResource(dir, self.stats.texEdit))
        self.reportSkippedAsset(f"{FileTypes.Ini.value}s", self.stats.ini.skipped, lambda file: self.logger.getBulletStr(f"{file}:\n\t{Heading(type(self.stats.ini.skipped[file]).__name__, 3, '-').open()}\n\t{self.stats.ini.skipped[file]}\n\n"))
        self.reportSkippedAsset(f"{FileTypes.Blend.value} files", self.stats.blend.skippedByMods, lambda dir: self.warnSkippedIniResource(dir, self.stats.blend))
        self.reportSkippedAsset(f"{FileTypes.Position.value}, files", self.stats.position.skippedByMods, lambda dir: self.warnSkippedIniResource(dir, self.stats.position))
        self.reportSkippedAsset("mods", self.stats.mod.skipped, lambda dir: self.logger.getBulletStr(f"{dir}:\n\t{Heading(type(self.stats.mod.skipped[dir]).__name__, 3, '-').open()}\n\t{self.stats.mod.skipped[dir]}\n\n"))

    def reportSummary(self):
        skippedMods = len(self.stats.mod.skipped)
        fixedMods = len(self.stats.mod.fixed)
        foundMods = fixedMods + skippedMods

        fixedBlends = len(self.stats.blend.fixed)
        skippedBlends = len(self.stats.blend.skipped)
        removedRemapBlends = len(self.stats.blend.removed)
        foundBlends = fixedBlends + skippedBlends

        fixedPositions = len(self.stats.position.fixed)
        skippedPositions = len(self.stats.position.skipped)
        removedRemapPositions = len(self.stats.position.removed)
        foundPositions = fixedPositions + skippedPositions

        fixedInis = len(self.stats.ini.fixed)
        skippedInis = len(self.stats.ini.skipped)
        undoedInis = len(self.stats.ini.undoed)
        foundInis = fixedInis + skippedInis

        fixedAddTextures = len(self.stats.texAdd.fixed)
        skippedAddTextures = len(self.stats.texAdd.skipped)
        removedTextures = len(self.stats.texAdd.removed)
        foundAddTextures = fixedAddTextures + skippedAddTextures

        fixedEditTextures = len(self.stats.texEdit.fixed)
        skippedEditTextures = len(self.stats.texEdit.skipped)
        foundEditTextures = fixedEditTextures + skippedEditTextures

        downloadedFiles = len(self.stats.download.fixed)
        cachedDownloadedFiles = len(self.stats.download.hit)
        skippedDownloads = len(self.stats.download.skipped)
        foundDownloads = downloadedFiles + cachedDownloadedFiles + skippedDownloads
        removedDownloads = len(self.stats.download.removed)

        self.logger.openHeading("Summary", sideLen = 10)
        self.logger.space()
        
        modFixMsg = ""
        blendFixMsg = ""
        positionFixMsg = ""
        iniFixMsg = ""
        removedRemapBlendMsg = ""
        removedRemapPositionMsg = ""
        undoedInisMsg = ""
        texAddFixMsg = ""
        texEditFixMsg = ""
        removedTexMsg = ""
        downloadMsg = ""
        removedDownloadMsg = ""

        if (not self.undoOnly):
            modFixMsg = f"Out of {foundMods} found mods, fixed {fixedMods} mods and skipped {skippedMods} mods"
            iniFixMsg = f"Out of the {foundInis} {FileTypes.Ini.value}s within the found mods, fixed {fixedInis} {FileTypes.Ini.value}s and skipped {skippedInis} {FileTypes.Ini.value}s"
            blendFixMsg = f"Out of the {foundBlends} {FileTypes.Blend.value} files within the found mods, fixed {fixedBlends} {FileTypes.Blend.value} files and skipped {skippedBlends} {FileTypes.Blend.value} files"

            if (foundPositions > 0):
                positionFixMsg = f"Out of the {foundPositions} {FileTypes.Position.value} files within the found mods, fixed {fixedPositions} {FileTypes.Position.value} files and skipped {skippedPositions} {FileTypes.Position.value} files"

            if (foundAddTextures > 0):
                texAddFixMsg = f"Out of the {foundAddTextures} {FileTypes.Texture.value} files that were attempted to be created in the found mods, created {fixedAddTextures} {FileTypes.Texture.value} files and skipped {skippedAddTextures} {FileTypes.Texture.value} files"

            if (foundEditTextures > 0):
                texEditFixMsg = f"Out of the {foundEditTextures} {FileTypes.Texture.value} files within the found mods, editted {fixedEditTextures} {FileTypes.Texture.value} files and skipped {skippedEditTextures} {FileTypes.Texture.value} files"

            if (foundDownloads > 0):
                downloadMsg = f"Out of {foundDownloads} download requests within the found mods, downloaded {downloadedFiles} files, copied {cachedDownloadedFiles} files from existing downloads and skipped {skippedDownloads} downloads"
        else:
            modFixMsg = f"Out of {foundMods} found mods, remove fix from {fixedMods} mods and skipped {skippedMods} mods"

        if (not self.fixOnly and undoedInis > 0):
            undoedInisMsg = f"Removed fix from up to {undoedInis} {FileTypes.Ini.value}s"

            if (self.undoOnly):
                undoedInisMsg += f" and skipped {skippedInis} {FileTypes.Ini.value}s"

        if (not self.fixOnly and removedRemapBlends > 0):
            removedRemapBlendMsg = f"Removed {removedRemapBlends} old {FileTypes.RemapBlend.value} files"

        if (not self.fixOnly and removedRemapPositions > 0):
            removedRemapPositionMsg = f"Removed {removedRemapPositions} old {FileTypes.RemapPosition.value} files"

        if (not self.fixOnly and removedTextures > 0):
            removedTexMsg = f"Removed {removedTextures} old {FileTypes.RemapTexture.value} files"

        if (not self.fixOnly and removedDownloads > 0):
            removedDownloadMsg = f"Removed {removedDownloads} old {FileTypes.RemapDownload.value} files"


        self.logger.bulletPoint(modFixMsg)
        if (iniFixMsg):
            self.logger.bulletPoint(iniFixMsg)

        if (blendFixMsg):
            self.logger.bulletPoint(blendFixMsg)

        if (positionFixMsg):
            self.logger.bulletPoint(positionFixMsg)

        if (texAddFixMsg):
            self.logger.bulletPoint(texAddFixMsg)

        if (texEditFixMsg):
            self.logger.bulletPoint(texEditFixMsg)

        if (downloadMsg):
            self.logger.bulletPoint(downloadMsg)

        if (undoedInisMsg):
            self.logger.bulletPoint(undoedInisMsg)

        if (removedRemapBlendMsg):
            self.logger.bulletPoint(removedRemapBlendMsg)

        if (removedRemapPositionMsg):
            self.logger.bulletPoint(removedRemapPositionMsg)

        if (removedTexMsg):
            self.logger.bulletPoint(removedTexMsg)

        if (removedDownloadMsg):
            self.logger.bulletPoint(removedDownloadMsg)

        self.logger.space()
        self.logger.closeHeading()

    def createLog(self):
        """
        Creates a log text file that contains all the text printed on the command line
        """

        if (self._log is None):
            return

        self.logger.includePrefix = False
        self.logger.space()

        self.logger.log(f"Creating log file, {FileTypes.Log.value}")

        self.logger.includePrefix = True

        with open(self._log, "w", encoding = FileEncodings.UTF8.value) as f:
            f.write(self.logger.loggedTxt)

    def createMod(self, path: Optional[str] = None, files: Optional[List[str]] = None) -> Mod:
        """
        Creates a mod

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`

        Parameters
        ----------
        path: Optional[:class:`str`]
            The absolute path to the mod folder. :raw-html:`<br />` :raw-html:`<br />`
            
            If this argument is set to ``None``, then will use the current directory of where this module is loaded

        files: Optional[List[:class:`str`]]
            The direct children files to the mod folder (does not include files located in a folder within the mod folder). :raw-html:`<br />` :raw-html:`<br />`

            If this parameter is set to ``None``, then the module will search the folders for you

        Returns
        -------
        :class:`Mod`
            The mod that has been created
        """

        path = FileService.getPath(path)
        mod = Mod(path = path, files = files, logger = self.logger, types = self.types, defaultType = self.defaultType, 
                  version = self.version, remappedTypes = self.remappedTypes, forcedType = self.forcedType, downloadMode = self.downloadMode)
        return mod

    def _fix(self):
        """
        The overall logic for fixing a bunch of mods

        For finding out which folders may contain mods, this function:
            #. recursively searches all folders from where the :attr:`RemapService.path` is located
            #. for every .ini file in a valid mod and every Blend.buf file encountered that is encountered, recursively search all the folders from where the .ini file or Blend.buf file is located

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`
        """

        if (self.__errorsBeforeFix is not None):
            raise self.__errorsBeforeFix

        if (self.fixOnly and self.undoOnly):
            raise ConflictingOptions([CommandOpts.FixOnly.value, CommandOpts.Revert.value])

        parentFolder = os.path.dirname(self._path)
        self._loggerBasePrefix = os.path.basename(self._path)
        self.logger.prefix = os.path.basename(FilePathConsts.DefaultPath)

        visitedDirs = set()
        visitingDirs = set()
        gotNeighbours = set()
        dirs = deque()
        dirs.append(self._path)
        visitingDirs.add(self._path)

        OrderedSet = GlobalPackageManager.get(PackageModules.OrderedSet.value).OrderedSet
    
        while (dirs):
            path = dirs.pop()
            fixedMod = False

            # skip if the directory has already been visited
            if (path in visitedDirs):
                visitingDirs.remove(path)
                visitedDirs.add(path)
                continue 
            
            self.logger.split()

            # get the relative path to where the program runs
            self.logger.prefix = FileService.getRelPath(path, parentFolder)

            # try to make the mod, skip if cannot be made
            try:
                mod = self.createMod(path = path)
            except Exception as e:
                visitingDirs.remove(path)
                visitedDirs.add(path)
                continue
            
            # fix the mod
            try:
                fixedMod = self.fixMod(mod, flushIfTemplates = False)
            except Exception as e:
                self.logger.handleException(e)
                if (mod.inis):
                    self.stats.mod.addSkipped(path, e, modFolder = path)

            # get all the folders that could potentially be other mods
            modDirs = []
            if (path not in gotNeighbours):
                modFiles, modDirs = FileService.getFilesAndDirs(path = path, recursive = True)

            gotNeighbours.update(set(modDirs))

            if (mod.inis):
                iniModDirs = OrderedSet([])

                for iniPath in mod.inis:
                    ini = mod.inis[iniPath]
                    currentIniModDirs = ini.getReferencedFolders()

                    for folder in currentIniModDirs:
                        iniModDirs.add(folder)

                modDirs += list(iniModDirs)
            
            # add in all the folders that need to be visited
            for dir in modDirs:
                if (dir in visitedDirs):
                    continue

                if (dir not in visitingDirs):
                    dirs.append(dir)
                visitingDirs.add(dir)

            # increment the count of mods found
            if (fixedMod):
                self.stats.mod.addFixed(path)

            visitingDirs.remove(path)
            visitedDirs.add(path)

        self.logger.split()
        self.logger.prefix = self._loggerBasePrefix
        self.reportSkippedMods()
        self.logger.space()
        self.reportSummary()


    def fix(self):
        """
        Fixes a bunch of mods

        see :meth:`_fix` for more info
        """
        
        try:
            self._fix()
        except Exception as e:
            if (self.handleExceptions):
                self.logger.handleException(e)
            else:
                self.createLog()
                raise e from e
        else:
            noErrors = bool(not self.stats.mod.skipped and not self.stats.blend.skippedByMods)

            if (noErrors):
                self.logger.space()
                self.logger.log("ENJOY")

            self.logger.split()

            if (noErrors):
                self.addTips()

        self.createLog()


def remapMain():

    command = CommandBuilder()
    command.addEpilog(ModTypes.getHelpStr())

    args = command.parse()
    readAllInis = args.all
    defaultType = args.defaultType
    forcedType = args.forceType

    remapService = RemapService(path = args.src, keepBackups = not args.deleteBackup, fixOnly = args.fixOnly, hideOrig = args.hideOriginal,
                                undoOnly = args.undo, readAllInis = readAllInis, types = args.types, defaultType = defaultType, forcedType = forcedType,
                                log = args.log, verbose = True, handleExceptions = True, remappedTypes = args.remappedTypes,
                                version = args.version, proxy = args.proxy, downloadMode = args.download)
    remapService.fix()
    remapService.logger.waitExit()


# Main Driver Code
if __name__ == "__main__":
    remapMain()

########### END OF AUTO-GENERATED SCRIPT ###########