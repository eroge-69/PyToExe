import tkinter as tk
from tkinter import messagebox
import random

# Группировка вопросов по разделам
sections = {
    "Создание и изменение объектов метаданных": [],
    "Код-стиль и модули": [],
    "Запросы": [],
    "Документирование кода": []
}

# Вопросы с разделением по разделам
quiz_data = [
    # Раздел 1: Создание и изменение объектов метаданных
    {"question": "Что такое объект метаданных в 1С?", 
     "options": [
         "Физическая таблица базы данных",
         "Описание структуры данных и логики",
         "Пользовательский интерфейс",
         "Внешняя обработка"
     ], "answer": 1},
    {"question": "Какое назначение у регистра сведений?", 
     "options": [
         "Хранить историю изменений данных",
         "Хранить статичные данные без истории",
         "Хранить сведения для быстрого поиска",
         "Хранить информацию о событиях"
     ], "answer": 2},
    {"question": "Как создаётся новый справочник?", 
     "options": [
         "Через конфигуратор, выбирая тип "Справочник"",
         "Через код на языке 1С",
         "Автоматически при добавлении элемента",
         "Нельзя создавать новые справочники"
     ], "answer": 0},
    {"question": "Что такое форма объекта?", 
     "options": [
         "Набор данных в таблице",
         "Интерфейс для взаимодействия с пользователем",
         "Запрос к базе данных",
         "Отчёт"
     ], "answer": 1},
    {"question": "Какой тип объекта метаданных используется для регистрации операций?", 
     "options": [
         "Документ",
         "Справочник",
         "Регистр сведений",
         "План видов характеристик"
     ], "answer": 0},
    {"question": "Что означает 'периодичность' у регистра накопления?", 
     "options": [
         "Время обновления данных",
         "Промежуток времени для учёта изменений",
         "Тип операции (приход/расход)",
         "Способ группировки данных"
     ], "answer": 1},
    {"question": "Можно ли создавать внешние обработки в конфигураторе?", 
     "options": [
         "Да, это стандартный объект",
         "Нет, только в режиме пользователя",
         "Только в управляемом приложении",
         "Внешние обработки создаются отдельно"
     ], "answer": 0},
    {"question": "Что такое план видов характеристик?", 
     "options": [
         "Объект для хранения параметров и признаков",
         "Отчёт по данным",
         "Справочник по сотрудникам",
         "Тип документа"
     ], "answer": 0},
    {"question": "Как изменить структуру существующего объекта метаданных?", 
     "options": [
         "Изменить конфигурацию в конфигураторе и обновить базу",
         "Изменить данные в базе напрямую",
         "Написать обработку изменения",
         "Нельзя изменить"
     ], "answer": 0},
    {"question": "Для чего используются планы видов расчёта?", 
     "options": [
         "Для настройки расчётов зарплаты и других значений",
         "Для хранения пользовательских данных",
         "Для построения форм",
         "Для управления правами доступа"
     ], "answer": 0},

    # Раздел 2: Код-стиль и модули
    {"question": "Какой стиль именования рекомендуют для переменных в 1С?", 
     "options": [
         "CamelCase",
         "snake_case",
         "PascalCase",
         "Заглавными буквами"
     ], "answer": 1},
    {"question": "Что означает префикс '_' в имени переменной?", 
     "options": [
         "Переменная является приватной",
         "Переменная является глобальной",
         "Переменная временная",
         "Нет особого значения"
     ], "answer": 0},
    {"question": "Где лучше всего хранить общие процедуры и функции?", 
     "options": [
         "В модуле объекта",
         "В общем модуле",
         "В модуле формы",
         "В модуле отчёта"
     ], "answer": 1},
    {"question": "Как оформлять комментарии к коду в 1С?", 
     "options": [
         "Только однострочные комментарии //",
         "Только многострочные /* */",
         "Однострочные // и многострочные /* */",
         "Комментарии не используются"
     ], "answer": 2},
    {"question": "Какая рекомендация по длине строк кода?", 
     "options": [
         "Не более 120 символов",
         "Не более 80 символов",
         "Не более 200 символов",
         "Не ограничено"
     ], "answer": 0},
    {"question": "Как нужно именовать процедуры?", 
     "options": [
         "С глаголом в начале",
         "С существительным в начале",
         "С прилагательным в начале",
         "Без ограничений"
     ], "answer": 0},
    {"question": "Что лучше использовать для повторного кода?", 
     "options": [
         "Копировать и вставлять",
         "Создавать общие процедуры и функции",
         "Писать всё заново",
         "Использовать макросы"
     ], "answer": 1},
    {"question": "Какую роль выполняют модули объектов?", 
     "options": [
         "Хранят пользовательские данные",
         "Содержат логику работы с объектом",
         "Отвечают за интерфейс",
         "Обрабатывают ошибки"
     ], "answer": 1},
    {"question": "Что такое обработка исключений в 1С?", 
     "options": [
         "Специальный объект конфигурации",
         "Механизм перехвата ошибок",
         "Встроенный тип данных",
         "Отчёт о работе программы"
     ], "answer": 1},
    {"question": "Как правильно использовать отступы в 1С?", 
     "options": [
         "4 пробела или табуляция (стиль един)",
         "Без отступов",
         "2 пробела",
         "Отступы не важны"
     ], "answer": 0},

    # Раздел 3: Запросы
    {"question": "Что такое запрос в 1С?", 
     "options": [
         "Процедура обработки данных",
         "Язык выборки данных из базы",
         "Интерфейс пользователя",
         "Обработка ошибок"
     ], "answer": 1},
    {"question": "Какие ключевые слова есть в запросах 1С?", 
     "options": [
         "SELECT, FROM, WHERE, GROUP BY",
         "IF, ELSE, END",
         "FOR, WHILE, DO",
         "CASE, WHEN, THEN"
     ], "answer": 0},
    {"question": "Как объединить две таблицы в запросе?", 
     "options": [
         "Использовать JOIN",
         "Использовать UNION",
         "Использовать GROUP BY",
         "Использовать HAVING"
     ], "answer": 0},
    {"question": "Что такое параметр запроса?", 
     "options": [
         "Значение, передаваемое в запрос извне",
         "Колонка таблицы",
         "Результат выполнения запроса",
         "Объект метаданных"
     ], "answer": 0},
    {"question": "Как ограничить выборку данных?", 
     "options": [
         "Использовать WHERE",
         "Использовать SELECT",
         "Использовать FROM",
         "Использовать ORDER BY"
     ], "answer": 0},
    {"question": "Что означает оператор GROUP BY?", 
     "options": [
         "Группировка строк по значению",
         "Фильтрация данных",
         "Сортировка данных",
         "Объединение таблиц"
     ], "answer": 0},
    {"question": "Как получить сумму значений по группе?", 
     "options": [
         "Использовать функцию SUM",
         "Использовать функцию COUNT",
         "Использовать функцию AVG",
         "Использовать функцию MIN"
     ], "answer": 0},
    {"question": "Что такое подзапрос?", 
     "options": [
         "Запрос внутри другого запроса",
         "Отдельный запрос",
         "Отчёт",
         "Процедура"
     ], "answer": 0},
    {"question": "Как сортировать данные в запросе?", 
     "options": [
         "Использовать ORDER BY",
         "Использовать WHERE",
         "Использовать GROUP BY",
         "Использовать HAVING"
     ], "answer": 0},
    {"question": "Что такое HAVING?", 
     "options": [
         "Условие для групп",
         "Условие для строк",
         "Агрегатная функция",
         "Объединение таблиц"
     ], "answer": 0},

    # Раздел 4: Документирование кода
    {"question": "Для чего нужно документировать код?", 
     "options": [
         "Чтобы другие могли понять логику",
         "Для ускорения работы программы",
         "Чтобы уменьшить размер файла",
         "Для оформления отчётов"
     ], "answer": 0},
    {"question": "Как оформлять заголовок процедуры?", 
     "options": [
         "Кратко описывать назначение и параметры",
         "Писать только имя процедуры",
         "Не писать ничего",
         "Писать полный текст процедуры"
     ], "answer": 0},
    {"question": "Какие стандарты для комментариев существуют?", 
     "options": [
         "Однострочные и многострочные",
         "Только однострочные",
         "Только многострочные",
         "Комментарии не нужны"
     ], "answer": 0},
    {"question": "Что писать в описании параметров процедуры?", 
     "options": [
         "Тип, назначение и возможные значения",
         "Только тип",
         "Только назначение",
         "Не писать"
     ], "answer": 0},
    {"question": "Как часто нужно обновлять документацию?", 
     "options": [
         "При каждом изменении кода",
         "Раз в год",
         "Только при релизе",
         "Не обновлять"
     ], "answer": 0},
    {"question": "Для чего служат TODO комментарии?", 
     "options": [
         "Для обозначения задач на доработку",
         "Для отметки ошибок",
         "Для описания структуры данных",
         "Для тестирования"
     ], "answer": 0},
    {"question": "Что лучше использовать для описания алгоритмов?", 
     "options": [
         "Комментарии и документацию",
         "Отдельный текстовый файл",
         "Никак не описывать",
         "Встроенные отчёты"
     ], "answer": 0},
    {"question": "Какой стиль документации предпочтителен?", 
     "options": [
         "Краткий и понятный",
         "Очень подробный",
         "Минимальный",
         "Без комментариев"
     ], "answer": 0},
    {"question": "Какие ошибки могут быть из-за отсутствия документации?", 
     "options": [
         "Непонимание кода и ошибки при доработке",
         "Уменьшение производительности",
         "Увеличение размера базы",
         "Потеря данных"
     ], "answer": 0},
    {"question": "Что делать с устаревшей документацией?", 
     "options": [
         "Обновлять или удалять",
         "Оставлять без изменений",
         "Игнорировать",
         "Удалять полностью"
     ], "answer": 0}
]

# Распределяем вопросы по разделам
for i, question in enumerate(quiz_data):
    if i < 10:
        sections["Создание и изменение объектов метаданных"].append(question)
    elif i < 20:
        sections["Код-стиль и модули"].append(question)
    elif i < 30:
        sections["Запросы"].append(question)
    else:
        sections["Документирование кода"].append(question)

class QuizApp:
    def __init__(self, master):
        self.master = master
        self.master.title("Викторина по стандартам 1С")
        self.master.geometry("750x450")

        self.section_names = list(sections.keys())

        self.section_label = tk.Label(master, text="Выберите раздел:", font=("Arial", 14))
        self.section_label.pack(pady=10)

        self.section_buttons = []
        for section in self.section_names:
            btn = tk.Button(master, text=section, width=50, font=("Arial", 12), command=lambda s=section: self.start_quiz(s))
            btn.pack(pady=5)
            self.section_buttons.append(btn)

        self.question_label = tk.Label(master, text="", wraplength=700, font=("Arial", 14))
        self.buttons = []
        for i in range(4):
            btn = tk.Button(master, text="", width=70, font=("Arial", 12), command=lambda i=i: self.check_answer(i))
            self.buttons.append(btn)

        self.reset_quiz()

    def reset_quiz(self):
        self.current_question = 0
        self.score = 0
        self.questions = []
        self.correct_index = -1

    def start_quiz(self, section):
        self.reset_quiz()
        self.questions = sections[section]
        random.shuffle(self.questions)

        # Скрыть выбор разделов
        self.section_label.pack_forget()
        for btn in self.section_buttons:
            btn.pack_forget()

        # Показать интерфейс викторины
        self.question_label.pack(pady=20)
        for btn in self.buttons:
            btn.pack(pady=5)

        self.show_question()

    def show_question(self):
        q = self.questions[self.current_question]
        self.question_label.config(text=f"Вопрос {self.current_question + 1}: {q['question']}")

        options = q["options"][:]
        self.correct_index = q["answer"]
        correct_option = options[self.correct_index]
        random.shuffle(options)
        self.shuffled_correct_index = options.index(correct_option)

        for i in range(4):
            self.buttons[i].config(text=options[i])

    def check_answer(self, selected):
        if selected == self.shuffled_correct_index:
            self.score += 1

        self.current_question += 1
        if self.current_question < len(self.questions):
            self.show_question()
        else:
            messagebox.showinfo("Результат", f"Вы ответили правильно на {self.score} из {len(self.questions)} вопросов.")
            self.master.quit()

if __name__ == "__main__":
    root = tk.Tk()
    app = QuizApp(root)
    root.mainloop()
