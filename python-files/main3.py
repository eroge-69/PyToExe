import requests, tkinter as tk, customtkinter as ctk
import datetime, json, os
from tkinter import messagebox
import google.generativeai as genai
from openai import OpenAI
from dateutil import parser

# =====================
# API KEYS
# =====================
FOOTBALL_API_KEY = "cb27b6c89dd5ef422d529a3c23e6a208"
GEMINI_API_KEY = "AIzaSyCIpHtAUohjYf5fcpHndnSgF4SGtKEDReA"
genai.configure(api_key=GEMINI_API_KEY)
OPENROUTER_API_KEY = "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"
openrouter_client = OpenAI(base_url="https://openrouter.ai/api/v1", api_key=OPENROUTER_API_KEY)

HISTORY_FILE = "predictions_history.json"

# =====================
# Football API
# =====================
class FootballAPI:
    def __init__(self, api_key):
        self.base_url = "https://v3.football.api-sports.io"
        self.headers = {"x-apisports-key": api_key}

    def get_today_fixtures(self):
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        r = requests.get(
            f"{self.base_url}/fixtures?date={today}&timezone=Europe/Istanbul",
            headers=self.headers
        ).json()
        return r.get("response", [])

    def get_live_fixtures(self):
        r = requests.get(
            f"{self.base_url}/fixtures?live=all&timezone=Europe/Istanbul",
            headers=self.headers
        ).json()
        return r.get("response", [])

# =====================
# AI Predictor
# =====================
class AIPredictor:
    def __init__(self, api, model="gemini-flash"):
        self.api, self.model = api, model

    def _call(self, prompt):
        if self.model.startswith("gemini"):
            mname = "gemini-2.5-flash" if self.model=="gemini-flash" else "gemini-2.5-pro"
            resp = genai.GenerativeModel(mname).generate_content(prompt)
            return resp.text
        response = openrouter_client.chat.completions.create(
            model="openai/gpt-4.1-mini",
            messages=[{"role":"system","content":"Profesyonel futbol bahis analisti."},
                      {"role":"user","content":prompt}],
            temperature=0.3, max_tokens=1200)
        return getattr(response.choices[0].message, "content", "‚ö† Yanƒ±t alƒ±namadƒ±.")

    def analyze(self, fixtures):
        results = []
        for f in fixtures:
            prompt = f"""
Ma√ß: {f['teams']['home']['name']} vs {f['teams']['away']['name']}
G√∂rev:
1. Son 5 ma√ß formunu ‚úÖ ‚ùå ‚õî ile tablo halinde yaz.
2. Head-to-Head ge√ßmi≈üini yaz.
3. Kƒ±sa uzman yorumu ekle.
4. A≈üaƒüƒ±daki t√ºm pazarlar i√ßin % olasƒ±lƒ±k ver ve renklendir (üü¢ ‚â•70, üü° 40-69, üî¥ <40).
MS1, MSX, MS2, 2.5 Alt, 2.5 √úst, KG VAR, KG YOK...
"""
            try:
                ai_text = self._call(prompt)
                results.append((f, ai_text))
                self.save_history(f, ai_text)
            except Exception as e:
                results.append((f, f"‚ö† Hata: {e}"))
        return results

    def save_history(self, fixture, text):
        data = {
            "date": datetime.datetime.now().strftime("%Y-%m-%d %H:%M"),
            "match": f"{fixture['teams']['home']['name']} vs {fixture['teams']['away']['name']}",
            "league": fixture["league"]["name"],
            "analysis": text
        }
        if os.path.exists(HISTORY_FILE):
            with open(HISTORY_FILE,"r",encoding="utf-8") as f:
                history = json.load(f)
        else:
            history = []
        history.append(data)
        if len(history) > 500:  # max 500 kayƒ±t
            history = history[-500:]
        with open(HISTORY_FILE,"w",encoding="utf-8") as f:
            json.dump(history,f,indent=2,ensure_ascii=False)

# =====================
# Uygulama
# =====================
class App:
    def __init__(self, root):
        self.api = FootballAPI(FOOTBALL_API_KEY)
        self.match_vars, self.last_scores = {}, {}
        self.live_visible = tk.BooleanVar(value=True)

        root.title("PredictAI HexPro - G√ºnl√ºk Ma√ßlar")
        root.geometry("1700x950")

        # Sol panel
        p1 = ctk.CTkFrame(root, width=220)
        p1.pack(side="left", fill="y", padx=5, pady=5)
        ctk.CTkLabel(p1, text="‚öôÔ∏è Ayarlar").pack(pady=10)
        self.model_var = tk.StringVar(value="gemini-flash")
        ctk.CTkOptionMenu(p1, values=["gemini-flash","gemini-pro","openrouter"], variable=self.model_var,
                          command=self.model_warning).pack(pady=10)
        ctk.CTkButton(p1, text="üìÖ Bug√ºnk√º Ma√ßlarƒ± Listele", command=self.list_fixtures).pack(pady=10)
        ctk.CTkButton(p1, text="‚öΩ Se√ßilenleri Analiz Et", command=self.load_selected).pack(pady=10)
        ctk.CTkButton(p1, text="üëë Kim Kazanƒ±r?", command=self.who_wins).pack(pady=10)
        ctk.CTkButton(p1, text="üìÇ Ge√ßmi≈ü Tahminleri G√∂ster", command=self.show_history).pack(pady=10)
        ctk.CTkCheckBox(p1, text="‚ö° Canlƒ± Ma√ßlarƒ± G√∂ster", variable=self.live_visible, command=self.list_fixtures).pack(pady=10)

        # Orta panel - ma√ß listesi
        p2 = ctk.CTkFrame(root, width=500)
        p2.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        ctk.CTkLabel(p2, text="üìå Bug√ºnk√º Ma√ßlar").pack(pady=5)

        self.can = tk.Canvas(p2, bg="#1e1e1e", highlightthickness=0)
        self.sb_y = tk.Scrollbar(p2, orient="vertical", command=self.can.yview)
        self.scroll_frame = ctk.CTkFrame(self.can, fg_color="transparent")
        self.scroll_frame.bind("<Configure>", lambda e: self.can.configure(scrollregion=self.can.bbox("all")))
        self.can.create_window((0,0), window=self.scroll_frame, anchor="nw")
        self.can.configure(yscrollcommand=self.sb_y.set)
        self.can.pack(side="left", fill="both", expand=True)
        self.sb_y.pack(side="right", fill="y")

        # Saƒü panel - analizler
        p3 = ctk.CTkFrame(root, width=800)
        p3.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        ctk.CTkLabel(p3, text="ü§ñ Tahmin & Analizler").pack(pady=5)
        self.analysis_box = ctk.CTkTextbox(p3, wrap="word", font=("Segoe UI",13))
        self.analysis_box.pack(fill="both", expand=True, padx=10, pady=10)

        # Emoji renk taglarƒ±
        self.analysis_box.tag_config("green", foreground="lime")
        self.analysis_box.tag_config("yellow", foreground="gold")
        self.analysis_box.tag_config("red", foreground="tomato")

        # Canlƒ± g√ºncelleme ba≈ülat
        self.refresh_live()

    def model_warning(self, choice):
        if choice.startswith("gemini"):
            messagebox.showinfo("Uyarƒ±", "Bu modelde sonu√ßlar 1‚Äì3 dk s√ºrebilir.")
        elif choice == "openrouter":
            messagebox.showinfo("Uyarƒ±", "Bu modelde sonu√ßlar 1‚Äì2 dk s√ºrebilir.")

    def list_fixtures(self):
        for w in self.scroll_frame.winfo_children():
            w.destroy()
        self.match_vars = {}

        # Canlƒ± ma√ßlar
        if self.live_visible.get():
            live = self.api.get_live_fixtures()
            if live:
                header = ctk.CTkLabel(self.scroll_frame, text="‚ö° CANLI MA√áLAR",
                                      font=("Segoe UI", 14, "bold"), text_color="orange")
                header.pack(anchor="w", pady=5)
                for f in live:
                    dt = parser.parse(f["fixture"]["date"])
                    date_str = dt.strftime("%d.%m.%Y %H:%M")
                    hs, as_ = f["goals"]["home"], f["goals"]["away"]
                    home, away = f["teams"]["home"]["name"], f["teams"]["away"]["name"]
                    minute = f["fixture"]["status"]["elapsed"]

                    var = tk.BooleanVar()
                    cb = ctk.CTkCheckBox(self.scroll_frame,
                        text=f"{date_str}  {home} {hs}-{as_} {away}  CANLI {minute}'",
                        font=("Segoe UI", 13), text_color="red", variable=var)
                    cb.pack(anchor="w", pady=2)
                    self.match_vars[f["fixture"]["id"]] = (var, f)

        # G√ºnl√ºk ma√ßlar - filtre
        matches = self.api.get_today_fixtures()
        leagues_filter = ["UEFA Champions League", "UEFA Europa League", "World Cup", "S√ºper Lig", "1. Lig", "2. Lig", "3. Lig"]
        for f in matches:
            if not any(l in f["league"]["name"] for l in leagues_filter):
                continue
            dt = parser.parse(f["fixture"]["date"])
            date_str = dt.strftime("%d.%m.%Y %H:%M")
            home, away = f["teams"]["home"]["name"], f["teams"]["away"]["name"]

            var = tk.BooleanVar()
            cb = ctk.CTkCheckBox(self.scroll_frame,
                text=f"{date_str}  {home} - {away}",
                font=("Segoe UI", 13),
                text_color="white", variable=var)
            cb.pack(anchor="w", padx=20, pady=2)
            self.match_vars[f["fixture"]["id"]] = (var, f)

    def refresh_live(self):
        try:
            live = self.api.get_live_fixtures()
            for f in live:
                fid = f["fixture"]["id"]
                hs, as_ = f["goals"]["home"], f["goals"]["away"]
                score = f"{hs}-{as_}"
                if fid in self.last_scores and self.last_scores[fid] != score:
                    messagebox.showinfo("‚öΩ Gol!", f"{f['teams']['home']['name']} {hs}-{as_} {f['teams']['away']['name']}")
                self.last_scores[fid] = score
        except: pass
        self.list_fixtures()
        self.can.after(30000, self.refresh_live)

    def load_selected(self):
        selected = [f for fid,(var,f) in self.match_vars.items() if var.get()]
        if not selected:
            messagebox.showwarning("Uyarƒ±", "Hi√ß ma√ß se√ßmedin!")
            return

        preds = AIPredictor(self.api, model=self.model_var.get()).analyze(selected)
        self.analysis_box.delete("1.0","end")
        for f, text in preds:
            self.analysis_box.insert("end", f"\nüìå {f['teams']['home']['name']} vs {f['teams']['away']['name']} ({f['league']['name']})\n", "bold")
            # emoji renklendirme
            for line in text.splitlines():
                if "üü¢" in line:
                    self.analysis_box.insert("end", line+"\n", "green")
                elif "üü°" in line:
                    self.analysis_box.insert("end", line+"\n", "yellow")
                elif "üî¥" in line:
                    self.analysis_box.insert("end", line+"\n", "red")
                else:
                    self.analysis_box.insert("end", line+"\n")
            self.analysis_box.insert("end", "\n")

    def who_wins(self):
        selected = [f for fid,(var,f) in self.match_vars.items() if var.get()]
        if not selected:
            messagebox.showwarning("Uyarƒ±", "Hi√ß ma√ß se√ßmedin!")
            return

        predictor = AIPredictor(self.api, model=self.model_var.get())
        self.analysis_box.delete("1.0","end")
        for f in selected:
            prompt = f"""
Ma√ß: {f['teams']['home']['name']} vs {f['teams']['away']['name']}
Tahmin: MS1, MSX, MS2 y√ºzdelik daƒüƒ±lƒ±mƒ± ver.
"""
            result = predictor._call(prompt)
            self.analysis_box.insert("end", f"\nüëë {f['teams']['home']['name']} vs {f['teams']['away']['name']}\n")
            self.analysis_box.insert("end", result + "\n\n")

    def show_history(self):
        if not os.path.exists(HISTORY_FILE):
            messagebox.showinfo("Ge√ßmi≈ü", "Hen√ºz tahmin kaydedilmedi.")
            return
        with open(HISTORY_FILE,"r",encoding="utf-8") as f:
            history = json.load(f)
        self.analysis_box.delete("1.0","end")
        self.analysis_box.insert("end", "üìÇ GE√áMƒ∞≈û TAHMƒ∞NLER\n\n")
        for h in history[-10:]:
            self.analysis_box.insert("end", f"{h['date']} | {h['match']} ({h['league']})\n")
            self.analysis_box.insert("end", h['analysis'] + "\n\n")

# =====================
# √áalƒ±≈ütƒ±r
# =====================
if __name__ == "__main__":
    ctk.set_appearance_mode("dark"); ctk.set_default_color_theme("blue")
    root = ctk.CTk()
    App(root)
    root.mainloop()
