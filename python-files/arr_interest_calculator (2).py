
#!/usr/bin/env python3
"""
ARR Interest Calculator (SONIA / SOFR) - Lookback, Compounded-in-Arrears

Usage:
  Run the script and follow the prompts.

What it does:
  • Reads a CSV of daily SONIA or SOFR rates (date in first column, rate in second).
  • Computes interest for an interest period using *compounded in arrears* with a
    business-day lookback (without observation shift), which is the market convention
    recommended for loans.
  • Assumes day count ACT/365F for SONIA and ACT/360 for SOFR.
  • Lets you add a **Margin** and a **Credit Adjustment Spread (CAS)** (both per annum).
    These are **not compounded**; they are added after compounding the RFR and applied
    using the day-count fraction over the interest period.
  • Supports a **single margin change** during the interest period (step-up/step-down):
    from an effective date (inclusive), the new margin applies; before that date, the
    original margin applies.

Notes:
  • Rates may be given as percents (e.g., 5.12) or decimals (e.g., 0.0512). Both are accepted.
  • The CSV’s first column must be the effective date (YYYY-MM-DD). The second column
    must be the daily rate. Extra columns are ignored.
  • The CSV implicitly defines the “business days” calendar (rows present ⇒ business day).
  • Lookback is in *business days* (>= 1). For each calendar day in the accrual period,
    the script uses the rate from (that day’s prior business day shifted back by `lookback`). 
  • Interest amount = Principal × [ (CompoundedFactor − 1)  +  (Margin + CAS) × (dc/N) ],
    where Margin (and optional MarginAfterChange) and CAS are per annum and are NOT compounded.

Limitations:
  • Floors, lockout days, observation shift, multiple margin steps, and payment lag are NOT included but can be added.

Author: Generated by ChatGPT
License: MIT
"""
import csv
from datetime import datetime, date, timedelta
from decimal import Decimal, getcontext, ROUND_HALF_UP
from collections import OrderedDict

getcontext().prec = 34  # high precision for financial compounding

def parse_date(s: str) -> date:
    return datetime.strptime(s.strip(), "%Y-%m-%d").date()

def parse_rate_input(s: str) -> Decimal:
    """Accept decimal or percent; return decimal (e.g., 2.5 -> 0.025 if >1)."""
    x = Decimal(s.strip())
    return x / Decimal(100) if x > 1 else x

def read_rates_csv(path: str) -> OrderedDict:
    """Return OrderedDict[date -> Decimal_rate_decimal] sorted by date.
    Accepts CSV with header or no header. First column is date, second is rate.
    Rate can be a percent (e.g. 5.12) or decimal (0.0512). """
    rows = []
    with open(path, 'r', newline='') as f:
        sniffer = csv.Sniffer()
        sample = f.read(2048)
        f.seek(0)
        try:
            dialect = sniffer.sniff(sample) if sample else csv.excel
        except csv.Error:
            dialect = csv.excel
        reader = csv.reader(f, dialect)
        # Try to skip header if the first cell is not a date
        peek = next(reader, None)
        def is_date_str(x):
            try:
                parse_date(x)
                return True
            except Exception:
                return False
        if peek is not None and not (len(peek) >= 2 and is_date_str(peek[0])):
            # treat as header, move on
            pass
        else:
            if peek is not None:
                rows.append(peek)
        for row in reader:
            if not row or len(row) < 2:
                continue
            rows.append(row)
    dmap = {}
    for r in rows:
        try:
            d = parse_date(r[0])
        except Exception:
            continue
        try:
            raw = Decimal(str(r[1]).strip())
        except Exception:
            continue
        # If given as percent (e.g., 5.12), convert to decimal
        rate_dec = raw / Decimal(100) if raw > 1 else raw
        dmap[d] = rate_dec
    # Order by date
    return OrderedDict(sorted(dmap.items(), key=lambda kv: kv[0]))

def previous_business_day(bdays: list[date], d: date) -> date:
    """Return the greatest business day <= d. Raise if none found."""
    # bdays is sorted ascending
    # Binary search for rightmost <= d
    lo, hi = 0, len(bdays) - 1
    ans = None
    while lo <= hi:
        mid = (lo + hi) // 2
        if bdays[mid] <= d:
            ans = bdays[mid]
            lo = mid + 1
        else:
            hi = mid - 1
    if ans is None:
        raise ValueError(f"No business day on/before {d} in the supplied CSV.")
    return ans

def shift_back_business_days(bdays_index: dict[date, int], bdays: list[date], d: date, n: int) -> date:
    """Return the business day that is n business days before business day d."""
    if d not in bdays_index:
        raise ValueError(f"{d} is not a business day in the CSV.")
    i = bdays_index[d] - n
    if i < 0:
        raise ValueError(f"CSV does not go back {n} business days before {d}. Add more history.")
    return bdays[i]

def daterange(start: date, end: date):
    """Yield dates from start (inclusive) to end (exclusive)."""
    cur = start
    while cur < end:
        yield cur
        cur = cur + timedelta(days=1)

def compute_interest_compounded_in_arrears(
    principal: Decimal,
    start: date,
    end: date,
    lookback_bdays: int,
    rates: OrderedDict,
    basis_days: int,
    margin_pa: Decimal,
    cas_pa: Decimal,
    margin_change_date: date | None = None,
    margin_pa_after: Decimal | None = None,
) -> dict:
    """Compute interest components and return a dict with details.

    - Compounds RFR daily with business-day lookback (without observation shift).
    - Adds Margin and CAS (per annum) *after* compounding, using day-count fraction.
    - Supports a single margin change on `margin_change_date` (inclusive).

    Returns dict with keys:
      interest_total, interest_rfr, interest_margin, interest_cas,
      compounded_factor, rfr_annualized, applicable_annualized_rate, dc, N,
      margin_breakdown: { 'pre': {'days': int, 'margin_pa': Decimal},
                          'post': {'days': int, 'margin_pa': Decimal, 'effective_date': date} }
    """
    if lookback_bdays < 1:
        raise ValueError("Lookback must be at least 1 business day.")
    if end <= start:
        raise ValueError("End date must be after start date.")
    bdays = list(rates.keys())
    if not bdays:
        raise ValueError("No rates found in CSV.")
    bdays_index = {bd: i for i, bd in enumerate(bdays)}

    # Ensure coverage: earliest observation needed for the first accrual day
    first_needed_bd = previous_business_day(bdays, start)
    _ = shift_back_business_days(bdays_index, bdays, first_needed_bd, lookback_bdays)

    N = Decimal(basis_days)
    C = Decimal(1)  # compounded factor for the RFR piece only

    for d in daterange(start, end):
        b = previous_business_day(bdays, d)
        obs = shift_back_business_days(bdays_index, bdays, b, lookback_bdays)
        r = rates[obs]  # decimal (e.g., 0.0512 for 5.12%)
        C *= (Decimal(1) + (r / N))

    dc = Decimal((end - start).days)  # calendar days in the accrual period
    dcf_total = dc / N

    # Margin calculation with a single step change
    pre_days = int(dc)  # default all pre if no change
    post_days = 0
    m1 = margin_pa
    m2 = margin_pa_after if margin_pa_after is not None else margin_pa
    eff = None

    if margin_change_date is not None:
        eff = margin_change_date
        if eff <= start:
            # Entire period uses new margin
            pre_days = 0
            post_days = int(dc)
            m1 = m2
        elif eff >= end:
            # Change after the period end -> ignore
            pre_days = int(dc)
            post_days = 0
            m2 = m1
        else:
            pre_days = (eff - start).days
            post_days = (end - eff).days  # eff is inclusive for 'post' segment

    dcf_pre = Decimal(pre_days) / N
    dcf_post = Decimal(post_days) / N

    interest_rfr = (C - Decimal(1)) * principal
    interest_margin = (m1 * dcf_pre + m2 * dcf_post) * principal
    interest_cas = cas_pa * dcf_total * principal
    interest_total = interest_rfr + interest_margin + interest_cas

    # Annualized representations (for display)
    rfr_annualized = (C - Decimal(1)) * (N / dc)
    # Weighted average margin over the period
    margin_pa_weighted = (m1 * dcf_pre + m2 * dcf_post) / (dcf_total if dcf_total != 0 else Decimal(1))
    applicable_annualized_rate = rfr_annualized + margin_pa_weighted + cas_pa

    return {
        "interest_total": interest_total,
        "interest_rfr": interest_rfr,
        "interest_margin": interest_margin,
        "interest_cas": interest_cas,
        "compounded_factor": C,
        "rfr_annualized": rfr_annualized,
        "applicable_annualized_rate": applicable_annualized_rate,
        "dc": int(dc),
        "N": int(N),
        "margin_breakdown": {
            "pre": {"days": pre_days, "margin_pa": m1},
            "post": {"days": post_days, "margin_pa": m2, "effective_date": eff},
        },
    }

def quantize_money(x: Decimal) -> Decimal:
    return x.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)

def main():
    print("\n=== ARR Interest Calculator (SONIA / SOFR) ===\n")
    principal = Decimal(input("Balance amount (e.g., 1000000.00): ").strip())
    start = parse_date(input("Start date (YYYY-MM-DD): ").strip())
    end = parse_date(input("End date (YYYY-MM-DD): ").strip())
    po = input("Pricing option (SONIA or SOFR): ").strip().upper()
    if po not in {"SONIA", "SOFR"}:
        raise SystemExit("Pricing option must be SONIA or SOFR.")

    lb_in = input("Lookback (business days, press Enter for default 5): ").strip()
    lookback = int(lb_in) if lb_in else 5

    margin_in = input("Margin per annum (e.g., 2.00 for 2% or 0.02): ").strip()
    cas_in = input("Credit Adjustment Spread per annum (e.g., 0.10 for 0.10% or 0.001): ").strip() or "0"
    margin_pa = parse_rate_input(margin_in)
    cas_pa = parse_rate_input(cas_in)

    # Optional margin change
    step = input("Is there a margin change during the interest period? (Y/N): ").strip().upper()
    margin_change_date = None
    margin_pa_after = None
    if step == "Y":
        m_after_in = input("New margin per annum from the effective date (e.g., 2.25 or 0.0225): ").strip()
        margin_pa_after = parse_rate_input(m_after_in)
        eff_in = input("Effective date for the new margin (YYYY-MM-DD): ").strip()
        margin_change_date = parse_date(eff_in)

    csv_path = input(f"Path to daily {po} CSV file: ").strip()
    rates = read_rates_csv(csv_path)
    basis = 365 if po == "SONIA" else 360  # ACT/365F vs ACT/360

    result = compute_interest_compounded_in_arrears(
        principal, start, end, lookback, rates, basis, margin_pa, cas_pa,
        margin_change_date=margin_change_date, margin_pa_after=margin_pa_after
    )

    print("\n--- Result ---")
    print(f"Pricing option: {po} | Basis: ACT/{basis} | Lookback applied: {lookback} business day(s)")
    print(f"Accrual period: {start} to {end} (dc={result['dc']} calendar days)")
    print(f"Compounded factor (RFR only): {result['compounded_factor']}")
    print(f"RFR annualized (compounded): {result['rfr_annualized']:.10f}")
    pre = result["margin_breakdown"]["pre"]
    post = result["margin_breakdown"]["post"]
    if (pre["days"] + post["days"]) != 0 and (post["days"] > 0):
        print(f"Margin step: {pre['days']} day(s) at {pre['margin_pa']:.6f} pa, then {post['days']} day(s) at {post['margin_pa']:.6f} pa from {post['effective_date']}")
    else:
        print(f"Margin applied for full period: {pre['margin_pa']:.6f} pa")
    print(f"Applicable annualized rate (weighted): {result['applicable_annualized_rate']:.10f}")
    print(f"Interest due - RFR component: {quantize_money(result['interest_rfr'])}")
    print(f"Interest due - Margin component: {quantize_money(result['interest_margin'])}")
    print(f"Interest due - CAS component: {quantize_money(result['interest_cas'])}")
    print(f"TOTAL interest due: {quantize_money(result['interest_total'])}\n")

if __name__ == "__main__":
    main()
