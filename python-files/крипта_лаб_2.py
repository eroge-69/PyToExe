# -*- coding: utf-8 -*-
"""Крипта лаб 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LMZccmsaOdA_RAnrcjsalEiyR9P9lVUh
"""

# feistel_net_mod4_v2.py
# Сеть Фейстеля:
# - Раунды 1–3: swap4bits(R), потом swap L<->R, XOR левой с подключом
# - Раунд 4: swap4bits(R), XOR левой с k4, но L и R не меняются местами

MASTER_KEY = "1010101011110000"  # 16-битный мастер-ключ

# --- Извлечение подключей ---
def derive_subkeys(bits16: str):
    k1 = int(bits16[0:8], 2)    # биты 0-7
    k2 = int(bits16[3:11], 2)   # биты 3-10
    k3 = int(bits16[6:14], 2)   # биты 6-13
    k4 = int(bits16[8:16], 2)   # биты 8-15
    return (k1, k2, k3, k4)

# --- Перестановка 4+4 бита ---
def swap4bits(byte):
    hi = (byte >> 4) & 0xF   # старшие 4
    lo = byte & 0xF          # младшие 4
    return (lo << 4) | hi    # меняем местами

# --- Шифрование ---
def feistel_encrypt(block16: int, key16: str) -> int:
    k1, k2, k3, k4 = derive_subkeys(key16)

    L = (block16 >> 8) & 0xFF
    R = block16 & 0xFF

    # Раунды 1–3
    for k in (k1, k2, k3):
        R_perm = swap4bits(R)
        newL = R_perm
        newR = (L ^ k) & 0xFF
        L, R = newL, newR

    # Раунд 4 (без обмена половинами)
    R = swap4bits(R)
    L = (L ^ k4) & 0xFF

    return ((L << 8) | R) & 0xFFFF

# --- Основная программа ---
if __name__ == "__main__":
    user_input = input("Введите plaintext (в hex, например 1A2B): ")
    plaintext = int(user_input, 16)   # hex → число

    ciphertext = feistel_encrypt(plaintext, MASTER_KEY)


    print(f"Plaintext  : {plaintext:04X}  ({format(plaintext, '016b')})")
    print(f"Ciphertext : {ciphertext:04X}  ({format(ciphertext, '016b')})")