# -*- coding: utf-8 -*-
"""Aditivos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DGilEE-68c4UFWs9gbM1-K2t2SkohqZH
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pandas as pd

# --- Funciones de Cálculo (Reutilizadas de la versión de consola) ---

def obtener_float_valido_gui(entry_widget, min_val=0):
    """Obtiene un float de un widget Entry y valida. Retorna valor o None."""
    try:
        valor = float(entry_widget.get())
        if valor < min_val:
            messagebox.showerror("Error de Entrada", f"El valor debe ser al menos {min_val}.")
            return None
        return valor
    except ValueError:
        messagebox.showerror("Error de Entrada", "Entrada inválida. Por favor, ingresa un número.")
        return None

def obtener_porcentaje_valido_gui(entry_widget):
    """Obtiene un porcentaje de un widget Entry y valida. Retorna valor o None."""
    valor = obtener_float_valido_gui(entry_widget, 0)
    if valor is not None:
        if 0 <= valor <= 100:
            return valor
        else:
            messagebox.showerror("Error de Entrada", "El porcentaje debe estar entre 0 y 100.")
            return None
    return None

def calcular_costo_cemento(composicion, costos_componentes, aditivo_gramos_ton=0, costo_aditivo_kg=0):
    """
    Calcula el costo por tonelada de cemento.
    Considera que el aditivo se añade a la composición base y su peso se suma.
    """
    clinker_pct, caliza_pct, yeso_pct, flyash_pct = composicion
    costo_clinker_ton, costo_caliza_ton, costo_yeso_ton, costo_flyash_ton = costos_componentes

    # Convertir porcentajes a fracciones de 1 (para 1000 kg de base)
    peso_clinker = clinker_pct / 100 * 1000 # kg
    peso_caliza = caliza_pct / 100 * 1000   # kg
    peso_yeso = yeso_pct / 100 * 1000     # kg
    peso_flyash = flyash_pct / 100 * 1000   # kg

    costo_componentes_base = (peso_clinker * costo_clinker_ton / 1000) + \
                             (peso_caliza * costo_caliza_ton / 1000) + \
                             (peso_yeso * costo_yeso_ton / 1000) + \
                             (peso_flyash * costo_flyash_ton / 1000)

    # Costo del aditivo y su peso
    costo_aditivo = (aditivo_gramos_ton / 1000) * costo_aditivo_kg # Costo por kg de aditivo * kg de aditivo por tonelada base
    peso_aditivo_kg = aditivo_gramos_ton / 1000 # Convertir gramos a kg

    peso_total_cemento_con_aditivo = 1000 + peso_aditivo_kg # kg

    costo_total = costo_componentes_base + costo_aditivo
    costo_por_tonelada_final = costo_total / (peso_total_cemento_con_aditivo / 1000) # Costo por tonelada de producto final

    return costo_por_tonelada_final, peso_total_cemento_con_aditivo

# --- Clase Principal de la Aplicación GUI ---

class CementOptimizerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Calculador y Optimizador de Costos de Cemento")
        self.root.geometry("1200x800") # Tamaño inicial de la ventana

        # Variables para almacenar datos
        self.moneda_seleccionada = tk.StringVar(value="USD")
        self.costo_total_cemento_original = 0.0
        self.composicion_base = (0, 0, 0, 0)
        self.costos_componentes_base = (0, 0, 0, 0)
        self.aditivo_gramos_ton_original = 0
        self.costo_aditivo_kg_original = 0

        # Crear un Notebook (pestañas) para organizar la interfaz
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(expand=True, fill="both", padx=10, pady=10)

        # Pestaña 1: Datos del Cemento Original
        self.frame_original_cement = ttk.Frame(self.notebook, padding="10 10 10 10")
        self.notebook.add(self.frame_original_cement, text="Datos Cemento Original")
        self.create_original_cement_widgets(self.frame_original_cement)

        # Pestaña 2: Optimización y Simulación
        self.frame_optimization = ttk.Frame(self.notebook, padding="10 10 10 10")
        self.notebook.add(self.frame_optimization, text="Optimización y Simulación")
        self.create_optimization_widgets(self.frame_optimization)

        # Configurar filas y columnas para que se expandan
        for i in range(10): # Ajustar según el número de widgets
            self.frame_original_cement.grid_rowconfigure(i, weight=1)
            self.frame_original_cement.grid_columnconfigure(i, weight=1)
            self.frame_optimization.grid_rowconfigure(i, weight=1)
            self.frame_optimization.grid_columnconfigure(i, weight=1)


    def create_original_cement_widgets(self, parent_frame):
        # Sección de Moneda
        moneda_frame = ttk.LabelFrame(parent_frame, text="Moneda", padding="10")
        moneda_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=5, padx=5)
        ttk.Label(moneda_frame, text="Selecciona la Moneda:").pack(side="left", padx=5)
        self.moneda_combo = ttk.Combobox(moneda_frame, textvariable=self.moneda_seleccionada,
                                         values=["USD", "MXN", "EUR", "GBP", "JPY"], state="readonly")
        self.moneda_combo.pack(side="left", padx=5)
        self.moneda_combo.set("USD") # Valor por defecto

        # Sección de Datos del Cemento
        cement_data_frame = ttk.LabelFrame(parent_frame, text="Datos del Cemento Original", padding="10")
        cement_data_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=5, padx=5)

        ttk.Label(cement_data_frame, text="Tipo de Cemento:").grid(row=0, column=0, sticky="w", pady=2)
        self.entry_tipo_cemento = ttk.Entry(cement_data_frame)
        self.entry_tipo_cemento.grid(row=0, column=1, sticky="ew", pady=2)

        # Composición Mineral
        comp_frame = ttk.LabelFrame(cement_data_frame, text="Composición Mineral (%)", padding="5")
        comp_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=5)

        labels = ["Clinker:", "Caliza:", "Yeso:", "Flyash:"]
        self.comp_entries = {}
        for i, text in enumerate(labels):
            ttk.Label(comp_frame, text=text).grid(row=i, column=0, sticky="w", pady=2)
            entry = ttk.Entry(comp_frame)
            entry.grid(row=i, column=1, sticky="ew", pady=2)
            self.comp_entries[text.replace(":", "").strip().lower()] = entry
            # Valores por defecto para pruebas rápidas
            if text == "Clinker:": entry.insert(0, "80")
            elif text == "Caliza:": entry.insert(0, "10")
            elif text == "Yeso:": entry.insert(0, "5")
            elif text == "Flyash:": entry.insert(0, "5")


        # Costos por Tonelada
        costos_frame = ttk.LabelFrame(cement_data_frame, text="Costos por Tonelada de Componentes", padding="5")
        costos_frame.grid(row=2, column=0, columnspan=2, sticky="ew", pady=5)

        self.costo_entries = {}
        for i, text in enumerate(labels):
            ttk.Label(costos_frame, text=f"Costo {text.replace(':', '')} / Ton:").grid(row=i, column=0, sticky="w", pady=2)
            entry = ttk.Entry(costos_frame)
            entry.grid(row=i, column=1, sticky="ew", pady=2)
            self.costo_entries[text.replace(":", "").strip().lower()] = entry
            # Valores por defecto para pruebas rápidas
            if text == "Clinker:": entry.insert(0, "100")
            elif text == "Caliza:": entry.insert(0, "10")
            elif text == "Yeso:": entry.insert(0, "20")
            elif text == "Flyash:": entry.insert(0, "15")

        # Aditivo Original
        aditivo_original_frame = ttk.LabelFrame(parent_frame, text="Aditivo Original (Opcional)", padding="10")
        aditivo_original_frame.grid(row=3, column=0, columnspan=2, sticky="ew", pady=5, padx=5)

        ttk.Label(aditivo_original_frame, text="Gramos por Ton (composición base):").grid(row=0, column=0, sticky="w", pady=2)
        self.entry_aditivo_gr_original = ttk.Entry(aditivo_original_frame)
        self.entry_aditivo_gr_original.grid(row=0, column=1, sticky="ew", pady=2)
        self.entry_aditivo_gr_original.insert(0, "0") # Default

        ttk.Label(aditivo_original_frame, text="Costo Aditivo / Kg:").grid(row=1, column=0, sticky="w", pady=2)
        self.entry_costo_aditivo_kg_original = ttk.Entry(aditivo_original_frame)
        self.entry_costo_aditivo_kg_original.grid(row=1, column=1, sticky="ew", pady=2)
        self.entry_costo_aditivo_kg_original.insert(0, "0") # Default

        # Botón de Calcular Costo Original
        btn_calc_original = ttk.Button(parent_frame, text="Calcular Costo Cemento Original", command=self.calculate_original_cost)
        btn_calc_original.grid(row=4, column=0, columnspan=2, pady=10)

        # Área de Resultados Original
        self.results_original_text = scrolledtext.ScrolledText(parent_frame, wrap=tk.WORD, height=8, width=50)
        self.results_original_text.grid(row=5, column=0, columnspan=2, sticky="nsew", pady=5, padx=5)

        # Configuración de columnas para expandirse dentro de los frames
        cement_data_frame.grid_columnconfigure(1, weight=1)
        comp_frame.grid_columnconfigure(1, weight=1)
        costos_frame.grid_columnconfigure(1, weight=1)
        aditivo_original_frame.grid_columnconfigure(1, weight=1)


    def calculate_original_cost(self):
        self.results_original_text.delete(1.0, tk.END) # Limpiar texto anterior

        # 1. Obtener Composición Mineral
        clinker = obtener_porcentaje_valido_gui(self.comp_entries['clinker'])
        caliza = obtener_porcentaje_valido_gui(self.comp_entries['caliza'])
        yeso = obtener_porcentaje_valido_gui(self.comp_entries['yeso'])
        flyash = obtener_porcentaje_valido_gui(self.comp_entries['flyash'])

        if any(x is None for x in [clinker, caliza, yeso, flyash]):
            return

        current_comp_sum = clinker + caliza + yeso + flyash
        if abs(current_comp_sum - 100) > 0.01:
            messagebox.showerror("Error de Validación", f"La suma de la composición mineral es {current_comp_sum:.2f}%. Debe sumar 100%.")
            return
        self.composicion_base = (clinker, caliza, yeso, flyash)

        # 2. Obtener Costos por Tonelada
        costo_clinker = obtener_float_valido_gui(self.costo_entries['clinker'])
        costo_caliza = obtener_float_valido_gui(self.costo_entries['caliza'])
        costo_yeso = obtener_float_valido_gui(self.costo_entries['yeso'])
        costo_flyash = obtener_float_valido_gui(self.costo_entries['flyash'])

        if any(x is None for x in [costo_clinker, costo_caliza, costo_yeso, costo_flyash]):
            return
        self.costos_componentes_base = (costo_clinker, costo_caliza, costo_yeso, costo_flyash)

        # 3. Obtener Datos del Aditivo Original
        aditivo_gr = obtener_float_valido_gui(self.entry_aditivo_gr_original)
        costo_aditivo_kg = obtener_float_valido_gui(self.entry_costo_aditivo_kg_original)

        if aditivo_gr is None or costo_aditivo_kg is None:
            return

        self.aditivo_gramos_ton_original = aditivo_gr
        self.costo_aditivo_kg_original = costo_aditivo_kg

        # 4. Calcular y Mostrar Costo Base
        self.costo_total_cemento_original, peso_final_cemento_original = calcular_costo_cemento(
            self.composicion_base,
            self.costos_componentes_base,
            self.aditivo_gramos_ton_original,
            self.costo_aditivo_kg_original
        )

        moneda = self.moneda_seleccionada.get()
        tipo_cemento = self.entry_tipo_cemento.get()

        results_text = f"--- Resumen del Cemento Original ---\n" \
                       f"Tipo de Cemento: {tipo_cemento if tipo_cemento else 'No especificado'}\n" \
                       f"Composición Mineral Base: Clinker={clinker:.2f}%, Caliza={caliza:.2f}%, Yeso={yeso:.2f}%, Flyash={flyash:.2f}%\n" \
                       f"Aditivo Original: {aditivo_gr:.2f} g/ton, Costo: {costo_aditivo_kg:.2f} {moneda}/kg\n" \
                       f"Costo por Tonelada de Cemento Final (Original): {self.costo_total_cemento_original:.2f} {moneda}/ton\n" \
                       f"Peso Total del Cemento Final (Original): {peso_final_cemento_original:.2f} kg por cada 1000 kg de composición mineral base\n"

        self.results_original_text.insert(tk.END, results_text)
        messagebox.showinfo("Cálculo Completado", "Costo del cemento original calculado. Ahora puedes ir a la pestaña 'Optimización y Simulación'.")


    def create_optimization_widgets(self, parent_frame):
        # Frame para la entrada de dosificaciones para el gráfico
        dosificaciones_frame = ttk.LabelFrame(parent_frame, text="Dosificaciones de Aditivo para Gráfico (g/ton)", padding="10")
        dosificaciones_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=5, padx=5)

        self.dosificaciones_listbox = tk.Listbox(dosificaciones_frame, height=4, width=30)
        self.dosificaciones_listbox.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        self.dosificaciones_listbox.bind("<Double-Button-1>", self.remove_dosificacion) # Doble clic para eliminar

        ttk.Label(dosificaciones_frame, text="Nueva Dosificación (g/ton):").grid(row=1, column=0, sticky="w", pady=2)
        self.entry_nueva_dosificacion_graph = ttk.Entry(dosificaciones_frame)
        self.entry_nueva_dosificacion_graph.grid(row=1, column=1, sticky="ew", pady=2)
        self.entry_nueva_dosificacion_graph.insert(0, "100") # Default para ejemplo

        btn_add_dosificacion = ttk.Button(dosificaciones_frame, text="Añadir Dosificación", command=self.add_dosificacion_for_graph)
        btn_add_dosificacion.grid(row=1, column=2, padx=5, pady=5)
        ttk.Label(dosificaciones_frame, text="(Doble clic en la lista para eliminar)").grid(row=2, column=0, columnspan=3, sticky="w", padx=5)

        dosificaciones_frame.grid_columnconfigure(1, weight=1) # Expandir campo de entrada


        # Botón para Generar Gráfico
        btn_generate_graph = ttk.Button(parent_frame, text="Generar Gráfico de Optimización", command=self.generate_optimization_graph)
        btn_generate_graph.grid(row=1, column=0, columnspan=2, pady=10)

        # Área para el gráfico
        self.graph_frame = ttk.Frame(parent_frame, borderwidth=2, relief="groove")
        self.graph_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=5, pady=5)
        self.graph_frame.grid_rowconfigure(0, weight=1)
        self.graph_frame.grid_columnconfigure(0, weight=1)

        self.fig, self.ax = plt.subplots(figsize=(10, 5))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.graph_frame)
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

        # Área de tabla de resultados
        self.table_results_text = scrolledtext.ScrolledText(parent_frame, wrap=tk.WORD, height=10, width=80)
        self.table_results_text.grid(row=3, column=0, columnspan=2, sticky="nsew", pady=5, padx=5)


        # Sección de Simulación Interactiva
        simulation_frame = ttk.LabelFrame(parent_frame, text="Simulación Interactiva", padding="10")
        simulation_frame.grid(row=4, column=0, columnspan=2, sticky="ew", pady=10, padx=5)

        ttk.Label(simulation_frame, text="Reducción Clinker Sim. (%):").grid(row=0, column=0, sticky="w", pady=2)
        self.entry_reduccion_clinker_sim = ttk.Entry(simulation_frame)
        self.entry_reduccion_clinker_sim.grid(row=0, column=1, sticky="ew", pady=2)
        self.entry_reduccion_clinker_sim.insert(0, "5")

        ttk.Label(simulation_frame, text="Dosificación Nuevo Aditivo (g/ton):").grid(row=1, column=0, sticky="w", pady=2)
        self.entry_dosificacion_aditivo_sim = ttk.Entry(simulation_frame)
        self.entry_dosificacion_aditivo_sim.grid(row=1, column=1, sticky="ew", pady=2)
        self.entry_dosificacion_aditivo_sim.insert(0, "150")

        ttk.Label(simulation_frame, text="Costo Nuevo Aditivo / Kg:").grid(row=2, column=0, sticky="w", pady=2)
        self.entry_costo_aditivo_sim = ttk.Entry(simulation_frame)
        self.entry_costo_aditivo_sim.grid(row=2, column=1, sticky="ew", pady=2)
        self.entry_costo_aditivo_sim.insert(0, "50")

        btn_run_simulation = ttk.Button(simulation_frame, text="Ejecutar Simulación", command=self.run_interactive_simulation)
        btn_run_simulation.grid(row=3, column=0, columnspan=2, pady=10)

        self.simulation_results_text = scrolledtext.ScrolledText(simulation_frame, wrap=tk.WORD, height=7, width=50)
        self.simulation_results_text.grid(row=4, column=0, columnspan=2, sticky="nsew", pady=5)

        simulation_frame.grid_columnconfigure(1, weight=1) # Expandir campos de entrada


    def add_dosificacion_for_graph(self):
        dosificacion = obtener_float_valido_gui(self.entry_nueva_dosificacion_graph, min_val=0.01) # Min 0.01 para evitar dosificaciones 0
        if dosificacion is not None:
            if str(dosificacion) not in self.dosificaciones_listbox.get(0, tk.END): # Evitar duplicados
                self.dosificaciones_listbox.insert(tk.END, str(dosificacion))
                self.entry_nueva_dosificacion_graph.delete(0, tk.END)
            else:
                messagebox.showwarning("Duplicado", "Esta dosificación ya ha sido añadida.")

    def remove_dosificacion(self, event):
        selected_indices = self.dosificaciones_listbox.curselection()
        if selected_indices:
            self.dosificaciones_listbox.delete(selected_indices[0])

    def generate_optimization_graph(self):
        if self.costo_total_cemento_original == 0.0:
            messagebox.showwarning("Datos Faltantes", "Por favor, calcula el costo del cemento original primero en la pestaña anterior.")
            self.notebook.select(self.frame_original_cement) # Cambiar a la pestaña de datos originales
            return

        dosificaciones_para_graficar_str = self.dosificaciones_listbox.get(0, tk.END)
        if not dosificaciones_para_graficar_str:
            messagebox.showwarning("Datos Faltantes", "Por favor, añade al menos una dosificación para el aditivo para generar el gráfico.")
            return

        dosificaciones_para_graficar = [float(d) for d in dosificaciones_para_graficar_str]

        self.ax.clear() # Limpiar el gráfico anterior
        reducciones_clinker_eje_x = list(range(0, 16))
        all_results = []

        clinker_base, caliza_base, yeso_base, flyash_base = self.composicion_base
        costos_componentes_base = self.costos_componentes_base
        moneda = self.moneda_seleccionada.get()

        for dosificacion_aditivo_nuevo_gr_ton in dosificaciones_para_graficar:
            costos_optimos_aditivo_curva = []
            for reduccion_pct in reducciones_clinker_eje_x:
                clinker_reducido_pct = max(0, clinker_base - reduccion_pct)
                caliza_ajustada_pct = caliza_base + (clinker_base - clinker_reducido_pct)

                composicion_ajustada = (clinker_reducido_pct, caliza_ajustada_pct, yeso_base, flyash_base)

                costo_componentes_sin_aditivo_hipotetico = (
                    (clinker_reducido_pct / 100 * 1000 * costos_componentes_base[0] / 1000) +
                    (caliza_ajustada_pct / 100 * 1000 * costos_componentes_base[1] / 1000) +
                    (yeso_base / 100 * 1000 * costos_componentes_base[2] / 1000) +
                    (flyash_base / 100 * 1000 * costos_componentes_base[3] / 1000)
                )

                peso_aditivo_nuevo_kg = dosificacion_aditivo_nuevo_gr_ton / 1000
                peso_total_cemento_nuevo = 1000 + peso_aditivo_nuevo_kg

                costo_total_deseado_por_ton_final = self.costo_total_cemento_original

                costo_optimo = 0
                if peso_aditivo_nuevo_kg == 0:
                    if reduccion_pct > 0:
                        costo_optimo = float('inf') # No se puede 'pagar' por un aditivo que no se usa y aún así cubrir el ahorro
                    else:
                        costo_optimo = 0
                else:
                    costo_optimo = (
                        (costo_total_deseado_por_ton_final * (peso_total_cemento_nuevo / 1000)) -
                        costo_componentes_sin_aditivo_hipotetico
                    ) / peso_aditivo_nuevo_kg

                costos_optimos_aditivo_curva.append(costo_optimo)
                all_results.append({
                    "Reducción Clinker (%)": reduccion_pct,
                    "Dosificación Aditivo (g/ton)": dosificacion_aditivo_nuevo_gr_ton,
                    "Clinker (%)": f"{clinker_reducido_pct:.2f}",
                    "Caliza (%)": f"{caliza_ajustada_pct:.2f}",
                    "Yeso (%)": f"{yeso_base:.2f}",
                    "Flyash (%)": f"{flyash_base:.2f}",
                    f"Costo Óptimo Aditivo ({moneda}/kg)": f"{costo_optimo:.2f}" if costo_optimo != float('inf') else "N/A",
                })
            self.ax.plot(reducciones_clinker_eje_x, costos_optimos_aditivo_curva, marker='o', linestyle='-', label=f'{dosificacion_aditivo_nuevo_gr_ton} g/ton')

        # Actualizar tabla
        df_resultados = pd.DataFrame(all_results)
        df_resultados_pivot = df_resultados.pivot_table(
            index=['Reducción Clinker (%)', 'Clinker (%)', 'Caliza (%)', 'Yeso (%)', 'Flyash (%)'],
            columns='Dosificación Aditivo (g/ton)',
            values=[f"Costo Óptimo Aditivo ({moneda}/kg)"],
            aggfunc='first'
        )
        df_resultados_pivot.columns = ['_'.join(map(str, col)).replace(' ', '_').replace('.', '_') for col in df_resultados_pivot.columns.values]
        self.table_results_text.delete(1.0, tk.END)
        self.table_results_text.insert(tk.END, "--- Tabla de Resultados de Optimización por Dosificación ---\n")
        self.table_results_text.insert(tk.END, df_resultados_pivot.to_string())

        # Configurar gráfico
        self.ax.set_title(f'Costo Óptimo del Aditivo vs. Reducción de Clinker para mantener costo original\nCosto Cemento Original: {self.costo_total_cemento_original:.2f} {moneda}/ton')
        self.ax.set_xlabel('Reducción de Clinker (%)')
        self.ax.set_ylabel(f'Costo Óptimo del Nuevo Aditivo ({moneda}/kg)')
        self.ax.grid(True)
        self.ax.axhline(0, color='gray', linestyle='--', linewidth=0.8)
        self.ax.legend(title="Dosificación de Aditivo")
        self.canvas.draw()


    def run_interactive_simulation(self):
        self.simulation_results_text.delete(1.0, tk.END)

        if self.costo_total_cemento_original == 0.0:
            messagebox.showwarning("Datos Faltantes", "Por favor, calcula el costo del cemento original primero en la pestaña 'Datos Cemento Original'.")
            self.notebook.select(self.frame_original_cement)
            return

        reduccion_clinker_sim = obtener_porcentaje_valido_gui(self.entry_reduccion_clinker_sim)
        dosificacion_aditivo_sim_gr_ton = obtener_float_valido_gui(self.entry_dosificacion_aditivo_sim)
        costo_aditivo_sim_kg = obtener_float_valido_gui(self.entry_costo_aditivo_sim)

        if any(x is None for x in [reduccion_clinker_sim, dosificacion_aditivo_sim_gr_ton, costo_aditivo_sim_kg]):
            return

        if not (0 <= reduccion_clinker_sim <= 15):
            messagebox.showerror("Error de Entrada", "La reducción de clinker para la simulación debe estar entre 0% y 15%.")
            return

        clinker_base, caliza_base, yeso_base, flyash_base = self.composicion_base
        costos_componentes_base = self.costos_componentes_base
        moneda = self.moneda_seleccionada.get()

        clinker_reducido_sim_pct = max(0, clinker_base - reduccion_clinker_sim)
        caliza_ajustada_sim_pct = caliza_base + (clinker_base - clinker_reducido_sim_pct)
        composicion_sim = (clinker_reducido_sim_pct, caliza_ajustada_sim_pct, yeso_base, flyash_base)

        costo_total_cemento_simulado, _ = calcular_costo_cemento(
            composicion_sim,
            costos_componentes_base,
            dosificacion_aditivo_sim_gr_ton,
            costo_aditivo_sim_kg
        )

        diferencia_costo = costo_total_cemento_simulado - self.costo_total_cemento_original

        sim_results_text = f"--- Resultados de la Simulación ---\n" \
                           f"Reducción de Clinker aplicada: {reduccion_clinker_sim:.2f}%\n" \
                           f"Nueva Composición: Clinker={clinker_reducido_sim_pct:.2f}%, Caliza={caliza_ajustada_sim_pct:.2f}%, Yeso={yeso_base:.2f}%, Flyash={flyash_base:.2f}%\n" \
                           f"Dosificación Nuevo Aditivo: {dosificacion_aditivo_sim_gr_ton:.2f} g/ton\n" \
                           f"Costo Nuevo Aditivo: {costo_aditivo_sim_kg:.2f} {moneda}/kg\n" \
                           f"Costo por Tonelada de Cemento Final (Simulado): {costo_total_cemento_simulado:.2f} {moneda}/ton\n"

        if diferencia_costo < 0:
            sim_results_text += f"¡Ahorro! El costo se redujo en {-diferencia_costo:.2f} {moneda}/ton respecto al costo original.\n"
        elif diferencia_costo > 0:
            sim_results_text += f"¡Incremento! El costo aumentó en {diferencia_costo:.2f} {moneda}/ton respecto al costo original.\n"
        else:
            sim_results_text += f"El costo se mantiene igual que el original. Costo equilibrado.\n"

        self.simulation_results_text.insert(tk.END, sim_results_text)


if __name__ == "__main__":
    root = tk.Tk()
    app = CementOptimizerApp(root)
    root.mainloop()