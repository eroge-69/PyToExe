# -*- coding: utf-8 -*-
"""Python Flask Backend for Mutasi Blanko App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1er3cSJtWQ_68iQDl_wbc0PEjW-4Dlp0k
"""

import os
import json
from flask import Flask, request, jsonify
from datetime import datetime
import csv
from io import StringIO

# Firebase Admin SDK imports
import firebase_admin
from firebase_admin import credentials, firestore

app = Flask(__name__)

# --- Firebase Initialization ---
# IMPORTANT: Replace this with your actual Firebase service account credentials.
# You can download a service account JSON file from your Firebase Project settings
# (Project settings -> Service accounts -> Generate new private key).
#
# Example using a JSON file:
# cred = credentials.Certificate("path/to/your/serviceAccountKey.json")
# firebase_admin.initialize_app(cred)
#
# Example using environment variables (safer in production):
# firebase_config = {
#     "type": os.environ.get("FIREBASE_TYPE"),
#     "project_id": os.environ.get("FIREBASE_PROJECT_ID"),
#     "private_key_id": os.environ.get("FIREBASE_PRIVATE_KEY_ID"),
#     "private_key": os.environ.get("FIREBASE_PRIVATE_KEY").replace('\\n', '\n'),
#     "client_email": os.environ.get("FIREBASE_CLIENT_EMAIL"),
#     "client_id": os.environ.get("FIREBASE_CLIENT_ID"),
#     "auth_uri": os.environ.get("FIREBASE_AUTH_URI"),
#     "token_uri": os.environ.get("FIREBASE_TOKEN_URI"),
#     "auth_provider_x509_cert_url": os.environ.get("FIREBASE_AUTH_PROVIDER_X509_CERT_URL"),
#     "client_x509_cert_url": os.environ.get("FIREBASE_CLIENT_X509_CERT_URL")
# }
# cred = credentials.Certificate(firebase_config)
# firebase_admin.initialize_app(cred)

# For demonstration purposes, if you run this locally without a service account,
# you might get a default app error. In a real environment, ensure Firebase is initialized.
try:
    # Attempt to initialize Firebase if not already initialized
    # This might work in some cloud environments where default credentials are provided
    firebase_admin.get_app()
except ValueError:
    # If no app is initialized, you MUST provide credentials here
    print("Firebase Admin SDK not initialized. Please provide service account credentials.")
    print("Example: cred = credentials.Certificate('path/to/your/serviceAccountKey.json')")
    print("firebase_admin.initialize_app(cred)")
    # As a fallback for local testing without a key, you might comment out the line below
    # and ensure your GOOGLE_APPLICATION_CREDENTIALS environment variable is set.
    # For this specific environment, we'll assume a default initialization is possible
    # or that the user will set up their credentials.
    firebase_admin.initialize_app()


db = firestore.client()
# Define the collection name for blanko mutations
BLANKO_COLLECTION = "blanko_mutations"

# --- Helper Functions ---

def calculate_quantity(start_serial, end_serial):
    """
    Calculates the quantity of blankos from a given serial number range.
    Assumes serial numbers are in format like 'AO00001'.
    """
    if not start_serial:
        return 0
    if not end_serial:
        return 1

    try:
        # Extract numeric part from serial numbers
        start_num_str = ''.join(filter(str.isdigit, start_serial))
        end_num_str = ''.join(filter(str.isdigit, end_serial))

        start_num = int(start_num_str)
        end_num = int(end_num_str)

        if start_num > end_num:
            return 0 # Invalid range

        return end_num - start_num + 1
    except ValueError:
        # Handle cases where parsing fails (e.g., non-numeric parts or invalid format)
        return 1 # Default to 1 if parsing fails

def format_date(timestamp):
    """Formats a Firestore Timestamp object to 'YYYY-MM-DD' string."""
    if isinstance(timestamp, firestore.SERVER_TIMESTAMP):
        # If it's still a server timestamp placeholder, return None or handle as needed
        return None
    if timestamp:
        return timestamp.strftime('%Y-%m-%d')
    return None

# --- API Endpoints ---

@app.route("/api/mutasi-masuk", methods=["POST"])
def add_mutasi_masuk():
    """
    Handles adding a new 'mutasi masuk' (inbound transfer) record.
    """
    try:
        data = request.get_json()
        nomor_seri = data.get("nomor_seri")
        nomor_seri_akhir = data.get("nomor_seri_akhir")
        tanggal = data.get("tanggal")
        nomor_ba = data.get("nomor_ba")
        penerima = data.get("penerima")
        yang_menyerahkan = data.get("yang_menyerahkan")

        if not all([nomor_seri, tanggal, nomor_ba, penerima, yang_menyerahkan]):
            return jsonify({"success": False, "error": "Missing required fields"}), 400

        jumlah_blanko = calculate_quantity(nomor_seri, nomor_seri_akhir)

        new_entry = {
            "nomor_seri_awal_masuk": nomor_seri,
            "nomor_seri_akhir_masuk": nomor_seri_akhir if nomor_seri_akhir else nomor_seri,
            "jumlah_masuk": jumlah_blanko,
            "tanggal_masuk": tanggal,
            "nomor_ba": nomor_ba,
            "penerima": penerima,
            "yang_menyerahkan": yang_menyerahkan,
            "timestamp_masuk": firestore.SERVER_TIMESTAMP,
            "status": "tersedia",
            # Initialize keluar fields as empty
            "nomor_seri_awal_keluar": "",
            "nomor_seri_akhir_keluar": "",
            "jumlah_keluar": 0,
            "tanggal_keluar": "",
            "petugas_penerima": "",
            "keperluan": "",
            "timestamp_keluar": None,
        }

        doc_ref = db.collection(BLANKO_COLLECTION).document()
        doc_ref.set(new_entry)

        # Fetch the document after it's written to get the actual timestamp
        # This is optional, but useful if you need the exact timestamp immediately
        # updated_doc = doc_ref.get()
        # if updated_doc.exists:
        #     new_entry_with_ts = updated_doc.to_dict()
        #     new_entry_with_ts['id'] = updated_doc.id

        return jsonify({"success": True, "message": "Mutasi masuk added successfully", "data": {"jumlah": jumlah_blanko}}), 201

    except Exception as e:
        print(f"Error adding mutasi masuk: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route("/api/mutasi-keluar", methods=["POST"])
def add_mutasi_keluar():
    """
    Handles adding a new 'mutasi keluar' (outbound transfer) record.
    This updates an existing 'tersedia' mutasi masuk record.
    """
    try:
        data = request.get_json()
        nomor_seri_keluar = data.get("nomor_seri")
        nomor_seri_akhir_keluar = data.get("nomor_seri_akhir")
        tanggal_keluar = data.get("tanggal")
        petugas_penerima = data.get("petugas_penerima")
        keperluan = data.get("keperluan")

        if not all([nomor_seri_keluar, tanggal_keluar, petugas_penerima, keperluan]):
            return jsonify({"success": False, "error": "Missing required fields"}), 400

        # Determine the exact range for keluar, defaulting to single if akhir is empty
        actual_nomor_seri_akhir_keluar = nomor_seri_akhir_keluar if nomor_seri_akhir_keluar else nomor_seri_keluar
        jumlah_blanko_keluar = calculate_quantity(nomor_seri_keluar, actual_nomor_seri_akhir_keluar)

        if jumlah_blanko_keluar <= 0:
            return jsonify({"success": False, "error": "Invalid blanko quantity for keluar"}), 400

        # Find a matching 'tersedia' record in Firestore
        # This assumes a simple 1:1 match for now.
        # More complex logic would involve splitting ranges if partials are issued.
        query = db.collection(BLANKO_COLLECTION).where("status", "==", "tersedia") \
                                            .where("nomor_seri_awal_masuk", "==", nomor_seri_keluar) \
                                            .where("nomor_seri_akhir_masuk", "==", actual_nomor_seri_akhir_keluar) \
                                            .limit(1)
        docs = query.get()

        if not docs:
            return jsonify({"success": False, "error": "No matching available blanko range found for this keluar transaction. Ensure the exact series range is available and not yet issued."}), 404

        doc_to_update = docs[0]
        doc_ref = db.collection(BLANKO_COLLECTION).document(doc_to_update.id)

        # Basic validation: ensure the keluar quantity doesn't exceed the masuk quantity
        if jumlah_blanko_keluar > doc_to_update.to_dict().get("jumlah_masuk", 0):
            return jsonify({"success": False, "error": "Jumlah keluar melebihi jumlah masuk yang tersedia."}), 400

        update_data = {
            "nomor_seri_awal_keluar": nomor_seri_keluar,
            "nomor_seri_akhir_keluar": actual_nomor_seri_akhir_keluar,
            "jumlah_keluar": jumlah_blanko_keluar,
            "tanggal_keluar": tanggal_keluar,
            "petugas_penerima": petugas_penerima,
            "keperluan": keperluan,
            "timestamp_keluar": firestore.SERVER_TIMESTAMP,
            "status": "keluar",
        }
        doc_ref.update(update_data)

        return jsonify({"success": True, "message": "Mutasi keluar added successfully", "data": {"jumlah": jumlah_blanko_keluar}}), 200

    except Exception as e:
        print(f"Error adding mutasi keluar: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route("/api/mutasi-records", methods=["POST"])
def get_mutasi_records():
    """
    Fetches all mutasi records, combining masuk and keluar data for display.
    """
    try:
        docs = db.collection(BLANKO_COLLECTION).order_by("timestamp_masuk", direction=firestore.Query.DESCENDING).get()
        records = []
        for doc in docs:
            data = doc.to_dict()
            record_data = {
                "id": doc.id,
                "range_masuk": f"{data['nomor_seri_awal_masuk']}-{data['nomor_seri_akhir_masuk']}" if data['nomor_seri_awal_masuk'] != data['nomor_seri_akhir_masuk'] else data['nomor_seri_awal_masuk'],
                "jumlah_masuk": data.get("jumlah_masuk", 0),
                "tanggal_masuk": format_date(data.get("timestamp_masuk")),
                "nomor_ba": data.get("nomor_ba", "-"),
                "penerima": data.get("penerima", "-"),
                "yang_menyerahkan": data.get("yang_menyerahkan", "-"),
                "range_keluar": f"{data.get('nomor_seri_awal_keluar', '')}-{data.get('nomor_seri_akhir_keluar', '')}" if data.get('nomor_seri_awal_keluar') and data.get('nomor_seri_awal_keluar') != data.get('nomor_seri_akhir_keluar') else data.get('nomor_seri_awal_keluar', ''),
                "jumlah_keluar": data.get("jumlah_keluar", 0),
                "keperluan": data.get("keperluan", "-"),
                "mutasi_keluar_id": doc.id if data.get("status") == "keluar" else None, # React uses this to determine status
                "status": data.get("status", "tersedia") # Explicit status
            }
            records.append(record_data)

        return jsonify({"success": True, "data": records}), 200

    except Exception as e:
        print(f"Error fetching mutasi records: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route("/api/mutasi-summary", methods=["POST"])
def get_mutasi_summary():
    """
    Calculates and returns summary statistics of blanko mutations.
    """
    try:
        docs = db.collection(BLANKO_COLLECTION).get()
        total_blanko_masuk = 0
        total_blanko_keluar = 0
        total_transaksi_masuk = 0
        total_transaksi_keluar = 0
        blanko_tersedia_count = 0

        for doc in docs:
            data = doc.to_dict()
            total_blanko_masuk += data.get("jumlah_masuk", 0)
            total_transaksi_masuk += 1 # Each document is one masuk transaction

            if data.get("status") == "keluar":
                total_blanko_keluar += data.get("jumlah_keluar", 0)
                total_transaksi_keluar += 1 # Each 'keluar' marked document is one keluar transaction
            else:
                blanko_tersedia_count += data.get("jumlah_masuk", 0) # Sum of blankos in 'tersedia' batches

        saldo = total_blanko_masuk - total_blanko_keluar

        summary = {
            "total_blanko_masuk": total_blanko_masuk,
            "total_blanko_keluar": total_blanko_keluar,
            "total_masuk": total_transaksi_masuk, # Number of masuk transactions
            "total_keluar": total_transaksi_keluar, # Number of keluar transactions
            "tersedia": blanko_tersedia_count, # Sum of blankos in available batches
            "saldo": saldo,
        }

        return jsonify({"success": True, "data": summary}), 200

    except Exception as e:
        print(f"Error fetching mutasi summary: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route("/api/export-csv", methods=["POST"])
def export_csv():
    """
    Exports all mutasi records to a CSV format.
    """
    try:
        docs = db.collection(BLANKO_COLLECTION).order_by("timestamp_masuk", direction=firestore.Query.ASCENDING).get()

        output = StringIO()
        writer = csv.writer(output)

        # CSV Header
        header = [
            "Range Masuk", "Jumlah Masuk", "Tanggal Masuk", "Nomor BA", "Penerima", "Yang Menyerahkan",
            "Range Keluar", "Jumlah Keluar", "Tanggal Keluar", "Petugas Penerima", "Keperluan", "Status"
        ]
        writer.writerow(header)

        record_count = 0
        for doc in docs:
            data = doc.to_dict()
            range_masuk_str = f"{data['nomor_seri_awal_masuk']}-{data['nomor_seri_akhir_masuk']}" if data['nomor_seri_awal_masuk'] != data['nomor_seri_akhir_masuk'] else data['nomor_seri_awal_masuk']
            range_keluar_str = f"{data.get('nomor_seri_awal_keluar', '')}-{data.get('nomor_seri_akhir_keluar', '')}" if data.get('nomor_seri_awal_keluar') and data.get('nomor_seri_awal_keluar') != data.get('nomor_seri_akhir_keluar') else data.get('nomor_seri_awal_keluar', '')

            row = [
                range_masuk_str,
                data.get("jumlah_masuk", 0),
                format_date(data.get("timestamp_masuk")),
                data.get("nomor_ba", "-"),
                data.get("penerima", "-"),
                data.get("yang_menyerahkan", "-"),
                range_keluar_str,
                data.get("jumlah_keluar", 0),
                format_date(data.get("timestamp_keluar")),
                data.get("petugas_penerima", "-"),
                data.get("keperluan", "-"),
                data.get("status", "tersedia")
            ]
            writer.writerow(row)
            record_count += 1

        csv_string = output.getvalue()
        output.close()

        filename = f"mutasi_blanko_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"

        return jsonify({"success": True, "data": {"csv": csv_string, "filename": filename, "recordCount": record_count}}), 200

    except Exception as e:
        print(f"Error exporting CSV: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

if __name__ == "__main__":
    # To run this Flask app locally:
    # 1. Save it as e.g., `app.py`.
    # 2. Install Flask and Firebase Admin SDK: `pip install Flask firebase-admin`
    # 3. Set your Firebase service account credentials (as explained above).
    # 4. Run: `python app.py`
    # This will typically run on http://127.0.0.1:5000/
    # You might need to configure your React app to proxy API requests to this address,
    # or deploy this Flask app to a server accessible by your React app.
    app.run(debug=True, port=5000)