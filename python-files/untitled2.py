# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IfhtOw2Aa6xr2mxskOnx1TjYW3qGiYd5
"""



"""# Task
Create an interactive notebook that allows users to input data into a "pengambilan barang" table with columns "no", "tanggal", "nama", "divisi", and "item". The notebook should also maintain a "data base" of items and their "jumlah stok". A "resume" table should be displayed alongside the "pengambilan barang" table, showing the "nama item" and the remaining stock ("sisa"), calculated as "jumlah stok" from the "data base" minus the total "item" taken from the "pengambilan barang" table for each item. The display should update automatically as data is entered.

## Set up the data structure

### Subtask:
Create a way to store the "data base" of items and their stock, and a structure to store the "pengambilan barang" entries.

**Reasoning**:
Initialize the data structures to store the "pengambilan barang" entries and the item database.
"""

pengambilan_barang = []
item_database = {
    "pensil": 100,
    "pulpen": 150,
    "penghapus": 75,
    "penggaris": 50
}

"""## Create the input form

### Subtask:
Generate code to create a user interface for entering data into the "pengambilan barang" table.

**Reasoning**:
Import ipywidgets and create the input widgets for the "pengambilan barang" table, including a Dropdown for "item" based on the `item_database` keys, a DatePicker for "tanggal", Text widgets for "nama" and "divisi", and an IntText for "no". Also, create a Button to submit the data. Finally, arrange these widgets using `VBox` and display the layout.
"""

import ipywidgets as widgets
from IPython.display import display

no_input = widgets.IntText(description='No:')
tanggal_input = widgets.DatePicker(description='Tanggal:')
nama_input = widgets.Text(description='Nama:')
divisi_input = widgets.Text(description='Divisi:')
item_input = widgets.Dropdown(options=item_database.keys(), description='Item:')
jumlah_input = widgets.IntText(description='Jumlah:') # Add the new jumlah_input here


submit_button = widgets.Button(description='Submit')
submit_button.style.button_color = 'lightgreen' # Set button color to green

form_layout = widgets.VBox([
    no_input,
    tanggal_input,
    nama_input,
    divisi_input,
    item_input,
    jumlah_input,
    submit_button
])

# The form_layout is displayed later in the notebook

"""## Display the tables

### Subtask:
Generate code to display both the "pengambilan barang" table and the "data base" table.

**Reasoning**:
Import the pandas library and create DataFrames from the existing data structures, then display them.
"""

import pandas as pd

if not pengambilan_barang:
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item"])
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)

item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

print("Pengambilan Barang Table:")
display(pengambilan_df)

print("\nItem Database Table:")
display(item_database_df)

"""## Implement the "resume" table and calculations

### Subtask:
Create a table to show the remaining stock ("sisa") for each item based on the "data base" and the "pengambilan barang" entries.

**Reasoning**:
Calculate the total quantity of each item taken, create a new DataFrame for the resume table, merge with the item database, calculate the remaining stock, and select/rename columns for display.
"""

total_taken = pengambilan_df.groupby('item').size().reset_index(name='total_taken')
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

print("\nResume Table:")
display(resume_df)

"""## Connect the input to the tables and calculations

### Subtask:
Ensure that entering data in the form updates the "pengambilan barang" table and triggers the calculation for the "resume" table.

**Reasoning**:
Define the function to handle form submission, update the dataframes, and display the results.
"""

def handle_submit(button):
    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": tanggal_input.value,
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)

    # e. Recalculate `total_taken`
    global total_taken
    total_taken = pengambilan_df.groupby('item').size().reset_index(name='total_taken')

    # f. Recalculate `resume_df`
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    from IPython.display import clear_output
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item

"""**Reasoning**:
Link the defined function to the submit button's click event.


"""

submit_button.on_click(handle_submit)

# Initial display of the form and tables
from IPython.display import clear_output
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nResume Table:")
display(resume_df)

"""## Summary:

### Data Analysis Key Findings

*   Two data structures were initialized: an empty list `pengambilan_barang` to store item withdrawal entries and a dictionary `item_database` holding initial item stock counts.
*   A user interface was successfully created using `ipywidgets` with input fields for "no", "tanggal", "nama", "divisi", and "item", including a dropdown for selecting items from the `item_database`.
*   Code was generated to display the "pengambilan barang" and "item database" as pandas DataFrames.
*   A "resume" table was successfully created and displayed, showing the remaining stock for each item by calculating the difference between the initial stock from `item_database` and the total quantity taken from `pengambilan_barang` entries.
*   A function was implemented and linked to a submit button to handle new entries. This function retrieves input values, appends them to the `pengambilan_barang` list, updates the relevant DataFrames (`pengambilan_df`, `resume_df`), recalculates the remaining stock, clears the output, and re-displays the updated tables and the form.

### Insights or Next Steps

*   Consider adding input validation to the form to ensure data integrity (e.g., check for valid item names, non-negative numbers for 'no').
*   Explore options for persistent storage of the `pengambilan_barang` data and `item_database` so the data is not lost when the notebook is closed.

# Task
Add a button and input fields to the application to allow users to add new items to the "data base" table.

## Create input form for new item

### Subtask:
Add input fields for the new item's name and its initial stock.

**Reasoning**:
Create the input widgets for adding new items to the item database.
"""

new_item_name_input = widgets.Text(description='New Item Name:')
new_item_stock_input = widgets.IntText(description='Initial Stock:')

"""## Create button for adding new item

### Subtask:
Add a button to trigger the addition of the new item to the database.

**Reasoning**:
Create a button widget to trigger the addition of a new item.
"""

add_item_button = widgets.Button(description='tambahkan')

"""## Implement function to add new item

### Subtask:
Write a function that takes the input values, adds the new item to the `item_database`, and updates the displayed tables.

**Reasoning**:
Define the function `handle_add_item` to process the new item input, update the item database and dataframes, and refresh the display.
"""

def handle_add_item(button):
    # Retrieve the values from the input widgets
    new_item_name = new_item_name_input.value
    new_item_stock = new_item_stock_input.value

    # Add the new item and its initial stock to the global item_database dictionary
    item_database[new_item_name] = new_item_stock

    # Update the global item_database_df DataFrame
    global item_database_df
    item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

    # Recalculate the global resume_df DataFrame
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Clear the current output
    clear_output(wait=True)

    # Re-display the form layout
    display(form_layout)

    # Display the updated tables
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Clear the input fields
    new_item_name_input.value = ''
    new_item_stock_input.value = 0

"""## Connect the button to the function

### Subtask:
Link the click event of the new button to the function that adds the new item.

**Reasoning**:
Link the defined function to the add item button's click event.
"""

add_item_button.on_click(handle_add_item)

"""## Update display to include new item input

### Subtask:
Arrange the new input fields and button with the existing form and tables.

**Reasoning**:
Arrange the new input fields and button with the existing form and tables by updating the VBox layout and re-displaying the layout along with the tables.
"""

form_layout = widgets.VBox([
    no_input,
    tanggal_input,
    nama_input,
    divisi_input,
    item_input,
    submit_button,
    widgets.Label("Add New Item:"),  # Add a label for clarity
    new_item_name_input,
    new_item_stock_input,
    add_item_button
])

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Summary:

### Data Analysis Key Findings

*   Input fields for adding new items (name and initial stock) were successfully created.
*   A button to trigger the addition of a new item was successfully created.
*   A function `handle_add_item` was implemented to retrieve input values, update the `item_database` dictionary and associated DataFrames (`item_database_df`, `resume_df`), clear the output, redisplay the form and tables, and clear the input fields.
*   The click event of the "Add New Item" button was successfully linked to the `handle_add_item` function.
*   The display layout was updated to include the new item input fields and button within the existing form, ensuring they are presented alongside the existing tables.

### Insights or Next Steps

*   The application now has a functional interface for adding new items to the database and immediately seeing the updated inventory status.
*   Consider adding input validation to the `handle_add_item` function to ensure that required fields are filled and that the initial stock is a valid number.

# Task
Add a button and input field to delete data from the "data base" table, and implement the corresponding functionality.

## Create input form for deleting item

### Subtask:
Add an input field (e.g., a dropdown) to select the item to be deleted from the `item_database`.

**Reasoning**:
Create a Dropdown widget to select the item to be deleted from the item database.
"""

delete_item_input = widgets.Dropdown(
    options=list(item_database.keys()),
    description='Select Item to Delete:'
)

"""## Create button for deleting item

### Subtask:
Add a button to trigger the deletion of the selected item from the database.

**Reasoning**:
Create a button widget to trigger the deletion of a selected item.
"""

delete_item_button = widgets.Button(description='hapus')

"""## Implement function to delete item

### Subtask:
Write a function that takes the selected item name, removes it from the `item_database`, and updates the displayed tables.

**Reasoning**:
Define the function to handle the deletion of an item from the item database and update the displayed tables.
"""

def handle_delete_item(button):
    # Retrieve the value of the selected item from the delete_item_input widget
    item_to_delete = delete_item_input.value

    # Check if the selected item exists as a key in the global item_database dictionary
    if item_to_delete in item_database:
        # If the item exists, remove it from the item_database dictionary using the del keyword
        del item_database[item_to_delete]

        # Update the global item_database_df DataFrame
        global item_database_df
        item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

        # Recalculate the global resume_df DataFrame
        global resume_df
        # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
        global total_taken
        # total_taken needs to be recalculated based on the *current* pengambilan_df
        total_taken = pengambilan_df.groupby('item').size().reset_index(name='total_taken')


        resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
        resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
        resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
        resume_df = resume_df[['nama item', 'sisa']]

        # Update the options of the item selection dropdown in the main form and the delete form
        item_input.options = list(item_database.keys())
        delete_item_input.options = list(item_database.keys())


        # Clear the current output
        clear_output(wait=True)

        # Re-display the form layout
        display(form_layout)

        # Display the updated tables
        print("Pengambilan Barang Table:")
        display(pengambilan_df)
        print("\nItem Database Table:")
        display(item_database_df)
        print("\nResume Table:")
        display(resume_df)

    else:
        # If the item did not exist in step 3, inform the user
        print(f"Item '{item_to_delete}' not found in the database.")

"""## Connect the button to the function

### Subtask:
Link the click event of the new button to the function that deletes the item.

**Reasoning**:
Link the defined function to the delete item button's click event.
"""

delete_item_button.on_click(handle_delete_item)

"""## Update display to include delete item input

### Subtask:
Arrange the new input fields and button with the existing form and tables.

**Reasoning**:
Arrange the new input fields and button with the existing form and tables by updating the VBox layout and re-displaying the layout along with the tables.
"""

form_layout = widgets.VBox([
    no_input,
    tanggal_input,
    nama_input,
    divisi_input,
    item_input,
    submit_button,
    widgets.Label("Add New Item:"),  # Add a label for clarity
    new_item_name_input,
    new_item_stock_input,
    add_item_button,
    widgets.Label("Delete Item:"),  # Add a label for clarity
    delete_item_input,
    delete_item_button
])

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Summary:

### Data Analysis Key Findings

*   A dropdown widget was created to select the item to be deleted, populated with existing item names from the `item_database`.
*   A button widget with the description "Delete Selected Item" was created to trigger the deletion process.
*   A Python function `handle_delete_item` was implemented to remove the selected item from the `item_database`, update the `item_database_df` and `resume_df` dataframes, and refresh the displayed tables.
*   The click event of the delete button was successfully linked to the `handle_delete_item` function.
*   The new dropdown and button for item deletion were integrated into the existing form layout and the display was updated to show the modified layout and tables.

### Insights or Next Steps

*   Consider adding a confirmation dialog before deleting an item to prevent accidental data loss.
*   Implement input validation to handle cases where the selected item might not exist in the database (although the current function checks for this, a user-facing message could be improved).

# Task
Modify the notebook to add a "jumlah" column to the "pengambilan barang" table, add an input field for "jumlah" to the data entry form, and update the "resume" table to calculate the remaining stock based on the "jumlah" taken.

## Add input field for "jumlah"

### Subtask:
Add a new input widget for the "jumlah" (quantity) to the form.

**Reasoning**:
Create an IntText widget for the "jumlah" input.
"""

jumlah_input = widgets.IntText(description='Jumlah:')

"""## Update form layout

### Subtask:
Arrange the new input field in the form layout.

**Reasoning**:
Arrange the new input field within the existing form layout and re-display the form.
"""

import ipywidgets as widgets
from IPython.display import display, clear_output
import pandas as pd

# Initialize the data structures
pengambilan_barang = []
item_database = {
    "pensil": 100,
    "pulpen": 150,
    "penghapus": 75,
    "penggaris": 50
}

# Define the input widgets
no_input = widgets.IntText(description='No:')
tanggal_input = widgets.DatePicker(description='Tanggal:')
nama_input = widgets.Text(description='Nama:')
divisi_input = widgets.Text(description='Divisi:')
item_input = widgets.Dropdown(options=item_database.keys(), description='Item:')
jumlah_input = widgets.IntText(description='Jumlah:')
submit_button = widgets.Button(description='Submit')
submit_button.style.button_color = 'lightgreen'

# Define the new item input widgets
new_item_name_input = widgets.Text(description='New Item Name:')
new_item_stock_input = widgets.IntText(description='Initial Stock:')
add_item_button = widgets.Button(description='tambahkan')

# Define the delete item input widget and button
delete_item_input = widgets.Dropdown(
    options=list(item_database.keys()),
    description='Select Item to Delete:'
)
delete_item_button = widgets.Button(description='hapus')


# Define the form layout
form_layout = widgets.VBox([
    no_input,
    tanggal_input,
    nama_input,
    divisi_input,
    item_input,
    jumlah_input, # Add the new jumlah_input here
    submit_button,
    widgets.Label("Add New Item:"),
    new_item_name_input,
    new_item_stock_input,
    add_item_button,
    widgets.Label("Delete Item:"),
    delete_item_input,
    delete_item_button
])

# Ensure `pengambilan_barang` is defined if it doesn't exist
if 'pengambilan_barang' not in globals():
    pengambilan_barang = []

# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    pengambilan_df = pengambilan_df[cols]

# Ensure `item_database` is defined if it doesn't exist
if 'item_database' not in globals():
     item_database = {
        "pensil": 100,
        "pulpen": 150,
        "penghapus": 75,
        "penggaris": 50
    }

# Update the global item_database_df DataFrame
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]


# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Modify `handle submit` function

### Subtask:
Update the function to capture the "jumlah" input and include it in the new entry for the "pengambilan barang" table.

**Reasoning**:
Modify the handle_submit function to include the 'jumlah' input value in the new entry dictionary.
"""

def handle_submit(button):
    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": tanggal_input.value,
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value # Retrieve the value from jumlah_input and add it to the dictionary
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)

    # e. Recalculate `total_taken`
    # This will be updated in the next subtask to use the 'jumlah' column
    global total_taken
    total_taken = pengambilan_df.groupby('item').size().reset_index(name='total_taken')


    # f. Recalculate `resume_df`
    # This will be updated in the next subtask to use the 'jumlah' column
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    from IPython.display import clear_output
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field

"""## Modify dataframe creation

### Subtask:
Update the code that creates the `pengambilan_df` DataFrame to include the "jumlah" column.

**Reasoning**:
Update the code that creates the `pengambilan_df` DataFrame to include the "jumlah" column when the `pengambilan_barang` list is empty.
"""

# Update the code that creates the `pengambilan_df` DataFrame
if not pengambilan_barang:
    # Ensure "jumlah" column is included when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"])
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)

# The rest of the display code from the previous cell remains the same
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Update resume table calculation

### Subtask:
Adjust the resume table calculation to use the "jumlah" column instead of just counting the rows per item.

**Reasoning**:
Modify the calculation of `total_taken` in the `handle_submit` function and for the initial display to sum the 'jumlah' column, then update the `resume_df` calculation.
"""

def handle_submit(button):
    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": tanggal_input.value,
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value # Retrieve the value from jumlah_input and add it to the dictionary
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)

    # e. Recalculate `total_taken` by summing the 'jumlah' column
    global total_taken
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')


    # f. Recalculate `resume_df` using the summed 'jumlah'
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())

    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    from IPython.display import clear_output
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field


# Update the calculation of total_taken outside the handle_submit function
total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')

# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""**Reasoning**:
The error "KeyError: 'Column not found: jumlah'" indicates that the 'jumlah' column is not present in the `pengambilan_df` DataFrame when the initial `total_taken` calculation is attempted outside the `handle_submit` function. This happens when `pengambilan_barang` is initially empty, and `pengambilan_df` is created with specified columns but no data, and the `groupby` operation is performed on an empty DataFrame which might not have the column correctly initialized or the column might be of object type which can cause issues with sum. To fix this, ensure that the 'jumlah' column exists and has a numeric type in `pengambilan_df` before performing the `groupby` and `sum` operation, especially when the DataFrame is initially empty. Also, ensure the `handle_add_item` and `handle_delete_item` functions also correctly update the `item_input.options` and `delete_item_input.options`.


"""

def handle_submit(button):
    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": tanggal_input.value,
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value # Retrieve the value from jumlah_input and add it to the dictionary
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric, defaulting to 0 if missing (though it should be present now)
    if 'jumlah' in pengambilan_df.columns:
        pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)
    else:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing

    # e. Recalculate `total_taken` by summing the 'jumlah' column
    global total_taken
    if not pengambilan_df.empty:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case


    # f. Recalculate `resume_df` using the summed 'jumlah'
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    from IPython.display import clear_output
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field

def handle_add_item(button):
    # Retrieve the values from the input widgets
    new_item_name = new_item_name_input.value
    new_item_stock = new_item_stock_input.value

    # Add the new item and its initial stock to the global item_database dictionary
    item_database[new_item_name] = new_item_stock

    # Update the global item_database_df DataFrame
    global item_database_df
    item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

    # Recalculate the global resume_df DataFrame
    global resume_df
    # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
    global total_taken
    # total_taken needs to be recalculated based on the *current* pengambilan_df
    if not pengambilan_df.empty:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken'])


    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # Clear the current output
    clear_output(wait=True)

    # Re-display the form layout
    display(form_layout)

    # Display the updated tables
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Clear the input fields
    new_item_name_input.value = ''
    new_item_stock_input.value = 0

def handle_delete_item(button):
    # Retrieve the value of the selected item from the delete_item_input widget
    item_to_delete = delete_item_input.value

    # Check if the selected item exists as a key in the global item_database dictionary
    if item_to_delete in item_database:
        # If the item exists, remove it from the item_database dictionary using the del keyword
        del item_database[item_to_delete]

        # Update the global item_database_df DataFrame
        global item_database_df
        item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

        # Recalculate the global resume_df DataFrame
        global resume_df
        # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
        global total_taken
        # total_taken needs to be recalculated based on the *current* pengambilan_df
        if not pengambilan_df.empty:
            total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
        else:
            total_taken = pd.DataFrame(columns=['item', 'total_taken'])


        resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
        resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
        resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
        resume_df = resume_df[['nama item', 'sisa']]

        # Update the options of the item selection dropdown in the main form and the delete form
        item_input.options = list(item_database.keys())
        delete_item_input.options = list(item_database.keys())


        # Clear the current output
        clear_output(wait=True)

        # Re-display the form layout
        display(form_layout)

        # Display the updated tables
        print("Pengambilan Barang Table:")
        display(pengambilan_df)
        print("\nItem Database Table:")
        display(item_database_df)
        print("\nResume Table:")
        display(resume_df)

    else:
        # If the item did not exist in step 3, inform the user
        print(f"Item '{item_to_delete}' not found in the database.")


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""**Reasoning**:
The KeyError persists because the initial `pengambilan_df` created when `pengambilan_barang` is empty still doesn't guarantee the 'jumlah' column is correctly initialized as a numeric type before the `groupby().sum()` operation outside the `handle_submit` function. The code creating the empty DataFrame needs to explicitly define the data type for the 'jumlah' column as integer.


"""

from IPython.display import clear_output, display
import pandas as pd
import ipywidgets as widgets

def handle_submit(button):
    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": tanggal_input.value,
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value # Retrieve the value from jumlah_input and add it to the dictionary
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric, defaulting to 0 if missing
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)
    # Reorder columns to place 'jumlah' after 'item'
    cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
    if all(col in pengambilan_df.columns for col in cols):
        pengambilan_df = pengambilan_df[cols]


    # e. Recalculate `total_taken` by summing the 'jumlah' column
    global total_taken
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


    # f. Recalculate `resume_df` using the summed 'jumlah'
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field

def handle_add_item(button):
    # Retrieve the values from the input widgets
    new_item_name = new_item_name_input.value
    new_item_stock = new_item_stock_input.value

    # Add the new item and its initial stock to the global item_database dictionary
    item_database[new_item_name] = new_item_stock

    # Update the global item_database_df DataFrame
    global item_database_df
    item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

    # Recalculate the global resume_df DataFrame
    global resume_df
    # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
    global total_taken
    # total_taken needs to be recalculated based on the *current* pengambilan_df
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken'])


    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # Clear the current output
    clear_output(wait=True)

    # Re-display the form layout
    display(form_layout)

    # Display the updated tables
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Clear the input fields
    new_item_name_input.value = ''
    new_item_stock_input.value = 0


def handle_delete_item(button):
    # Retrieve the value of the selected item from the delete_item_input widget
    item_to_delete = delete_item_input.value

    # Check if the selected item exists as a key in the global item_database dictionary
    if item_to_delete in item_database:
        # If the item exists, remove it from the item_database dictionary using the del keyword
        del item_database[item_to_delete]

        # Update the global item_database_df DataFrame
        global item_database_df
        item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

        # Recalculate the global resume_df DataFrame
        global resume_df
        # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
        global total_taken
        # total_taken needs to be recalculated based on the *current* pengambilan_df
        if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
            total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
        else:
            total_taken = pd.DataFrame(columns=['item', 'total_taken'])


        resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
        resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
        resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
        resume_df = resume_df[['nama item', 'sisa']]

        # Update the options of the item selection dropdown in the main form and the delete form
        item_input.options = list(item_database.keys())
        delete_item_input.options = list(item_database.keys())


        # Clear the current output
        clear_output(wait=True)

        # Re-display the form layout
        display(form_layout)

        # Display the updated tables
        print("Pengambilan Barang Table:")
        display(pengambilan_df)
        print("\nItem Database Table:")
        display(item_database_df)
        print("\nResume Table:")
        display(resume_df)

    else:
        # If the item did not exist in step 3, inform the user
        print(f"Item '{item_to_delete}' not found in the database.")


# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    pengambilan_df = pengambilan_df[cols]


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

"""**Reasoning**:
The KeyError 'jumlah' on line 178 `pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)` indicates that when `pengambilan_df` is created from `pengambilan_barang` (which contains data), the 'jumlah' column is not present in the DataFrame columns at that point. This is unexpected since the `handle_submit` function should be adding 'jumlah' to each entry in `pengambilan_barang`. Let's re-examine how `pengambilan_df` is created from the list and ensure the 'jumlah' column is consistently present and handled. It's possible the issue arises if `pengambilan_barang` contains entries added before the 'jumlah' column was introduced to the `new_entry` dictionary in `handle_submit`. To address this, when creating `pengambilan_df` from `pengambilan_barang`, ensure all expected columns, including 'jumlah', are present, potentially adding it with a default value if missing in older entries, and then convert the 'jumlah' column to a numeric type.


"""

def handle_submit(button):
    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": tanggal_input.value,
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value # Retrieve the value from jumlah_input and add it to the dictionary
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric, defaulting to 0 if missing
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)
    # Reorder columns to place 'jumlah' after 'item'
    cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
    pengambilan_df = pengambilan_df[cols]


    # e. Recalculate `total_taken` by summing the 'jumlah' column
    global total_taken
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


    # f. Recalculate `resume_df` using the summed 'jumlah'
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    from IPython.display import clear_output
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field

def handle_add_item(button):
    # Retrieve the values from the input widgets
    new_item_name = new_item_name_input.value
    new_item_stock = new_item_stock_input.value

    # Add the new item and its initial stock to the global item_database dictionary
    item_database[new_item_name] = new_item_stock

    # Update the global item_database_df DataFrame
    global item_database_df
    item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

    # Recalculate the global resume_df DataFrame
    global resume_df
    # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
    global total_taken
    # total_taken needs to be recalculated based on the *current* pengambilan_df
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken'])


    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # Clear the current output
    clear_output(wait=True)

    # Re-display the form layout
    display(form_layout)

    # Display the updated tables
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Clear the input fields
    new_item_name_input.value = ''
    new_item_stock_input.value = 0


def handle_delete_item(button):
    # Retrieve the value of the selected item from the delete_item_input widget
    item_to_delete = delete_item_input.value

    # Check if the selected item exists as a key in the global item_database dictionary
    if item_to_delete in item_database:
        # If the item exists, remove it from the item_database dictionary using the del keyword
        del item_database[item_to_delete]

        # Update the global item_database_df DataFrame
        global item_database_df
        item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

        # Recalculate the global resume_df DataFrame
        global resume_df
        # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
        global total_taken
        # total_taken needs to be recalculated based on the *current* pengambilan_df
        if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
            total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
        else:
            total_taken = pd.DataFrame(columns=['item', 'total_taken'])


        resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
        resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
        resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
        resume_df = resume_df[['nama item', 'sisa']]

        # Update the options of the item selection dropdown in the main form and the delete form
        item_input.options = list(item_database.keys())
        delete_item_input.options = list(item_database.keys())


        # Clear the current output
        clear_output(wait=True)

        # Re-display the form layout
        display(form_layout)

        # Display the updated tables
        print("Pengambilan Barang Table:")
        display(pengambilan_df)
        print("\nItem Database Table:")
        display(item_database_df)
        print("\nResume Table:")
        display(resume_df)

    else:
        # If the item did not exist in step 3, inform the user
        print(f"Item '{item_to_delete}' not found in the database.")


# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    pengambilan_df = pengambilan_df[cols]


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Update display

### Subtask:
Ensure the updated tables are displayed correctly with the new "jumlah" column.

**Reasoning**:
Ensure the updated tables are displayed correctly with the new "jumlah" column by clearing the output and displaying the form and tables.
"""

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

from IPython.display import clear_output, display

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

items_to_delete = ["pensil", "pulpen", "penghapus", "penggaris"]

for item in items_to_delete:
    # Check if the item exists in the database before attempting to delete
    if item in item_database:
        # Remove the item from the item_database dictionary
        del item_database[item]
        print(f"Deleted item: {item}") # Optional: print confirmation

# After deleting all items in the list, update the dataframes and display once
# Update the global item_database_df DataFrame
global item_database_df
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

# Recalculate the global resume_df DataFrame
global resume_df
global total_taken
# total_taken needs to be recalculated based on the *current* pengambilan_df
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken'])

resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Update the options of the item selection dropdown in the main form and the delete form
item_input.options = list(item_database.keys())
delete_item_input.options = list(item_database.keys())

# Clear the current output and re-display everything
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Summary:

### Data Analysis Key Findings

*   A new input field for "Jumlah" (quantity) was successfully added to the data entry form.
*   The `handle_submit` function was modified to capture the entered "Jumlah" value and include it in the new entry for the "pengambilan barang" table.
*   The creation of the `pengambilan_df` DataFrame was updated to ensure the "jumlah" column is always included, even when the DataFrame is initially empty.
*   The calculation for the "sisa" (remaining stock) in the "resume" table was updated to sum the "jumlah" taken per item from the `pengambilan_df` DataFrame, instead of simply counting the number of entries.
*   Robust error handling was implemented to ensure the "jumlah" column is present and numeric in `pengambilan_df` before performing calculations, addressing `KeyError` issues encountered during development.
*   All relevant tables (`pengambilan_df`, `item_database_df`, and `resume_df`) are displayed correctly, reflecting the added "jumlah" column and the updated stock calculations.

### Insights or Next Steps

*   Consider adding data validation to the "Jumlah" input field to ensure only positive integer values are accepted.
*   Implement functionality to edit or delete entries from the "pengambilan barang" table, which would require updating the resume table calculations accordingly.

# Task
Add persistent storage to the notebook to save and load the `item_database` and `pengambilan_barang` data.

## Define file paths

### Subtask:
Define the file paths where the `item_database` and `pengambilan_barang` will be saved.

**Reasoning**:
Define the file paths for saving the item database and the pengambilan barang data.
"""

item_database_file = 'item_database.json'
pengambilan_barang_file = 'pengambilan_barang.json'

"""## Implement save function

### Subtask:
Create a function to save the current state of `item_database` and `pengambilan_barang` to JSON files.

**Reasoning**:
Import the json library and define the save_data function to save the item_database and pengambilan_barang to JSON files.
"""

import json

def save_data():
    with open(item_database_file, 'w') as f:
        json.dump(item_database, f, indent=4)
    with open(pengambilan_barang_file, 'w') as f:
        json.dump(pengambilan_barang, f, indent=4)

"""## Implement load function

### Subtask:
Create a function to load the data from the JSON files when the notebook starts.

**Reasoning**:
Define the function to load data from the JSON files, handling cases where the files might not exist.
"""

import os
import json

def load_data():
    global item_database
    global pengambilan_barang
    try:
        if os.path.exists(item_database_file):
            with open(item_database_file, 'r') as f:
                item_database = json.load(f)
        if os.path.exists(pengambilan_barang_file):
            with open(pengambilan_barang_file, 'r') as f:
                pengambilan_barang = json.load(f)
    except FileNotFoundError:
        # No existing data files found, continue with empty data structures
        pass
    except json.JSONDecodeError:
        # Handle cases where the JSON file is empty or corrupted
        print("Error decoding JSON. Starting with empty data.")
        item_database = {} # Initialize with empty if JSON is invalid
        pengambilan_barang = [] # Initialize with empty if JSON is invalid

"""## Integrate save and load

### Subtask:
Call the load function at the beginning of the notebook execution and call the save function whenever the data in `item_database` or `pengambilan_barang` is modified.

**Reasoning**:
Call the load function at the beginning of the notebook execution and call the save function whenever the data in `item_database` or `pengambilan_barang` is modified.
"""

# Call the load_data() function at the beginning
load_data()

# Define the form layout and widgets (assuming they are already defined in previous cells)
# Update options for item_input and delete_item_input after loading data
item_input.options = list(item_database.keys())
delete_item_input.options = list(item_database.keys())

# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    pengambilan_df = pd.DataFrame(pengambilan_barang, columns=cols).astype({'jumlah': int})
else:
     # Handle case where some columns might be missing in loaded data
     # Create a new DataFrame with all columns and fill missing ones
     temp_df = pd.DataFrame(pengambilan_barang)
     for col in cols:
         if col not in temp_df.columns:
             temp_df[col] = None # Or an appropriate default value
     pengambilan_df = temp_df[cols].astype({'jumlah': int})


# Update the global item_database_df DataFrame
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]


# Update the handle_submit function to call save_data()
def handle_submit(button):
    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": tanggal_input.value,
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value # Retrieve the value from jumlah_input and add it to the dictionary
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric, defaulting to 0 if missing
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)
    # Reorder columns to place 'jumlah' after 'item'
    cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
    if all(col in pengambilan_df.columns for col in cols):
        pengambilan_df = pengambilan_df[cols]


    # e. Recalculate `total_taken` by summing the 'jumlah' column
    global total_taken
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


    # f. Recalculate `resume_df` using the summed 'jumlah'
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field

    # Call save_data() after modifying data
    save_data()


# Update the handle_add_item function to call save_data()
def handle_add_item(button):
    # Retrieve the values from the input widgets
    new_item_name = new_item_name_input.value
    new_item_stock = new_item_stock_input.value

    # Add the new item and its initial stock to the global item_database dictionary
    item_database[new_item_name] = new_item_stock

    # Update the global item_database_df DataFrame
    global item_database_df
    item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

    # Recalculate the global resume_df DataFrame
    global resume_df
    # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
    global total_taken
    # total_taken needs to be recalculated based on the *current* pengambilan_df
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken'])


    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # Clear the current output
    clear_output(wait=True)

    # Re-display the form layout
    display(form_layout)

    # Display the updated tables
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Clear the input fields
    new_item_name_input.value = ''
    new_item_stock_input.value = 0

    # Call save_data() after modifying data
    save_data()


# Update the handle_delete_item function to call save_data()
def handle_delete_item(button):
    # Retrieve the value of the selected item from the delete_item_input widget
    item_to_delete = delete_item_input.value

    # Check if the selected item exists as a key in the global item_database dictionary
    if item_to_delete in item_database:
        # If the item exists, remove it from the item_database dictionary using the del keyword
        del item_database[item_to_delete]

        # Update the global item_database_df DataFrame
        global item_database_df
        item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

        # Recalculate the global resume_df DataFrame
        global resume_df
        # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
        global total_taken
        # total_taken needs to be recalculated based on the *current* pengambilan_df
        if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
            total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
        else:
            total_taken = pd.DataFrame(columns=['item', 'total_taken'])


        resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
        resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
        resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
        resume_df = resume_df[['nama item', 'sisa']]

        # Update the options of the item selection dropdown in the main form and the delete form
        item_input.options = list(item_database.keys())
        delete_item_input.options = list(item_database.keys())


        # Clear the current output
        clear_output(wait=True)

        # Re-display the form layout
        display(form_layout)

        # Display the updated tables
        print("Pengambilan Barang Table:")
        display(pengambilan_df)
        print("\nItem Database Table:")
        display(item_database_df)
        print("\nResume Table:")
        display(resume_df)

        # Call save_data() after modifying data
        save_data()

    else:
        # If the item did not exist in step 3, inform the user
        print(f"Item '{item_to_delete}' not found in the database.")


# Bind the submit button to the handler function
submit_button.on_click(handle_submit)
add_item_button.on_click(handle_add_item)
delete_item_button.on_click(handle_delete_item)


# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Initial data handling

### Subtask:
Initial data handling

**Reasoning**:
Modify the initial data handling code to check if `item_database` and `pengambilan_barang` are empty after loading and initialize them with default values if they are.
"""

# Call the load_data() function at the beginning
load_data()

# 1. Modify the section of code after the load_data() call to check if item_database is empty.
# 2. If item_database is empty (meaning no data was loaded), initialize it with the default item data.
if not item_database:
    item_database = {
        "pensil": 100,
        "pulpen": 150,
        "penghapus": 75,
        "penggaris": 50
    }

# 3. Similarly, check if pengambilan_barang is empty after the load_data() call.
# 4. If pengambilan_barang is empty, initialize it as an empty list [].
if not pengambilan_barang:
    pengambilan_barang = []

# 5. Ensure that the subsequent steps that create DataFrames (item_database_df, pengambilan_df, resume_df) and update widget options use these potentially initialized item_database and pengambilan_barang variables.

# Update options for item_input and delete_item_input after loading data and potential initialization
item_input.options = list(item_database.keys())
delete_item_input.options = list(item_database.keys())

# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    pengambilan_df = pengambilan_df[cols]

# Update the global item_database_df DataFrame
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

# Clear the item_database dictionary
item_database.clear()

# Update the global item_database_df DataFrame
global item_database_df
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

# Recalculate the global resume_df DataFrame
global resume_df
global total_taken
# total_taken needs to be recalculated based on the *current* pengambilan_df
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken'])

resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Update the options of the item selection dropdown in the main form and the delete form
item_input.options = list(item_database.keys())
delete_item_input.options = list(item_database.keys())

# Save the updated data
save_data()

# Clear the current output and re-display everything
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Summary:

### Data Analysis Key Findings

*   The file paths for saving `item_database` and `pengambilan_barang` were defined as 'item_database.json' and 'pengambilan_barang.json', respectively.
*   A `save_data` function was successfully implemented to save the `item_database` dictionary and `pengambilan_barang` list to JSON files with 4-space indentation.
*   A `load_data` function was created to load data from the defined JSON files, including error handling for `FileNotFoundError`.
*   The `load_data` function is called at the beginning of the notebook execution, and the `save_data` function is called within the `handle_submit`, `handle_add_item`, and `handle_delete_item` functions to ensure data persistence after modifications.
*   Initial data handling was added to check if `item_database` and `pengambilan_barang` are empty after loading and initialize them with default values (`item_database` with sample items and `pengambilan_barang` as an empty list) if no data was loaded.

### Insights or Next Steps

*   The persistent storage mechanism is now functional, ensuring that the application state is saved and loaded across notebook sessions.
*   Consider adding more robust error handling or user feedback mechanisms for file operations (e.g., informing the user if data was loaded or if saving failed).

# Task
Implement input validation for the form fields and the add item functionality in the provided Python code.

## Identify validation requirements

### Subtask:
Determine which input fields require validation and the type of validation needed (e.g., non-empty, numeric, positive values, valid date).

## Implement validation in `handle submit`

### Subtask:
Modify the `handle_submit` function to check the input values against the identified validation rules before adding the entry to `pengambilan_barang`.

**Reasoning**:
Modify the handle_submit function to include validation checks for the input fields before adding the new entry.
"""

def handle_submit(button):
    # Validation checks
    if not isinstance(no_input.value, int) or no_input.value <= 0:
        print("Error: 'No' must be a positive integer.")
        return # Stop execution if validation fails

    if tanggal_input.value is None:
        print("Error: 'Tanggal' must be selected.")
        return # Stop execution if validation fails

    if not isinstance(nama_input.value, str) or not nama_input.value.strip():
        print("Error: 'Nama' cannot be empty.")
        return # Stop execution if validation fails

    if not isinstance(divisi_input.value, str) or not divisi_input.value.strip():
        print("Error: 'Divisi' cannot be empty.")
        return # Stop execution if validation fails

    if not isinstance(jumlah_input.value, int) or jumlah_input.value <= 0:
        print("Error: 'Jumlah' must be a positive integer.")
        return # Stop execution if validation fails

    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": str(tanggal_input.value), # Convert date to string for JSON serialization
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric, defaulting to 0 if missing
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)
    # Reorder columns to place 'jumlah' after 'item'
    cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
    if all(col in pengambilan_df.columns for col in cols):
        pengambilan_df = pengambilan_df[cols]


    # e. Recalculate `total_taken` by summing the 'jumlah' column
    global total_taken
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


    # f. Recalculate `resume_df` using the summed 'jumlah'
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field

    # Call save_data() after modifying data
    save_data()

"""## Provide user feedback

### Subtask:
Add a mechanism to inform the user if validation fails (e.g., display an error message).

**Reasoning**:
Add an Output widget to the form layout and modify the handle_submit, handle_add_item, and handle_delete_item functions to use this widget for displaying validation errors.
"""

# Add an Output widget to the form layout
error_output = widgets.Output()

# Define the form layout including the error_output widget
form_layout = widgets.VBox([
    no_input,
    tanggal_input,
    nama_input,
    divisi_input,
    item_input,
    jumlah_input,
    submit_button,
    widgets.Label("Add New Item:"),
    new_item_name_input,
    new_item_stock_input,
    add_item_button,
    widgets.Label("Delete Item:"),
    delete_item_input,
    delete_item_button,
    error_output # Add the error output widget here
])


def handle_submit(button):
    # Clear previous error messages
    with error_output:
        clear_output(wait=True)
        # Validation checks
        if not isinstance(no_input.value, int) or no_input.value <= 0:
            print("Error: 'No' must be a positive integer.")
            return # Stop execution if validation fails

        if tanggal_input.value is None:
            print("Error: 'Tanggal' must be selected.")
            return # Stop execution if validation fails

        if not isinstance(nama_input.value, str) or not nama_input.value.strip():
            print("Error: 'Nama' cannot be empty.")
            return # Stop execution if validation fails

        if not isinstance(divisi_input.value, str) or not divisi_input.value.strip():
            print("Error: 'Divisi' cannot be empty.")
            return # Stop execution if validation fails

        if not isinstance(jumlah_input.value, int) or jumlah_input.value <= 0:
            print("Error: 'Jumlah' must be a positive integer.")
            return # Stop execution if validation fails


    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": str(tanggal_input.value), # Convert date to string for JSON serialization
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric, defaulting to 0 if missing
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)
    # Reorder columns to place 'jumlah' after 'item'
    cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
    if all(col in pengambilan_df.columns for col in cols):
        pengambilan_df = pd.DataFrame(pengambilan_barang, columns=cols).astype({'jumlah': int})
    else:
         # Handle case where some columns might be missing in loaded data
         # Create a new DataFrame with all columns and fill missing ones
         temp_df = pd.DataFrame(pengambilan_barang)
         for col in cols:
             if col not in temp_df.columns:
                 temp_df[col] = None # Or an appropriate default value
         pengambilan_df = temp_df[cols].astype({'jumlah': int})


    # e. Recalculate `total_taken` by summing the 'jumlah' column
    global total_taken
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


    # f. Recalculate `resume_df` using the summed 'jumlah'
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field

    # Call save_data() after modifying data
    save_data()


def handle_add_item(button):
    # Clear previous error messages
    with error_output:
        clear_output(wait=True)
        # Retrieve the values from the input widgets
        new_item_name = new_item_name_input.value
        new_item_stock = new_item_stock_input.value

        # Validation for new item
        if not isinstance(new_item_name, str) or not new_item_name.strip():
            print("Error: New Item Name cannot be empty.")
            return

        if new_item_name.strip() in item_database:
             print(f"Error: Item '{new_item_name.strip()}' already exists.")
             return

        if not isinstance(new_item_stock, int) or new_item_stock < 0:
            print("Error: Initial Stock must be a non-negative integer.")
            return


    # Add the new item and its initial stock to the global item_database dictionary
    item_database[new_item_name] = new_item_stock

    # Update the global item_database_df DataFrame
    global item_database_df
    item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

    # Recalculate the global resume_df DataFrame
    global resume_df
    # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
    global total_taken
    # total_taken needs to be recalculated based on the *current* pengambilan_df
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken'])


    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # Clear the current output
    clear_output(wait=True)

    # Re-display the form layout
    display(form_layout)

    # Display the updated tables
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Clear the input fields
    new_item_name_input.value = ''
    new_item_stock_input.value = 0

    # Call save_data() after modifying data
    save_data()


def handle_delete_item(button):
    # Clear previous error messages
    with error_output:
        clear_output(wait=True)
        # Retrieve the value of the selected item from the delete_item_input widget
        item_to_delete = delete_item_input.value

        # Validation for delete item
        if item_to_delete is None:
             print("Error: Please select an item to delete.")
             return


    # Check if the selected item exists as a key in the global item_database dictionary
    if item_to_delete in item_database:
        # If the item exists, remove it from the item_database dictionary using the del keyword
        del item_database[item_to_delete]

        # Update the global item_database_df DataFrame
        global item_database_df
        item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

        # Recalculate the global resume_df DataFrame
        global resume_df
        # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
        global total_taken
        # total_taken needs to be recalculated based on the *current* pengambilan_df
        if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
            total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
        else:
            total_taken = pd.DataFrame(columns=['item', 'total_taken'])


        resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
        resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
        resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
        resume_df = resume_df[['nama item', 'sisa']]

        # Update the options of the item selection dropdown in the main form and the delete form
        item_input.options = list(item_database.keys())
        delete_item_input.options = list(item_database.keys())


        # Clear the current output
        clear_output(wait=True)

        # Re-display the form layout
        display(form_layout)

        # Display the updated tables
        print("Pengambilan Barang Table:")
        display(pengambilan_df)
        print("\nItem Database Table:")
        display(item_database_df)
        print("\nResume Table:")
        display(resume_df)

        # Call save_data() after modifying data
        save_data()

    else:
        # If the item did not exist in step 3, inform the user
        with error_output:
            print(f"Error: Item '{item_to_delete}' not found in the database.")

# Bind the submit button to the handler function
submit_button.on_click(handle_submit)
add_item_button.on_click(handle_add_item)
delete_item_button.on_click(handle_delete_item)

# Call the load_data() function at the beginning
load_data()

# Check if item_database is empty and initialize if needed
if not item_database:
    item_database = {
        "pensil": 100,
        "pulpen": 150,
        "penghapus": 75,
        "penggaris": 50
    }

# Check if pengambilan_barang is empty and initialize if needed
if not pengambilan_barang:
    pengambilan_barang = []

# Update options for item_input and delete_item_input after loading data and potential initialization
item_input.options = list(item_database.keys())
delete_item_input.options = list(item_database.keys())

# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    pengambilan_df = pd.DataFrame(pengambilan_barang, columns=cols).astype({'jumlah': int})
else:
     # Handle case where some columns might be missing in loaded data
     # Create a new DataFrame with all columns and fill missing ones
     temp_df = pd.DataFrame(pengambilan_barang)
     for col in cols:
         if col not in temp_df.columns:
             temp_df[col] = None # Or an appropriate default value
     pengambilan_df = temp_df[cols].astype({'jumlah': int})


# Update the global item_database_df DataFrame
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Implement validation in `handle add item`

### Subtask:
Implement validation in `handle add item`

#### Instructions
Modify the `handle_add_item` function to validate the new item's name and initial stock.

**Reasoning**:
Modify the `handle_add_item` function to include validation checks for the new item's name (non-empty and unique) and initial stock (non-negative integer), and display error messages using the `error_output` widget if validation fails.
"""

def handle_submit(button):
    # Clear previous error messages
    with error_output:
        clear_output(wait=True)
        # Validation checks
        if not isinstance(no_input.value, int) or no_input.value <= 0:
            print("Error: 'No' must be a positive integer.")
            return # Stop execution if validation fails

        if tanggal_input.value is None:
            print("Error: 'Tanggal' must be selected.")
            return # Stop execution if validation fails

        if not isinstance(nama_input.value, str) or not nama_input.value.strip():
            print("Error: 'Nama' cannot be empty.")
            return # Stop execution if validation fails

        if not isinstance(divisi_input.value, str) or not divisi_input.value.strip():
            print("Error: 'Divisi' cannot be empty.")
            return # Stop execution if validation fails

        if not isinstance(jumlah_input.value, int) or jumlah_input.value <= 0:
            print("Error: 'Jumlah' must be a positive integer.")
            return # Stop execution if validation fails


    # a. Retrieve the values from the input widgets
    new_entry = {
        "no": no_input.value,
        "tanggal": str(tanggal_input.value), # Convert date to string for JSON serialization
        "nama": nama_input.value,
        "divisi": divisi_input.value,
        "item": item_input.value,
        "jumlah": jumlah_input.value
    }

    # c. Append this dictionary to the `pengambilan_barang` list
    pengambilan_barang.append(new_entry)

    # d. Update the `pengambilan_df` DataFrame from the `pengambilan_barang` list
    global pengambilan_df
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric, defaulting to 0 if missing
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)
    # Reorder columns to place 'jumlah' after 'item'
    cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
    if all(col in pengambilan_df.columns for col in cols):
        # Ensure 'tanggal' column is treated as string for consistent DataFrame creation
        temp_df = pd.DataFrame(pengambilan_barang, columns=cols)
        temp_df['tanggal'] = temp_df['tanggal'].astype(str)
        pengambilan_df = temp_df.astype({'jumlah': int})
    else:
         # Handle case where some columns might be missing in loaded data
         # Create a new DataFrame with all columns and fill missing ones
         temp_df = pd.DataFrame(pengambilan_barang)
         for col in cols:
             if col not in temp_df.columns:
                 temp_df[col] = None # Or an appropriate default value
         pengambilan_df = temp_df[cols].astype({'jumlah': int})


    # e. Recalculate `total_taken` by summing the 'jumlah' column
    global total_taken
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


    # f. Recalculate `resume_df` using the summed 'jumlah'
    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # g. Update the display of `pengambilan_df` and `resume_df`
    # Clear previous output and display updated dataframes
    clear_output(wait=True)
    display(form_layout) # Redisplay the form
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)


    # h. Clear the input fields in the form after submission
    no_input.value = 0
    tanggal_input.value = None
    nama_input.value = ''
    divisi_input.value = ''
    item_input.value = list(item_database.keys())[0] # Reset to first item
    jumlah_input.value = 0 # Clear the jumlah input field

    # Call save_data() after modifying data
    save_data()


def handle_add_item(button):
    # Clear previous error messages
    with error_output:
        clear_output(wait=True)
        # Retrieve the values from the input widgets
        new_item_name = new_item_name_input.value
        new_item_stock = new_item_stock_input.value

        # 1. Validation for new item name (non-empty)
        if not isinstance(new_item_name, str) or not new_item_name.strip():
            print("Error: New Item Name cannot be empty.")
            return

        # 2. Validation for new item name (uniqueness)
        if new_item_name.strip() in item_database:
             print(f"Error: Item '{new_item_name.strip()}' already exists.")
             return

        # 3. Validation for initial stock (non-negative integer)
        if not isinstance(new_item_stock, int) or new_item_stock < 0:
            print("Error: Initial Stock must be a non-negative integer.")
            return

        # 4. If all validation passes, proceed to add the item and update display
        # Add the new item and its initial stock to the global item_database dictionary
        item_database[new_item_name.strip()] = new_item_stock # Use stripped name

        # Update the global item_database_df DataFrame
        global item_database_df
        item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

        # Recalculate the global resume_df DataFrame
        global resume_df
        # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
        global total_taken
        # total_taken needs to be recalculated based on the *current* pengambilan_df
        if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
            total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
        else:
            total_taken = pd.DataFrame(columns=['item', 'total_taken'])


        resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
        resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
        resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
        resume_df = resume_df[['nama item', 'sisa']]

        # Update the options of the item selection dropdown in the main form and the delete form
        item_input.options = list(item_database.keys())
        delete_item_input.options = list(item_database.keys())


        # Clear the current output
        clear_output(wait=True)

        # Re-display the form layout
        display(form_layout)

        # Display the updated tables
        print("Pengambilan Barang Table:")
        display(pengambilan_df)
        print("\nItem Database Table:")
        display(item_database_df)
        print("\nResume Table:")
        display(resume_df)

        # Clear the input fields
        new_item_name_input.value = ''
        new_item_stock_input.value = 0

        # Call save_data() after modifying data
        save_data()


def handle_delete_item(button):
    # Clear previous error messages
    with error_output:
        clear_output(wait=True)
        # Retrieve the value of the selected item from the delete_item_input widget
        item_to_delete = delete_item_input.value

        # Validation for delete item: check if an item is selected
        if item_to_delete is None:
             print("Error: Please select an item to delete.")
             return

        # Check if the selected item exists as a key in the global item_database dictionary
        if item_to_delete not in item_database:
            # If the item does not exist, inform the user via the error_output widget
            print(f"Error: Item '{item_to_delete}' not found in the database.")
            return # Stop execution if the item is not found


    # If the item exists, remove it from the item_database dictionary using the del keyword
    del item_database[item_to_delete]

    # Update the global item_database_df DataFrame
    global item_database_df
    item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

    # Recalculate the global resume_df DataFrame
    global resume_df
    # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
    global total_taken
    # total_taken needs to be recalculated based on the *current* pengambilan_df
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken'])


    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # Clear the current output
    clear_output(wait=True)

    # Re-display the form layout
    display(form_layout)

    # Display the updated tables
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Call save_data() after modifying data
    save_data()

# Bind the submit button to the handler function (ensure this is done after redefining the functions)
submit_button.on_click(handle_submit)
add_item_button.on_click(handle_add_item)
delete_item_button.on_click(handle_delete_item)

# Call the load_data() function at the beginning
load_data()

# Check if item_database is empty and initialize if needed
if not item_database:
    item_database = {
        "pensil": 100,
        "pulpen": 150,
        "penghapus": 75,
        "penggaris": 50
    }

# Check if pengambilan_barang is empty and initialize if needed
if not pengambilan_barang:
    pengambilan_barang = []

# Update options for item_input and delete_item_input after loading data and potential initialization
item_input.options = list(item_database.keys())
delete_item_input.options = list(item_database.keys())

# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    # Ensure 'tanggal' column is treated as string for consistent DataFrame creation
    temp_df = pd.DataFrame(pengambilan_barang, columns=cols)
    temp_df['tanggal'] = temp_df['tanggal'].astype(str)
    pengambilan_df = temp_df.astype({'jumlah': int})
else:
     # Handle case where some columns might be missing in loaded data
     # Create a new DataFrame with all columns and fill missing ones
     temp_df = pd.DataFrame(pengambilan_barang)
     for col in cols:
         if col not in temp_df.columns:
             temp_df[col] = None # Or an appropriate default value
     pengambilan_df = temp_df[cols].astype({'jumlah': int})


# Update the global item_database_df DataFrame
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Provide user feedback for add item

### Subtask:
Provide user feedback for validation failures when adding a new item.

## Refine delete item validation

### Subtask:
Refine delete item validation

**Reasoning**:
Review the `handle_delete_item` function to ensure it checks if the item to be deleted exists in the `item_database` and displays an error message in the `error_output` widget if it does not exist. If these checks are already present, the subtask is complete.
"""

def handle_delete_item(button):
    # Clear previous error messages
    with error_output:
        clear_output(wait=True)
        # Retrieve the value of the selected item from the delete_item_input widget
        item_to_delete = delete_item_input.value

        # Validation for delete item: check if an item is selected
        if item_to_delete is None:
             print("Error: Please select an item to delete.")
             return

        # Check if the selected item exists as a key in the global item_database dictionary
        if item_to_delete not in item_database:
            # If the item does not exist, inform the user via the error_output widget
            print(f"Error: Item '{item_to_delete}' not found in the database.")
            return # Stop execution if the item is not found


    # If the item exists, remove it from the item_database dictionary using the del keyword
    del item_database[item_to_delete]

    # Update the global item_database_df DataFrame
    global item_database_df
    item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])

    # Recalculate the global resume_df DataFrame
    global resume_df
    # Ensure total_taken is correctly updated if the deleted item was in pengambilan_df
    global total_taken
    # total_taken needs to be recalculated based on the *current* pengambilan_df
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken'])


    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Update the options of the item selection dropdown in the main form and the delete form
    item_input.options = list(item_database.keys())
    delete_item_input.options = list(item_database.keys())


    # Clear the current output
    clear_output(wait=True)

    # Re-display the form layout
    display(form_layout)

    # Display the updated tables
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Call save_data() after modifying data
    save_data()

# Bind the submit button to the handler function (ensure this is done after redefining the functions)
submit_button.on_click(handle_submit)
add_item_button.on_click(handle_add_item)
delete_item_button.on_click(handle_delete_item)

# Call the load_data() function at the beginning
load_data()

# Check if item_database is empty and initialize if needed
if not item_database:
    item_database = {
        "pensil": 100,
        "pulpen": 150,
        "penghapus": 75,
        "penggaris": 50
    }

# Check if pengambilan_barang is empty and initialize if needed
if not pengambilan_barang:
    pengambilan_barang = []

# Update options for item_input and delete_item_input after loading data and potential initialization
item_input.options = list(item_database.keys())
delete_item_input.options = list(item_database.keys())

# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    pengambilan_df = pd.DataFrame(pengambilan_barang, columns=cols).astype({'jumlah': int})
else:
     # Handle case where some columns might be missing in loaded data
     # Create a new DataFrame with all columns and fill missing ones
     temp_df = pd.DataFrame(pengambilan_barang)
     for col in cols:
         if col not in temp_df.columns:
             temp_df[col] = None # Or an appropriate default value
     pengambilan_df = temp_df[cols].astype({'jumlah': int})


# Update the global item_database_df DataFrame
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Summary:

### Data Analysis Key Findings

*   Input validation was successfully implemented for the form fields (`no_input`, `tanggal_input`, `nama_input`, `divisi_input`, `item_input`, `jumlah_input`) and the add item functionality (`new_item_name_input`, `new_item_stock_input`).
*   Validation rules include checking for positive integers (`no_input`, `jumlah_input`), valid dates (`tanggal_input`), non-empty strings (`nama_input`, `divisi_input`, `new_item_name_input`), unique item names (`new_item_name_input`), and non-negative integers (`new_item_stock_input`).
*   An `ipywidgets.Output` widget (`error_output`) was integrated into the form layout to display validation error messages to the user.
*   The `handle_submit`, `handle_add_item`, and `handle_delete_item` functions were modified to clear previous error messages and display new ones within the `error_output` widget when validation fails.
*   The delete item validation already correctly checked if the selected item exists in the database and provided feedback.

### Insights or Next Steps

*   Consider adding visual indicators to the input fields themselves (e.g., changing border color) when validation fails, in addition to the error message in the `error_output` widget, for more immediate user feedback.
*   Implement validation to ensure that the `jumlah_input` for an item does not exceed the available stock (`sisa`) before allowing the submission.

# Task
Implement a feature to delete entries from the "Pengambilan Barang" table in the notebook.

## Add a mechanism to select entries for deletion

### Subtask:
Determine how users will select entries from the "Pengambilan Barang" table to delete (e.g., by 'No' or by selecting rows in the displayed DataFrame).

## Create input/button for deletion

### Subtask:
Add an input field (e.g., an IntText) for the user to enter the 'No' of the entry to be deleted from the "Pengambilan Barang" table, and a button to trigger the deletion.

**Reasoning**:
Create the input widgets for deleting a specific entry from the pengambilan barang table and update the form layout to include them.
"""

delete_entry_no_input = widgets.IntText(description='Entry No to Delete:')
delete_entry_button = widgets.Button(description='Delete Entry')

# Update the form layout to include the new widgets
form_layout = widgets.VBox([
    no_input,
    tanggal_input,
    nama_input,
    divisi_input,
    item_input,
    jumlah_input,
    submit_button,
    widgets.Label("Add New Item:"),
    new_item_name_input,
    new_item_stock_input,
    add_item_button,
    widgets.Label("Delete Item from Database:"),
    delete_item_input,
    delete_item_button,
    widgets.Label("Delete Entry from Pengambilan Barang:"), # Add a label for clarity
    delete_entry_no_input,
    delete_entry_button,
    error_output
])

# Re-display the updated form layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Implement delete entry function

### Subtask:
Write a function that takes the entry number, removes the corresponding entry from the `pengambilan_barang` list, and updates the displayed tables.

**Reasoning**:
Define the `handle_delete_entry` function to handle the deletion of an entry from the `pengambilan_barang` list based on the provided entry number, update the dataframes, and refresh the display, including error handling and saving the data.
"""

def handle_delete_entry(button):
    # Clear previous error messages
    with error_output:
        clear_output(wait=True)

    # Retrieve the value from the delete_entry_no_input widget
    entry_to_delete_no = delete_entry_no_input.value

    # Validate that the retrieved value is a positive integer
    if not isinstance(entry_to_delete_no, int) or entry_to_delete_no <= 0:
        with error_output:
            print("Error: Entry No to Delete must be a positive integer.")
        return # Stop execution if validation fails

    # Iterate through the `pengambilan_barang` list to find the entry with a matching 'no'.
    entry_found = False
    global pengambilan_barang
    # Create a new list to avoid modifying the list while iterating
    updated_pengambilan_barang = []
    for entry in pengambilan_barang:
        if entry.get("no") == entry_to_delete_no:
            entry_found = True
            # Do not append this entry to updated_pengambilan_barang (effectively deleting it)
        else:
            updated_pengambilan_barang.append(entry)

    # If no matching entry is found after iterating through the list, display an error message and return.
    if not entry_found:
        with error_output:
            print(f"Error: Entry with No '{entry_to_delete_no}' not found in Pengambilan Barang.")
        return # Stop execution if no matching entry is found

    # If an entry was successfully deleted, update the `pengambilan_barang` list
    pengambilan_barang = updated_pengambilan_barang


    # Update the `pengambilan_df` DataFrame from the modified `pengambilan_barang` list
    global pengambilan_df
    if not pengambilan_barang:
        # Ensure "jumlah" column is included and is of integer type when the list is empty
        pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
    else:
        pengambilan_df = pd.DataFrame(pengambilan_barang)
        # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
        if 'jumlah' not in pengambilan_df.columns:
             pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
        pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)
        # Explicitly convert 'tanggal' to string type
        if 'tanggal' in pengambilan_df.columns:
            pengambilan_df['tanggal'] = pengambilan_df['tanggal'].astype(str)

        # Reorder columns to place 'jumlah' after 'item'
        cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
        if all(col in pengambilan_df.columns for col in cols):
            pengambilan_df = pengambilan_df[cols]


    # Recalculate the `total_taken` and `resume_df` DataFrames based on the updated `pengambilan_df`.
    global total_taken
    if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
        total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
    else:
        total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


    global resume_df
    resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
    resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
    resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
    resume_df = resume_df[['nama item', 'sisa']]

    # Clear the output and re-display the form_layout, and tables.
    clear_output(wait=True)
    display(form_layout)
    print("Pengambilan Barang Table:")
    display(pengambilan_df)
    print("\nItem Database Table:")
    display(item_database_df)
    print("\nResume Table:")
    display(resume_df)

    # Clear the delete_entry_no_input field.
    delete_entry_no_input.value = 0

    # Call the save_data() function to persist the changes.
    save_data()

"""**Reasoning**:
Link the defined `handle_delete_entry` function to the `delete_entry_button` click event and ensure the initial display reflects all the widgets and tables.


"""

# Bind the delete entry button to the handler function
delete_entry_button.on_click(handle_delete_entry)

# Bind the submit button to the handler function (ensure this is done after redefining the functions)
submit_button.on_click(handle_submit)
add_item_button.on_click(handle_add_item)
delete_item_button.on_click(handle_delete_item)


# Call the load_data() function at the beginning
load_data()

# Check if item_database is empty and initialize if needed
if not item_database:
    item_database = { }

# Check if pengambilan_barang is empty and initialize if needed
if not pengambilan_barang:
    pengambilan_barang = []

# Update options for item_input and delete_item_input after loading data and potential initialization
item_input.options = list(item_database.keys())
delete_item_input.options = list(item_database.keys())

# Update the code that creates the `pengambilan_df` DataFrame for initial display
if not pengambilan_barang:
    # Ensure "jumlah" column is included and is of integer type when the list is empty
    pengambilan_df = pd.DataFrame(columns=["no", "tanggal", "nama", "divisi", "item", "jumlah"]).astype({'jumlah': int})
else:
    pengambilan_df = pd.DataFrame(pengambilan_barang)
    # Ensure 'jumlah' column is numeric after creating from list, handling potential missing 'jumlah'
    if 'jumlah' not in pengambilan_df.columns:
         pengambilan_df['jumlah'] = 0 # Add 'jumlah' column if it's somehow missing
    pengambilan_df['jumlah'] = pd.to_numeric(pengambilan_df['jumlah'], errors='coerce').fillna(0).astype(int)

# Reorder columns for initial display as well
cols = ["no", "tanggal", "nama", "divisi", "item", "jumlah"]
if all(col in pengambilan_df.columns for col in cols):
    pengambilan_df = pd.DataFrame(pengambilan_barang, columns=cols).astype({'jumlah': int})
else:
     # Handle case where some columns might be missing in loaded data
     # Create a new DataFrame with all columns and fill missing ones
     temp_df = pd.DataFrame(pengambilan_barang)
     for col in cols:
         if col not in temp_df.columns:
             temp_df[col] = None # Or an appropriate default value
     pengambilan_df = temp_df[cols].astype({'jumlah': int})


# Update the global item_database_df DataFrame
item_database_df = pd.DataFrame(list(item_database.items()), columns=["nama item", "jumlah stok"])


# Update the calculation of total_taken outside the handle_submit function
if not pengambilan_df.empty and 'jumlah' in pengambilan_df.columns:
    total_taken = pengambilan_df.groupby('item')['jumlah'].sum().reset_index(name='total_taken')
else:
    total_taken = pd.DataFrame(columns=['item', 'total_taken']) # Handle empty case or missing 'jumlah'


# Recalculate resume_df for the initial display
resume_df = item_database_df.merge(total_taken, left_on='nama item', right_on='item', how='left')
resume_df['total_taken'] = resume_df['total_taken'].fillna(0)
resume_df['sisa'] = resume_df['jumlah stok'] - resume_df['total_taken']
resume_df = resume_df[['nama item', 'sisa']]

# Initial display of the form and tables with the updated layout
clear_output(wait=True)
display(form_layout)
print("Pengambilan Barang Table:")
display(pengambilan_df)
print("\nItem Database Table:")
display(item_database_df)
print("\nResume Table:")
display(resume_df)

"""## Connect button to function

### Subtask:
Link the click event of the new delete entry button to the `handle_delete_entry` function.

**Reasoning**:
Link the defined function to the delete entry button's click event.
"""

delete_entry_button.on_click(handle_delete_entry)

"""## Update display

### Subtask:
Ensure the updated tables are displayed correctly after deletion.

**Reasoning**:
Review the `handle_delete_entry` function and the initial display code to confirm that the updated tables are displayed correctly after deletion and on initial load.
"""

# Review the handle_delete_entry function
# The handle_delete_entry function already includes steps to clear the output and re-display:
# clear_output(wait=True)
# display(form_layout)
# print("Pengambilan Barang Table:")
# display(pengambilan_df)
# print("\nItem Database Table:")
# display(item_database_df)
# print("\nResume Table:")
# display(resume_df)

# Review the initial display code block
# The initial display code block also includes steps to clear the output and display:
# clear_output(wait=True)
# display(form_layout)
# print("Pengambilan Barang Table:")
# display(pengambilan_df)
# print("\nItem Database Table:")
# display(item_database_df)
# print("\nResume Table:")
# display(resume_df)

# Since the display updates are already present in both the handle_delete_entry function
# and the initial display code, no new code is needed for this subtask.

# The subtask is completed.

"""## Update save/load

### Subtask:
Modify the save/load functions or their calls to handle the changes in `pengambilan_barang`.

**Reasoning**:
Review the save_data and load_data functions and their calls to ensure they correctly handle the `pengambilan_barang` list and integrate with the delete entry functionality. Since the previous subtask confirmed the display updates and the save_data call within `handle_delete_entry`, this step primarily involves reviewing the existing code to confirm correctness and completeness for persistence.
"""

# Review of save_data function:
# The save_data function serializes the global 'pengambilan_barang' list to a JSON file.
# This function appears correct for saving the list's current state.
# def save_data():
#     with open(item_database_file, 'w') as f:
#         json.dump(item_database, f, indent=4)
#     with open(pengambilan_barang_file, 'w') as f:
#         json.dump(pengambilan_barang, f, indent=4)

# Review of load_data function:
# The load_data function attempts to load the 'pengambilan_barang' list from a JSON file.
# It handles FileNotFoundError and JSONDecodeError, initializing an empty list if errors occur.
# This function appears correct for loading the list.
# def load_data():
#     global item_database
#     global pengambilan_barang
#     try:
#         if os.path.exists(item_database_file):
#             with open(item_database_file, 'r') as f:
#                 item_database = json.load(f)
#         if os.path.exists(pengambilan_barang_file):
#             with open(pengambilan_barang_file, 'r') as f:
#                 pengambilan_barang = json.load(f)
#     except FileNotFoundError:
#         pass # Continue with default empty data structures
#     except json.JSONDecodeError:
#         print("Error decoding JSON. Starting with empty data.")
#         item_database = {} # Initialize with empty if JSON is invalid
#         pengambilan_barang = [] # Initialize with empty if JSON is invalid

# Review of handle_delete_entry function:
# The handle_delete_entry function calls save_data() after successfully deleting an entry
# and updating the data structures. This ensures persistence of the deletion.
# (Code for handle_delete_entry reviewed in previous subtask)

# Review of initial data loading and DataFrame creation:
# The code after load_data() checks if 'pengambilan_barang' is empty and initializes it.
# It then creates 'pengambilan_df' from 'pengambilan_barang', ensuring the 'jumlah' column
# is present and numeric, and recalculates 'total_taken' and 'resume_df'.
# This process correctly uses the loaded 'pengambilan_barang' data.
# (Code for initial loading and DataFrame creation reviewed in previous subtasks)


# Since the review confirms that the save/load functions and their calls correctly handle
# the 'pengambilan_barang' list in conjunction with the delete entry functionality,
# no code modifications are needed for this subtask.

# The subtask is completed.

"""## Summary:

### Data Analysis Key Findings

*   A mechanism was implemented to allow users to select entries for deletion from the "Pengambilan Barang" table by entering the 'No' of the entry in a dedicated input field.
*   A button labeled "Delete Entry" was added to trigger the deletion process.
*   A function `handle_delete_entry` was created to remove the selected entry from the `pengambilan_barang` list, update the associated pandas DataFrames (`pengambilan_df`, `total_taken`, `resume_df`), and refresh the display.
*   Error handling was included in `handle_delete_entry` to validate the input (positive integer) and check if the entry exists.
*   The `handle_delete_entry` function is correctly linked to the "Delete Entry" button's click event using `.on_click()`.
*   The existing `save_data` and `load_data` functions, along with their calls within `handle_delete_entry` and the initial load sequence, were confirmed to correctly handle the persistence of changes to the `pengambilan_barang` list after deletion.
*   The display update logic, including clearing output and re-displaying the form and tables, was already present in the `handle_delete_entry` function and the initial display code, ensuring that changes are visible to the user.

### Insights or Next Steps

*   The implemented deletion feature enhances the usability of the notebook by allowing users to correct errors or remove unwanted entries from the "Pengambilan Barang" log.
*   Consider adding a confirmation step before deletion to prevent accidental data loss.

"""