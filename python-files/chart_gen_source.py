import librosa
import numpy as np
import json
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import random
import threading
from collections import OrderedDict

SAMPLE_RATE = 44100
PLAYER_NOTES = [0, 1, 2, 3]
OPPONENT_NOTES = [4, 5, 6, 7]

class FNFChartGenerator:
    def __init__(self, progress_callback=None):
        self.player_voices = None
        self.opponent_voices = None
        self.bpm = 180
        self.song_name = ""
        self.player1_char = "bf"
        self.player2_char = "dad"
        self.speed = 2.6
        self.default_sustain_length = 0
        self.offset = 0.0
        self.gf_version = "gf"
        self.charter = "Generated by FNF Chart Generator"
        self.game_over_char = "bf-dead"
        self.artist = "Unknown Artist"
        self.stage = "stage"
        
        self.prevent_consecutive_notes = tk.BooleanVar(value=False)
        self.max_consecutive_allowed_count = tk.IntVar(value=1) 

        self.onset_delta = tk.DoubleVar(value=0.03)
        self.onset_wait = tk.DoubleVar(value=30)
        self.onset_backtrack = tk.BooleanVar(value=True)

        self.enable_ai_sustain = tk.BooleanVar(value=False)
        self.min_sustain_duration_ms = tk.IntVar(value=150)
        self.sustain_threshold_db = tk.DoubleVar(value=-30.0)
        self.sustain_release_threshold_db = tk.DoubleVar(value=-28.0) # Скорректировано для лучшего определения очень длинных нот
        self.sustain_extension_ms = tk.IntVar(value=150) # Скорректировано для продления сустейнов
        self.min_silence_between_sustains_ms = tk.IntVar(value=50)

        self.enable_ai_tonality = tk.BooleanVar(value=False)
        self.pitch_low_c_threshold = tk.DoubleVar(value=150.0)
        self.pitch_mid_c_threshold = tk.DoubleVar(value=250.0)
        self.pitch_high_c_threshold = tk.DoubleVar(value=400.0)
        self.pitch_very_high_c_threshold = tk.DoubleVar(value=600.0)
        self.pitch_confidence_threshold = tk.DoubleVar(value=0.8)

        self.min_note_duration_ms = tk.IntVar(value=20)
        self.quantization_subdivision = tk.IntVar(value=16)

        self.progress_callback = progress_callback or (lambda x, msg: None)

    def update_progress(self, value, message=""):
        self.progress_callback(value, message)

    def load_audio(self, is_player):
        files = filedialog.askopenfilenames(
            title=self.app_instance.translations["select_player_voices"] if is_player else self.app_instance.translations["select_opponent_voices"],
            filetypes=[(self.app_instance.translations["ogg_files"], "*.ogg")]
        )
        if not files:
            return 0

        self.update_progress(0, self.app_instance.translations["loading_audio"])
        combined = np.array([])
        for i, path in enumerate(files):
            y, _ = librosa.load(path, sr=SAMPLE_RATE)
            combined = np.concatenate((combined, y))
            self.update_progress((i + 1) / len(files) * 50,
                                 f"{self.app_instance.translations['loading_voices_progress']} {'player' if is_player else 'opponent'}...")
        
        if is_player:
            self.player_voices = combined
        else:
            self.opponent_voices = combined

        self.update_progress(70, self.app_instance.translations["audio_loaded_success"])
        return len(files)

    def _find_onsets(self, y):
        self.update_progress(75, self.app_instance.translations["detecting_notes"])
        wait_seconds = self.onset_wait.get() / 1000.0 if self.onset_wait.get() > 0 else None

        return librosa.onset.onset_detect(
            y=y, 
            sr=SAMPLE_RATE, 
            units='time',
            delta=self.onset_delta.get(),
            wait=wait_seconds,
            backtrack=self.onset_backtrack.get()
        )

    def _detect_sustain_segments(self, y):
        if y is None or len(y) == 0:
            return []

        frame_length = 2048
        hop_length = 512
        rms = librosa.feature.rms(y=y, frame_length=frame_length, hop_length=hop_length)[0]

        rms_db = librosa.amplitude_to_db(rms, ref=np.max)

        sustain_segments = []
        in_sustain = False
        segment_start_frame = 0

        for i in range(len(rms_db)):
            current_rms_db = rms_db[i]
            if not in_sustain:
                if current_rms_db > self.sustain_threshold_db.get():
                    segment_start_frame = i
                    in_sustain = True
            else:
                if current_rms_db < self.sustain_release_threshold_db.get():
                    segment_end_frame = i
                    
                    start_time_ms = librosa.frames_to_time(segment_start_frame, sr=SAMPLE_RATE, hop_length=hop_length) * 1000
                    end_time_ms = librosa.frames_to_time(segment_end_frame, sr=SAMPLE_RATE, hop_length=hop_length) * 1000

                    duration_ms = end_time_ms - start_time_ms

                    if duration_ms >= self.min_sustain_duration_ms.get():
                        sustain_segments.append((start_time_ms, end_time_ms))
                    
                    in_sustain = False
        
        if in_sustain:
            start_time_ms = librosa.frames_to_time(segment_start_frame, sr=SAMPLE_RATE, hop_length=hop_length) * 1000
            end_time_ms = librosa.frames_to_time(len(rms_db) - 1, sr=SAMPLE_RATE, hop_length=hop_length) * 1000
            duration_ms = end_time_ms - start_time_ms
            if duration_ms >= self.min_sustain_duration_ms.get():
                sustain_segments.append((start_time_ms, end_time_ms))

        if self.min_silence_between_sustains_ms.get() > 0:
            merged_sustain_segments = []
            if sustain_segments:
                current_segment = list(sustain_segments[0]) 
                for i in range(1, len(sustain_segments)):
                    next_segment = sustain_segments[i]
                    gap_duration = next_segment[0] - current_segment[1] 

                    if gap_duration < self.min_silence_between_sustains_ms.get():
                        current_segment[1] = next_segment[1] 
                    else:
                        merged_sustain_segments.append(tuple(current_segment))
                        current_segment = list(next_segment)
                merged_sustain_segments.append(tuple(current_segment)) 
            sustain_segments = merged_sustain_segments

        return sustain_segments

    def _detect_pitch_for_notes(self, y, onsets, is_player):
        pitched_notes = {}
        if y is None or len(y) == 0:
            return pitched_notes

        base_note_offset = 0 if is_player else 4
        
        for onset_time_sec in onsets:
            ms_time = round(onset_time_sec * 1000, 3)
            
            start_sample = int(max(0, onset_time_sec - 0.1) * SAMPLE_RATE)
            end_sample = int(min(len(y) / SAMPLE_RATE, onset_time_sec + 0.1) * SAMPLE_RATE)
            
            segment = y[start_sample:end_sample]

            if len(segment) == 0:
                continue

            f0, confidence, _ = librosa.pyin(
                y=segment, 
                sr=SAMPLE_RATE, 
                fmin=librosa.note_to_hz('C2'),
                fmax=librosa.note_to_hz('C7')
            )
            
            valid_f0_indices = ~np.isnan(f0) & (confidence > self.pitch_confidence_threshold.get())
            
            if np.any(valid_f0_indices):
                dominant_f0 = np.median(f0[valid_f0_indices])
                
                assigned_note = -1
                if dominant_f0 < self.pitch_low_c_threshold.get():
                    assigned_note = 0 + base_note_offset
                elif dominant_f0 < self.pitch_mid_c_threshold.get():
                    assigned_note = 1 + base_note_offset
                elif dominant_f0 < self.pitch_high_c_threshold.get():
                    assigned_note = 2 + base_note_offset
                else:
                    assigned_note = 3 + base_note_offset
                
                if assigned_note != -1:
                    pitched_notes[ms_time] = assigned_note

        return pitched_notes

    def _refine_chart_data(self, chart_data):
        min_note_dur = self.min_note_duration_ms.get()
        beat_duration_ms = 60000 / self.bpm
        
        quant_sub = self.quantization_subdivision.get()
        if quant_sub <= 0:
            quant_sub = 16

        subdivision_duration_ms = beat_duration_ms / quant_sub

        for section in chart_data["notes"]:
            original_notes = section["sectionNotes"]
            
            quantized_temp_notes = []
            for note in original_notes:
                note_time_ms = note[0]
                
                quantized_time_ms = round(note_time_ms / subdivision_duration_ms) * subdivision_duration_ms
                
                if quantized_time_ms < 0:
                    quantized_time_ms = 0
                
                quantized_temp_notes.append([quantized_time_ms, note[1], note[2]])
            
            quantized_temp_notes.sort(key=lambda x: x[0])

            refined_notes = []
            if not quantized_temp_notes:
                section["sectionNotes"] = []
                continue

            refined_notes.append(list(quantized_temp_notes[0]))

            for i in range(1, len(quantized_temp_notes)):
                current_note = quantized_temp_notes[i]
                last_refined_note = refined_notes[-1]

                if current_note[0] == last_refined_note[0] and current_note[1] == last_refined_note[1]:
                    if current_note[2] > 0:
                        current_note_end_time = current_note[0] + current_note[2]
                        
                        new_sustain = max(last_refined_note[2], current_note_end_time - last_refined_note[0])
                        last_refined_note[2] = round(new_sustain, 3)
                    
                    continue

                if current_note[2] == 0 and (current_note[0] - last_refined_note[0] < min_note_dur):
                    continue

                refined_notes.append(list(current_note))

            for i, note in enumerate(refined_notes):
                if note[2] < 0:
                    note[2] = 0

                limit_time = float('inf')
                if i + 1 < len(refined_notes):
                    limit_time = refined_notes[i+1][0]

                current_note_end = note[0] + note[2]

                if current_note_end > limit_time:
                    note[2] = max(0, limit_time - note[0] - 1)

            section["sectionNotes"] = refined_notes
        return chart_data

    def apply_refinement(self, chart_data, num_passes):
        for i in range(num_passes):
            progress_val = (i + 1) * (100 / num_passes)
            self.update_progress(progress_val,
                                 f"{self.app_instance.translations['chart_refining_progress']} (Проход {i+1}/{num_passes})")
            chart_data = self._refine_chart_data(chart_data)
        return chart_data


    def generate_chart(self):
        try:
            if self.player_voices is None and self.opponent_voices is None:
                raise ValueError(self.app_instance.translations["no_voices_loaded_error"])

            self.update_progress(0, self.app_instance.translations["starting_chart_generation"])

            player_onsets = self._find_onsets(self.player_voices) if self.player_voices is not None else []
            opponent_onsets = self._find_onsets(self.opponent_voices) if self.opponent_voices is not None else []

            self.update_progress(25, self.app_instance.translations["combining_sorting_notes"])

            combined_onsets = [(t, True) for t in player_onsets] + [(t, False) for t in opponent_onsets]
            combined_onsets.sort(key=lambda x: x[0])

            player_sustain_segments = []
            opponent_sustain_segments = []
            if self.enable_ai_sustain.get():
                self.update_progress(30, self.app_instance.translations["detecting_sustain_segments"])
                player_sustain_segments = self._detect_sustain_segments(self.player_voices)
                opponent_sustain_segments = self._detect_sustain_segments(self.opponent_voices)

            player_pitched_notes = {}
            opponent_pitched_notes = {}
            if self.enable_ai_tonality.get():
                self.update_progress(40, self.app_instance.translations["analyzing_tonality"])
                player_pitched_notes = self._detect_pitch_for_notes(self.player_voices, player_onsets, True)
                opponent_pitched_notes = self._detect_pitch_for_notes(self.opponent_voices, opponent_onsets, False)


            sections = []
            
            beat_duration_ms = 60000 / self.bpm
            section_duration_ms = beat_duration_ms * 4

            current_section_start_ms = 0.0
            onset_index = 0
            
            current_must_hit_state = False 

            max_song_time_ms = 0
            if combined_onsets:
                max_song_time_ms = combined_onsets[-1][0] * 1000
            
            while current_section_start_ms <= max_song_time_ms + section_duration_ms:
                section_notes = []
                num_player_notes_in_section = 0
                num_opponent_notes_in_section = 0
                
                while onset_index < len(combined_onsets):
                    onset_time_sec, is_player_note = combined_onsets[onset_index]
                    ms_time = round(onset_time_sec * 1000, 3)

                    if ms_time < current_section_start_ms + section_duration_ms:
                        
                        note_pool = PLAYER_NOTES if is_player_note else OPPONENT_NOTES
                        
                        chosen_direction = random.choice(note_pool)

                        if self.enable_ai_tonality.get():
                            pitched_notes_map = player_pitched_notes if is_player_note else opponent_pitched_notes
                            if ms_time in pitched_notes_map:
                                chosen_direction = pitched_notes_map[ms_time]
                                if chosen_direction not in note_pool:
                                    chosen_direction = random.choice(note_pool)
                            else:
                                pass

                        if self.prevent_consecutive_notes.get():
                            max_allowed_consecutive = self.max_consecutive_allowed_count.get()
                            
                            is_problematic = False
                            if max_allowed_consecutive == 0:
                                if len(section_notes) > 0 and section_notes[-1][1] == chosen_direction:
                                    is_problematic = True
                            else:
                                if len(section_notes) >= max_allowed_consecutive: 
                                    last_notes_in_section = [note[1] for note in section_notes[-max_allowed_consecutive:]]
                                    
                                    if all(n == chosen_direction for n in last_notes_in_section):
                                        is_problematic = True
                                
                            if is_problematic:
                                available_directions = [d for d in note_pool if d != chosen_direction]
                                
                                if available_directions:
                                    chosen_direction = random.choice(available_directions)

                        note_sustain_length = self.default_sustain_length

                        if self.enable_ai_sustain.get():
                            sustain_segments_to_check = player_sustain_segments if is_player_note else opponent_sustain_segments
                            for seg_start, seg_end in sustain_segments_to_check:
                                if seg_start <= ms_time < seg_end:
                                    calculated_sustain_end = seg_end + self.sustain_extension_ms.get()
                                    sustain_duration = calculated_sustain_end - ms_time

                                    next_onset_time = float('inf')
                                    for next_onset_idx in range(onset_index + 1, len(combined_onsets)):
                                        next_onset_time = round(combined_onsets[next_onset_idx][0] * 1000, 3)
                                        break

                                    if ms_time + sustain_duration > next_onset_time:
                                        sustain_duration = next_onset_time - ms_time - 1

                                    if sustain_duration > self.min_sustain_duration_ms.get():
                                        note_sustain_length = round(sustain_duration, 3)
                                    break


                        section_notes.append([ms_time, chosen_direction, note_sustain_length])
                        
                        if is_player_note:
                            num_player_notes_in_section += 1
                        else:
                            num_opponent_notes_in_section += 1
                        onset_index += 1
                    else:
                        break

                must_hit_for_this_section = False

                if num_player_notes_in_section > num_opponent_notes_in_section:
                    must_hit_for_this_section = True
                elif num_opponent_notes_in_section > num_player_notes_in_section:
                    must_hit_for_this_section = False
                else:
                    must_hit_for_this_section = not current_must_hit_state


                sections.append({
                    "sectionNotes": section_notes,
                    "sectionBeats": 4,
                    "mustHitSection": must_hit_for_this_section,
                    "typeOfSection": 0,
                    "altAnim": False
                })

                current_must_hit_state = must_hit_for_this_section
                current_section_start_ms += section_duration_ms

                if onset_index >= len(combined_onsets) and current_section_start_ms > max_song_time_ms + section_duration_ms:
                    break
                if not combined_onsets and len(sections) >= 1:
                    break


            if not sections:
                sections.append({
                    "sectionNotes": [],
                    "sectionBeats": 4,
                    "mustHitSection": True,
                    "typeOfSection": 0,
                    "altAnim": False
                })

            self.update_progress(100, self.app_instance.translations["constructing_chart_json"])
            return OrderedDict([
                ("player1", self.player1_char),
                ("player2", self.player2_char),
                ("notes", sections),
                ("events", []), 
                ("gfVersion", self.gf_version),
                ("offset", self.offset),
                ("charter", self.charter),
                ("gameOverChar", self.game_over_char),
                ("song", self.song_name),
                ("needsVoices", True),
                ("generatedBy", "P-Slice converter"),
                ("stage", self.stage), 
                ("format", "psych_v1_convert"),
                ("bpm", self.bpm),
                ("artist", self.artist),
                ("speed", self.speed),
            ])

        except Exception as e:
            self.update_progress(0, f"{self.app_instance.translations['error_during_generation']}: {e}")
            raise

class ChartGeneratorApp(tk.Tk):
    LANGUAGES = {
        "en": {
            "app_title": "FNF Chart Generator",
            "main_title": "Friday Night Funkin' Chart Generator",
            "load_player_voices": "Load Player Voices",
            "load_opponent_voices": "Load Opponent Voices",
            "player_voices_label": "Player voices: {count} files loaded",
            "opponent_voices_label": "Opponent voices: {count} files loaded",
            "player_voices_not_loaded": "Player voices: Not loaded",
            "opponent_voices_not_loaded": "Opponent voices: Not loaded",
            "bpm": "BPM:",
            "song_name": "Song Name:",
            "player1_char": "Player 1 Character:",
            "player2_char": "Player 2 Character:",
            "chart_speed": "Chart Speed:",
            "default_sustain_length": "Default Sustain Length (ms):",
            "offset": "Offset (ms):",
            "gf_version": "GF Version:",
            "charter": "Charter:",
            "game_over_char": "Game Over Character:",
            "artist": "Artist:",
            "stage": "Stage:",
            "prevent_consecutive_notes_checkbox": "Prevent Consecutive Notes", 
            "max_consecutive_notes_allowed": "Max Consecutive Notes Allowed:",
            "onset_delta": "Onset Delta:",
            "onset_wait": "Onset Wait (ms):",
            "onset_backtrack": "Onset Backtrack:",
            "enable_ai_sustain": "Enable AI Sustain",
            "min_sustain_duration_ms": "Min Sustain Duration (ms):",
            "sustain_threshold_db": "Sustain Threshold (dB):",
            "sustain_release_threshold_db": "Sustain Release Threshold (dB):",
            "sustain_extension_ms": "Sustain Extension (ms):",
            "min_silence_between_sustains_ms": "Min Silence Between Sustains (ms):",
            "detecting_sustain_segments": "Detecting sustain segments...",
            "enable_ai_tonality": "Enable AI Tonality",
            "pitch_low_c_threshold": "Pitch Low Threshold (Hz):",
            "pitch_mid_c_threshold": "Pitch Mid Threshold (Hz):",
            "pitch_high_c_threshold": "Pitch High Threshold (Hz):",
            "pitch_very_high_c_threshold": "Pitch Very High Threshold (Hz):",
            "pitch_confidence_threshold": "Pitch Confidence Threshold (0-1):",
            "analyzing_tonality": "Analyzing tonality...",
            "ai_process_note": "AI analysis may take time and is not always perfect.",
            "min_note_duration_ms": "Min Note Duration (ms):",
            "quantization_subdivision": "Quantization Subdivision (e.g., 16 for 16th notes):", 
            "chart_validation_warning": "Chart refinement may take a long time ({passes} passes).", 
            "chart_refining_progress": "Refining chart",
            "tonality_test_function": "This is a test function and may not work perfectly.",
            "generate_chart": "Generate Chart",
            "refine_chart": "Refine Chart", 
            "refinement_passes": "Refinement Passes:", 
            "ready_to_generate": "Ready to generate",
            "loading_audio": "Loading audio...",
            "loading_voices_progress": "Loading",
            "audio_loaded_success": "Audio loaded successfully",
            "detecting_notes": "Detecting notes (onsets)...",
            "starting_chart_generation": "Starting chart generation for Psych Engine 1.0.4...",
            "combining_sorting_notes": "Combining and sorting notes...",
            "constructing_chart_json": "Constructing final chart JSON...",
            "chart_generation_complete": "Chart generation complete!",
            "input_error_title": "Input Error",
            "error_message": "Error",
            "error_during_generation": "Error during generation",
            "no_chart_to_refine": "No chart generated yet. Please generate a chart first.", 
            "please_enter_song_name": "Please enter a song name.",
            "please_enter_player1_char": "Please enter Player 1 character.",
            "please_enter_player2_char": "Please enter Player 2 character.",
            "please_enter_stage_name": "Please enter a stage name.",
            "sustain_probability_range_error": "Sustain Probability must be between 0 and 100.", 
            "max_consecutive_notes_error": "Max Consecutive Notes Allowed must be a non-negative integer.",
            "onset_delta_error": "Onset Delta must be a non-negative number.",
            "onset_wait_error": "Onset Wait (ms) must be a non-negative integer.",
            "min_sustain_duration_error": "Min Sustain Duration (ms) must be a non-negative integer.",
            "sustain_threshold_error": "Sustain Threshold (dB) must be a number.",
            "sustain_release_threshold_error": "Sustain Release Threshold (dB) must be a number.",
            "sustain_extension_error": "Sustain Extension (ms) must be a non-negative integer.",
            "min_silence_between_sustains_error": "Min Silence Between Sustains (ms) must be a non-negative integer.",
            "min_note_duration_error": "Min Note Duration (ms) must be a non-negative integer.",
            "pitch_threshold_error": "Pitch thresholds must be positive numbers.",
            "pitch_confidence_error": "Pitch Confidence Threshold must be between 0 and 1.",
            "success_title": "Success",
            "chart_saved_to": "Chart saved to:\n{path}",
            "ogg_files": "OGG files",
            "select_player_voices": "Select Player Voice Files",
            "select_opponent_voices": "Select Opponent Voice Files",
            "no_voices_loaded_error": "No voices loaded – load player or opponent voices to generate a chart.",
            "language": "Language:"
        },
        "ru": {
            "app_title": "Генератор Чартов FNF",
            "main_title": "Генератор Чартов Friday Night Funkin'",
            "load_player_voices": "Загрузить Голос Игрока",
            "load_opponent_voices": "Загрузить Голос Противника",
            "player_voices_label": "Голос игрока: загружено файлов: {count}",
            "opponent_voices_label": "Голос противника: загружено файлов: {count}",
            "player_voices_not_loaded": "Голос игрока: Не загружено",
            "opponent_voices_not_loaded": "Голос противника: Не загружено",
            "bpm": "BPM:",
            "song_name": "Название Песни:",
            "player1_char": "Персонаж Игрока 1:",
            "player2_char": "Персонаж Игрока 2:",
            "chart_speed": "Скорость Чарта:",
            "default_sustain_length": "Длина Удержания по Умолчанию (мс):",
            "offset": "Смещение (мс):",
            "gf_version": "Версия GF:",
            "charter": "Чартер:",
            "game_over_char": "Персонаж Game Over:",
            "artist": "Исполнитель:",
            "stage": "Сцена:",
            "prevent_consecutive_notes_checkbox": "Предотвращать Последовательные Ноты", 
            "max_consecutive_notes_allowed": "Макс. Разрешенных Последовательных Нот:",
            "onset_delta": "Порог Обнаружения Ноты:",
            "onset_wait": "Мин. Время Между Нотами (мс):",
            "onset_backtrack": "Возврат к Началу:",
            "enable_ai_sustain": "Включить ИИ-Удержание",
            "min_sustain_duration_ms": "Мин. Длительность Удержания (мс):",
            "sustain_threshold_db": "Порог Удержания (дБ):",
            "sustain_release_threshold_db": "Порог Отпускания Удержания (дБ):",
            "sustain_extension_ms": "Расширение Удержания (мс):",
            "min_silence_between_sustains_ms": "Мин. Тишина Между Удержаниями (мс):",
            "detecting_sustain_segments": "Обнаружение сегментов удержания...",
            "enable_ai_tonality": "Включить ИИ-Тональность",
            "pitch_low_c_threshold": "Порог Низкой Высоты (Гц):",
            "pitch_mid_c_threshold": "Порог Средней Высоты (Гц):",
            "pitch_high_c_threshold": "Порог Высокой Высоты (Гц):",
            "pitch_very_high_c_threshold": "Порог Очень Высокой Высоты (Гц):",
            "pitch_confidence_threshold": "Порог Уверенности Высоты (0-1):",
            "analyzing_tonality": "Анализ тональности...",
            "ai_process_note": "ИИ-анализ может занять время и не всегда идеален.",
            "min_note_duration_ms": "Мин. Длительность Ноты (мс):",
            "quantization_subdivision": "Квантование (например, 16 для 16-х нот):", 
            "chart_validation_warning": "Валидация чарта может занять много времени ({passes} проходов).", 
            "chart_refining_progress": "Уточнение чарта",
            "tonality_test_function": "Это тестовая функция и может работать не идеально.",
            "generate_chart": "Сгенерировать Чарт",
            "refine_chart": "Уточнить Чарт",
            "refinement_passes": "Количество проходов уточнения:",
            "ready_to_generate": "Готов к генерации",
            "loading_audio": "Загрузка аудио...",
            "loading_voices_progress": "Загрузка",
            "audio_loaded_success": "Аудио успешно загружено",
            "detecting_notes": "Обнаружение нот (начал)...",
            "starting_chart_generation": "Запуск генерации чарта для Psych Engine 1.0.4...",
            "combining_sorting_notes": "Объединение и сортировка нот...",
            "constructing_chart_json": "Построение окончательного JSON чарта...",
            "chart_generation_complete": "Генерация чарта завершена!",
            "input_error_title": "Ошибка ввода",
            "error_message": "Ошибка",
            "error_during_generation": "Ошибка во время генерации",
            "no_chart_to_refine": "Чарт еще не сгенерирован. Пожалуйста, сначала сгенерируйте чарт.",
            "please_enter_song_name": "Пожалуйста, введите название песни.",
            "please_enter_player1_char": "Пожалуйста, введите персонажа Игрока 1.",
            "please_enter_player2_char": "Пожалуйста, введите персонажа Игрока 2.",
            "please_enter_stage_name": "Пожалуйста, введите название сцены.",
            "sustain_probability_range_error": "Вероятность удержания должна быть от 0 до 100.", 
            "max_consecutive_notes_error": "Макс. Последовательных Нот должно быть неотрицательным целым числом.",
            "onset_delta_error": "Порог Обнаружения Ноты должен быть неотрицательным числом.",
            "onset_wait_error": "Мин. Время Между Нотами (мс) должно быть неотрицательным целым числом.",
            "min_sustain_duration_error": "Мин. Длительность Удержания (мс) должно быть неотрицательным целым числом.",
            "sustain_threshold_error": "Порог Удержания (дБ) должен быть числом.",
            "sustain_release_threshold_error": "Порог Отпускания Удержания (дБ) должен быть числом.",
            "sustain_extension_error": "Расширение Удержания (мс) должно быть неотрицательным целым числом.",
            "min_silence_between_sustains_error": "Мин. Тишина Между Удержаниями (мс) должно быть неотрицательным целым числом.",
            "min_note_duration_error": "Мин. Длительность Ноты (мс) должно быть неотрицательным целым числом.",
            "pitch_threshold_error": "Пороги высоты звука должны быть положительными числами.",
            "pitch_confidence_error": "Порог Уверенности Высоты должен быть от 0 до 1.",
            "success_title": "Успех",
            "chart_saved_to": "Чарт сохранен в:\n{path}",
            "ogg_files": "OGG файлы",
            "select_player_voices": "Выбрать файлы голоса игрока",
            "select_opponent_voices": "Выбрать файлы голоса противника",
            "no_voices_loaded_error": "Голоса не загружены – загрузите голоса игрока или противника для генерации чарта.",
            "language": "Язык:"
        }
    }

    def __init__(self):
        super().__init__()
        self.current_language = tk.StringVar(value="en")
        self.translations = self.LANGUAGES[self.current_language.get()]
        self.title(self.translations["app_title"])
        self.geometry("1000x950")
        self.resizable(True, True)
        self.generator = FNFChartGenerator(self.update_progress)
        self.generator.app_instance = self
        self.current_chart_data = None
        self.num_refinement_passes_var = tk.IntVar(value=5)
        self.create_widgets()
        self.switch_language()

    def create_widgets(self):
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=1)
        self.grid_rowconfigure(3, weight=0)

        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=0)

        top_frame = ttk.Frame(self)
        top_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=10)
        top_frame.grid_columnconfigure(0, weight=1)
        top_frame.grid_columnconfigure(1, weight=0)

        self.lang_label = ttk.Label(top_frame, text=self.translations["language"])
        self.lang_label.grid(row=0, column=0, sticky="w")
        self.lang_combobox = ttk.Combobox(top_frame, textvariable=self.current_language,
                                          values=list(self.LANGUAGES.keys()), state="readonly", width=10)
        self.lang_combobox.grid(row=0, column=1, sticky="e")
        self.lang_combobox.bind("<<ComboboxSelected>>", self.switch_language)

        self.main_title_label = ttk.Label(top_frame, text=self.translations["main_title"], font=("Arial", 14, "bold"))
        self.main_title_label.grid(row=1, column=0, columnspan=2, pady=10)

        audio_frame = ttk.LabelFrame(self, text="Audio Files")
        audio_frame.grid(row=1, column=0, sticky="ew", padx=20, pady=10)
        audio_frame.grid_columnconfigure(0, weight=1)
        audio_frame.grid_columnconfigure(1, weight=1)

        self.load_player_btn = ttk.Button(audio_frame, text=self.translations["load_player_voices"], command=self.load_player)
        self.load_player_btn.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.load_opponent_btn = ttk.Button(audio_frame, text=self.translations["load_opponent_voices"], command=self.load_opponent)
        self.load_opponent_btn.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.player_label = ttk.Label(audio_frame, text=self.translations["player_voices_not_loaded"])
        self.player_label.grid(row=1, column=0, columnspan=2, pady=2)
        self.opponent_label = ttk.Label(audio_frame, text=self.translations["opponent_voices_not_loaded"])
        self.opponent_label.grid(row=2, column=0, columnspan=2, pady=2)

        settings_canvas = tk.Canvas(self, borderwidth=0, highlightthickness=0)
        settings_canvas.grid(row=2, column=0, sticky="nsew", padx=20, pady=10)

        settings_scrollbar = ttk.Scrollbar(self, orient="vertical", command=settings_canvas.yview)
        settings_scrollbar.grid(row=2, column=1, sticky="ns", pady=10)

        settings_canvas.configure(yscrollcommand=settings_scrollbar.set)
        
        sf = ttk.LabelFrame(settings_canvas, text="Chart Settings")
        self.settings_window_id = settings_canvas.create_window((0, 0), window=sf, anchor="nw")

        settings_canvas.bind('<Configure>', lambda e: settings_canvas.itemconfigure(self.settings_window_id, width=e.width))
        sf.bind("<Configure>", lambda e: settings_canvas.configure(scrollregion=settings_canvas.bbox("all")))
        
        sf.grid_columnconfigure(1, weight=1)

        current_row = 0

        self.bpm_label = ttk.Label(sf, text=self.translations["bpm"])
        self.bpm_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.bpm_entry = ttk.Entry(sf, width=10)
        self.bpm_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.bpm_entry.insert(0, "180")

        self.song_label = ttk.Label(sf, text=self.translations["song_name"])
        self.song_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.song_entry = ttk.Entry(sf)
        self.song_entry.grid(row=current_row-1, column=1, sticky="ew", pady=2)

        self.player1_char_label = ttk.Label(sf, text=self.translations["player1_char"])
        self.player1_char_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.player1_char_entry = ttk.Entry(sf)
        self.player1_char_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.player1_char_entry.insert(0, "bf")

        self.player2_char_label = ttk.Label(sf, text=self.translations["player2_char"])
        self.player2_char_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.player2_char_entry = ttk.Entry(sf)
        self.player2_char_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.player2_char_entry.insert(0, "dad")

        self.speed_label = ttk.Label(sf, text=self.translations["chart_speed"])
        self.speed_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.speed_entry = ttk.Entry(sf, width=10)
        self.speed_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.speed_entry.insert(0, "2.6") 

        self.sustain_label = ttk.Label(sf, text=self.translations["default_sustain_length"])
        self.sustain_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.sustain_entry = ttk.Entry(sf, width=10)
        self.sustain_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.sustain_entry.insert(0, "0")

        self.offset_label = ttk.Label(sf, text=self.translations["offset"])
        self.offset_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.offset_entry = ttk.Entry(sf, width=10)
        self.offset_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.offset_entry.insert(0, "0")

        self.gf_version_label = ttk.Label(sf, text=self.translations["gf_version"])
        self.gf_version_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.gf_version_entry = ttk.Entry(sf)
        self.gf_version_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.gf_version_entry.insert(0, "gf")

        self.charter_label = ttk.Label(sf, text=self.translations["charter"])
        self.charter_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.charter_entry = ttk.Entry(sf)
        self.charter_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.charter_entry.insert(0, "Generated by FNF Chart Generator")

        self.game_over_char_label = ttk.Label(sf, text=self.translations["game_over_char"])
        self.game_over_char_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.game_over_char_entry = ttk.Entry(sf)
        self.game_over_char_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.game_over_char_entry.insert(0, "bf-dead")

        self.artist_label = ttk.Label(sf, text=self.translations["artist"])
        self.artist_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.artist_entry = ttk.Entry(sf)
        self.artist_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.artist_entry.insert(0, "Unknown Artist")

        self.stage_label = ttk.Label(sf, text=self.translations["stage"])
        self.stage_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.stage_entry = ttk.Entry(sf)
        self.stage_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.stage_entry.insert(0, "stage")
        
        self.prevent_consecutive_notes_checkbox = ttk.Checkbutton(sf, text=self.translations["prevent_consecutive_notes_checkbox"],
                                                                  variable=self.generator.prevent_consecutive_notes)
        self.prevent_consecutive_notes_checkbox.grid(row=current_row, column=0, columnspan=2, sticky="w", padx=5, pady=2); current_row += 1

        self.max_consecutive_notes_label = ttk.Label(sf, text=self.translations["max_consecutive_notes_allowed"])
        self.max_consecutive_notes_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.max_consecutive_notes_combobox = ttk.Combobox(sf, textvariable=self.generator.max_consecutive_allowed_count,
                                                           values=[0, 1, 2, 3], state="readonly", width=8)
        self.max_consecutive_notes_combobox.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.max_consecutive_notes_combobox.set(self.generator.max_consecutive_allowed_count.get())
        
        self.onset_delta_label = ttk.Label(sf, text=self.translations["onset_delta"])
        self.onset_delta_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.onset_delta_entry = ttk.Entry(sf, width=10, textvariable=self.generator.onset_delta)
        self.onset_delta_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.onset_wait_label = ttk.Label(sf, text=self.translations["onset_wait"])
        self.onset_wait_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.onset_wait_entry = ttk.Entry(sf, width=10, textvariable=self.generator.onset_wait)
        self.onset_wait_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.onset_backtrack_checkbox = ttk.Checkbutton(sf, text=self.translations["onset_backtrack"],
                                                        variable=self.generator.onset_backtrack)
        self.onset_backtrack_checkbox.grid(row=current_row, column=0, columnspan=2, sticky="w", padx=5, pady=2); current_row += 1

        self.enable_ai_sustain_checkbox = ttk.Checkbutton(sf, text=self.translations["enable_ai_sustain"],
                                                          variable=self.generator.enable_ai_sustain)
        self.enable_ai_sustain_checkbox.grid(row=current_row, column=0, columnspan=2, sticky="w", padx=5, pady=2); current_row += 1

        self.min_sustain_duration_label = ttk.Label(sf, text=self.translations["min_sustain_duration_ms"])
        self.min_sustain_duration_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.min_sustain_duration_entry = ttk.Entry(sf, width=10, textvariable=self.generator.min_sustain_duration_ms)
        self.min_sustain_duration_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.sustain_threshold_label = ttk.Label(sf, text=self.translations["sustain_threshold_db"])
        self.sustain_threshold_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.sustain_threshold_entry = ttk.Entry(sf, width=10, textvariable=self.generator.sustain_threshold_db)
        self.sustain_threshold_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.sustain_release_threshold_label = ttk.Label(sf, text=self.translations["sustain_release_threshold_db"])
        self.sustain_release_threshold_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.sustain_release_threshold_entry = ttk.Entry(sf, width=10, textvariable=self.generator.sustain_release_threshold_db)
        self.sustain_release_threshold_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.sustain_extension_label = ttk.Label(sf, text=self.translations["sustain_extension_ms"])
        self.sustain_extension_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.sustain_extension_entry = ttk.Entry(sf, width=10, textvariable=self.generator.sustain_extension_ms)
        self.sustain_extension_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.min_silence_between_sustains_label = ttk.Label(sf, text=self.translations["min_silence_between_sustains_ms"])
        self.min_silence_between_sustains_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.min_silence_between_sustains_entry = ttk.Entry(sf, width=10, textvariable=self.generator.min_silence_between_sustains_ms)
        self.min_silence_between_sustains_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.enable_ai_tonality_checkbox = ttk.Checkbutton(sf, text=self.translations["enable_ai_tonality"],
                                                           variable=self.generator.enable_ai_tonality)
        self.enable_ai_tonality_checkbox.grid(row=current_row, column=0, columnspan=2, sticky="w", padx=5, pady=2); current_row += 1

        self.pitch_low_c_label = ttk.Label(sf, text=self.translations["pitch_low_c_threshold"])
        self.pitch_low_c_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.pitch_low_c_entry = ttk.Entry(sf, width=10, textvariable=self.generator.pitch_low_c_threshold)
        self.pitch_low_c_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.pitch_mid_c_label = ttk.Label(sf, text=self.translations["pitch_mid_c_threshold"])
        self.pitch_mid_c_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.pitch_mid_c_entry = ttk.Entry(sf, width=10, textvariable=self.generator.pitch_mid_c_threshold)
        self.pitch_mid_c_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.pitch_high_c_label = ttk.Label(sf, text=self.translations["pitch_high_c_threshold"])
        self.pitch_high_c_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.pitch_high_c_entry = ttk.Entry(sf, width=10, textvariable=self.generator.pitch_high_c_threshold)
        self.pitch_high_c_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.pitch_very_high_c_label = ttk.Label(sf, text=self.translations["pitch_very_high_c_threshold"])
        self.pitch_very_high_c_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.pitch_very_high_c_entry = ttk.Entry(sf, width=10, textvariable=self.generator.pitch_very_high_c_threshold)
        self.pitch_very_high_c_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.pitch_confidence_label = ttk.Label(sf, text=self.translations["pitch_confidence_threshold"])
        self.pitch_confidence_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.pitch_confidence_entry = ttk.Entry(sf, width=10, textvariable=self.generator.pitch_confidence_threshold)
        self.pitch_confidence_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.min_note_duration_label = ttk.Label(sf, text=self.translations["min_note_duration_ms"])
        self.min_note_duration_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.min_note_duration_entry = ttk.Entry(sf, width=10, textvariable=self.generator.min_note_duration_ms)
        self.min_note_duration_entry.grid(row=current_row-1, column=1, pady=2, sticky="ew")

        self.quantization_subdivision_label = ttk.Label(sf, text=self.translations["quantization_subdivision"])
        self.quantization_subdivision_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1
        self.quantization_subdivision_spinbox = ttk.Spinbox(sf, from_=1, to=64, textvariable=self.generator.quantization_subdivision, width=8)
        self.quantization_subdivision_spinbox.grid(row=current_row-1, column=1, pady=2, sticky="ew")
        self.quantization_subdivision_spinbox.set(self.generator.quantization_subdivision.get())

        self.refinement_passes_label = ttk.Label(sf, text=self.translations["refinement_passes"])
        self.refinement_passes_label.grid(row=current_row, column=0, sticky="e", padx=5, pady=2); current_row += 1

        self.refinement_passes_spinbox = ttk.Spinbox(sf, from_=1, to=10, textvariable=self.num_refinement_passes_var, width=5)
        self.refinement_passes_spinbox.grid(row=current_row-1, column=1, padx=5, pady=2, sticky="ew")

        self.refine_chart_btn = ttk.Button(sf, text=self.translations["refine_chart"], command=self.start_refinement, state=tk.DISABLED)
        self.refine_chart_btn.grid(row=current_row, column=0, columnspan=2, pady=10)
        current_row += 1

        bottom_frame = ttk.Frame(self)
        bottom_frame.grid(row=3, column=0, sticky="ew", padx=20, pady=10)
        bottom_frame.grid_columnconfigure(0, weight=1)

        self.progress_label = ttk.Label(bottom_frame, text=self.translations["ready_to_generate"])
        self.progress_label.pack(pady=5)
        self.progress_bar = ttk.Progressbar(bottom_frame, orient="horizontal", length=400, mode="determinate")
        self.progress_bar.pack(fill=tk.X, pady=5)

        self.ai_process_note_label = ttk.Label(bottom_frame, text=self.translations["ai_process_note"],
                                               font=("Arial", 9, "italic"), foreground="gray")
        self.ai_process_note_label.pack(pady=5)

        self.chart_validation_warning_label = ttk.Label(bottom_frame, text="",
                                                        font=("Arial", 9, "italic"), foreground="orange")
        self.chart_validation_warning_label.pack(pady=2)

        self.generate_chart_btn = ttk.Button(bottom_frame, text=self.translations["generate_chart"], command=self.start_generation)
        self.generate_chart_btn.pack(pady=10)


    def switch_language(self, event=None):
        self.translations = self.LANGUAGES[self.current_language.get()]
        self.title(self.translations["app_title"])
        self.main_title_label.config(text=self.translations["main_title"])
        self.load_player_btn.config(text=self.translations["load_player_voices"])
        self.load_opponent_btn.config(text=self.translations["load_opponent_voices"])
        
        if self.generator.player_voices is not None:
            self.player_label.config(text=self.translations["player_voices_label"].format(count=len(self.generator.player_voices)))
        else:
            self.player_label.config(text=self.translations["player_voices_not_loaded"])

        if self.generator.opponent_voices is not None:
            self.opponent_label.config(text=self.translations["opponent_voices_label"].format(count=len(self.generator.opponent_voices)))
        else:
            self.opponent_label.config(text=self.translations["opponent_voices_not_loaded"])

        self.bpm_label.config(text=self.translations["bpm"])
        self.song_label.config(text=self.translations["song_name"])
        self.player1_char_label.config(text=self.translations["player1_char"])
        self.player2_char_label.config(text=self.translations["player2_char"])
        self.speed_label.config(text=self.translations["chart_speed"])
        self.sustain_label.config(text=self.translations["default_sustain_length"])
        self.offset_label.config(text=self.translations["offset"])
        self.gf_version_label.config(text=self.translations["gf_version"])
        self.charter_label.config(text=self.translations["charter"])
        self.game_over_char_label.config(text=self.translations["game_over_char"])
        self.artist_label.config(text=self.translations["artist"])
        self.stage_label.config(text=self.translations["stage"])
        self.prevent_consecutive_notes_checkbox.config(text=self.translations["prevent_consecutive_notes_checkbox"])
        self.max_consecutive_notes_label.config(text=self.translations["max_consecutive_notes_allowed"])
        self.onset_delta_label.config(text=self.translations["onset_delta"])
        self.onset_wait_label.config(text=self.translations["onset_wait"])
        self.onset_backtrack_checkbox.config(text=self.translations["onset_backtrack"])
        self.enable_ai_sustain_checkbox.config(text=self.translations["enable_ai_sustain"])
        self.min_sustain_duration_label.config(text=self.translations["min_sustain_duration_ms"])
        self.sustain_threshold_label.config(text=self.translations["sustain_threshold_db"])
        self.sustain_release_threshold_label.config(text=self.translations["sustain_release_threshold_db"])
        self.sustain_extension_label.config(text=self.translations["sustain_extension_ms"])
        self.min_silence_between_sustains_label.config(text=self.translations["min_silence_between_sustains_ms"])
        self.enable_ai_tonality_checkbox.config(text=self.translations["enable_ai_tonality"])
        self.pitch_low_c_label.config(text=self.translations["pitch_low_c_threshold"])
        self.pitch_mid_c_label.config(text=self.translations["pitch_mid_c_threshold"])
        self.pitch_high_c_label.config(text=self.translations["pitch_high_c_threshold"])
        self.pitch_very_high_c_label.config(text=self.translations["pitch_very_high_c_threshold"])
        self.pitch_confidence_label.config(text=self.translations["pitch_confidence_threshold"])
        self.ai_process_note_label.config(text=self.translations["ai_process_note"])
        self.min_note_duration_label.config(text=self.translations["min_note_duration_ms"])
        self.quantization_subdivision_label.config(text=self.translations["quantization_subdivision"])
        self.chart_validation_warning_label.config(text="")
        self.generate_chart_btn.config(text=self.translations["generate_chart"])
        self.refine_chart_btn.config(text=self.translations["refine_chart"])
        self.refinement_passes_label.config(text=self.translations["refinement_passes"])
        self.progress_label.config(text=self.translations["ready_to_generate"])
        self.lang_label.config(text=self.translations["language"])


    def load_player(self):
        cnt = self.generator.load_audio(True)
        self.player_label.config(text=self.translations["player_voices_label"].format(count=cnt))

    def load_opponent(self):
        cnt = self.generator.load_audio(False)
        self.opponent_label.config(text=self.translations["opponent_voices_label"].format(count=cnt))

    def update_progress(self, val, msg=""):
        self.progress_bar["value"] = val
        self.progress_label.config(text=msg)
        self.update_idletasks()

    def start_generation(self):
        try:
            self.generator.bpm = int(self.bpm_entry.get())

            self.generator.song_name = self.song_entry.get().strip()
            self.generator.player1_char = self.player1_char_entry.get().strip()
            self.generator.player2_char = self.player2_char_entry.get().strip()
            self.generator.speed = float(self.speed_entry.get())
            self.generator.default_sustain_length = int(self.sustain_entry.get())
            self.generator.offset = float(self.offset_entry.get())
            self.generator.gf_version = self.gf_version_entry.get().strip()
            self.generator.charter = self.charter_entry.get().strip()
            self.generator.game_over_char = self.game_over_char_entry.get().strip()
            self.generator.artist = self.artist_entry.get().strip()
            self.generator.stage = self.stage_entry.get().strip()
            
            try:
                onset_delta_val = float(self.onset_delta_entry.get())
                if onset_delta_val < 0:
                    raise ValueError(self.translations["onset_delta_error"])
                self.generator.onset_delta.set(onset_delta_val)
            except ValueError:
                raise ValueError(self.translations["onset_delta_error"])

            try:
                onset_wait_val = int(self.onset_wait_entry.get())
                if onset_wait_val < 0:
                    raise ValueError(self.translations["onset_wait_error"])
                self.generator.onset_wait.set(onset_wait_val)
            except ValueError:
                raise ValueError(self.translations["onset_wait_error"])

            try:
                min_sustain_duration_val = int(self.min_sustain_duration_entry.get())
                if min_sustain_duration_val < 0:
                    raise ValueError(self.translations["min_sustain_duration_error"])
                self.generator.min_sustain_duration_ms.set(min_sustain_duration_val)
            except ValueError:
                raise ValueError(self.translations["min_sustain_duration_error"])

            try:
                sustain_threshold_val = float(self.sustain_threshold_entry.get())
                self.generator.sustain_threshold_db.set(sustain_threshold_val)
            except ValueError:
                raise ValueError(self.translations["sustain_threshold_error"])

            try:
                sustain_release_threshold_val = float(self.sustain_release_threshold_entry.get())
                self.generator.sustain_release_threshold_db.set(sustain_release_threshold_val)
            except ValueError:
                raise ValueError(self.translations["sustain_release_threshold_error"])

            try:
                sustain_extension_val = int(self.sustain_extension_entry.get())
                if sustain_extension_val < 0:
                    raise ValueError(self.translations["sustain_extension_error"])
                self.generator.sustain_extension_ms.set(sustain_extension_val)
            except ValueError:
                raise ValueError(self.translations["sustain_extension_error"])

            try:
                min_silence_between_sustains_val = int(self.min_silence_between_sustains_entry.get())
                if min_silence_between_sustains_val < 0:
                    raise ValueError(self.translations["min_silence_between_sustains_error"])
                self.generator.min_silence_between_sustains_ms.set(min_silence_between_sustains_val)
            except ValueError:
                raise ValueError(self.translations["min_silence_between_sustains_error"])

            try:
                min_note_duration_val = int(self.min_note_duration_entry.get())
                if min_note_duration_val < 0:
                    raise ValueError(self.translations["min_note_duration_error"])
                self.generator.min_note_duration_ms.set(min_note_duration_val)
            except ValueError:
                raise ValueError(self.translations["min_note_duration_error"])

            try:
                quant_sub_val = int(self.quantization_subdivision_spinbox.get())
                if quant_sub_val <= 0:
                    raise ValueError("Quantization Subdivision must be a positive integer.")
                self.generator.quantization_subdivision.set(quant_sub_val)
            except ValueError:
                raise ValueError("Quantization Subdivision must be a positive integer.")


            if self.generator.enable_ai_tonality.get():
                try:
                    pitch_thresholds = [
                        self.pitch_low_c_entry.get(),
                        self.pitch_mid_c_entry.get(),
                        self.pitch_high_c_entry.get(),
                        self.pitch_very_high_c_entry.get()
                    ]
                    for threshold_str in pitch_thresholds:
                        threshold_val = float(threshold_str)
                        if threshold_val <= 0:
                            raise ValueError(self.translations["pitch_threshold_error"])
                    
                    pitch_confidence_val = float(self.pitch_confidence_entry.get())
                    if not (0 <= pitch_confidence_val <= 1):
                        raise ValueError(self.translations["pitch_confidence_error"])
                    self.generator.pitch_confidence_threshold.set(pitch_confidence_val)

                except ValueError:
                    raise ValueError(self.translations["pitch_threshold_error"])


            if not self.generator.song_name:
                raise ValueError(self.translations["please_enter_song_name"])
            if not self.generator.player1_char:
                raise ValueError(self.translations["please_enter_player1_char"])
            if not self.generator.player2_char:
                raise ValueError(self.translations["please_enter_player2_char"])
            if not self.generator.stage:
                raise ValueError(self.translations["please_enter_stage_name"])
            
            if self.generator.max_consecutive_allowed_count.get() < 0:
                raise ValueError(self.translations["max_consecutive_notes_error"])


            self.set_ui_state(False)
            threading.Thread(target=self.generate_chart_and_save).start()

        except ValueError as ve:
            messagebox.showerror(self.translations["input_error_title"], str(ve))
            self.update_progress(0, self.translations["error_message"])
            self.set_ui_state(True)

    def generate_chart_and_save(self):
        try:
            self.current_chart_data = self.generator.generate_chart()
            self.update_progress(100, self.translations["chart_generation_complete"])
            self.refine_chart_btn.config(state=tk.NORMAL)
            messagebox.showinfo(self.translations["success_title"], self.translations["chart_generation_complete"])

            path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[(self.translations["ogg_files"], "*.json")])
            if path:
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(self.current_chart_data, f, indent=4)
                messagebox.showinfo(self.translations["success_title"], self.translations["chart_saved_to"].format(path=path))

        except Exception as e:
            messagebox.showerror(self.translations["error_message"], str(e))
        finally:
            self.after(0, lambda: self.set_ui_state(True))
            self.update_progress(0, self.translations["ready_to_generate"])
            self.chart_validation_warning_label.config(text="")

    def start_refinement(self):
        if self.current_chart_data is None:
            messagebox.showerror(self.translations["input_error_title"], self.translations["no_chart_to_refine"])
            return

        try:
            num_passes = self.num_refinement_passes_var.get()
            if not (1 <= num_passes <= 10):
                raise ValueError("Количество проходов уточнения должно быть от 1 до 10.")

            self.set_ui_state(False)
            self.chart_validation_warning_label.config(text=self.translations["chart_validation_warning"].format(passes=num_passes))
            threading.Thread(target=self._perform_refinement_and_save, args=(num_passes,)).start()

        except ValueError as ve:
            messagebox.showerror(self.translations["input_error_title"], str(ve))
            self.update_progress(0, self.translations["error_message"])
            self.set_ui_state(True)

    def _perform_refinement_and_save(self, num_passes):
        try:
            self.generator.bpm = int(self.bpm_entry.get())
            self.generator.min_note_duration_ms.set(int(self.min_note_duration_entry.get()))
            self.generator.quantization_subdivision.set(int(self.quantization_subdivision_spinbox.get()))

            refined_chart = self.generator.apply_refinement(self.current_chart_data, num_passes)
            self.current_chart_data = refined_chart
            self.update_progress(100, self.translations["chart_generation_complete"])
            
            messagebox.showinfo(self.translations["success_title"], self.translations["chart_generation_complete"])

            path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[(self.translations["ogg_files"], "*.json")])
            if path:
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(self.current_chart_data, f, indent=4)
                messagebox.showinfo(self.translations["success_title"], self.translations["chart_saved_to"].format(path=path))

        except Exception as e:
            messagebox.showerror(self.translations["error_message"], str(e))
        finally:
            self.after(0, lambda: self.set_ui_state(True))
            self.update_progress(0, self.translations["ready_to_generate"])
            self.chart_validation_warning_label.config(text="")


    def set_ui_state(self, enabled):
        state = tk.NORMAL if enabled else tk.DISABLED
        def recurse(w):
            for c in w.winfo_children():
                if isinstance(c, (ttk.Button, ttk.Entry, ttk.Progressbar, ttk.Checkbutton, ttk.Combobox, ttk.Spinbox)): 
                    try: 
                        if c == self.lang_combobox:
                            c.config(state=tk.NORMAL)
                        elif c == self.refine_chart_btn:
                            if enabled and self.current_chart_data is not None:
                                c.config(state=tk.NORMAL)
                            else:
                                c.config(state=tk.DISABLED)
                        else:
                            c.config(state=state)
                    except tk.TclError: pass
                elif isinstance(c, (ttk.Frame, tk.Frame, tk.Canvas, ttk.LabelFrame)):
                    recurse(c)
        recurse(self)

if __name__ == "__main__":
    app = ChartGeneratorApp()
    app.mainloop()
